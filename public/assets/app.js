/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "assets/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/FlickrTagWidget.js":
/*!***********************************!*\
  !*** ./assets/FlickrTagWidget.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, OO) {/**
 * @class
 * @constructor
 */
FlickrTagWidget = function flickrTagWidget(config) {
  config = $.extend({
    allowArbitrary: true
  }, config);
  FlickrTagWidget.parent.call(this, config);
  this.connect(this, {
    change: this.onMultiselectChange
  });
  this.onMultiselectChange();
  this.input.connect(this, {
    change: OO.ui.debounce(this.onInputChangeDebounced, 800)
  });
};

OO.inheritClass(FlickrTagWidget, OO.ui.MenuTagMultiselectWidget);

FlickrTagWidget.prototype.onInputChangeDebounced = function () {
  var value = this.input.getValue();

  if (value === '' || value === []) {
    return;
  }

  $.getJSON(appConfig.baseUrl + 'tags?q=' + value, this.searchCallback.bind(this));
};

FlickrTagWidget.prototype.searchCallback = function (data) {
  var menuOption,
      searchResult,
      i,
      options = [];

  __webpack_require__(/*! ./TagMenuOptionWidget */ "./assets/TagMenuOptionWidget.js");

  for (i = 0; i < data.length; i++) {
    searchResult = data[i];
    menuOption = new TagMenuOptionWidget(searchResult);
    menuOption.$element.data('tag-info', searchResult);
    options.push(menuOption);
  }

  this.menu.clearItems();
  this.menu.addItems(options);
  this.menu.toggle(true);
};

FlickrTagWidget.prototype.onMenuChoose = function (menuItem) {
  FlickrTagWidget.parent.prototype.onMenuChoose.apply(this, arguments);
  var searchResult = menuItem.$element.data('tag-info');

  if (searchResult.itemid !== undefined) {
    this.addTag('wikidata=' + searchResult.itemid);
  }
};

FlickrTagWidget.prototype.onMultiselectChange = function () {
  var flickrInput = $(':input[name="flickr[tags]"]');
  var items = this.getItems();
  var tagsForFlickr = [];

  for (i = 0; i < items.length; i++) {
    var tag = items[i].data;

    if (tag.includes(' ')) {
      tag = ' "' + tag + '"';
    }

    tagsForFlickr.push(tag);
  }

  flickrInput.val(tagsForFlickr.join(' '));
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! oojs */ "./node_modules/oojs/dist/oojs.js")))

/***/ }),

/***/ "./assets/TagMenuOptionWidget.js":
/*!***************************************!*\
  !*** ./assets/TagMenuOptionWidget.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(OO, $) {/**
 * @class
 * @constructor
 * @param {Object} [config] Configuration options.
 * @cfg {jQuery|string} [description=''] Search result description
 */
TagMenuOptionWidget = function tagMenuOptionWidget(config) {
  var $description, url;

  if (config.label === undefined && config.data !== undefined) {
    config.label = config.data;
  }

  if (config.itemid !== undefined) {
    url = 'https://www.wikidata.org/wiki/' + config.itemid;
    config.label = new OO.ui.HtmlSnippet('<a href="' + url + '" target="_blank">' + config.label + '</a>');
  }

  TagMenuOptionWidget.super.call(this, config); // Description.

  $description = $('<span>').addClass('description').append($('<bdi>').text(config.description || ''));

  if (config.aliases) {
    console.log(config.aliases);
    $description.append(' <span class="aliases">' + $.i18n('wikidata-aliases') + ' ' + config.aliases.join(' &middot; '));
  }

  this.$element.append($description);
};

OO.inheritClass(TagMenuOptionWidget, OO.ui.MenuOptionWidget);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! oojs */ "./node_modules/oojs/dist/oojs.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./assets/app.js":
/*!***********************!*\
  !*** ./assets/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(OO, global, $) {// Workaround for OOUI and Webpack not loading things to global scope.
global.OO = OO; // Load i18n message files.

$(function () {
  var lang = $('html').attr('lang'),
      messagesToLoadUls = {},
      messagesToLoadApp = {};
  messagesToLoadUls[lang] = appConfig.assetsPath + '/i18n/jquery.uls/' + lang + '.json';
  messagesToLoadApp[lang] = appConfig.assetsPath + '/i18n/app/' + lang + '.json';

  if (lang !== 'en') {
    // Also load English files for fallback.
    messagesToLoadUls.en = appConfig.assetsPath + '/i18n/jquery.uls/en.json';
    messagesToLoadApp.en = appConfig.assetsPath + '/i18n/app/en.json';
  }

  $.i18n().locale = lang;
  $.i18n().load(messagesToLoadUls);
  $.i18n().load(messagesToLoadApp);
});
$(function () {
  var searchButton = new OO.ui.ButtonWidget({
    label: $.i18n('flickr-duplicates-search')
  }),
      dupesContainer = $("#flickr-dupes"),
      progressBarField;
  dupesContainer.append(searchButton.$element);
  var progressBar = new OO.ui.ProgressBarWidget();
  searchButton.on('click', function () {
    progressBarField = new OO.ui.FieldLayout(progressBar, {
      //align: 'top',
      label: $.i18n('flickr-dupes-progress')
    });
    dupesContainer.append(progressBarField.$element);
    getNextDuplicate(1); // $.getJSON(dupesContainer.data('info-url'), function ( info ) {
    //     console.log(info);
    //     for ( var page = 1; page < info.pages; page++ ) {
    //         console.log(page);
    //         progressBar.setProgress( ( page / info.pages ) * 100 );
    //         jQuery.ajax({
    //             url: dupesContainer.data('info-url') + '/' + page,
    //             type: 'get',
    //             dataType: 'json',
    //             success: function (data) {
    //                 console.log(data);
    //             },
    //             //async: false,
    //         } );
    //     }
    // });
  });

  function getNextDuplicate(pageNum) {
    $.getJSON(dupesContainer.data('info-url') + '/' + pageNum, function (info) {
      console.log(info);

      if (info.url) {
        console.log("found!", info); // @TODO redirect to URL.
      } else {
        console.log(pageNum, info.pages, pageNum / info.pages * 100);
        progressBar.setProgress(pageNum / info.pages * 100);
        getNextDuplicate(pageNum + 1);
      }
    });
  } // var searchButtonElement = $("#flickr-dupes-search-button");
  // if (searchButtonElement.length === 1) {
  //     console.log(searchButtonElement);
  //     var searchButton = OO.ui.infuse(searchButtonElement);
  //     console.log(searchButton);
  // }

  /**
   * Set up the map.
   */


  if ($('#map').length === 1) {
    // Add a marker at the specified location.
    var addMarker = function addMarker(latLng) {
      var mapPinUrlPath, icon;

      if (map.hasLayer(marker)) {
        map.removeLayer(marker);
      }

      mapPinUrlPath = __webpack_require__(/*! ../node_modules/oojs-ui/dist/themes/wikimediaui/images/icons/mapPin.svg */ "./node_modules/oojs-ui/dist/themes/wikimediaui/images/icons/mapPin.svg");
      icon = L.icon({
        iconUrl: appConfig.baseUrl + 'assets/' + mapPinUrlPath,
        iconAnchor: [10, 20]
      });
      marker = L.marker(latLng, {
        clickable: true,
        draggable: true,
        icon: icon
      });
      marker.on({
        add: recordNewCoords,
        dragend: recordNewCoords
      });
      marker.addTo(map);
      map.panTo(marker.getLatLng());
    };

    var recordNewCoords = function recordNewCoords(e) {
      var locationTemplate,
          pageText,
          locationTplPattern = /{{location\|[-.0-9]+\|[-.0-9]+[^}]*}}/i,
          newLat = Math.round(marker.getLatLng().lat * 100000) / 100000,
          newLon = Math.round(marker.getLatLng().lng * 100000) / 100000; // FLickr.

      if (flickrLatWidget) {
        flickrLatWidget.setValue(newLat);
        flickrLonWIdget.setValue(newLon);
        flickrAccuracyWidget.setValue(map.getZoom());
      } // Commons.


      commonsPageTextWidget = OO.ui.infuse($('#commons-page-text-widget'));
      locationTemplate = '{{location|' + newLat + '|' + newLon + '}}';
      pageText = commonsPageTextWidget.getValue();

      if (pageText.match(locationTplPattern)) {
        pageText = pageText.replace(locationTplPattern, locationTemplate);
      } else {
        pageText = pageText + '\n\n' + locationTemplate;
      }

      commonsPageTextWidget.setValue(pageText);
    };

    var flickrLatWidget,
        flickrLonWIdget,
        flickrAccuracyWidget,
        lat = 0,
        lon = 0,
        flickrAccuracy = 4,
        $flickrLatInput = $(":input[name='flickr[latitude]']");

    if ($flickrLatInput.length === 1) {
      flickrLatWidget = OO.ui.infuse($flickrLatInput.parents('.oo-ui-widget'));
      lat = flickrLatWidget.getValue();
      flickrLonWIdget = OO.ui.infuse($(":input[name='flickr[longitude]']").parents('.oo-ui-widget'));
      lon = flickrLonWIdget.getValue();
      flickrAccuracyWidget = OO.ui.infuse($(":input[name='flickr[accuracy]']").parents('.oo-ui-widget'));
      flickrAccuracy = flickrAccuracyWidget.getValue();
    }

    var mapOptions = {
      center: [lat, lon],
      zoom: flickrAccuracy
    };
    var map = L.map('map', mapOptions),
        marker;
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    if (lat && lon) {
      addMarker({
        lat: lat,
        lng: lon
      });
    }

    map.on('click', function (e) {
      addMarker(e.latlng);
    });
  }
  /**
   * Enable/disable the Commons form for Flickr photos that are not on Commons yet.
   */


  var $commonsUploadElement = $('#commons-upload-widget');

  if ($commonsUploadElement.length === 1) {
    var commonsUploadWidget = OO.ui.infuse($commonsUploadElement),
        commonsTitleWidget = OO.ui.infuse($('#commons-title-widget')),
        commonsCaptionWidget = OO.ui.infuse($('#commons-caption-widget')),
        commonsPageTextWidget = OO.ui.infuse($('#commons-page-text-widget'));
    commonsTitleWidget.setDisabled(true);
    commonsCaptionWidget.setDisabled(true);
    commonsPageTextWidget.setDisabled(true);
    commonsUploadWidget.on('change', function () {
      commonsTitleWidget.setDisabled(!commonsUploadWidget.isSelected());
      commonsCaptionWidget.setDisabled(!commonsUploadWidget.isSelected());
      commonsPageTextWidget.setDisabled(!commonsUploadWidget.isSelected());
    });
  }
  /**
   * Make the Commons edit summary required if any modification is made to the two Commons fields.
   */


  $(':input[name^=commons]').on('change', function () {
    $(':input[name="commons[comment]"]').prop('required', true);
  });
  /**
   * Tags.
   */

  var $tagWidgetElement = $(':input[name="flickr[tags]"]').parents('.oo-ui-widget');

  if ($tagWidgetElement.length === 1) {
    var tagWidget = OO.ui.infuse($tagWidgetElement);
    var selected = [];
    tagWidget.data.forEach(function (tag) {
      selected.push(tag.raw);
    });

    __webpack_require__(/*! ./FlickrTagWidget */ "./assets/FlickrTagWidget.js");

    var flickrTagWidget = new FlickrTagWidget({
      selected: selected,
      name: 'foo'
    });
    tagWidget.$element.after(flickrTagWidget.$element);
    tagWidget.$element.hide();
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! oojs */ "./node_modules/oojs/dist/oojs.js"), __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./assets/app.less":
/*!*************************!*\
  !*** ./assets/app.less ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.emitter.js":
/*!************************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.emitter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do
 * anything special to choose one license or the other and you don't have to
 * notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	var MessageParserEmitter = function () {
		this.language = $.i18n.languages[ String.locale ] || $.i18n.languages[ 'default' ];
	};

	MessageParserEmitter.prototype = {
		constructor: MessageParserEmitter,

		/**
		 * (We put this method definition here, and not in prototype, to make
		 * sure it's not overwritten by any magic.) Walk entire node structure,
		 * applying replacements and template functions when appropriate
		 *
		 * @param {Mixed} node abstract syntax tree (top node or subnode)
		 * @param {Array} replacements for $1, $2, ... $n
		 * @return {Mixed} single-string node or array of nodes suitable for
		 *  jQuery appending.
		 */
		emit: function ( node, replacements ) {
			var ret, subnodes, operation,
				messageParserEmitter = this;

			switch ( typeof node ) {
				case 'string':
				case 'number':
					ret = node;
					break;
				case 'object':
				// node is an array of nodes
					subnodes = $.map( node.slice( 1 ), function ( n ) {
						return messageParserEmitter.emit( n, replacements );
					} );

					operation = node[ 0 ].toLowerCase();

					if ( typeof messageParserEmitter[ operation ] === 'function' ) {
						ret = messageParserEmitter[ operation ]( subnodes, replacements );
					} else {
						throw new Error( 'unknown operation "' + operation + '"' );
					}

					break;
				case 'undefined':
				// Parsing the empty string (as an entire expression, or as a
				// paramExpression in a template) results in undefined
				// Perhaps a more clever parser can detect this, and return the
				// empty string? Or is that useful information?
				// The logical thing is probably to return the empty string here
				// when we encounter undefined.
					ret = '';
					break;
				default:
					throw new Error( 'unexpected type in AST: ' + typeof node );
			}

			return ret;
		},

		/**
		 * Parsing has been applied depth-first we can assume that all nodes
		 * here are single nodes Must return a single node to parents -- a
		 * jQuery with synthetic span However, unwrap any other synthetic spans
		 * in our children and pass them upwards
		 *
		 * @param {Array} nodes Mixed, some single nodes, some arrays of nodes.
		 * @return {string}
		 */
		concat: function ( nodes ) {
			var result = '';

			$.each( nodes, function ( i, node ) {
				// strings, integers, anything else
				result += node;
			} );

			return result;
		},

		/**
		 * Return escaped replacement of correct index, or string if
		 * unavailable. Note that we expect the parsed parameter to be
		 * zero-based. i.e. $1 should have become [ 0 ]. if the specified
		 * parameter is not found return the same string (e.g. "$99" ->
		 * parameter 98 -> not found -> return "$99" ) TODO throw error if
		 * nodes.length > 1 ?
		 *
		 * @param {Array} nodes One element, integer, n >= 0
		 * @param {Array} replacements for $1, $2, ... $n
		 * @return {string} replacement
		 */
		replace: function ( nodes, replacements ) {
			var index = parseInt( nodes[ 0 ], 10 );

			if ( index < replacements.length ) {
				// replacement is not a string, don't touch!
				return replacements[ index ];
			} else {
				// index not found, fallback to displaying variable
				return '$' + ( index + 1 );
			}
		},

		/**
		 * Transform parsed structure into pluralization n.b. The first node may
		 * be a non-integer (for instance, a string representing an Arabic
		 * number). So convert it back with the current language's
		 * convertNumber.
		 *
		 * @param {Array} nodes List [ {String|Number}, {String}, {String} ... ]
		 * @return {string} selected pluralized form according to current
		 *  language.
		 */
		plural: function ( nodes ) {
			var count = parseFloat( this.language.convertNumber( nodes[ 0 ], 10 ) ),
				forms = nodes.slice( 1 );

			return forms.length ? this.language.convertPlural( count, forms ) : '';
		},

		/**
		 * Transform parsed structure into gender Usage
		 * {{gender:gender|masculine|feminine|neutral}}.
		 *
		 * @param {Array} nodes List [ {String}, {String}, {String} , {String} ]
		 * @return {string} selected gender form according to current language
		 */
		gender: function ( nodes ) {
			var gender = nodes[ 0 ],
				forms = nodes.slice( 1 );

			return this.language.gender( gender, forms );
		},

		/**
		 * Transform parsed structure into grammar conversion. Invoked by
		 * putting {{grammar:form|word}} in a message
		 *
		 * @param {Array} nodes List [{Grammar case eg: genitive}, {String word}]
		 * @return {string} selected grammatical form according to current
		 *  language.
		 */
		grammar: function ( nodes ) {
			var form = nodes[ 0 ],
				word = nodes[ 1 ];

			return word && form && this.language.convertGrammar( word, form );
		}
	};

	$.extend( $.i18n.parser.emitter, new MessageParserEmitter() );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.fallbacks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.fallbacks.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2012 Santhosh Thottingal
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do anything special to
 * choose one license or the other and you don't have to notify anyone which license you are using.
 * You are free to use UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */
( function ( $ ) {
	'use strict';

	$.i18n = $.i18n || {};
	$.extend( $.i18n.fallbacks, {
		ab: [ 'ru' ],
		ace: [ 'id' ],
		aln: [ 'sq' ],
		// Not so standard - als is supposed to be Tosk Albanian,
		// but in Wikipedia it's used for a Germanic language.
		als: [ 'gsw', 'de' ],
		an: [ 'es' ],
		anp: [ 'hi' ],
		arn: [ 'es' ],
		arz: [ 'ar' ],
		av: [ 'ru' ],
		ay: [ 'es' ],
		ba: [ 'ru' ],
		bar: [ 'de' ],
		'bat-smg': [ 'sgs', 'lt' ],
		bcc: [ 'fa' ],
		'be-x-old': [ 'be-tarask' ],
		bh: [ 'bho' ],
		bjn: [ 'id' ],
		bm: [ 'fr' ],
		bpy: [ 'bn' ],
		bqi: [ 'fa' ],
		bug: [ 'id' ],
		'cbk-zam': [ 'es' ],
		ce: [ 'ru' ],
		crh: [ 'crh-latn' ],
		'crh-cyrl': [ 'ru' ],
		csb: [ 'pl' ],
		cv: [ 'ru' ],
		'de-at': [ 'de' ],
		'de-ch': [ 'de' ],
		'de-formal': [ 'de' ],
		dsb: [ 'de' ],
		dtp: [ 'ms' ],
		egl: [ 'it' ],
		eml: [ 'it' ],
		ff: [ 'fr' ],
		fit: [ 'fi' ],
		'fiu-vro': [ 'vro', 'et' ],
		frc: [ 'fr' ],
		frp: [ 'fr' ],
		frr: [ 'de' ],
		fur: [ 'it' ],
		gag: [ 'tr' ],
		gan: [ 'gan-hant', 'zh-hant', 'zh-hans' ],
		'gan-hans': [ 'zh-hans' ],
		'gan-hant': [ 'zh-hant', 'zh-hans' ],
		gl: [ 'pt' ],
		glk: [ 'fa' ],
		gn: [ 'es' ],
		gsw: [ 'de' ],
		hif: [ 'hif-latn' ],
		hsb: [ 'de' ],
		ht: [ 'fr' ],
		ii: [ 'zh-cn', 'zh-hans' ],
		inh: [ 'ru' ],
		iu: [ 'ike-cans' ],
		jut: [ 'da' ],
		jv: [ 'id' ],
		kaa: [ 'kk-latn', 'kk-cyrl' ],
		kbd: [ 'kbd-cyrl' ],
		khw: [ 'ur' ],
		kiu: [ 'tr' ],
		kk: [ 'kk-cyrl' ],
		'kk-arab': [ 'kk-cyrl' ],
		'kk-latn': [ 'kk-cyrl' ],
		'kk-cn': [ 'kk-arab', 'kk-cyrl' ],
		'kk-kz': [ 'kk-cyrl' ],
		'kk-tr': [ 'kk-latn', 'kk-cyrl' ],
		kl: [ 'da' ],
		'ko-kp': [ 'ko' ],
		koi: [ 'ru' ],
		krc: [ 'ru' ],
		ks: [ 'ks-arab' ],
		ksh: [ 'de' ],
		ku: [ 'ku-latn' ],
		'ku-arab': [ 'ckb' ],
		kv: [ 'ru' ],
		lad: [ 'es' ],
		lb: [ 'de' ],
		lbe: [ 'ru' ],
		lez: [ 'ru' ],
		li: [ 'nl' ],
		lij: [ 'it' ],
		liv: [ 'et' ],
		lmo: [ 'it' ],
		ln: [ 'fr' ],
		ltg: [ 'lv' ],
		lzz: [ 'tr' ],
		mai: [ 'hi' ],
		'map-bms': [ 'jv', 'id' ],
		mg: [ 'fr' ],
		mhr: [ 'ru' ],
		min: [ 'id' ],
		mo: [ 'ro' ],
		mrj: [ 'ru' ],
		mwl: [ 'pt' ],
		myv: [ 'ru' ],
		mzn: [ 'fa' ],
		nah: [ 'es' ],
		nap: [ 'it' ],
		nds: [ 'de' ],
		'nds-nl': [ 'nl' ],
		'nl-informal': [ 'nl' ],
		no: [ 'nb' ],
		os: [ 'ru' ],
		pcd: [ 'fr' ],
		pdc: [ 'de' ],
		pdt: [ 'de' ],
		pfl: [ 'de' ],
		pms: [ 'it' ],
		pt: [ 'pt-br' ],
		'pt-br': [ 'pt' ],
		qu: [ 'es' ],
		qug: [ 'qu', 'es' ],
		rgn: [ 'it' ],
		rmy: [ 'ro' ],
		'roa-rup': [ 'rup' ],
		rue: [ 'uk', 'ru' ],
		ruq: [ 'ruq-latn', 'ro' ],
		'ruq-cyrl': [ 'mk' ],
		'ruq-latn': [ 'ro' ],
		sa: [ 'hi' ],
		sah: [ 'ru' ],
		scn: [ 'it' ],
		sg: [ 'fr' ],
		sgs: [ 'lt' ],
		sli: [ 'de' ],
		sr: [ 'sr-ec' ],
		srn: [ 'nl' ],
		stq: [ 'de' ],
		su: [ 'id' ],
		szl: [ 'pl' ],
		tcy: [ 'kn' ],
		tg: [ 'tg-cyrl' ],
		tt: [ 'tt-cyrl', 'ru' ],
		'tt-cyrl': [ 'ru' ],
		ty: [ 'fr' ],
		udm: [ 'ru' ],
		ug: [ 'ug-arab' ],
		uk: [ 'ru' ],
		vec: [ 'it' ],
		vep: [ 'et' ],
		vls: [ 'nl' ],
		vmf: [ 'de' ],
		vot: [ 'fi' ],
		vro: [ 'et' ],
		wa: [ 'fr' ],
		wo: [ 'fr' ],
		wuu: [ 'zh-hans' ],
		xal: [ 'ru' ],
		xmf: [ 'ka' ],
		yi: [ 'he' ],
		za: [ 'zh-hans' ],
		zea: [ 'nl' ],
		zh: [ 'zh-hans' ],
		'zh-classical': [ 'lzh' ],
		'zh-cn': [ 'zh-hans' ],
		'zh-hant': [ 'zh-hans' ],
		'zh-hk': [ 'zh-hant', 'zh-hans' ],
		'zh-min-nan': [ 'nan' ],
		'zh-mo': [ 'zh-hk', 'zh-hant', 'zh-hans' ],
		'zh-my': [ 'zh-sg', 'zh-hans' ],
		'zh-sg': [ 'zh-hans' ],
		'zh-tw': [ 'zh-hant', 'zh-hans' ],
		'zh-yue': [ 'yue' ]
	} );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.js":
/*!****************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2012 Santhosh Thottingal
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do
 * anything special to choose one license or the other and you don't have to
 * notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	var I18N,
		slice = Array.prototype.slice;
	/**
	 * @constructor
	 * @param {Object} options
	 */
	I18N = function ( options ) {
		// Load defaults
		this.options = $.extend( {}, I18N.defaults, options );

		this.parser = this.options.parser;
		this.locale = this.options.locale;
		this.messageStore = this.options.messageStore;
		this.languages = {};
	};

	I18N.prototype = {
		/**
		 * Localize a given messageKey to a locale.
		 * @param {String} messageKey
		 * @return {String} Localized message
		 */
		localize: function ( messageKey ) {
			var localeParts, localePartIndex, locale, fallbackIndex,
				tryingLocale, message;

			locale = this.locale;
			fallbackIndex = 0;

			while ( locale ) {
				// Iterate through locales starting at most-specific until
				// localization is found. As in fi-Latn-FI, fi-Latn and fi.
				localeParts = locale.split( '-' );
				localePartIndex = localeParts.length;

				do {
					tryingLocale = localeParts.slice( 0, localePartIndex ).join( '-' );
					message = this.messageStore.get( tryingLocale, messageKey );

					if ( message ) {
						return message;
					}

					localePartIndex--;
				} while ( localePartIndex );

				if ( locale === 'en' ) {
					break;
				}

				locale = ( $.i18n.fallbacks[ this.locale ] &&
						$.i18n.fallbacks[ this.locale ][ fallbackIndex ] ) ||
						this.options.fallbackLocale;
				$.i18n.log( 'Trying fallback locale for ' + this.locale + ': ' + locale + ' (' + messageKey + ')' );

				fallbackIndex++;
			}

			// key not found
			return '';
		},

		/*
		 * Destroy the i18n instance.
		 */
		destroy: function () {
			$.removeData( document, 'i18n' );
		},

		/**
		 * General message loading API This can take a URL string for
		 * the json formatted messages. Example:
		 * <code>load('path/to/all_localizations.json');</code>
		 *
		 * To load a localization file for a locale:
		 * <code>
		 * load('path/to/de-messages.json', 'de' );
		 * </code>
		 *
		 * To load a localization file from a directory:
		 * <code>
		 * load('path/to/i18n/directory', 'de' );
		 * </code>
		 * The above method has the advantage of fallback resolution.
		 * ie, it will automatically load the fallback locales for de.
		 * For most usecases, this is the recommended method.
		 * It is optional to have trailing slash at end.
		 *
		 * A data object containing message key- message translation mappings
		 * can also be passed. Example:
		 * <code>
		 * load( { 'hello' : 'Hello' }, optionalLocale );
		 * </code>
		 *
		 * A source map containing key-value pair of languagename and locations
		 * can also be passed. Example:
		 * <code>
		 * load( {
		 * bn: 'i18n/bn.json',
		 * he: 'i18n/he.json',
		 * en: 'i18n/en.json'
		 * } )
		 * </code>
		 *
		 * If the data argument is null/undefined/false,
		 * all cached messages for the i18n instance will get reset.
		 *
		 * @param {string|Object} source
		 * @param {string} locale Language tag
		 * @return {jQuery.Promise}
		 */
		load: function ( source, locale ) {
			var fallbackLocales, locIndex, fallbackLocale, sourceMap = {};
			if ( !source && !locale ) {
				source = 'i18n/' + $.i18n().locale + '.json';
				locale = $.i18n().locale;
			}
			if ( typeof source === 'string' &&
				// source extension should be json, but can have query params after that.
				source.split( '?' )[ 0 ].split( '.' ).pop() !== 'json'
			) {
				// Load specified locale then check for fallbacks when directory is
				// specified in load()
				sourceMap[ locale ] = source + '/' + locale + '.json';
				fallbackLocales = ( $.i18n.fallbacks[ locale ] || [] )
					.concat( this.options.fallbackLocale );
				for ( locIndex = 0; locIndex < fallbackLocales.length; locIndex++ ) {
					fallbackLocale = fallbackLocales[ locIndex ];
					sourceMap[ fallbackLocale ] = source + '/' + fallbackLocale + '.json';
				}
				return this.load( sourceMap );
			} else {
				return this.messageStore.load( source, locale );
			}

		},

		/**
		 * Does parameter and magic word substitution.
		 *
		 * @param {string} key Message key
		 * @param {Array} parameters Message parameters
		 * @return {string}
		 */
		parse: function ( key, parameters ) {
			var message = this.localize( key );
			// FIXME: This changes the state of the I18N object,
			// should probably not change the 'this.parser' but just
			// pass it to the parser.
			this.parser.language = $.i18n.languages[ $.i18n().locale ] || $.i18n.languages[ 'default' ];
			if ( message === '' ) {
				message = key;
			}
			return this.parser.parse( message, parameters );
		}
	};

	/**
	 * Process a message from the $.I18N instance
	 * for the current document, stored in jQuery.data(document).
	 *
	 * @param {string} key Key of the message.
	 * @param {string} param1 [param...] Variadic list of parameters for {key}.
	 * @return {string|$.I18N} Parsed message, or if no key was given
	 * the instance of $.I18N is returned.
	 */
	$.i18n = function ( key, param1 ) {
		var parameters,
			i18n = $.data( document, 'i18n' ),
			options = typeof key === 'object' && key;

		// If the locale option for this call is different then the setup so far,
		// update it automatically. This doesn't just change the context for this
		// call but for all future call as well.
		// If there is no i18n setup yet, don't do this. It will be taken care of
		// by the `new I18N` construction below.
		// NOTE: It should only change language for this one call.
		// Then cache instances of I18N somewhere.
		if ( options && options.locale && i18n && i18n.locale !== options.locale ) {
			i18n.locale = options.locale;
		}

		if ( !i18n ) {
			i18n = new I18N( options );
			$.data( document, 'i18n', i18n );
		}

		if ( typeof key === 'string' ) {
			if ( param1 !== undefined ) {
				parameters = slice.call( arguments, 1 );
			} else {
				parameters = [];
			}

			return i18n.parse( key, parameters );
		} else {
			// FIXME: remove this feature/bug.
			return i18n;
		}
	};

	$.fn.i18n = function () {
		var i18n = $.data( document, 'i18n' );

		if ( !i18n ) {
			i18n = new I18N();
			$.data( document, 'i18n', i18n );
		}

		return this.each( function () {
			var $this = $( this ),
				messageKey = $this.data( 'i18n' ),
				lBracket, rBracket, type, key;

			if ( messageKey ) {
				lBracket = messageKey.indexOf( '[' );
				rBracket = messageKey.indexOf( ']' );
				if ( lBracket !== -1 && rBracket !== -1 && lBracket < rBracket ) {
					type = messageKey.slice( lBracket + 1, rBracket );
					key = messageKey.slice( rBracket + 1 );
					if ( type === 'html' ) {
						$this.html( i18n.parse( key ) );
					} else {
						$this.attr( type, i18n.parse( key ) );
					}
				} else {
					$this.text( i18n.parse( messageKey ) );
				}
			} else {
				$this.find( '[data-i18n]' ).i18n();
			}
		} );
	};

	function getDefaultLocale() {
		var nav, locale = $( 'html' ).attr( 'lang' );

		if ( !locale ) {
			if ( typeof window.navigator !== undefined ) {
				nav = window.navigator;
				locale = nav.language || nav.userLanguage || '';
			} else {
				locale = '';
			}
		}
		return locale;
	}

	$.i18n.languages = {};
	$.i18n.messageStore = $.i18n.messageStore || {};
	$.i18n.parser = {
		// The default parser only handles variable substitution
		parse: function ( message, parameters ) {
			return message.replace( /\$(\d+)/g, function ( str, match ) {
				var index = parseInt( match, 10 ) - 1;
				return parameters[ index ] !== undefined ? parameters[ index ] : '$' + match;
			} );
		},
		emitter: {}
	};
	$.i18n.fallbacks = {};
	$.i18n.debug = false;
	$.i18n.log = function ( /* arguments */ ) {
		if ( window.console && $.i18n.debug ) {
			window.console.log.apply( window.console, arguments );
		}
	};
	/* Static members */
	I18N.defaults = {
		locale: getDefaultLocale(),
		fallbackLocale: 'en',
		parser: $.i18n.parser,
		messageStore: $.i18n.messageStore
	};

	// Expose constructor
	$.i18n.constructor = I18N;
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.language.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.language.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/* global pluralRuleParser */
( function ( $ ) {
	'use strict';

	// jscs:disable
	var language = {
		// CLDR plural rules generated using
		// libs/CLDRPluralRuleParser/tools/PluralXML2JSON.html
		pluralRules: {
			ak: {
				one: 'n = 0..1'
			},
			am: {
				one: 'i = 0 or n = 1'
			},
			ar: {
				zero: 'n = 0',
				one: 'n = 1',
				two: 'n = 2',
				few: 'n % 100 = 3..10',
				many: 'n % 100 = 11..99'
			},
			ars: {
				zero: 'n = 0',
				one: 'n = 1',
				two: 'n = 2',
				few: 'n % 100 = 3..10',
				many: 'n % 100 = 11..99'
			},
			as: {
				one: 'i = 0 or n = 1'
			},
			be: {
				one: 'n % 10 = 1 and n % 100 != 11',
				few: 'n % 10 = 2..4 and n % 100 != 12..14',
				many: 'n % 10 = 0 or n % 10 = 5..9 or n % 100 = 11..14'
			},
			bh: {
				one: 'n = 0..1'
			},
			bn: {
				one: 'i = 0 or n = 1'
			},
			br: {
				one: 'n % 10 = 1 and n % 100 != 11,71,91',
				two: 'n % 10 = 2 and n % 100 != 12,72,92',
				few: 'n % 10 = 3..4,9 and n % 100 != 10..19,70..79,90..99',
				many: 'n != 0 and n % 1000000 = 0'
			},
			bs: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14'
			},
			cs: {
				one: 'i = 1 and v = 0',
				few: 'i = 2..4 and v = 0',
				many: 'v != 0'
			},
			cy: {
				zero: 'n = 0',
				one: 'n = 1',
				two: 'n = 2',
				few: 'n = 3',
				many: 'n = 6'
			},
			da: {
				one: 'n = 1 or t != 0 and i = 0,1'
			},
			dsb: {
				one: 'v = 0 and i % 100 = 1 or f % 100 = 1',
				two: 'v = 0 and i % 100 = 2 or f % 100 = 2',
				few: 'v = 0 and i % 100 = 3..4 or f % 100 = 3..4'
			},
			fa: {
				one: 'i = 0 or n = 1'
			},
			ff: {
				one: 'i = 0,1'
			},
			fil: {
				one: 'v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9'
			},
			fr: {
				one: 'i = 0,1'
			},
			ga: {
				one: 'n = 1',
				two: 'n = 2',
				few: 'n = 3..6',
				many: 'n = 7..10'
			},
			gd: {
				one: 'n = 1,11',
				two: 'n = 2,12',
				few: 'n = 3..10,13..19'
			},
			gu: {
				one: 'i = 0 or n = 1'
			},
			guw: {
				one: 'n = 0..1'
			},
			gv: {
				one: 'v = 0 and i % 10 = 1',
				two: 'v = 0 and i % 10 = 2',
				few: 'v = 0 and i % 100 = 0,20,40,60,80',
				many: 'v != 0'
			},
			he: {
				one: 'i = 1 and v = 0',
				two: 'i = 2 and v = 0',
				many: 'v = 0 and n != 0..10 and n % 10 = 0'
			},
			hi: {
				one: 'i = 0 or n = 1'
			},
			hr: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14'
			},
			hsb: {
				one: 'v = 0 and i % 100 = 1 or f % 100 = 1',
				two: 'v = 0 and i % 100 = 2 or f % 100 = 2',
				few: 'v = 0 and i % 100 = 3..4 or f % 100 = 3..4'
			},
			hy: {
				one: 'i = 0,1'
			},
			is: {
				one: 't = 0 and i % 10 = 1 and i % 100 != 11 or t != 0'
			},
			iu: {
				one: 'n = 1',
				two: 'n = 2'
			},
			iw: {
				one: 'i = 1 and v = 0',
				two: 'i = 2 and v = 0',
				many: 'v = 0 and n != 0..10 and n % 10 = 0'
			},
			kab: {
				one: 'i = 0,1'
			},
			kn: {
				one: 'i = 0 or n = 1'
			},
			kw: {
				one: 'n = 1',
				two: 'n = 2'
			},
			lag: {
				zero: 'n = 0',
				one: 'i = 0,1 and n != 0'
			},
			ln: {
				one: 'n = 0..1'
			},
			lt: {
				one: 'n % 10 = 1 and n % 100 != 11..19',
				few: 'n % 10 = 2..9 and n % 100 != 11..19',
				many: 'f != 0'
			},
			lv: {
				zero: 'n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19',
				one: 'n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1'
			},
			mg: {
				one: 'n = 0..1'
			},
			mk: {
				one: 'v = 0 and i % 10 = 1 or f % 10 = 1'
			},
			mo: {
				one: 'i = 1 and v = 0',
				few: 'v != 0 or n = 0 or n != 1 and n % 100 = 1..19'
			},
			mr: {
				one: 'i = 0 or n = 1'
			},
			mt: {
				one: 'n = 1',
				few: 'n = 0 or n % 100 = 2..10',
				many: 'n % 100 = 11..19'
			},
			naq: {
				one: 'n = 1',
				two: 'n = 2'
			},
			nso: {
				one: 'n = 0..1'
			},
			pa: {
				one: 'n = 0..1'
			},
			pl: {
				one: 'i = 1 and v = 0',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14',
				many: 'v = 0 and i != 1 and i % 10 = 0..1 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 12..14'
			},
			prg: {
				zero: 'n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19',
				one: 'n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1'
			},
			pt: {
				one: 'i = 0..1'
			},
			ro: {
				one: 'i = 1 and v = 0',
				few: 'v != 0 or n = 0 or n != 1 and n % 100 = 1..19'
			},
			ru: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14',
				many: 'v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14'
			},
			se: {
				one: 'n = 1',
				two: 'n = 2'
			},
			sh: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14'
			},
			shi: {
				one: 'i = 0 or n = 1',
				few: 'n = 2..10'
			},
			si: {
				one: 'n = 0,1 or i = 0 and f = 1'
			},
			sk: {
				one: 'i = 1 and v = 0',
				few: 'i = 2..4 and v = 0',
				many: 'v != 0'
			},
			sl: {
				one: 'v = 0 and i % 100 = 1',
				two: 'v = 0 and i % 100 = 2',
				few: 'v = 0 and i % 100 = 3..4 or v != 0'
			},
			sma: {
				one: 'n = 1',
				two: 'n = 2'
			},
			smi: {
				one: 'n = 1',
				two: 'n = 2'
			},
			smj: {
				one: 'n = 1',
				two: 'n = 2'
			},
			smn: {
				one: 'n = 1',
				two: 'n = 2'
			},
			sms: {
				one: 'n = 1',
				two: 'n = 2'
			},
			sr: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14'
			},
			ti: {
				one: 'n = 0..1'
			},
			tl: {
				one: 'v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9'
			},
			tzm: {
				one: 'n = 0..1 or n = 11..99'
			},
			uk: {
				one: 'v = 0 and i % 10 = 1 and i % 100 != 11',
				few: 'v = 0 and i % 10 = 2..4 and i % 100 != 12..14',
				many: 'v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14'
			},
			wa: {
				one: 'n = 0..1'
			},
			zu: {
				one: 'i = 0 or n = 1'
			}
		},
		// jscs:enable

		/**
		 * Plural form transformations, needed for some languages.
		 *
		 * @param {integer} count
		 *            Non-localized quantifier
		 * @param {Array} forms
		 *            List of plural forms
		 * @return {string} Correct form for quantifier in this language
		 */
		convertPlural: function ( count, forms ) {
			var pluralRules,
				pluralFormIndex,
				index,
				explicitPluralPattern = new RegExp( '\\d+=', 'i' ),
				formCount,
				form;

			if ( !forms || forms.length === 0 ) {
				return '';
			}

			// Handle for Explicit 0= & 1= values
			for ( index = 0; index < forms.length; index++ ) {
				form = forms[ index ];
				if ( explicitPluralPattern.test( form ) ) {
					formCount = parseInt( form.slice( 0, form.indexOf( '=' ) ), 10 );
					if ( formCount === count ) {
						return ( form.slice( form.indexOf( '=' ) + 1 ) );
					}
					forms[ index ] = undefined;
				}
			}

			forms = $.map( forms, function ( form ) {
				if ( form !== undefined ) {
					return form;
				}
			} );

			pluralRules = this.pluralRules[ $.i18n().locale ];

			if ( !pluralRules ) {
				// default fallback.
				return ( count === 1 ) ? forms[ 0 ] : forms[ 1 ];
			}

			pluralFormIndex = this.getPluralForm( count, pluralRules );
			pluralFormIndex = Math.min( pluralFormIndex, forms.length - 1 );

			return forms[ pluralFormIndex ];
		},

		/**
		 * For the number, get the plural for index
		 *
		 * @param {integer} number
		 * @param {Object} pluralRules
		 * @return {integer} plural form index
		 */
		getPluralForm: function ( number, pluralRules ) {
			var i,
				pluralForms = [ 'zero', 'one', 'two', 'few', 'many', 'other' ],
				pluralFormIndex = 0;

			for ( i = 0; i < pluralForms.length; i++ ) {
				if ( pluralRules[ pluralForms[ i ] ] ) {
					if ( pluralRuleParser( pluralRules[ pluralForms[ i ] ], number ) ) {
						return pluralFormIndex;
					}

					pluralFormIndex++;
				}
			}

			return pluralFormIndex;
		},

		/**
		 * Converts a number using digitTransformTable.
		 *
		 * @param {number} num Value to be converted
		 * @param {boolean} integer Convert the return value to an integer
		 * @return {string} The number converted into a String.
		 */
		convertNumber: function ( num, integer ) {
			var tmp, item, i,
				transformTable, numberString, convertedNumber;

			// Set the target Transform table:
			transformTable = this.digitTransformTable( $.i18n().locale );
			numberString = String( num );
			convertedNumber = '';

			if ( !transformTable ) {
				return num;
			}

			// Check if the restore to Latin number flag is set:
			if ( integer ) {
				if ( parseFloat( num, 10 ) === num ) {
					return num;
				}

				tmp = [];

				for ( item in transformTable ) {
					tmp[ transformTable[ item ] ] = item;
				}

				transformTable = tmp;
			}

			for ( i = 0; i < numberString.length; i++ ) {
				if ( transformTable[ numberString[ i ] ] ) {
					convertedNumber += transformTable[ numberString[ i ] ];
				} else {
					convertedNumber += numberString[ i ];
				}
			}

			return integer ? parseFloat( convertedNumber, 10 ) : convertedNumber;
		},

		/**
		 * Grammatical transformations, needed for inflected languages.
		 * Invoked by putting {{grammar:form|word}} in a message.
		 * Override this method for languages that need special grammar rules
		 * applied dynamically.
		 *
		 * @param {string} word
		 * @param {string} form
		 * @return {string}
		 */
		// eslint-disable-next-line no-unused-vars
		convertGrammar: function ( word, form ) {
			return word;
		},

		/**
		 * Provides an alternative text depending on specified gender. Usage
		 * {{gender:[gender|user object]|masculine|feminine|neutral}}. If second
		 * or third parameter are not specified, masculine is used.
		 *
		 * These details may be overriden per language.
		 *
		 * @param {string} gender
		 *      male, female, or anything else for neutral.
		 * @param {Array} forms
		 *      List of gender forms
		 *
		 * @return {string}
		 */
		gender: function ( gender, forms ) {
			if ( !forms || forms.length === 0 ) {
				return '';
			}

			while ( forms.length < 2 ) {
				forms.push( forms[ forms.length - 1 ] );
			}

			if ( gender === 'male' ) {
				return forms[ 0 ];
			}

			if ( gender === 'female' ) {
				return forms[ 1 ];
			}

			return ( forms.length === 3 ) ? forms[ 2 ] : forms[ 0 ];
		},

		/**
		 * Get the digit transform table for the given language
		 * See http://cldr.unicode.org/translation/numbering-systems
		 *
		 * @param {string} language
		 * @return {Array|boolean} List of digits in the passed language or false
		 * representation, or boolean false if there is no information.
		 */
		digitTransformTable: function ( language ) {
			var tables = {
				ar: '٠١٢٣٤٥٦٧٨٩',
				fa: '۰۱۲۳۴۵۶۷۸۹',
				ml: '൦൧൨൩൪൫൬൭൮൯',
				kn: '೦೧೨೩೪೫೬೭೮೯',
				lo: '໐໑໒໓໔໕໖໗໘໙',
				or: '୦୧୨୩୪୫୬୭୮୯',
				kh: '០១២៣៤៥៦៧៨៩',
				pa: '੦੧੨੩੪੫੬੭੮੯',
				gu: '૦૧૨૩૪૫૬૭૮૯',
				hi: '०१२३४५६७८९',
				my: '၀၁၂၃၄၅၆၇၈၉',
				ta: '௦௧௨௩௪௫௬௭௮௯',
				te: '౦౧౨౩౪౫౬౭౮౯',
				th: '๐๑๒๓๔๕๖๗๘๙', // FIXME use iso 639 codes
				bo: '༠༡༢༣༤༥༦༧༨༩' // FIXME use iso 639 codes
			};

			if ( !tables[ language ] ) {
				return false;
			}

			return tables[ language ].split( '' );
		}
	};

	$.extend( $.i18n.languages, {
		'default': language
	} );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.messagestore.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.messagestore.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Internationalization library - Message Store
 *
 * Copyright (C) 2012 Santhosh Thottingal
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do anything special to
 * choose one license or the other and you don't have to notify anyone which license you are using.
 * You are free to use UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	var MessageStore = function () {
		this.messages = {};
		this.sources = {};
	};

	function jsonMessageLoader( url ) {
		var deferred = $.Deferred();

		$.getJSON( url )
			.done( deferred.resolve )
			.fail( function ( jqxhr, settings, exception ) {
				$.i18n.log( 'Error in loading messages from ' + url + ' Exception: ' + exception );
				// Ignore 404 exception, because we are handling fallabacks explicitly
				deferred.resolve();
			} );

		return deferred.promise();
	}

	/**
	 * See https://github.com/wikimedia/jquery.i18n/wiki/Specification#wiki-Message_File_Loading
	 */
	MessageStore.prototype = {

		/**
		 * General message loading API This can take a URL string for
		 * the json formatted messages.
		 * <code>load('path/to/all_localizations.json');</code>
		 *
		 * This can also load a localization file for a locale <code>
		 * load( 'path/to/de-messages.json', 'de' );
		 * </code>
		 * A data object containing message key- message translation mappings
		 * can also be passed Eg:
		 * <code>
		 * load( { 'hello' : 'Hello' }, optionalLocale );
		 * </code> If the data argument is
		 * null/undefined/false,
		 * all cached messages for the i18n instance will get reset.
		 *
		 * @param {string|Object} source
		 * @param {string} locale Language tag
		 * @return {jQuery.Promise}
		 */
		load: function ( source, locale ) {
			var key = null,
				deferred = null,
				deferreds = [],
				messageStore = this;

			if ( typeof source === 'string' ) {
				// This is a URL to the messages file.
				$.i18n.log( 'Loading messages from: ' + source );
				deferred = jsonMessageLoader( source )
					.done( function ( localization ) {
						messageStore.set( locale, localization );
					} );

				return deferred.promise();
			}

			if ( locale ) {
				// source is an key-value pair of messages for given locale
				messageStore.set( locale, source );

				return $.Deferred().resolve();
			} else {
				// source is a key-value pair of locales and their source
				for ( key in source ) {
					if ( Object.prototype.hasOwnProperty.call( source, key ) ) {
						locale = key;
						// No {locale} given, assume data is a group of languages,
						// call this function again for each language.
						deferreds.push( messageStore.load( source[ key ], locale ) );
					}
				}
				return $.when.apply( $, deferreds );
			}

		},

		/**
		 * Set messages to the given locale.
		 * If locale exists, add messages to the locale.
		 *
		 * @param {string} locale
		 * @param {Object} messages
		 */
		set: function ( locale, messages ) {
			if ( !this.messages[ locale ] ) {
				this.messages[ locale ] = messages;
			} else {
				this.messages[ locale ] = $.extend( this.messages[ locale ], messages );
			}
		},

		/**
		 *
		 * @param {string} locale
		 * @param {string} messageKey
		 * @return {boolean}
		 */
		get: function ( locale, messageKey ) {
			return this.messages[ locale ] && this.messages[ locale ][ messageKey ];
		}
	};

	$.extend( $.i18n.messageStore, new MessageStore() );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.parser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.parser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do
 * anything special to choose one license or the other and you don't have to
 * notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	var MessageParser = function ( options ) {
		this.options = $.extend( {}, $.i18n.parser.defaults, options );
		this.language = $.i18n.languages[ String.locale ] || $.i18n.languages[ 'default' ];
		this.emitter = $.i18n.parser.emitter;
	};

	MessageParser.prototype = {

		constructor: MessageParser,

		simpleParse: function ( message, parameters ) {
			return message.replace( /\$(\d+)/g, function ( str, match ) {
				var index = parseInt( match, 10 ) - 1;

				return parameters[ index ] !== undefined ? parameters[ index ] : '$' + match;
			} );
		},

		parse: function ( message, replacements ) {
			if ( message.indexOf( '{{' ) < 0 ) {
				return this.simpleParse( message, replacements );
			}

			this.emitter.language = $.i18n.languages[ $.i18n().locale ] ||
				$.i18n.languages[ 'default' ];

			return this.emitter.emit( this.ast( message ), replacements );
		},

		ast: function ( message ) {
			var pipe, colon, backslash, anyCharacter, dollar, digits, regularLiteral,
				regularLiteralWithoutBar, regularLiteralWithoutSpace, escapedOrLiteralWithoutBar,
				escapedOrRegularLiteral, templateContents, templateName, openTemplate,
				closeTemplate, expression, paramExpression, result,
				pos = 0;

			// Try parsers until one works, if none work return null
			function choice( parserSyntax ) {
				return function () {
					var i, result;

					for ( i = 0; i < parserSyntax.length; i++ ) {
						result = parserSyntax[ i ]();

						if ( result !== null ) {
							return result;
						}
					}

					return null;
				};
			}

			// Try several parserSyntax-es in a row.
			// All must succeed; otherwise, return null.
			// This is the only eager one.
			function sequence( parserSyntax ) {
				var i, res,
					originalPos = pos,
					result = [];

				for ( i = 0; i < parserSyntax.length; i++ ) {
					res = parserSyntax[ i ]();

					if ( res === null ) {
						pos = originalPos;

						return null;
					}

					result.push( res );
				}

				return result;
			}

			// Run the same parser over and over until it fails.
			// Must succeed a minimum of n times; otherwise, return null.
			function nOrMore( n, p ) {
				return function () {
					var originalPos = pos,
						result = [],
						parsed = p();

					while ( parsed !== null ) {
						result.push( parsed );
						parsed = p();
					}

					if ( result.length < n ) {
						pos = originalPos;

						return null;
					}

					return result;
				};
			}

			// Helpers -- just make parserSyntax out of simpler JS builtin types

			function makeStringParser( s ) {
				var len = s.length;

				return function () {
					var result = null;

					if ( message.slice( pos, pos + len ) === s ) {
						result = s;
						pos += len;
					}

					return result;
				};
			}

			function makeRegexParser( regex ) {
				return function () {
					var matches = message.slice( pos ).match( regex );

					if ( matches === null ) {
						return null;
					}

					pos += matches[ 0 ].length;

					return matches[ 0 ];
				};
			}

			pipe = makeStringParser( '|' );
			colon = makeStringParser( ':' );
			backslash = makeStringParser( '\\' );
			anyCharacter = makeRegexParser( /^./ );
			dollar = makeStringParser( '$' );
			digits = makeRegexParser( /^\d+/ );
			regularLiteral = makeRegexParser( /^[^{}[\]$\\]/ );
			regularLiteralWithoutBar = makeRegexParser( /^[^{}[\]$\\|]/ );
			regularLiteralWithoutSpace = makeRegexParser( /^[^{}[\]$\s]/ );

			// There is a general pattern:
			// parse a thing;
			// if it worked, apply transform,
			// otherwise return null.
			// But using this as a combinator seems to cause problems
			// when combined with nOrMore().
			// May be some scoping issue.
			function transform( p, fn ) {
				return function () {
					var result = p();

					return result === null ? null : fn( result );
				};
			}

			// Used to define "literals" within template parameters. The pipe
			// character is the parameter delimeter, so by default
			// it is not a literal in the parameter
			function literalWithoutBar() {
				var result = nOrMore( 1, escapedOrLiteralWithoutBar )();

				return result === null ? null : result.join( '' );
			}

			function literal() {
				var result = nOrMore( 1, escapedOrRegularLiteral )();

				return result === null ? null : result.join( '' );
			}

			function escapedLiteral() {
				var result = sequence( [ backslash, anyCharacter ] );

				return result === null ? null : result[ 1 ];
			}

			choice( [ escapedLiteral, regularLiteralWithoutSpace ] );
			escapedOrLiteralWithoutBar = choice( [ escapedLiteral, regularLiteralWithoutBar ] );
			escapedOrRegularLiteral = choice( [ escapedLiteral, regularLiteral ] );

			function replacement() {
				var result = sequence( [ dollar, digits ] );

				if ( result === null ) {
					return null;
				}

				return [ 'REPLACE', parseInt( result[ 1 ], 10 ) - 1 ];
			}

			templateName = transform(
				// see $wgLegalTitleChars
				// not allowing : due to the need to catch "PLURAL:$1"
				makeRegexParser( /^[ !"$&'()*,./0-9;=?@A-Z^_`a-z~\x80-\xFF+-]+/ ),

				function ( result ) {
					return result.toString();
				}
			);

			function templateParam() {
				var expr,
					result = sequence( [ pipe, nOrMore( 0, paramExpression ) ] );

				if ( result === null ) {
					return null;
				}

				expr = result[ 1 ];

				// use a "CONCAT" operator if there are multiple nodes,
				// otherwise return the first node, raw.
				return expr.length > 1 ? [ 'CONCAT' ].concat( expr ) : expr[ 0 ];
			}

			function templateWithReplacement() {
				var result = sequence( [ templateName, colon, replacement ] );

				return result === null ? null : [ result[ 0 ], result[ 2 ] ];
			}

			function templateWithOutReplacement() {
				var result = sequence( [ templateName, colon, paramExpression ] );

				return result === null ? null : [ result[ 0 ], result[ 2 ] ];
			}

			templateContents = choice( [
				function () {
					var res = sequence( [
						// templates can have placeholders for dynamic
						// replacement eg: {{PLURAL:$1|one car|$1 cars}}
						// or no placeholders eg:
						// {{GRAMMAR:genitive|{{SITENAME}}}
						choice( [ templateWithReplacement, templateWithOutReplacement ] ),
						nOrMore( 0, templateParam )
					] );

					return res === null ? null : res[ 0 ].concat( res[ 1 ] );
				},
				function () {
					var res = sequence( [ templateName, nOrMore( 0, templateParam ) ] );

					if ( res === null ) {
						return null;
					}

					return [ res[ 0 ] ].concat( res[ 1 ] );
				}
			] );

			openTemplate = makeStringParser( '{{' );
			closeTemplate = makeStringParser( '}}' );

			function template() {
				var result = sequence( [ openTemplate, templateContents, closeTemplate ] );

				return result === null ? null : result[ 1 ];
			}

			expression = choice( [ template, replacement, literal ] );
			paramExpression = choice( [ template, replacement, literalWithoutBar ] );

			function start() {
				var result = nOrMore( 0, expression )();

				if ( result === null ) {
					return null;
				}

				return [ 'CONCAT' ].concat( result );
			}

			result = start();

			/*
			 * For success, the pos must have gotten to the end of the input
			 * and returned a non-null.
			 * n.b. This is part of language infrastructure, so we do not throw an
			 * internationalizable message.
			 */
			if ( result === null || pos !== message.length ) {
				throw new Error( 'Parse error at position ' + pos.toString() + ' in input: ' + message );
			}

			return result;
		}

	};

	$.extend( $.i18n.parser, new MessageParser() );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/languages/fi.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/languages/fi.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Finnish (Suomi) language functions
 *
 * @author Santhosh Thottingal
 */

( function ( $ ) {
	'use strict';

	$.i18n.languages.fi = $.extend( {}, $.i18n.languages[ 'default' ], {
		convertGrammar: function ( word, form ) {
			// vowel harmony flag
			var aou = word.match( /[aou][^äöy]*$/i ),
				origWord = word;
			if ( word.match( /wiki$/i ) ) {
				aou = false;
			}

			// append i after final consonant
			if ( word.match( /[bcdfghjklmnpqrstvwxz]$/i ) ) {
				word += 'i';
			}

			switch ( form ) {
				case 'genitive':
					word += 'n';
					break;
				case 'elative':
					word += ( aou ? 'sta' : 'stä' );
					break;
				case 'partitive':
					word += ( aou ? 'a' : 'ä' );
					break;
				case 'illative':
				// Double the last letter and add 'n'
					word += word.slice( -1 ) + 'n';
					break;
				case 'inessive':
					word += ( aou ? 'ssa' : 'ssä' );
					break;
				default:
					word = origWord;
					break;
			}

			return word;
		}
	} );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/languages/he.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/languages/he.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Hebrew (עברית) language functions
 */
( function ( $ ) {
	'use strict';

	$.i18n.languages.he = $.extend( {}, $.i18n.languages[ 'default' ], {
		convertGrammar: function ( word, form ) {
			switch ( form ) {
				case 'prefixed':
				case 'תחילית': // the same word in Hebrew
					// Duplicate prefixed "Waw", but only if it's not already double
					if ( word.slice( 0, 1 ) === 'ו' && word.slice( 0, 2 ) !== 'וו' ) {
						word = 'ו' + word;
					}

					// Remove the "He" if prefixed
					if ( word.slice( 0, 1 ) === 'ה' ) {
						word = word.slice( 1 );
					}

					// Add a hyphen (maqaf) before numbers and non-Hebrew letters
					if ( word.slice( 0, 1 ) < 'א' || word.slice( 0, 1 ) > 'ת' ) {
						word = '־' + word;
					}
			}

			return word;
		}
	} );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/@wikimedia/jquery.i18n/src/languages/ml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@wikimedia/jquery.i18n/src/languages/ml.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Malayalam language functions
 *
 * @author Santhosh Thottingal
 */

( function ( $ ) {
	'use strict';

	$.i18n.languages.ml = $.extend( {}, $.i18n.languages[ 'default' ], {
		convertGrammar: function ( word, form ) {
			form = form.toLowerCase();
			switch ( form ) {
				case 'ഉദ്ദേശിക':
				case 'dative':
					if ( word.slice( -1 ) === 'ു' ||
						word.slice( -1 ) === 'ൂ' ||
						word.slice( -1 ) === 'ൗ' ||
						word.slice( -1 ) === 'ൌ'
					) {
						word += 'വിന്';
					} else if ( word.slice( -1 ) === 'ം' ) {
						word = word.slice( 0, -1 ) + 'ത്തിന്';
					} else if ( word.slice( -1 ) === 'ൻ' ) {
						// Atomic chillu n. അവൻ -> അവന്
						word = word.slice( 0, -1 ) + 'ന്';
					} else if ( word.slice( -3 ) === 'ന്\u200d' ) {
						// chillu n. അവൻ -> അവന്
						word = word.slice( 0, -1 );
					} else if ( word.slice( -1 ) === 'ൾ' || word.slice( -3 ) === 'ള്\u200d' ) {
						word += 'ക്ക്';
					} else if ( word.slice( -1 ) === 'ർ' || word.slice( -3 ) === 'ര്\u200d' ) {
						word += 'ക്ക്';
					} else if ( word.slice( -1 ) === 'ൽ' ) {
						// Atomic chillu ൽ , ഫയൽ -> ഫയലിന്
						word = word.slice( 0, -1 ) + 'ലിന്';
					} else if ( word.slice( -3 ) === 'ല്\u200d' ) {
						// chillu ല്\u200d , ഫയല്\u200d -> ഫയലിന്
						word = word.slice( 0, -2 ) + 'ിന്';
					} else if ( word.slice( -2 ) === 'ു്' ) {
						word = word.slice( 0, -2 ) + 'ിന്';
					} else if ( word.slice( -1 ) === '്' ) {
						word = word.slice( 0, -1 ) + 'ിന്';
					} else {
						// കാവ്യ -> കാവ്യയ്ക്ക്, ഹരി -> ഹരിയ്ക്ക്, മല -> മലയ്ക്ക്
						word += 'യ്ക്ക്';
					}

					break;
				case 'സംബന്ധിക':
				case 'genitive':
					if ( word.slice( -1 ) === 'ം' ) {
						word = word.slice( 0, -1 ) + 'ത്തിന്റെ';
					} else if ( word.slice( -2 ) === 'ു്' ) {
						word = word.slice( 0, -2 ) + 'ിന്റെ';
					} else if ( word.slice( -1 ) === '്' ) {
						word = word.slice( 0, -1 ) + 'ിന്റെ';
					} else if ( word.slice( -1 ) === 'ു' ||
						word.slice( -1 ) === 'ൂ' ||
						word.slice( -1 ) === 'ൗ' ||
						word.slice( -1 ) === 'ൌ'
					) {
						word += 'വിന്റെ';
					} else if ( word.slice( -1 ) === 'ൻ' ) {
						// Atomic chillu n. അവൻ -> അവന്റെ
						word = word.slice( 0, -1 ) + 'ന്റെ';
					} else if ( word.slice( -3 ) === 'ന്\u200d' ) {
						// chillu n. അവൻ -> അവന്റെ
						word = word.slice( 0, -1 ) + 'റെ';
					} else if ( word.slice( -3 ) === 'ള്\u200d' ) {
						// chillu n. അവൾ -> അവളുടെ
						word = word.slice( 0, -2 ) + 'ുടെ';
					} else if ( word.slice( -1 ) === 'ൾ' ) {
						// Atomic chillu n. അവള്\u200d -> അവളുടെ
						word = word.slice( 0, -1 ) + 'ളുടെ';
					} else if ( word.slice( -1 ) === 'ൽ' ) {
						// Atomic l. മുയല്\u200d -> മുയലിന്റെ
						word = word.slice( 0, -1 ) + 'ലിന്റെ';
					} else if ( word.slice( -3 ) === 'ല്\u200d' ) {
						// chillu l. മുയല്\u200d -> അവളുടെ
						word = word.slice( 0, -2 ) + 'ിന്റെ';
					} else if ( word.slice( -3 ) === 'ര്\u200d' ) {
						// chillu r. അവര്\u200d -> അവരുടെ
						word = word.slice( 0, -2 ) + 'ുടെ';
					} else if ( word.slice( -1 ) === 'ർ' ) {
						// Atomic chillu r. അവർ -> അവരുടെ
						word = word.slice( 0, -1 ) + 'രുടെ';
					} else {
						word += 'യുടെ';
					}

					break;
			}

			return word;
		}
	} );
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery.uls/css/jquery.uls.css":
/*!****************************************************!*\
  !*** ./node_modules/jquery.uls/css/jquery.uls.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/jquery.uls/css/jquery.uls.grid.css":
/*!*********************************************************!*\
  !*** ./node_modules/jquery.uls/css/jquery.uls.grid.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/jquery.uls/css/jquery.uls.lcd.css":
/*!********************************************************!*\
  !*** ./node_modules/jquery.uls/css/jquery.uls.lcd.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/jquery.uls/src/jquery.uls.core.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery.uls/src/jquery.uls.core.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Universal Language Selector
 * ULS core component.
 *
 * Copyright (C) 2012 Alolita Sharma, Amir Aharoni, Arun Ganesh, Brandon Harris,
 * Niklas Laxström, Pau Giner, Santhosh Thottingal, Siebrand Mazeland and other
 * contributors. See CREDITS for a list.
 *
 * UniversalLanguageSelector is dual licensed GPLv2 or later and MIT. You don't
 * have to do anything special to choose one license or the other and you don't
 * have to notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @file
 * @ingroup Extensions
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	var template, ULS;

	// Region numbers in id attributes also appear in the langdb.
	// eslint-disable-next-line no-multi-str
	template = '<div class="grid uls-menu"> \
			<div id="search" class="row uls-search"> \
				<div class="uls-search-wrapper"> \
					<label class="uls-search-label" for="uls-languagefilter"></label>\
					<div class="uls-search-input-wrapper">\
						<span class="uls-languagefilter-clear"></span>\
						<input type="text" class="uls-filterinput uls-filtersuggestion"\
							disabled="true" autocomplete="off">\
						<input type="text" class="uls-filterinput uls-languagefilter"\
							maxlength="40"\
							data-clear="uls-languagefilter-clear"\
							data-suggestion="uls-filtersuggestion"\
							placeholder="Search for a language" autocomplete="off">\
					</div>\
				</div>\
			</div>\
			<div class="row uls-language-list"></div>\
			<div class="row" id="uls-settings-block"></div>\
		</div>';

	/**
	 * ULS Public class definition
	 * @param {Element} element
	 * @param {Object} options
	 */
	ULS = function ( element, options ) {
		var code;
		this.$element = $( element );
		this.options = $.extend( {}, $.fn.uls.defaults, options );
		this.$menu = $( template );
		this.languages = this.options.languages;

		for ( code in this.languages ) {
			if ( $.uls.data.languages[ code ] === undefined ) {
				// Language is unknown to ULS.
				delete this.languages[ code ];
			}
		}

		this.left = this.options.left;
		this.top = this.options.top;
		this.shown = false;
		this.initialized = false;
		this.shouldRecreate = false;
		this.menuWidth = this.getMenuWidth();

		this.$languageFilter = this.$menu.find( '.uls-languagefilter' );
		this.$resultsView = this.$menu.find( '.uls-language-list' );

		this.render();
		this.listen();
		this.ready();
	};

	ULS.prototype = {
		constructor: ULS,

		/**
		 * A "hook" that runs after the ULS constructor.
		 * At this point it is not guaranteed that the ULS has its dimensions
		 * and that the languages lists are initialized.
		 *
		 * To use it, pass a function as the onReady parameter
		 * in the options when initializing ULS.
		 */
		ready: function () {
			if ( this.options.onReady ) {
				this.options.onReady.call( this );
			}
		},

		/**
		 * A "hook" that runs after the ULS panel becomes visible
		 * by using the show method.
		 *
		 * To use it, pass a function as the onVisible parameter
		 * in the options when initializing ULS.
		 */
		visible: function () {
			if ( this.options.onVisible ) {
				this.options.onVisible.call( this );
			}
		},

		/**
		 * Calculate the position of ULS
		 * Returns an object with top and left properties.
		 * @return {Object}
		 */
		position: function () {
			var pos,
				top = this.top,
				left = this.left;

			if ( top === undefined ) {
				pos = $.extend( {}, this.$element.offset(), {
					height: this.$element[ 0 ].offsetHeight
				} );
				top = pos.top + pos.height;
			}

			if ( left === undefined ) {
				left = $( window ).width() / 2 - this.$menu.outerWidth() / 2;
			}

			return {
				top: top,
				left: left
			};
		},

		/**
		 * Show the ULS window
		 */
		show: function () {
			var widthClasses = {
				wide: 'uls-wide',
				medium: 'uls-medium',
				narrow: 'uls-narrow'
			};

			this.$menu.addClass( widthClasses[ this.menuWidth ] );

			if ( !this.initialized ) {
				$( 'body' ).prepend( this.$menu );
				this.i18n();
				this.initialized = true;
			}

			this.$menu.css( this.position() );
			this.$menu.show();
			this.$menu.scrollIntoView();
			this.shown = true;

			if ( !this.isMobile() ) {
				this.$languageFilter.focus();
			}

			this.visible();
		},

		i18n: function () {
			if ( $.i18n ) {
				this.$menu.find( '[data-i18n]' ).i18n();
				this.$languageFilter.prop( 'placeholder', $.i18n( 'uls-search-placeholder' ) );
			}
		},

		/**
		 * Hide the ULS window
		 */
		hide: function () {
			this.$menu.hide();
			this.shown = false;

			this.$menu.removeClass( 'uls-wide uls-medium uls-narrow' );

			if ( this.shouldRecreate ) {
				this.recreateLanguageFilter();
			}

			if ( this.options.onCancel ) {
				this.options.onCancel.call( this );
			}
		},

		/**
		 * Render the UI elements.
		 * Does nothing by default. Can be used for customization.
		 */
		render: function () {
			// Rendering stuff here
		},

		/**
		 * Callback for results found context.
		 */
		success: function () {
			this.$resultsView.show();
		},

		createLanguageFilter: function () {
			var lcd, languagesCount,
				columnsOptions = {
					wide: 4,
					medium: 2,
					narrow: 1
				};

			languagesCount = Object.keys( this.options.languages ).length;
			lcd = this.$resultsView.lcd( {
				languages: this.languages,
				columns: columnsOptions[ this.menuWidth ],

				quickList: languagesCount > 12 ? this.options.quickList : [],
				clickhandler: this.select.bind( this ),
				showRegions: this.options.showRegions,
				languageDecorator: this.options.languageDecorator,
				noResultsTemplate: this.options.noResultsTemplate,
				itemsPerColumn: this.options.itemsPerColumn,
				groupByRegion: this.options.groupByRegion
			} ).data( 'lcd' );

			this.$languageFilter.languagefilter( {
				lcd: lcd,
				languages: this.languages,
				ulsPurpose: this.options.ulsPurpose,
				searchAPI: this.options.searchAPI,
				onSelect: this.select.bind( this )
			} );

			this.$languageFilter.on( 'noresults.uls', lcd.noResults.bind( lcd ) );
		},

		recreateLanguageFilter: function () {
			this.$resultsView.removeData( 'lcd' );
			this.$resultsView.empty();
			this.$languageFilter.removeData( 'languagefilter' );
			this.createLanguageFilter();

			this.shouldRecreate = false;
		},

		/**
		 * Bind the UI elements with their event listeners
		 */
		listen: function () {
			// Register all event listeners to the ULS here.
			this.$element.on( 'click', this.click.bind( this ) );

			// Don't do anything if pressing on empty space in the ULS
			this.$menu.on( 'click', function ( e ) {
				e.stopPropagation();
			} );

			// Handle key press events on the menu
			this.$menu.on( 'keydown', this.keypress.bind( this ) );

			this.createLanguageFilter();

			this.$languageFilter.on( 'resultsfound.uls', this.success.bind( this ) );

			$( 'html' ).click( this.cancel.bind( this ) );
			$( window ).resize( $.fn.uls.debounce( this.resize.bind( this ), 250 ) );
		},

		resize: function () {
			var menuWidth = this.getMenuWidth();

			if ( this.menuWidth === menuWidth ) {
				return;
			}

			this.menuWidth = menuWidth;
			this.shouldRecreate = true;
			if ( !this.shown ) {
				this.recreateLanguageFilter();
			}
		},

		/**
		 * On select handler for search results
		 * @param {string} langCode
		 * @param {Object} event The jQuery click event
		 */
		select: function ( langCode, event ) {
			this.hide();
			if ( this.options.onSelect ) {
				this.options.onSelect.call( this, langCode, event );
			}
		},

		/**
		 * On cancel handler for the uls menu
		 * @param {Event} e
		 */
		cancel: function ( e ) {
			if ( e && ( this.$element.is( e.target ) ||
				$.contains( this.$element[ 0 ], e.target ) ) ) {
				return;
			}

			this.hide();
		},

		keypress: function ( e ) {
			if ( !this.shown ) {
				return;
			}

			if ( e.keyCode === 27 ) { // escape
				this.cancel();
				e.preventDefault();
				e.stopPropagation();
			}
		},

		click: function () {
			if ( this.shown ) {
				this.hide();
			} else {
				this.show();
			}
		},

		/**
		 * Get the panel menu width parameter
		 * @return {string}
		 */
		getMenuWidth: function () {
			var languagesCount,
				screenWidth = document.documentElement.clientWidth;

			if ( this.options.menuWidth ) {
				return this.options.menuWidth;
			}

			languagesCount = Object.keys( this.options.languages ).length;

			if ( screenWidth > 900 && languagesCount >= 48 ) {
				return 'wide';
			}

			if ( screenWidth > 500 && languagesCount >= 24 ) {
				return 'medium';
			}

			return 'narrow';
		},

		isMobile: function () {
			return navigator.userAgent.match( /(iPhone|iPod|iPad|Android|BlackBerry)/ );
		}
	};

	/* ULS PLUGIN DEFINITION
	 * =========================== */

	$.fn.uls = function ( option ) {
		return this.each( function () {
			var $this = $( this ),
				data = $this.data( 'uls' ),
				options = typeof option === 'object' && option;

			if ( !data ) {
				$this.data( 'uls', ( data = new ULS( this, options ) ) );
			}

			if ( typeof option === 'string' ) {
				data[ option ]();
			}
		} );
	};

	$.fn.uls.defaults = {
		// CSS top position for the dialog
		top: undefined,
		// CSS left position for the dialog
		left: undefined,
		// Callback function when user selects a language
		onSelect: undefined,
		// Callback function when the dialog is closed without selecting a language
		onCancel: undefined,
		// Callback function when ULS has initialized
		onReady: undefined,
		// Callback function when ULS dialog is shown
		onVisible: undefined,
		// Languages to be used for ULS, default is all languages
		languages: $.uls.data.getAutonyms(),
		// The options are wide (4 columns), medium (2 columns), and narrow (1 column).
		// If not specified, it will be set automatically.
		menuWidth: undefined,
		// What is this ULS used for.
		// Should be set for distinguishing between different instances of ULS
		// in the same application.
		ulsPurpose: '',
		// Used by LCD
		quickList: [],
		// Used by LCD
		showRegions: undefined,
		// Used by LCD
		languageDecorator: undefined,
		// Used by LCD
		noResultsTemplate: undefined,
		// Used by LCD
		itemsPerColumn: undefined,
		// Used by LCD
		groupByRegion: undefined,
		// Used by LanguageFilter
		searchAPI: undefined
	};

	// Define a dummy i18n function, if jquery.i18n not integrated.
	if ( !$.fn.i18n ) {
		$.fn.i18n = function () {};
	}

	/**
	 * Creates and returns a new debounced version of the passed function,
	 * which will postpone its execution, until after wait milliseconds have elapsed
	 * since the last time it was invoked.
	 *
	 * @param {Function} fn Function to be debounced.
	 * @param {number} wait Wait interval in milliseconds.
	 * @param {boolean} [immediate] Trigger the function on the leading edge of the wait interval,
	 * instead of the trailing edge.
	 * @return {Function} Debounced function.
	 */
	$.fn.uls.debounce = function ( fn, wait, immediate ) {
		var timeout;

		return function () {
			var callNow, self = this,
				later = function () {
					timeout = null;
					if ( !immediate ) {
						fn.apply( self, arguments );
					}
				};

			callNow = immediate && !timeout;
			clearTimeout( timeout );
			timeout = setTimeout( later, wait || 100 );

			if ( callNow ) {
				fn.apply( self, arguments );
			}
		};
	};

	/*
	 * Simple scrollIntoView plugin.
	 * Scrolls the element to the viewport smoothly if it is not already.
	 */
	$.fn.scrollIntoView = function () {
		return this.each( function () {
			var scrollPosition,
				$window = $( window ),
				windowHeight = $window.height(),
				windowTop = $window.scrollTop(),
				windowBottom = windowTop + windowHeight,
				$element = $( this ),
				panelHeight = $element.height(),
				panelTop = $element.offset().top,
				panelBottom = panelTop + panelHeight;

			if ( ( panelTop < windowTop ) || ( panelBottom > windowBottom ) ) {
				if ( windowTop > panelTop ) {
					scrollPosition = panelTop;
				} else {
					scrollPosition = panelBottom - windowHeight;
				}
				$( 'html, body' ).stop().animate( {
					scrollTop: scrollPosition
				}, 500 );
			}
		} );
	};

	$.fn.uls.Constructor = ULS;
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery.uls/src/jquery.uls.data.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery.uls/src/jquery.uls.data.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {var require;var require;(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports=( function ( $ ) {
	$.uls = $.uls || {};
	$.uls.data = {
    "languages": {
        "aa": [
            "Latn",
            [
                "AF"
            ],
            "Qafár af"
        ],
        "ab": [
            "Cyrl",
            [
                "EU"
            ],
            "Аҧсшәа"
        ],
        "abe": [
            "Latn",
            [
                "AM"
            ],
            "Wôbanakiôdwawôgan"
        ],
        "abs": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Ambon"
        ],
        "ace": [
            "Latn",
            [
                "AS",
                "PA"
            ],
            "Acèh"
        ],
        "acf": [
            "Latn",
            [
                "AM"
            ],
            "kwéyòl"
        ],
        "ady": [
            "Cyrl",
            [
                "EU",
                "ME"
            ],
            "Адыгабзэ"
        ],
        "ady-cyrl": [
            "ady"
        ],
        "ady-latn": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "Adygabze"
        ],
        "aeb": [
            "aeb-arab"
        ],
        "aeb-arab": [
            "Arab",
            [
                "AF"
            ],
            "تونسي"
        ],
        "aeb-latn": [
            "Latn",
            [
                "AF"
            ],
            "Tûnsî"
        ],
        "af": [
            "Latn",
            [
                "AF"
            ],
            "Afrikaans"
        ],
        "ahr": [
            "Deva",
            [
                "AS"
            ],
            "अहिराणी"
        ],
        "ais": [
            "Latn",
            [
                "AS"
            ],
            "Sakizaya"
        ],
        "ak": [
            "Latn",
            [
                "AF"
            ],
            "Akan"
        ],
        "akz": [
            "Latn",
            [
                "AM"
            ],
            "Albaamo innaaɬiilka"
        ],
        "aln": [
            "Latn",
            [
                "EU"
            ],
            "Gegë"
        ],
        "am": [
            "Ethi",
            [
                "AF"
            ],
            "አማርኛ"
        ],
        "ami": [
            "Latn",
            [
                "AS"
            ],
            "Pangcah"
        ],
        "an": [
            "Latn",
            [
                "EU"
            ],
            "aragonés"
        ],
        "ang": [
            "Latn",
            [
                "EU"
            ],
            "Ænglisc"
        ],
        "anp": [
            "Deva",
            [
                "AS"
            ],
            "अङ्गिका"
        ],
        "ar": [
            "Arab",
            [
                "ME"
            ],
            "العربية"
        ],
        "arc": [
            "Syrc",
            [
                "ME"
            ],
            "ܐܪܡܝܐ"
        ],
        "arn": [
            "Latn",
            [
                "AM"
            ],
            "mapudungun"
        ],
        "aro": [
            "Latn",
            [
                "AM"
            ],
            "Araona"
        ],
        "arq": [
            "Arab",
            [
                "AF"
            ],
            "جازايرية"
        ],
        "ary": [
            "Latn",
            [
                "ME"
            ],
            "Maġribi"
        ],
        "arz": [
            "Arab",
            [
                "ME"
            ],
            "مصرى"
        ],
        "as": [
            "Beng",
            [
                "AS"
            ],
            "অসমীয়া"
        ],
        "ase": [
            "Sgnw",
            [
                "AM"
            ],
            "American sign language"
        ],
        "ast": [
            "Latn",
            [
                "EU"
            ],
            "asturianu"
        ],
        "atj": [
            "Latn",
            [
                "AM"
            ],
            "atikamekw"
        ],
        "av": [
            "Cyrl",
            [
                "EU"
            ],
            "авар"
        ],
        "avk": [
            "Latn",
            [
                "WW"
            ],
            "Kotava"
        ],
        "ay": [
            "Latn",
            [
                "AM"
            ],
            "Aymar aru"
        ],
        "az": [
            "az-latn"
        ],
        "az-arab": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "تۆرکجه"
        ],
        "az-latn": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "azərbaycanca"
        ],
        "az-cyrl": [
            "Cyrl",
            [
                "EU",
                "ME"
            ],
            "азәрбајҹанҹа"
        ],
        "azb": [
            "az-arab"
        ],
        "azj": [
            "az-latn"
        ],
        "ba": [
            "Cyrl",
            [
                "EU"
            ],
            "башҡортса"
        ],
        "ban": [
            "Bali",
            [
                "AS"
            ],
            "ᬩᬲᬩᬮᬶ"
        ],
        "bar": [
            "Latn",
            [
                "EU"
            ],
            "Boarisch"
        ],
        "bat-smg": [
            "sgs"
        ],
        "bbc-latn": [
            "Latn",
            [
                "AS"
            ],
            "Batak Toba"
        ],
        "bbc-batk": [
            "Batk",
            [
                "AS"
            ],
            "ᯅᯖᯂ᯲ ᯖᯬᯅ"
        ],
        "bbc": [
            "bbc-latn"
        ],
        "bcc": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "جهلسری بلوچی"
        ],
        "bcl": [
            "Latn",
            [
                "AS"
            ],
            "Bikol Central"
        ],
        "be-tarask": [
            "Cyrl",
            [
                "EU"
            ],
            "беларуская (тарашкевіца)"
        ],
        "be-x-old": [
            "be-tarask"
        ],
        "be": [
            "Cyrl",
            [
                "EU"
            ],
            "беларуская"
        ],
        "bew": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Betawi"
        ],
        "bfa": [
            "Latn",
            [
                "AF"
            ],
            "Bari"
        ],
        "bft": [
            "Arab",
            [
                "AS"
            ],
            "بلتی"
        ],
        "bfq": [
            "Taml",
            [
                "AS"
            ],
            "படகா"
        ],
        "bg": [
            "Cyrl",
            [
                "EU"
            ],
            "български"
        ],
        "bgn": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "روچ کپتین بلوچی"
        ],
        "bh": [
            "bho"
        ],
        "bho": [
            "Deva",
            [
                "AS"
            ],
            "भोजपुरी"
        ],
        "bi": [
            "Latn",
            [
                "PA"
            ],
            "Bislama"
        ],
        "bjn": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Banjar"
        ],
        "bm": [
            "Latn",
            [
                "AF"
            ],
            "bamanankan"
        ],
        "bn": [
            "Beng",
            [
                "AS"
            ],
            "বাংলা"
        ],
        "bnn": [
            "Latn",
            [
                "AS"
            ],
            "Bunun"
        ],
        "bo": [
            "Tibt",
            [
                "AS"
            ],
            "བོད་ཡིག"
        ],
        "bpy": [
            "Beng",
            [
                "AS"
            ],
            "বিষ্ণুপ্রিয়া মণিপুরী"
        ],
        "bqi": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "بختیاری"
        ],
        "br": [
            "Latn",
            [
                "EU"
            ],
            "brezhoneg"
        ],
        "brh": [
            "Latn",
            [
                "ME",
                "AS"
            ],
            "Bráhuí"
        ],
        "brx": [
            "Deva",
            [
                "AS"
            ],
            "बर'"
        ],
        "bs": [
            "Latn",
            [
                "EU"
            ],
            "bosanski"
        ],
        "btm": [
            "Latn",
            [
                "AS"
            ],
            "Mandailing"
        ],
        "bto": [
            "Latn",
            [
                "AS"
            ],
            "Iriga Bicolano"
        ],
        "bug": [
            "Bugi",
            [
                "AS"
            ],
            "ᨅᨔ ᨕᨘᨁᨗ"
        ],
        "bxr": [
            "Cyrl",
            [
                "AS"
            ],
            "буряад"
        ],
        "byn": [
            "Ethi",
            [
                "AF"
            ],
            "ብሊን"
        ],
        "ca": [
            "Latn",
            [
                "EU"
            ],
            "català"
        ],
        "cak": [
            "Latn",
            [
                "AM"
            ],
            "Kaqchikel"
        ],
        "cbk-zam": [
            "Latn",
            [
                "AS"
            ],
            "Chavacano de Zamboanga"
        ],
        "cdo": [
            "Latn",
            [
                "AS"
            ],
            "Mìng-dĕ̤ng-ngṳ̄"
        ],
        "ce": [
            "Cyrl",
            [
                "EU"
            ],
            "нохчийн"
        ],
        "ceb": [
            "Latn",
            [
                "AS"
            ],
            "Cebuano"
        ],
        "ch": [
            "Latn",
            [
                "PA"
            ],
            "Chamoru"
        ],
        "chm": [
            "mhr"
        ],
        "chn": [
            "Latn",
            [
                "AM"
            ],
            "chinuk wawa"
        ],
        "cho": [
            "Latn",
            [
                "AM"
            ],
            "Choctaw"
        ],
        "chr": [
            "Cher",
            [
                "AM"
            ],
            "ᏣᎳᎩ"
        ],
        "chy": [
            "Latn",
            [
                "AM"
            ],
            "Tsetsêhestâhese"
        ],
        "ciw": [
            "Latn",
            [
                "AM"
            ],
            "Ojibwemowin"
        ],
        "cjy": [
            "cjy-hant"
        ],
        "cjy-hans": [
            "Hans",
            [
                "AS"
            ],
            "晋语（简化字)"
        ],
        "cjy-hant": [
            "Hant",
            [
                "AS"
            ],
            "晉語"
        ],
        "ckb": [
            "Arab",
            [
                "ME"
            ],
            "کوردی"
        ],
        "cnh": [
            "Latn",
            [
                "AS"
            ],
            "Lai holh"
        ],
        "cnr": [
            "cnr-latn"
        ],
        "cnr-cyrl": [
            "Cyrl",
            [
                "EU"
            ],
            "црногорски"
        ],
        "cnr-latn": [
            "Latn",
            [
                "EU"
            ],
            "crnogorski"
        ],
        "co": [
            "Latn",
            [
                "EU"
            ],
            "corsu"
        ],
        "cop": [
            "Copt",
            [
                "AF",
                "ME"
            ],
            "ϯⲙⲉⲧⲣⲉⲙⲛ̀ⲭⲏⲙⲓ"
        ],
        "cps": [
            "Latn",
            [
                "AS"
            ],
            "Capiceño"
        ],
        "cr": [
            "Cans",
            [
                "AM"
            ],
            "ᓀᐦᐃᔭᐍᐏᐣ"
        ],
        "cr-cans": [
            "cr"
        ],
        "cr-latn": [
            "Latn",
            [
                "AM"
            ],
            "Nēhiyawēwin"
        ],
        "crh": [
            "Latn",
            [
                "EU"
            ],
            "qırımtatarca"
        ],
        "crh-cyrl": [
            "Cyrl",
            [
                "EU"
            ],
            "къырымтатарджа"
        ],
        "crh-latn": [
            "crh"
        ],
        "cs": [
            "Latn",
            [
                "EU"
            ],
            "čeština"
        ],
        "csb": [
            "Latn",
            [
                "EU"
            ],
            "kaszëbsczi"
        ],
        "cu": [
            "Cyrl",
            [
                "EU"
            ],
            "словѣньскъ \/ ⰔⰎⰑⰂⰡⰐⰠⰔⰍⰟ"
        ],
        "cv": [
            "Cyrl",
            [
                "EU"
            ],
            "Чӑвашла"
        ],
        "cy": [
            "Latn",
            [
                "EU"
            ],
            "Cymraeg"
        ],
        "da": [
            "Latn",
            [
                "EU"
            ],
            "dansk"
        ],
        "dag": [
            "Latn",
            [
                "AF"
            ],
            "dagbanli"
        ],
        "de-at": [
            "Latn",
            [
                "EU"
            ],
            "Österreichisches Deutsch"
        ],
        "de-ch": [
            "Latn",
            [
                "EU"
            ],
            "Schweizer Hochdeutsch"
        ],
        "de-formal": [
            "Latn",
            [
                "EU"
            ],
            "Deutsch (Sie-Form)"
        ],
        "de": [
            "Latn",
            [
                "EU"
            ],
            "Deutsch"
        ],
        "din": [
            "Latn",
            [
                "AF"
            ],
            "Thuɔŋjäŋ"
        ],
        "diq": [
            "Latn",
            [
                "EU",
                "AS"
            ],
            "Zazaki"
        ],
        "doi": [
            "Deva",
            [
                "AS"
            ],
            "डोगरी"
        ],
        "dsb": [
            "Latn",
            [
                "EU"
            ],
            "dolnoserbski"
        ],
        "dtp": [
            "Latn",
            [
                "AS"
            ],
            "Dusun Bundu-liwan"
        ],
        "dty": [
            "Deva",
            [
                "AS"
            ],
            "डोटेली"
        ],
        "dv": [
            "Thaa",
            [
                "AS"
            ],
            "ދިވެހިބަސް"
        ],
        "dz": [
            "Tibt",
            [
                "AS"
            ],
            "ཇོང་ཁ"
        ],
        "ee": [
            "Latn",
            [
                "AF"
            ],
            "eʋegbe"
        ],
        "egl": [
            "Latn",
            [
                "EU"
            ],
            "Emiliàn"
        ],
        "el": [
            "Grek",
            [
                "EU"
            ],
            "Ελληνικά"
        ],
        "eml": [
            "Latn",
            [
                "EU"
            ],
            "emiliàn e rumagnòl"
        ],
        "en-ca": [
            "Latn",
            [
                "AM"
            ],
            "Canadian English"
        ],
        "en-gb": [
            "Latn",
            [
                "EU",
                "AS",
                "PA"
            ],
            "British English"
        ],
        "en": [
            "Latn",
            [
                "EU",
                "AM",
                "AF",
                "ME",
                "AS",
                "PA",
                "WW"
            ],
            "English"
        ],
        "eo": [
            "Latn",
            [
                "WW"
            ],
            "Esperanto"
        ],
        "es-419": [
            "Latn",
            [
                "AM"
            ],
            "español de América Latina"
        ],
        "es-formal": [
            "Latn",
            [
                "EU",
                "AM",
                "AF",
                "WW"
            ],
            "español (formal)"
        ],
        "es": [
            "Latn",
            [
                "EU",
                "AM",
                "AF",
                "WW",
                "PA"
            ],
            "español"
        ],
        "es-ni": [
            "Latn",
            [
                "AM"
            ],
            "español nicaragüense"
        ],
        "esu": [
            "Latn",
            [
                "AM"
            ],
            "Yup'ik"
        ],
        "et": [
            "Latn",
            [
                "EU"
            ],
            "eesti"
        ],
        "eu": [
            "Latn",
            [
                "EU"
            ],
            "euskara"
        ],
        "ext": [
            "Latn",
            [
                "EU"
            ],
            "estremeñu"
        ],
        "eya": [
            "Latn",
            [
                "AM"
            ],
            "I·ya·q"
        ],
        "fa": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "فارسی"
        ],
        "fan": [
            "Latn",
            [
                "AF"
            ],
            "Faŋ"
        ],
        "fax": [
            "Latn",
            [
                "EU"
            ],
            "Fala"
        ],
        "ff": [
            "Latn",
            [
                "AF"
            ],
            "Fulfulde"
        ],
        "fi": [
            "Latn",
            [
                "EU"
            ],
            "suomi"
        ],
        "fil": [
            "tl"
        ],
        "fit": [
            "Latn",
            [
                "EU"
            ],
            "meänkieli"
        ],
        "fiu-vro": [
            "vro"
        ],
        "fj": [
            "Latn",
            [
                "PA"
            ],
            "Na Vosa Vakaviti"
        ],
        "fkv": [
            "Latn",
            [
                "EU"
            ],
            "kvääni"
        ],
        "fo": [
            "Latn",
            [
                "EU"
            ],
            "føroyskt"
        ],
        "fon": [
            "Latn",
            [
                "AF"
            ],
            "fɔ̀ngbè"
        ],
        "fr": [
            "Latn",
            [
                "EU",
                "AM",
                "WW"
            ],
            "français"
        ],
        "frc": [
            "Latn",
            [
                "AM"
            ],
            "français cadien"
        ],
        "frp": [
            "Latn",
            [
                "EU"
            ],
            "arpetan"
        ],
        "frr": [
            "Latn",
            [
                "EU"
            ],
            "Nordfriisk"
        ],
        "fuf": [
            "Latn",
            [
                "AF"
            ],
            "Fuuta Jalon"
        ],
        "fur": [
            "Latn",
            [
                "EU"
            ],
            "furlan"
        ],
        "fy": [
            "Latn",
            [
                "EU"
            ],
            "Frysk"
        ],
        "ga": [
            "Latn",
            [
                "EU"
            ],
            "Gaeilge"
        ],
        "gaa": [
            "Latn",
            [
                "AF"
            ],
            "Ga"
        ],
        "gag": [
            "Latn",
            [
                "EU"
            ],
            "Gagauz"
        ],
        "gah": [
            "Latn",
            [
                "AS"
            ],
            "Alekano"
        ],
        "gan-hans": [
            "Hans",
            [
                "AS"
            ],
            "赣语（简体）"
        ],
        "gan-hant": [
            "gan"
        ],
        "gan": [
            "Hant",
            [
                "AS"
            ],
            "贛語"
        ],
        "gbm": [
            "Deva",
            [
                "AS"
            ],
            "गढ़वळि"
        ],
        "gbz": [
            "Latn",
            [
                "AS"
            ],
            "Dari-e Mazdeyasnā"
        ],
        "gcf": [
            "Latn",
            [
                "AM"
            ],
            "Guadeloupean Creole French"
        ],
        "gcr": [
            "Latn",
            [
                "AM"
            ],
            "kréyòl gwiyanè"
        ],
        "gd": [
            "Latn",
            [
                "EU"
            ],
            "Gàidhlig"
        ],
        "gez": [
            "Ethi",
            [
                "AF"
            ],
            "ግዕዝ"
        ],
        "gl": [
            "Latn",
            [
                "EU"
            ],
            "galego"
        ],
        "glk": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "گیلکی"
        ],
        "gn": [
            "Latn",
            [
                "AM"
            ],
            "Avañe'ẽ"
        ],
        "gom": [
            "gom-deva"
        ],
        "gom-deva": [
            "Deva",
            [
                "AS"
            ],
            "गोंयची कोंकणी"
        ],
        "gom-latn": [
            "Latn",
            [
                "AS"
            ],
            "Gõychi Konknni"
        ],
        "gor": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Hulontalo"
        ],
        "got": [
            "Goth",
            [
                "EU"
            ],
            "𐌲𐌿𐍄𐌹𐍃𐌺"
        ],
        "grc": [
            "Grek",
            [
                "EU"
            ],
            "Ἀρχαία ἑλληνικὴ"
        ],
        "gsw": [
            "Latn",
            [
                "EU"
            ],
            "Alemannisch"
        ],
        "gu": [
            "Gujr",
            [
                "AS"
            ],
            "ગુજરાતી"
        ],
        "guc": [
            "Latn",
            [
                "AM"
            ],
            "Wayúu"
        ],
        "gum": [
            "Latn",
            [
                "AM"
            ],
            "Namtrik"
        ],
        "gur": [
            "Latn",
            [
                "AF"
            ],
            "Gurenɛ"
        ],
        "gv": [
            "Latn",
            [
                "EU"
            ],
            "Gaelg"
        ],
        "ha-arab": [
            "Arab",
            [
                "AF"
            ],
            "هَوُسَ"
        ],
        "ha-latn": [
            "Latn",
            [
                "AF"
            ],
            "Hausa"
        ],
        "ha": [
            "ha-latn"
        ],
        "hai": [
            "Latn",
            [
                "AM"
            ],
            "X̱aat Kíl"
        ],
        "hak": [
            "Latn",
            [
                "AS"
            ],
            "Hak-kâ-fa"
        ],
        "haw": [
            "Latn",
            [
                "AM",
                "PA"
            ],
            "Hawai`i"
        ],
        "he": [
            "Hebr",
            [
                "ME"
            ],
            "עברית"
        ],
        "hak-hans": [
            "Hans",
            [
                "AS"
            ],
            "客家语（简体）"
        ],
        "hak-hant": [
            "Hant",
            [
                "AS"
            ],
            "客家語（繁體）"
        ],
        "hi": [
            "Deva",
            [
                "AS"
            ],
            "हिन्दी"
        ],
        "hif": [
            "Latn",
            [
                "PA",
                "AS"
            ],
            "Fiji Hindi"
        ],
        "hif-deva": [
            "Deva",
            [
                "AS"
            ],
            "फ़ीजी हिन्दी"
        ],
        "hif-latn": [
            "hif"
        ],
        "hil": [
            "Latn",
            [
                "AS"
            ],
            "Ilonggo"
        ],
        "hne": [
            "Deva",
            [
                "AS"
            ],
            "छत्तीसगढ़ी"
        ],
        "ho": [
            "Latn",
            [
                "PA"
            ],
            "Hiri Motu"
        ],
        "hoc": [
            "Wara",
            [
                "AS"
            ],
            "𑢹𑣉𑣉"
        ],
        "hr": [
            "Latn",
            [
                "EU"
            ],
            "hrvatski"
        ],
        "hrx": [
            "Latn",
            [
                "AM"
            ],
            "Hunsrik"
        ],
        "hsb": [
            "Latn",
            [
                "EU"
            ],
            "hornjoserbsce"
        ],
        "hsn": [
            "Hans",
            [
                "AS"
            ],
            "湘语"
        ],
        "ht": [
            "Latn",
            [
                "AM"
            ],
            "Kreyòl ayisyen"
        ],
        "hu-formal": [
            "Latn",
            [
                "EU"
            ],
            "Magyar (magázó)"
        ],
        "hu": [
            "Latn",
            [
                "EU"
            ],
            "magyar"
        ],
        "hy": [
            "Armn",
            [
                "EU",
                "ME"
            ],
            "հայերեն"
        ],
        "hyw": [
            "Armn",
            [
                "EU",
                "ME"
            ],
            "արեւմտահայերէն"
        ],
        "hz": [
            "Latn",
            [
                "AF"
            ],
            "Otsiherero"
        ],
        "ia": [
            "Latn",
            [
                "WW"
            ],
            "interlingua"
        ],
        "id": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Indonesia"
        ],
        "ie": [
            "Latn",
            [
                "WW"
            ],
            "Interlingue"
        ],
        "ig": [
            "Latn",
            [
                "AF"
            ],
            "Igbo"
        ],
        "ii": [
            "Yiii",
            [
                "AS"
            ],
            "ꆇꉙ"
        ],
        "ik": [
            "Latn",
            [
                "AM"
            ],
            "Iñupiak"
        ],
        "ike-cans": [
            "Cans",
            [
                "AM"
            ],
            "ᐃᓄᒃᑎᑐᑦ"
        ],
        "ike-latn": [
            "Latn",
            [
                "AM"
            ],
            "inuktitut"
        ],
        "ilo": [
            "Latn",
            [
                "AS"
            ],
            "Ilokano"
        ],
        "inh": [
            "Cyrl",
            [
                "EU"
            ],
            "ГӀалгӀай"
        ],
        "io": [
            "Latn",
            [
                "WW"
            ],
            "Ido"
        ],
        "is": [
            "Latn",
            [
                "EU"
            ],
            "íslenska"
        ],
        "it": [
            "Latn",
            [
                "EU"
            ],
            "italiano"
        ],
        "iu": [
            "ike-cans"
        ],
        "ja": [
            "Jpan",
            [
                "AS"
            ],
            "日本語"
        ],
        "jam": [
            "Latn",
            [
                "AM"
            ],
            "Patois"
        ],
        "jbo": [
            "Latn",
            [
                "WW"
            ],
            "lojban"
        ],
        "jdt": [
            "jdt-cyrl"
        ],
        "jdt-cyrl": [
            "Cyrl",
            [
                "EU",
                "AS"
            ],
            "жугьури"
        ],
        "jut": [
            "Latn",
            [
                "EU"
            ],
            "jysk"
        ],
        "jv": [
            "Latn",
            [
                "AS",
                "PA"
            ],
            "Basa Jawa"
        ],
        "jv-java": [
            "Java",
            [
                "AS",
                "PA"
            ],
            "ꦧꦱꦗꦮ"
        ],
        "ka": [
            "Geor",
            [
                "EU"
            ],
            "ქართული"
        ],
        "kaa": [
            "Latn",
            [
                "AS"
            ],
            "Qaraqalpaqsha"
        ],
        "kab": [
            "Latn",
            [
                "AF",
                "EU"
            ],
            "Taqbaylit"
        ],
        "kac": [
            "Latn",
            [
                "AS"
            ],
            "Jinghpaw"
        ],
        "kbd-cyrl": [
            "kbd"
        ],
        "kbd-latn": [
            "Latn",
            [
                "EU"
            ],
            "Qabardjajəbza"
        ],
        "kbd": [
            "Cyrl",
            [
                "EU",
                "ME"
            ],
            "Адыгэбзэ"
        ],
        "kbp": [
            "Latn",
            [
                "AF"
            ],
            "Kabɩyɛ"
        ],
        "kea": [
            "Latn",
            [
                "AF"
            ],
            "Kabuverdianu"
        ],
        "kg": [
            "Latn",
            [
                "AF"
            ],
            "Kongo"
        ],
        "kgp": [
            "Latn",
            [
                "AM"
            ],
            "Kaingáng"
        ],
        "khw": [
            "Arab",
            [
                "ME",
                "AS"
            ],
            "کھوار"
        ],
        "ki": [
            "Latn",
            [
                "AF"
            ],
            "Gĩkũyũ"
        ],
        "kiu": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "Kırmancki"
        ],
        "kj": [
            "Latn",
            [
                "AF"
            ],
            "Kwanyama"
        ],
        "kjh": [
            "Cyrl",
            [
                "AS"
            ],
            "хакас"
        ],
        "kjp": [
            "Mymr",
            [
                "AS"
            ],
            "ဖၠုံလိက်"
        ],
        "kk": [
            "kk-cyrl"
        ],
        "kk-arab": [
            "Arab",
            [
                "EU",
                "AS"
            ],
            "قازاقشا (تٶتە)"
        ],
        "kk-cn": [
            "kk-arab"
        ],
        "kk-cyrl": [
            "Cyrl",
            [
                "EU",
                "AS"
            ],
            "қазақша"
        ],
        "kk-kz": [
            "kk-cyrl"
        ],
        "kk-latn": [
            "Latn",
            [
                "EU",
                "AS",
                "ME"
            ],
            "qazaqşa"
        ],
        "kk-tr": [
            "kk-latn"
        ],
        "kl": [
            "Latn",
            [
                "AM",
                "EU"
            ],
            "kalaallisut"
        ],
        "km": [
            "Khmr",
            [
                "AS"
            ],
            "ភាសាខ្មែរ"
        ],
        "kn": [
            "Knda",
            [
                "AS"
            ],
            "ಕನ್ನಡ"
        ],
        "knn": [
            "Deva",
            [
                "AS"
            ],
            "महाराष्ट्रीय कोंकणी"
        ],
        "ko-kp": [
            "Kore",
            [
                "AS"
            ],
            "조선말"
        ],
        "ko": [
            "Kore",
            [
                "AS"
            ],
            "한국어"
        ],
        "koi": [
            "Cyrl",
            [
                "EU"
            ],
            "Перем Коми"
        ],
        "koy": [
            "Latn",
            [
                "AM"
            ],
            "Denaakkenaageʼ"
        ],
        "kr": [
            "Latn",
            [
                "AF"
            ],
            "Kanuri"
        ],
        "krc": [
            "Cyrl",
            [
                "EU"
            ],
            "къарачай-малкъар"
        ],
        "kri": [
            "Latn",
            [
                "AF"
            ],
            "Krio"
        ],
        "krj": [
            "Latn",
            [
                "ME",
                "EU"
            ],
            "Kinaray-a"
        ],
        "krl": [
            "Latn",
            [
                "EU"
            ],
            "Karjala"
        ],
        "ks-arab": [
            "Arab",
            [
                "AS"
            ],
            "کٲشُر"
        ],
        "ks-deva": [
            "Deva",
            [
                "AS"
            ],
            "कॉशुर"
        ],
        "ks": [
            "ks-arab"
        ],
        "ksf": [
            "Latn",
            [
                "AF"
            ],
            "Bafia"
        ],
        "ksh": [
            "Latn",
            [
                "EU"
            ],
            "Ripoarisch"
        ],
        "ku": [
            "ku-latn"
        ],
        "ku-arab": [
            "Arab",
            [
                "EU",
                "ME"
            ],
            "كوردي"
        ],
        "ku-latn": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "kurdî"
        ],
        "kum": [
            "Cyrl",
            [
                "EU"
            ],
            "къумукъ"
        ],
        "kv": [
            "Cyrl",
            [
                "EU"
            ],
            "коми"
        ],
        "kw": [
            "Latn",
            [
                "EU"
            ],
            "kernowek"
        ],
        "ky": [
            "Cyrl",
            [
                "AS"
            ],
            "Кыргызча"
        ],
        "la": [
            "Latn",
            [
                "EU"
            ],
            "Latina"
        ],
        "lad": [
            "lad-latn"
        ],
        "lad-latn": [
            "Latn",
            [
                "ME",
                "EU",
                "AM"
            ],
            "Ladino"
        ],
        "lad-hebr": [
            "Hebr",
            [
                "ME",
                "EU",
                "AM"
            ],
            "לאדינו"
        ],
        "lag": [
            "Latn",
            [
                "AF"
            ],
            "Kilaangi"
        ],
        "lb": [
            "Latn",
            [
                "EU"
            ],
            "Lëtzebuergesch"
        ],
        "lbe": [
            "Cyrl",
            [
                "EU"
            ],
            "лакку"
        ],
        "lez": [
            "Cyrl",
            [
                "EU"
            ],
            "лезги"
        ],
        "lfn": [
            "Latn",
            [
                "WW"
            ],
            "Lingua Franca Nova"
        ],
        "lg": [
            "Latn",
            [
                "AF"
            ],
            "Luganda"
        ],
        "li": [
            "Latn",
            [
                "EU"
            ],
            "Limburgs"
        ],
        "lij": [
            "Latn",
            [
                "EU"
            ],
            "Ligure"
        ],
        "liv": [
            "Latn",
            [
                "EU"
            ],
            "Līvõ kēļ"
        ],
        "lki": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "لەکی"
        ],
        "lkt": [
            "Latn",
            [
                "AM"
            ],
            "Lakȟótiyapi"
        ],
        "lld": [
            "Latn",
            [
                "EU"
            ],
            "Ladin"
        ],
        "lmo": [
            "Latn",
            [
                "EU"
            ],
            "lumbaart"
        ],
        "ln": [
            "Latn",
            [
                "AF"
            ],
            "lingála"
        ],
        "lo": [
            "Laoo",
            [
                "AS"
            ],
            "ລາວ"
        ],
        "loz": [
            "Latn",
            [
                "AF"
            ],
            "Silozi"
        ],
        "lt": [
            "Latn",
            [
                "EU"
            ],
            "lietuvių"
        ],
        "lrc": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "لۊری شومالی"
        ],
        "ltg": [
            "Latn",
            [
                "EU"
            ],
            "latgaļu"
        ],
        "lud": [
            "Latn",
            [
                "EU"
            ],
            "lüüdi"
        ],
        "lus": [
            "Latn",
            [
                "AS"
            ],
            "Mizo ţawng"
        ],
        "lut": [
            "Latn",
            [
                "AM"
            ],
            "dxʷləšucid"
        ],
        "luz": [
            "Arab",
            [
                "ME"
            ],
            "لئری دوٙمینی"
        ],
        "lv": [
            "Latn",
            [
                "EU"
            ],
            "latviešu"
        ],
        "lzh": [
            "Hant",
            [
                "AS"
            ],
            "文言"
        ],
        "lzz": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "Lazuri"
        ],
        "mai": [
            "Deva",
            [
                "AS"
            ],
            "मैथिली"
        ],
        "map-bms": [
            "Latn",
            [
                "AS"
            ],
            "Basa Banyumasan"
        ],
        "mdf": [
            "Cyrl",
            [
                "EU"
            ],
            "мокшень"
        ],
        "mfe": [
            "Latn",
            [
                "AM"
            ],
            "Morisyen"
        ],
        "mg": [
            "Latn",
            [
                "AF"
            ],
            "Malagasy"
        ],
        "mh": [
            "Latn",
            [
                "PA"
            ],
            "Ebon"
        ],
        "mhr": [
            "Cyrl",
            [
                "EU"
            ],
            "олык марий"
        ],
        "mi": [
            "Latn",
            [
                "PA"
            ],
            "Māori"
        ],
        "mic": [
            "Latn",
            [
                "AM"
            ],
            "Mi'kmaq"
        ],
        "min": [
            "Latn",
            [
                "AS"
            ],
            "Baso Minangkabau"
        ],
        "miq": [
            "Latn",
            [
                "AM"
            ],
            "Mískitu"
        ],
        "mk": [
            "Cyrl",
            [
                "EU"
            ],
            "македонски"
        ],
        "ml": [
            "Mlym",
            [
                "AS",
                "ME"
            ],
            "മലയാളം"
        ],
        "mn": [
            "Cyrl",
            [
                "AS"
            ],
            "монгол"
        ],
        "mnc": [
            "Mong",
            [
                "AS"
            ],
            "ᠮᠠᠨᠵᡠ ᡤᡳᠰᡠᠨ"
        ],
        "mni": [
            "Beng",
            [
                "AS"
            ],
            "মেইতেই লোন্"
        ],
        "mnw": [
            "Mymr",
            [
                "AS"
            ],
            "ဘာသာ မန်"
        ],
        "mo": [
            "Cyrl",
            [
                "EU"
            ],
            "молдовеняскэ"
        ],
        "moe": [
            "Latn",
            [
                "AM"
            ],
            "Innu-aimun"
        ],
        "mr": [
            "Deva",
            [
                "AS",
                "ME"
            ],
            "मराठी"
        ],
        "mrj": [
            "Cyrl",
            [
                "EU"
            ],
            "кырык мары"
        ],
        "ms": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Melayu"
        ],
        "mt": [
            "Latn",
            [
                "EU"
            ],
            "Malti"
        ],
        "mui": [
            "Latn",
            [
                "AS"
            ],
            "Musi"
        ],
        "mus": [
            "Latn",
            [
                "AM"
            ],
            "Mvskoke"
        ],
        "mwl": [
            "Latn",
            [
                "EU"
            ],
            "Mirandés"
        ],
        "mwv": [
            "Latn",
            [
                "AS"
            ],
            "Behase Mentawei"
        ],
        "mww": [
            "mww-latn"
        ],
        "mww-latn": [
            "Latn",
            [
                "AS"
            ],
            "Hmoob Dawb"
        ],
        "my": [
            "Mymr",
            [
                "AS"
            ],
            "မြန်မာဘာသာ"
        ],
        "myv": [
            "Cyrl",
            [
                "EU"
            ],
            "эрзянь"
        ],
        "mzn": [
            "Arab",
            [
                "ME",
                "AS"
            ],
            "مازِرونی"
        ],
        "na": [
            "Latn",
            [
                "PA"
            ],
            "Dorerin Naoero"
        ],
        "nah": [
            "Latn",
            [
                "AM"
            ],
            "Nāhuatl"
        ],
        "nan": [
            "Latn",
            [
                "AS"
            ],
            "Bân-lâm-gú"
        ],
        "nap": [
            "Latn",
            [
                "EU"
            ],
            "Napulitano"
        ],
        "nb": [
            "Latn",
            [
                "EU"
            ],
            "norsk (bokmål)"
        ],
        "nd": [
            "Latn",
            [
                "AF"
            ],
            "siNdebele saseNyakatho"
        ],
        "nds-nl": [
            "Latn",
            [
                "EU"
            ],
            "Nedersaksisch"
        ],
        "nds": [
            "Latn",
            [
                "EU"
            ],
            "Plattdüütsch"
        ],
        "ne": [
            "Deva",
            [
                "AS"
            ],
            "नेपाली"
        ],
        "new": [
            "Deva",
            [
                "AS"
            ],
            "नेपाल भाषा"
        ],
        "ng": [
            "Latn",
            [
                "AF"
            ],
            "Oshiwambo"
        ],
        "niu": [
            "Latn",
            [
                "PA"
            ],
            "ko e vagahau Niuē"
        ],
        "njo": [
            "Latn",
            [
                "AS"
            ],
            "Ao"
        ],
        "nl-informal": [
            "Latn",
            [
                "EU",
                "AM"
            ],
            "Nederlands (informeel)"
        ],
        "nl": [
            "Latn",
            [
                "EU",
                "AM"
            ],
            "Nederlands"
        ],
        "nn": [
            "Latn",
            [
                "EU"
            ],
            "norsk (nynorsk)"
        ],
        "no": [
            "Latn",
            [
                "EU"
            ],
            "norsk"
        ],
        "nod": [
            "Thai",
            [
                "AS"
            ],
            "คำเมือง"
        ],
        "nov": [
            "Latn",
            [
                "WW"
            ],
            "Novial"
        ],
        "nqo": [
            "Nkoo",
            [
                "AF"
            ],
            "ߒߞߏ"
        ],
        "nr": [
            "Latn",
            [
                "AF"
            ],
            "isiNdebele seSewula"
        ],
        "nrm": [
            "Latn",
            [
                "EU"
            ],
            "Nouormand"
        ],
        "nso": [
            "Latn",
            [
                "AF"
            ],
            "Sesotho sa Leboa"
        ],
        "nv": [
            "Latn",
            [
                "AM"
            ],
            "Diné bizaad"
        ],
        "ny": [
            "Latn",
            [
                "AF"
            ],
            "Chi-Chewa"
        ],
        "nys": [
            "Latn",
            [
                "PA"
            ],
            "Nyungar"
        ],
        "oc": [
            "Latn",
            [
                "EU"
            ],
            "occitan"
        ],
        "oka": [
            "Latn",
            [
                "AM"
            ],
            "n̓səl̓xcin̓"
        ],
        "olo": [
            "Latn",
            [
                "AS",
                "EU"
            ],
            "Livvinkarjala"
        ],
        "om": [
            "Latn",
            [
                "AF"
            ],
            "Oromoo"
        ],
        "ood": [
            "Latn",
            [
                "AM"
            ],
            "ʼOʼodham ha-ñeʼokĭ"
        ],
        "or": [
            "Orya",
            [
                "AS"
            ],
            "ଓଡ଼ିଆ"
        ],
        "os": [
            "Cyrl",
            [
                "EU"
            ],
            "Ирон"
        ],
        "ota": [
            "Arab",
            [
                "AS",
                "EU"
            ],
            "لسان عثمانى"
        ],
        "ovd": [
            "Latn",
            [
                "EU"
            ],
            "övdalsk"
        ],
        "pa": [
            "pa-guru"
        ],
        "pa-guru": [
            "Guru",
            [
                "AS"
            ],
            "ਪੰਜਾਬੀ"
        ],
        "pag": [
            "Latn",
            [
                "AS"
            ],
            "Pangasinan"
        ],
        "pam": [
            "Latn",
            [
                "AS"
            ],
            "Kapampangan"
        ],
        "pap": [
            "Latn",
            [
                "AM"
            ],
            "Papiamentu"
        ],
        "pbb": [
            "Latn",
            [
                "AM"
            ],
            "Nasa Yuwe"
        ],
        "pcd": [
            "Latn",
            [
                "EU"
            ],
            "Picard"
        ],
        "pdc": [
            "Latn",
            [
                "EU",
                "AM"
            ],
            "Deitsch"
        ],
        "pdt": [
            "Latn",
            [
                "EU",
                "AM"
            ],
            "Plautdietsch"
        ],
        "pfl": [
            "Latn",
            [
                "EU"
            ],
            "Pälzisch"
        ],
        "pi": [
            "Deva",
            [
                "AS"
            ],
            "पालि"
        ],
        "pih": [
            "Latn",
            [
                "PA"
            ],
            "Norfuk \/ Pitkern"
        ],
        "pis": [
            "Latn",
            [
                "PA"
            ],
            "Pijin"
        ],
        "pjt": [
            "Latn",
            [
                "PA"
            ],
            "Pitjantjatjara"
        ],
        "pko": [
            "Latn",
            [
                "AF"
            ],
            "Pökoot"
        ],
        "pl": [
            "Latn",
            [
                "EU"
            ],
            "polski"
        ],
        "pms": [
            "Latn",
            [
                "EU"
            ],
            "Piemontèis"
        ],
        "pnb": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "پنجابی"
        ],
        "pnt": [
            "Grek",
            [
                "EU"
            ],
            "Ποντιακά"
        ],
        "ppl": [
            "Latn",
            [
                "AM"
            ],
            "Nawat"
        ],
        "prg": [
            "Latn",
            [
                "EU"
            ],
            "Prūsiskan"
        ],
        "prs": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "دری"
        ],
        "ps": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "پښتو"
        ],
        "pt-br": [
            "Latn",
            [
                "AM"
            ],
            "português do Brasil"
        ],
        "pt": [
            "Latn",
            [
                "EU",
                "AM",
                "AS",
                "PA",
                "AF",
                "WW"
            ],
            "português"
        ],
        "qu": [
            "Latn",
            [
                "AM"
            ],
            "Runa Simi"
        ],
        "quc": [
            "Latn",
            [
                "AM"
            ],
            "K'iche'"
        ],
        "qug": [
            "Latn",
            [
                "AM"
            ],
            "Runa shimi"
        ],
        "qwh": [
            "Latn",
            [
                "AM"
            ],
            "anqash qichwa"
        ],
        "rap": [
            "Latn",
            [
                "AM"
            ],
            "arero rapa nui"
        ],
        "rcf": [
            "Latn",
            [
                "AF"
            ],
            "Kreol Réyoné"
        ],
        "rgn": [
            "Latn",
            [
                "EU"
            ],
            "Rumagnôl"
        ],
        "rif": [
            "Latn",
            [
                "AF"
            ],
            "Tarifit"
        ],
        "rki": [
            "Mymr",
            [
                "AS"
            ],
            "ရခိုင်"
        ],
        "rm": [
            "Latn",
            [
                "EU"
            ],
            "rumantsch"
        ],
        "rmf": [
            "Latn",
            [
                "EU"
            ],
            "kaalengo tšimb"
        ],
        "rmy": [
            "Latn",
            [
                "EU"
            ],
            "Romani"
        ],
        "rn": [
            "Latn",
            [
                "AF"
            ],
            "Kirundi"
        ],
        "ro": [
            "Latn",
            [
                "EU"
            ],
            "română"
        ],
        "roa-rup": [
            "rup"
        ],
        "roa-tara": [
            "Latn",
            [
                "EU"
            ],
            "tarandíne"
        ],
        "rtm": [
            "Latn",
            [
                "PA"
            ],
            "Faeag Rotuma"
        ],
        "ru": [
            "Cyrl",
            [
                "EU",
                "AS",
                "ME"
            ],
            "русский"
        ],
        "rue": [
            "Cyrl",
            [
                "EU"
            ],
            "русиньскый"
        ],
        "rup": [
            "Latn",
            [
                "EU"
            ],
            "armãneashti"
        ],
        "ruq": [
            "Cyrl",
            [
                "EU"
            ],
            "Влахесте"
        ],
        "ruq-cyrl": [
            "ruq"
        ],
        "ruq-grek": [
            "Grek",
            [
                "EU"
            ],
            "Megleno-Romanian (Greek script)"
        ],
        "ruq-latn": [
            "Latn",
            [
                "EU"
            ],
            "Vlăheşte"
        ],
        "rut": [
            "Cyrl",
            [
                "EU"
            ],
            "мыхаӀбишды"
        ],
        "rw": [
            "Latn",
            [
                "AF"
            ],
            "Kinyarwanda"
        ],
        "rwr": [
            "Deva",
            [
                "AS"
            ],
            "मारवाड़ी"
        ],
        "ryu": [
            "Kana",
            [
                "AS"
            ],
            "ʔucināguci"
        ],
        "sa": [
            "Deva",
            [
                "AS"
            ],
            "संस्कृतम्"
        ],
        "sah": [
            "Cyrl",
            [
                "EU",
                "AS"
            ],
            "саха тыла"
        ],
        "sat": [
            "Olck",
            [
                "AS"
            ],
            "ᱥᱟᱱᱛᱟᱲᱤ"
        ],
        "saz": [
            "Saur",
            [
                "AS"
            ],
            "ꢱꣃꢬꢵꢯ꣄ꢡ꣄ꢬꢵ"
        ],
        "sc": [
            "Latn",
            [
                "EU"
            ],
            "sardu"
        ],
        "scn": [
            "Latn",
            [
                "EU"
            ],
            "sicilianu"
        ],
        "sco": [
            "Latn",
            [
                "EU"
            ],
            "Scots"
        ],
        "sd": [
            "Arab",
            [
                "AS"
            ],
            "سنڌي"
        ],
        "sdc": [
            "Latn",
            [
                "EU"
            ],
            "Sassaresu"
        ],
        "sdh": [
            "Arab",
            [
                "ME"
            ],
            "کوردی خوارگ"
        ],
        "se": [
            "Latn",
            [
                "EU"
            ],
            "davvisámegiella"
        ],
        "ses": [
            "Latn",
            [
                "AF"
            ],
            "Koyraboro Senni"
        ],
        "sei": [
            "Latn",
            [
                "AM"
            ],
            "Cmique Itom"
        ],
        "sg": [
            "Latn",
            [
                "AF"
            ],
            "Sängö"
        ],
        "sgs": [
            "Latn",
            [
                "EU"
            ],
            "žemaitėška"
        ],
        "sh": [
            "Latn",
            [
                "EU"
            ],
            "srpskohrvatski"
        ],
        "shi-latn": [
            "Latn",
            [
                "AF"
            ],
            "Tašlḥiyt"
        ],
        "shi-tfng": [
            "Tfng",
            [
                "AF"
            ],
            "ⵜⴰⵛⵍⵃⵉⵜ"
        ],
        "shi": [
            "shi-latn"
        ],
        "shn": [
            "Mymr",
            [
                "AS"
            ],
            "လိၵ်ႈတႆး"
        ],
        "si": [
            "Sinh",
            [
                "AS"
            ],
            "සිංහල"
        ],
        "simple": [
            "Latn",
            [
                "WW"
            ],
            "Simple English"
        ],
        "sjd": [
            "Cyrl",
            [
                "EU"
            ],
            "Кӣллт са̄мь кӣлл"
        ],
        "sje": [
            "Latn",
            [
                "EU"
            ],
            "bidumsámegiella"
        ],
        "sjo": [
            "Mong",
            [
                "AS"
            ],
            "ᠰᡞᠪᡝ ᡤᡞᠰᡠᠨ"
        ],
        "sju": [
            "Latn",
            [
                "EU"
            ],
            "ubmejensámien giella"
        ],
        "sk": [
            "Latn",
            [
                "EU"
            ],
            "slovenčina"
        ],
        "sl": [
            "Latn",
            [
                "EU"
            ],
            "slovenščina"
        ],
        "sli": [
            "Latn",
            [
                "EU"
            ],
            "Schläsch"
        ],
        "slr": [
            "Latn",
            [
                "AS"
            ],
            "Salırça"
        ],
        "sly": [
            "Latn",
            [
                "AS"
            ],
            "Bahasa Selayar"
        ],
        "skr-arab": [
            "Arab",
            [
                "AS"
            ],
            "سرائیکی"
        ],
        "skr": [
            "skr-arab"
        ],
        "syc": [
            "Syrc",
            [
                "ME"
            ],
            "ܣܘܪܝܝܐ"
        ],
        "sm": [
            "Latn",
            [
                "PA"
            ],
            "Gagana Samoa"
        ],
        "sma": [
            "Latn",
            [
                "EU"
            ],
            "åarjelsaemien"
        ],
        "smj": [
            "Latn",
            [
                "EU"
            ],
            "julevsámegiella"
        ],
        "smn": [
            "Latn",
            [
                "EU"
            ],
            "anarâškielâ"
        ],
        "sms": [
            "Latn",
            [
                "EU"
            ],
            "sää´mǩiõll"
        ],
        "sn": [
            "Latn",
            [
                "AF"
            ],
            "chiShona"
        ],
        "so": [
            "Latn",
            [
                "AF"
            ],
            "Soomaaliga"
        ],
        "son": [
            "Latn",
            [
                "AF"
            ],
            "soŋay"
        ],
        "sq": [
            "Latn",
            [
                "EU"
            ],
            "shqip"
        ],
        "sr": [
            "sr-cyrl"
        ],
        "sr-ec": [
            "sr-cyrl"
        ],
        "sr-cyrl": [
            "Cyrl",
            [
                "EU"
            ],
            "српски"
        ],
        "sr-el": [
            "sr-latn"
        ],
        "sr-latn": [
            "Latn",
            [
                "EU"
            ],
            "srpski"
        ],
        "srn": [
            "Latn",
            [
                "AM",
                "EU"
            ],
            "Sranantongo"
        ],
        "ss": [
            "Latn",
            [
                "AF"
            ],
            "SiSwati"
        ],
        "st": [
            "Latn",
            [
                "AF"
            ],
            "Sesotho"
        ],
        "stq": [
            "Latn",
            [
                "EU"
            ],
            "Seeltersk"
        ],
        "sty": [
            "Cyrl",
            [
                "EU",
                "AS"
            ],
            "себертатар"
        ],
        "su": [
            "Latn",
            [
                "AS"
            ],
            "Basa Sunda"
        ],
        "sv": [
            "Latn",
            [
                "EU"
            ],
            "svenska"
        ],
        "sw": [
            "Latn",
            [
                "AF"
            ],
            "Kiswahili"
        ],
        "swb": [
            "Latn",
            [
                "AF"
            ],
            "Shikomoro"
        ],
        "sxu": [
            "Latn",
            [
                "EU"
            ],
            "Säggssch"
        ],
        "szl": [
            "Latn",
            [
                "EU"
            ],
            "ślůnski"
        ],
        "ta": [
            "Taml",
            [
                "AS"
            ],
            "தமிழ்"
        ],
        "tay": [
            "Latn",
            [
                "AS"
            ],
            "Tayal"
        ],
        "tcy": [
            "Knda",
            [
                "AS"
            ],
            "ತುಳು"
        ],
        "te": [
            "Telu",
            [
                "AS"
            ],
            "తెలుగు"
        ],
        "tet": [
            "Latn",
            [
                "AS",
                "PA"
            ],
            "tetun"
        ],
        "tg-cyrl": [
            "Cyrl",
            [
                "AS"
            ],
            "тоҷикӣ"
        ],
        "tg-latn": [
            "Latn",
            [
                "AS"
            ],
            "tojikī"
        ],
        "tg": [
            "tg-cyrl"
        ],
        "th": [
            "Thai",
            [
                "AS"
            ],
            "ไทย"
        ],
        "ti": [
            "Ethi",
            [
                "AF"
            ],
            "ትግርኛ"
        ],
        "tig": [
            "Ethi",
            [
                "AF"
            ],
            "ትግረ"
        ],
        "tk": [
            "Latn",
            [
                "AS"
            ],
            "Türkmençe"
        ],
        "tkr": [
            "Cyrl",
            [
                "AS"
            ],
            "ЦӀаӀхна миз"
        ],
        "tl": [
            "Latn",
            [
                "AS"
            ],
            "Tagalog"
        ],
        "tly": [
            "Cyrl",
            [
                "EU",
                "AS",
                "ME"
            ],
            "толышә зывон"
        ],
        "tmr": [
            "Hebr",
            [
                "ME",
                "EU",
                "AM"
            ],
            "ארמית בבלית"
        ],
        "tn": [
            "Latn",
            [
                "AF"
            ],
            "Setswana"
        ],
        "to": [
            "Latn",
            [
                "PA"
            ],
            "lea faka-Tonga"
        ],
        "tokipona": [
            "Latn",
            [
                "WW"
            ],
            "Toki Pona"
        ],
        "tpi": [
            "Latn",
            [
                "PA",
                "AS"
            ],
            "Tok Pisin"
        ],
        "tr": [
            "Latn",
            [
                "EU",
                "ME"
            ],
            "Türkçe"
        ],
        "trp": [
            "Latn",
            [
                "AS"
            ],
            "Kokborok (Tripuri)"
        ],
        "tru": [
            "Latn",
            [
                "AS"
            ],
            "Ṫuroyo"
        ],
        "trv": [
            "Latn",
            [
                "AS"
            ],
            "Sediq Taroko"
        ],
        "ts": [
            "Latn",
            [
                "AF"
            ],
            "Xitsonga"
        ],
        "tsd": [
            "Grek",
            [
                "EU"
            ],
            "Τσακωνικά"
        ],
        "tt": [
            "Cyrl",
            [
                "EU"
            ],
            "татарча"
        ],
        "tt-cyrl": [
            "tt"
        ],
        "tt-latn": [
            "Latn",
            [
                "EU"
            ],
            "tatarça"
        ],
        "ttt": [
            "Cyrl",
            [
                "AS"
            ],
            "Tati"
        ],
        "tum": [
            "Latn",
            [
                "AF"
            ],
            "chiTumbuka"
        ],
        "tw": [
            "Latn",
            [
                "AF"
            ],
            "Twi"
        ],
        "twd": [
            "Latn",
            [
                "EU"
            ],
            "Tweants"
        ],
        "ty": [
            "Latn",
            [
                "PA"
            ],
            "reo tahiti"
        ],
        "tyv": [
            "Cyrl",
            [
                "AS"
            ],
            "тыва дыл"
        ],
        "tzl": [
            "Latn",
            [
                "WW"
            ],
            "Talossan"
        ],
        "tzm": [
            "Tfng",
            [
                "AF"
            ],
            "ⵜⴰⵎⴰⵣⵉⵖⵜ"
        ],
        "udm": [
            "Cyrl",
            [
                "EU"
            ],
            "удмурт"
        ],
        "ug": [
            "ug-arab"
        ],
        "ug-arab": [
            "Arab",
            [
                "AS"
            ],
            "ئۇيغۇرچە"
        ],
        "ug-latn": [
            "Latn",
            [
                "AS"
            ],
            "uyghurche"
        ],
        "ug-cyrl": [
            "Cyrl",
            [
                "AS"
            ],
            "уйғурчә"
        ],
        "uk": [
            "Cyrl",
            [
                "EU"
            ],
            "українська"
        ],
        "umu": [
            "Latn",
            [
                "AM"
            ],
            "Huluníixsuwaakan"
        ],
        "ur": [
            "Arab",
            [
                "AS",
                "ME"
            ],
            "اردو"
        ],
        "uz": [
            "Latn",
            [
                "AS"
            ],
            "oʻzbekcha"
        ],
        "ve": [
            "Latn",
            [
                "AF"
            ],
            "Tshivenda"
        ],
        "vec": [
            "Latn",
            [
                "EU"
            ],
            "vèneto"
        ],
        "vep": [
            "Latn",
            [
                "EU"
            ],
            "vepsän kel’"
        ],
        "vi": [
            "Latn",
            [
                "AS"
            ],
            "Tiếng Việt"
        ],
        "vls": [
            "Latn",
            [
                "EU"
            ],
            "West-Vlams"
        ],
        "vmf": [
            "Latn",
            [
                "EU"
            ],
            "Mainfränkisch"
        ],
        "vo": [
            "Latn",
            [
                "WW"
            ],
            "Volapük"
        ],
        "vot": [
            "Latn",
            [
                "EU"
            ],
            "Vaďďa"
        ],
        "vro": [
            "Latn",
            [
                "EU"
            ],
            "Võro"
        ],
        "wa": [
            "Latn",
            [
                "EU"
            ],
            "walon"
        ],
        "war": [
            "Latn",
            [
                "AS"
            ],
            "Winaray"
        ],
        "wls": [
            "Latn",
            [
                "PA"
            ],
            "Faka'uvea"
        ],
        "wo": [
            "Latn",
            [
                "AF"
            ],
            "Wolof"
        ],
        "wuu": [
            "Hans",
            [
                "AS"
            ],
            "吴语"
        ],
        "xal": [
            "Cyrl",
            [
                "EU"
            ],
            "хальмг"
        ],
        "xh": [
            "Latn",
            [
                "AF"
            ],
            "isiXhosa"
        ],
        "xmf": [
            "Geor",
            [
                "EU"
            ],
            "მარგალური"
        ],
        "xsy": [
            "Latn",
            [
                "AS"
            ],
            "SaiSiyat"
        ],
        "ydd": [
            "Hebr",
            [
                "AS",
                "EU"
            ],
            "Eastern Yiddish"
        ],
        "yi": [
            "Hebr",
            [
                "ME",
                "EU",
                "AM"
            ],
            "ייִדיש"
        ],
        "yo": [
            "Latn",
            [
                "AF"
            ],
            "Yorùbá"
        ],
        "yrk": [
            "Cyrl",
            [
                "AS"
            ],
            "Ненэцяʼ вада"
        ],
        "yrl": [
            "Latn",
            [
                "AM"
            ],
            "ñe'engatú"
        ],
        "yua": [
            "Latn",
            [
                "AM"
            ],
            "Maaya T'aan"
        ],
        "yue": [
            "Hant",
            [
                "AS"
            ],
            "粵語"
        ],
        "za": [
            "Latn",
            [
                "AS"
            ],
            "Vahcuengh"
        ],
        "zea": [
            "Latn",
            [
                "EU"
            ],
            "Zeêuws"
        ],
        "zgh": [
            "Tfng",
            [
                "AF"
            ],
            "ⵜⴰⵎⴰⵣⵉⵖⵜ ⵜⴰⵏⴰⵡⴰⵢⵜ"
        ],
        "zh": [
            "Hans",
            [
                "AS"
            ],
            "中文"
        ],
        "zh-classical": [
            "lzh"
        ],
        "zh-cn": [
            "Hans",
            [
                "AS"
            ],
            "中文（中国大陆）"
        ],
        "zh-hans": [
            "Hans",
            [
                "AS"
            ],
            "中文（简体）"
        ],
        "zh-hant": [
            "Hant",
            [
                "AS"
            ],
            "中文（繁體）"
        ],
        "zh-hk": [
            "Hant",
            [
                "AS"
            ],
            "中文（香港）"
        ],
        "zh-min-nan": [
            "nan"
        ],
        "zh-mo": [
            "Hant",
            [
                "AS"
            ],
            "中文（澳門）"
        ],
        "zh-my": [
            "Hans",
            [
                "AS"
            ],
            "中文（马来西亚）"
        ],
        "zh-sg": [
            "Hans",
            [
                "AS"
            ],
            "中文（新加坡）"
        ],
        "zh-tw": [
            "Hant",
            [
                "AS"
            ],
            "中文（台灣）"
        ],
        "zh-yue": [
            "yue"
        ],
        "zu": [
            "Latn",
            [
                "AF"
            ],
            "isiZulu"
        ],
        "zun": [
            "Latn",
            [
                "AM"
            ],
            "Shiwi'ma"
        ]
    },
    "scriptgroups": {
        "Latin": [
            "Latn",
            "Goth"
        ],
        "Greek": [
            "Grek"
        ],
        "WestCaucasian": [
            "Armn",
            "Geor"
        ],
        "Arabic": [
            "Arab"
        ],
        "MiddleEastern": [
            "Hebr",
            "Syrc"
        ],
        "African": [
            "Ethi",
            "Nkoo",
            "Tfng",
            "Copt"
        ],
        "SouthAsian": [
            "Beng",
            "Deva",
            "Gujr",
            "Guru",
            "Knda",
            "Mlym",
            "Olck",
            "Orya",
            "Saur",
            "Sinh",
            "Taml",
            "Telu",
            "Tibt",
            "Thaa",
            "Wara"
        ],
        "Cyrillic": [
            "Cyrl"
        ],
        "CJK": [
            "Hans",
            "Hant",
            "Kana",
            "Kore",
            "Jpan",
            "Yiii"
        ],
        "SouthEastAsian": [
            "Bali",
            "Batk",
            "Bugi",
            "Java",
            "Khmr",
            "Laoo",
            "Mymr",
            "Thai"
        ],
        "Mongolian": [
            "Mong"
        ],
        "SignWriting": [
            "Sgnw"
        ],
        "NativeAmerican": [
            "Cher",
            "Cans"
        ],
        "Special": [
            "Zyyy"
        ]
    },
    "rtlscripts": [
        "Arab",
        "Hebr",
        "Syrc",
        "Nkoo",
        "Thaa"
    ],
    "regiongroups": {
        "WW": 1,
        "SP": 1,
        "AM": 2,
        "EU": 3,
        "ME": 3,
        "AF": 3,
        "AS": 4,
        "PA": 4
    },
    "territories": {
        "AC": [
            "en"
        ],
        "AD": [
            "ca",
            "es",
            "fr"
        ],
        "AE": [
            "ar",
            "ml",
            "ps",
            "fa"
        ],
        "AF": [
            "fa",
            "ps",
            "uz",
            "tk",
            "bgn",
            "ug-arab",
            "kk-arab",
            "kk-cyrl"
        ],
        "AG": [
            "en",
            "pt"
        ],
        "AI": [
            "en"
        ],
        "AL": [
            "sq",
            "el",
            "mk"
        ],
        "AM": [
            "hy",
            "ku-latn",
            "az-latn"
        ],
        "AO": [
            "pt",
            "ln"
        ],
        "AR": [
            "es",
            "en",
            "cy",
            "gn"
        ],
        "AS": [
            "sm",
            "en"
        ],
        "AT": [
            "de",
            "bar",
            "en",
            "fr",
            "it",
            "hr",
            "sl",
            "hu"
        ],
        "AU": [
            "en",
            "zh-hant",
            "zh",
            "it"
        ],
        "AW": [
            "nl",
            "pap",
            "en"
        ],
        "AX": [
            "sv"
        ],
        "AZ": [
            "az-latn",
            "az-cyrl",
            "tly",
            "ku-latn",
            "ttt",
            "tkr"
        ],
        "BA": [
            "bs",
            "en",
            "hr",
            "sr-cyrl",
            "sr-latn"
        ],
        "BB": [
            "en"
        ],
        "BD": [
            "bn",
            "en",
            "my",
            "mni"
        ],
        "BE": [
            "en",
            "nl",
            "fr",
            "de",
            "vls",
            "wa"
        ],
        "BF": [
            "fr",
            "ff"
        ],
        "BG": [
            "bg",
            "en",
            "ru",
            "tr",
            "de"
        ],
        "BH": [
            "ar",
            "ml"
        ],
        "BI": [
            "rn",
            "fr",
            "sw",
            "en"
        ],
        "BJ": [
            "fr",
            "fon",
            "yo"
        ],
        "BL": [
            "fr"
        ],
        "BM": [
            "en"
        ],
        "BN": [
            "ms",
            "zh-hant",
            "zh",
            "en"
        ],
        "BO": [
            "es",
            "qu",
            "ay",
            "gn",
            "aro"
        ],
        "BQ": [
            "pap",
            "nl"
        ],
        "BR": [
            "pt",
            "en",
            "de",
            "it",
            "ja",
            "es",
            "ko",
            "kgp",
            "yrl"
        ],
        "BS": [
            "en"
        ],
        "BT": [
            "dz",
            "ne",
            "en"
        ],
        "BW": [
            "en",
            "tn",
            "af"
        ],
        "BY": [
            "be",
            "ru"
        ],
        "BZ": [
            "en",
            "es"
        ],
        "CA": [
            "en",
            "fr",
            "it",
            "de",
            "pdt",
            "cr",
            "yi",
            "ike-cans",
            "moe",
            "atj"
        ],
        "CC": [
            "ms",
            "en"
        ],
        "CD": [
            "sw",
            "fr",
            "ln",
            "kg",
            "rw"
        ],
        "CF": [
            "fr",
            "sg",
            "ln"
        ],
        "CG": [
            "fr",
            "ln"
        ],
        "CH": [
            "de",
            "gsw",
            "en",
            "fr",
            "it",
            "lmo",
            "pt",
            "rm"
        ],
        "CI": [
            "fr"
        ],
        "CK": [
            "en"
        ],
        "CL": [
            "es",
            "en",
            "arn"
        ],
        "CM": [
            "fr",
            "en",
            "ff",
            "ar",
            "ksf",
            "ha-arab",
            "ha-latn"
        ],
        "CN": [
            "zh",
            "wuu",
            "yue",
            "hsn",
            "hak",
            "nan",
            "gan",
            "ii",
            "ug-arab",
            "za",
            "mn",
            "bo",
            "ko",
            "kk-arab",
            "kk-cyrl",
            "ky",
            "en",
            "ru",
            "vi",
            "uz",
            "lzh"
        ],
        "CO": [
            "es",
            "guc"
        ],
        "CR": [
            "es"
        ],
        "CU": [
            "es"
        ],
        "CV": [
            "kea",
            "pt"
        ],
        "CW": [
            "pap",
            "nl",
            "es"
        ],
        "CX": [
            "en"
        ],
        "CY": [
            "el",
            "en",
            "tr",
            "fr",
            "hy",
            "ar"
        ],
        "CZ": [
            "cs",
            "en",
            "sk",
            "de",
            "pl"
        ],
        "DE": [
            "de",
            "en",
            "fr",
            "bar",
            "nds",
            "nl",
            "it",
            "es",
            "ru",
            "vmf",
            "tr",
            "gsw",
            "da",
            "hr",
            "ku-latn",
            "el",
            "ksh",
            "pl",
            "hsb",
            "frr",
            "dsb",
            "stq",
            "pfl"
        ],
        "DG": [
            "en"
        ],
        "DJ": [
            "aa",
            "so",
            "ar",
            "fr"
        ],
        "DK": [
            "da",
            "en",
            "de",
            "sv",
            "fo",
            "kl",
            "jut"
        ],
        "DM": [
            "en"
        ],
        "DO": [
            "es",
            "en"
        ],
        "DZ": [
            "arq",
            "ar",
            "fr",
            "kab",
            "en"
        ],
        "EA": [
            "es"
        ],
        "EC": [
            "es",
            "qu",
            "qug"
        ],
        "EE": [
            "et",
            "ru",
            "en",
            "fi",
            "vro"
        ],
        "EG": [
            "ar",
            "arz",
            "en",
            "el"
        ],
        "EH": [
            "ar"
        ],
        "ER": [
            "ti",
            "en",
            "tig",
            "ar",
            "aa",
            "byn"
        ],
        "ES": [
            "es",
            "en",
            "ca",
            "gl",
            "eu",
            "ast",
            "ext"
        ],
        "ET": [
            "en",
            "am",
            "om",
            "so",
            "ti",
            "aa"
        ],
        "FI": [
            "fi",
            "en",
            "sv",
            "de",
            "ru",
            "et",
            "rmf",
            "se",
            "smn",
            "sms"
        ],
        "FJ": [
            "en",
            "hi",
            "hif",
            "fj",
            "rtm"
        ],
        "FK": [
            "en"
        ],
        "FM": [
            "en"
        ],
        "FO": [
            "fo"
        ],
        "FR": [
            "fr",
            "en",
            "es",
            "de",
            "oc",
            "it",
            "pt",
            "pcd",
            "gsw",
            "br",
            "co",
            "ca",
            "nl",
            "eu",
            "frp",
            "ia"
        ],
        "GA": [
            "fr"
        ],
        "GB": [
            "en",
            "fr",
            "de",
            "sco",
            "pa-guru",
            "cy",
            "bn",
            "zh-hant",
            "zh",
            "el",
            "it",
            "ks-arab",
            "gd",
            "yi",
            "ml",
            "ga",
            "kw"
        ],
        "GD": [
            "en"
        ],
        "GE": [
            "ka",
            "xmf",
            "ru",
            "hy",
            "ab",
            "os",
            "ku-latn"
        ],
        "GF": [
            "fr",
            "gcr",
            "zh-hant",
            "zh"
        ],
        "GG": [
            "en"
        ],
        "GH": [
            "ak",
            "en",
            "ee",
            "gur",
            "gaa",
            "ha-latn",
            "ff"
        ],
        "GI": [
            "en",
            "es"
        ],
        "GL": [
            "kl",
            "da"
        ],
        "GM": [
            "en",
            "ff"
        ],
        "GN": [
            "fr",
            "ff",
            "nqo"
        ],
        "GP": [
            "fr"
        ],
        "GQ": [
            "es",
            "fan",
            "fr",
            "pt"
        ],
        "GR": [
            "el",
            "en",
            "fr",
            "de",
            "pnt",
            "mk",
            "tr",
            "bg",
            "sq",
            "tsd"
        ],
        "GT": [
            "es",
            "quc"
        ],
        "GU": [
            "en",
            "ch"
        ],
        "GW": [
            "pt",
            "ff"
        ],
        "GY": [
            "en"
        ],
        "HK": [
            "zh-hant",
            "zh",
            "yue",
            "en"
        ],
        "HN": [
            "es",
            "en"
        ],
        "HR": [
            "hr",
            "en",
            "it"
        ],
        "HT": [
            "ht",
            "fr"
        ],
        "HU": [
            "hu",
            "en",
            "de",
            "fr",
            "ro",
            "hr",
            "sk",
            "sl"
        ],
        "IC": [
            "es"
        ],
        "ID": [
            "id",
            "jv",
            "su",
            "ms",
            "min",
            "bew",
            "ban",
            "bug",
            "bjn",
            "ace",
            "bbc-latn",
            "zh-hant",
            "zh",
            "gor",
            "sly",
            "mwv"
        ],
        "IE": [
            "en",
            "ga",
            "fr"
        ],
        "IL": [
            "he",
            "en",
            "ar",
            "ru",
            "ro",
            "yi",
            "pl",
            "lad-latn",
            "hu",
            "am",
            "ti",
            "ml"
        ],
        "IM": [
            "en",
            "gv"
        ],
        "IN": [
            "hi",
            "en",
            "bn",
            "te",
            "mr",
            "ta",
            "ur",
            "gu",
            "kn",
            "ml",
            "or",
            "pa-guru",
            "bho",
            "as",
            "mai",
            "hne",
            "ne",
            "sat",
            "ks-arab",
            "gom-deva",
            "gbm",
            "sd",
            "doi",
            "tcy",
            "brx",
            "mni",
            "hoc",
            "saz",
            "bfq",
            "njo",
            "bo",
            "bpy",
            "bft",
            "sa",
            "dv",
            "dz"
        ],
        "IO": [
            "en"
        ],
        "IQ": [
            "ar",
            "en",
            "ckb",
            "az-arab",
            "az-latn",
            "fa",
            "lrc"
        ],
        "IR": [
            "fa",
            "az-arab",
            "az-latn",
            "mzn",
            "glk",
            "ckb",
            "sdh",
            "tk",
            "lrc",
            "ar",
            "bqi",
            "luz",
            "lki",
            "bgn",
            "hy",
            "ps",
            "ka",
            "gbz",
            "kk-arab",
            "kk-cyrl"
        ],
        "IS": [
            "is",
            "da"
        ],
        "IT": [
            "it",
            "en",
            "fr",
            "sc",
            "de",
            "vec",
            "nap",
            "lij",
            "scn",
            "sl",
            "sdc",
            "fur",
            "egl",
            "ca",
            "el",
            "lmo",
            "pms",
            "hr",
            "rgn"
        ],
        "JE": [
            "en"
        ],
        "JM": [
            "en",
            "jam"
        ],
        "JO": [
            "ar",
            "en"
        ],
        "JP": [
            "ja",
            "ryu",
            "ko"
        ],
        "KE": [
            "sw",
            "en",
            "ki",
            "so",
            "pko",
            "om",
            "ar",
            "pa-guru",
            "gu"
        ],
        "KG": [
            "ky",
            "ru"
        ],
        "KH": [
            "km"
        ],
        "KI": [
            "en"
        ],
        "KM": [
            "ar",
            "fr"
        ],
        "KN": [
            "en"
        ],
        "KP": [
            "ko"
        ],
        "KR": [
            "ko"
        ],
        "KW": [
            "ar"
        ],
        "KY": [
            "en"
        ],
        "KZ": [
            "ru",
            "kk-cyrl",
            "en",
            "de",
            "ug-cyrl",
            "ug-arab"
        ],
        "LA": [
            "lo"
        ],
        "LB": [
            "ar",
            "en",
            "hy",
            "ku-arab",
            "ku-latn",
            "fr"
        ],
        "LC": [
            "en"
        ],
        "LI": [
            "de",
            "gsw"
        ],
        "LK": [
            "si",
            "ta",
            "en"
        ],
        "LR": [
            "en",
            "ff"
        ],
        "LS": [
            "st",
            "en",
            "zu",
            "ss",
            "xh"
        ],
        "LT": [
            "lt",
            "ru",
            "en",
            "de",
            "sgs"
        ],
        "LU": [
            "fr",
            "lb",
            "de",
            "en",
            "pt"
        ],
        "LV": [
            "lv",
            "en",
            "ru",
            "ltg"
        ],
        "LY": [
            "ar"
        ],
        "MA": [
            "ary",
            "ar",
            "zgh",
            "fr",
            "en",
            "tzm",
            "shi-latn",
            "rif",
            "es"
        ],
        "MC": [
            "fr"
        ],
        "MD": [
            "ro",
            "uk",
            "bg",
            "gag",
            "ru"
        ],
        "ME": [
            "sr-latn",
            "sr-cyrl",
            "sq"
        ],
        "MF": [
            "fr"
        ],
        "MG": [
            "mg",
            "fr",
            "en"
        ],
        "MH": [
            "en",
            "mh"
        ],
        "MK": [
            "mk",
            "sq",
            "tr"
        ],
        "ML": [
            "bm",
            "fr",
            "ses",
            "ar"
        ],
        "MM": [
            "my",
            "shn",
            "kac",
            "mnw"
        ],
        "MN": [
            "mn",
            "kk-arab",
            "kk-cyrl",
            "zh",
            "ru",
            "ug-cyrl",
            "ug-arab"
        ],
        "MO": [
            "zh-hant",
            "zh",
            "pt",
            "en"
        ],
        "MP": [
            "en",
            "ch"
        ],
        "MQ": [
            "fr"
        ],
        "MR": [
            "ar",
            "fr",
            "ff",
            "wo"
        ],
        "MS": [
            "en"
        ],
        "MT": [
            "mt",
            "en",
            "it",
            "fr"
        ],
        "MU": [
            "mfe",
            "en",
            "bho",
            "ur",
            "fr",
            "ta"
        ],
        "MV": [
            "dv"
        ],
        "MW": [
            "en",
            "ny",
            "tum",
            "zu"
        ],
        "MX": [
            "es",
            "en",
            "yua",
            "sei"
        ],
        "MY": [
            "ms",
            "en",
            "zh-hant",
            "zh",
            "ta",
            "jv",
            "dtp",
            "ml",
            "bug",
            "bjn"
        ],
        "MZ": [
            "pt",
            "ts",
            "ny",
            "sw",
            "zu"
        ],
        "NA": [
            "af",
            "kj",
            "ng",
            "hz",
            "en",
            "de",
            "tn"
        ],
        "NC": [
            "fr"
        ],
        "NE": [
            "ha-latn",
            "fr",
            "ar",
            "ff"
        ],
        "NF": [
            "en"
        ],
        "NG": [
            "en",
            "ha-latn",
            "ig",
            "yo",
            "ha-arab",
            "ar",
            "ff"
        ],
        "NI": [
            "es"
        ],
        "NL": [
            "nl",
            "en",
            "de",
            "fr",
            "nds",
            "li",
            "fy",
            "id",
            "zea",
            "rif",
            "tr"
        ],
        "NO": [
            "nb",
            "nn",
            "se"
        ],
        "NP": [
            "ne",
            "mai",
            "bho",
            "new",
            "en",
            "dty",
            "hi",
            "bo",
            "bn"
        ],
        "NR": [
            "en",
            "na"
        ],
        "NU": [
            "en",
            "niu"
        ],
        "NZ": [
            "en",
            "mi"
        ],
        "OM": [
            "ar",
            "fa"
        ],
        "PA": [
            "es",
            "en",
            "zh-hant",
            "zh"
        ],
        "PE": [
            "es",
            "qu",
            "ay"
        ],
        "PF": [
            "fr",
            "ty",
            "zh-hant",
            "zh"
        ],
        "PG": [
            "tpi",
            "en",
            "ho"
        ],
        "PH": [
            "en",
            "tl",
            "es",
            "ceb",
            "ilo",
            "hil",
            "war",
            "pam",
            "pag",
            "zh-hant",
            "zh",
            "cps",
            "krj",
            "bto"
        ],
        "PK": [
            "ur",
            "pa-guru",
            "en",
            "ps",
            "sd",
            "skr-arab",
            "brh",
            "fa",
            "bgn",
            "tg-cyrl",
            "bft",
            "khw",
            "ks-arab"
        ],
        "PL": [
            "pl",
            "en",
            "de",
            "ru",
            "szl",
            "be",
            "uk",
            "csb",
            "sli",
            "lt"
        ],
        "PM": [
            "fr",
            "en"
        ],
        "PN": [
            "en"
        ],
        "PR": [
            "es",
            "en"
        ],
        "PS": [
            "ar"
        ],
        "PT": [
            "pt",
            "en",
            "fr",
            "es",
            "gl"
        ],
        "PW": [
            "en"
        ],
        "PY": [
            "gn",
            "es",
            "de"
        ],
        "QA": [
            "ar",
            "fa",
            "ml"
        ],
        "RE": [
            "fr",
            "rcf",
            "ta"
        ],
        "RO": [
            "ro",
            "en",
            "fr",
            "es",
            "hu",
            "de",
            "tr",
            "sr-latn",
            "sr-cyrl",
            "bg",
            "el",
            "pl"
        ],
        "RS": [
            "sr-cyrl",
            "sr-latn",
            "sq",
            "hu",
            "ro",
            "hr",
            "sk",
            "uk"
        ],
        "RU": [
            "ru",
            "tt",
            "ba",
            "cv",
            "hy",
            "ce",
            "av",
            "udm",
            "mhr",
            "sah",
            "os",
            "kbd",
            "myv",
            "mdf",
            "kum",
            "kv",
            "lez",
            "krc",
            "inh",
            "tyv",
            "az-cyrl",
            "az-latn",
            "ady",
            "krl",
            "lbe",
            "koi",
            "mrj",
            "fi",
            "sr-latn",
            "sr-cyrl",
            "vep",
            "mn",
            "vot",
            "cu"
        ],
        "RW": [
            "rw",
            "en",
            "fr"
        ],
        "SA": [
            "ar"
        ],
        "SB": [
            "en"
        ],
        "SC": [
            "fr",
            "en"
        ],
        "SD": [
            "ar",
            "en",
            "ha-arab",
            "ha-latn"
        ],
        "SE": [
            "sv",
            "en",
            "fi",
            "fit",
            "se",
            "yi",
            "smj",
            "sma",
            "ia"
        ],
        "SG": [
            "en",
            "zh",
            "ms",
            "ta",
            "ml",
            "pa-guru"
        ],
        "SH": [
            "en"
        ],
        "SI": [
            "sl",
            "hr",
            "en",
            "de",
            "hu",
            "it"
        ],
        "SJ": [
            "nb",
            "ru"
        ],
        "SK": [
            "sk",
            "cs",
            "en",
            "de",
            "hu",
            "uk",
            "pl"
        ],
        "SL": [
            "kri",
            "en",
            "ff"
        ],
        "SM": [
            "it",
            "eo"
        ],
        "SN": [
            "wo",
            "fr",
            "ff"
        ],
        "SO": [
            "so",
            "ar",
            "sw",
            "om"
        ],
        "SR": [
            "nl",
            "srn",
            "zh-hant",
            "zh"
        ],
        "SS": [
            "ar",
            "en"
        ],
        "ST": [
            "pt"
        ],
        "SV": [
            "es"
        ],
        "SX": [
            "en",
            "es",
            "nl"
        ],
        "SY": [
            "ar",
            "ku-latn",
            "fr",
            "hy"
        ],
        "SZ": [
            "en",
            "ss",
            "zu",
            "ts"
        ],
        "TA": [
            "en"
        ],
        "TC": [
            "en"
        ],
        "TD": [
            "fr",
            "ar"
        ],
        "TF": [
            "fr"
        ],
        "TG": [
            "fr",
            "ee"
        ],
        "TH": [
            "th",
            "en",
            "nod",
            "zh-hant",
            "zh",
            "mnw",
            "shn"
        ],
        "TJ": [
            "tg-cyrl",
            "ru",
            "fa",
            "ar"
        ],
        "TK": [
            "en"
        ],
        "TL": [
            "pt",
            "tet"
        ],
        "TM": [
            "tk",
            "ru",
            "uz",
            "ku-latn"
        ],
        "TN": [
            "aeb-arab",
            "ar",
            "fr"
        ],
        "TO": [
            "to",
            "en"
        ],
        "TR": [
            "tr",
            "en",
            "ku-latn",
            "kbd",
            "az-latn",
            "az-arab",
            "ar",
            "bg",
            "ady",
            "kiu",
            "hy",
            "ka",
            "sr-latn",
            "sr-cyrl",
            "lzz",
            "sq",
            "ab",
            "el",
            "tru",
            "uz",
            "ky",
            "kk-cyrl"
        ],
        "TT": [
            "en",
            "es"
        ],
        "TV": [
            "en"
        ],
        "TW": [
            "zh-hant",
            "zh",
            "trv"
        ],
        "TZ": [
            "sw",
            "en",
            "lag"
        ],
        "UA": [
            "uk",
            "ru",
            "pl",
            "yi",
            "rue",
            "be",
            "crh",
            "ro",
            "bg",
            "tr",
            "hu",
            "el"
        ],
        "UG": [
            "sw",
            "lg",
            "en",
            "rw",
            "hi"
        ],
        "UM": [
            "en"
        ],
        "US": [
            "en",
            "es",
            "zh-hant",
            "zh",
            "fr",
            "de",
            "tl",
            "it",
            "vi",
            "ko",
            "ru",
            "nv",
            "yi",
            "pdc",
            "haw",
            "frc",
            "chr",
            "esu",
            "cho",
            "lkt",
            "ik",
            "mus"
        ],
        "UY": [
            "es"
        ],
        "UZ": [
            "uz",
            "ru",
            "kaa",
            "tr"
        ],
        "VA": [
            "it",
            "la"
        ],
        "VC": [
            "en"
        ],
        "VE": [
            "es"
        ],
        "VG": [
            "en"
        ],
        "VI": [
            "en"
        ],
        "VN": [
            "vi",
            "zh-hant",
            "zh"
        ],
        "VU": [
            "bi",
            "en",
            "fr"
        ],
        "WF": [
            "wls",
            "fr"
        ],
        "WS": [
            "sm",
            "en"
        ],
        "XK": [
            "sq",
            "aln",
            "sr-cyrl",
            "sr-latn"
        ],
        "YE": [
            "ar",
            "en"
        ],
        "YT": [
            "swb",
            "fr",
            "sw"
        ],
        "ZA": [
            "en",
            "zu",
            "xh",
            "af",
            "nso",
            "tn",
            "st",
            "ts",
            "ss",
            "ve",
            "hi",
            "nr",
            "sw"
        ],
        "ZM": [
            "en",
            "ny",
            "loz"
        ],
        "ZW": [
            "sn",
            "en",
            "nd",
            "ny",
            "ve",
            "tn"
        ]
    }
}
} ( jQuery ) );
},{}]},{},[1]);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery.uls/src/jquery.uls.data.utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/jquery.uls/src/jquery.uls.data.utils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Utility functions for querying language data.
 *
 * Copyright (C) 2012 Alolita Sharma, Amir Aharoni, Arun Ganesh, Brandon Harris,
 * Niklas Laxström, Pau Giner, Santhosh Thottingal, Siebrand Mazeland and other
 * contributors. See CREDITS for a list.
 *
 * UniversalLanguageSelector is dual licensed GPLv2 or later and MIT. You don't
 * have to do anything special to choose one license or the other and you don't
 * have to notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @file
 * @ingroup Extensions
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	/**
	 * Is this language a redirect to another language?
	 * @param {string} language Language code
	 * @return {string|boolean} Target language code if it's a redirect or false if it's not
	 */
	$.uls.data.isRedirect = function ( language ) {
		return ( $.uls.data.languages[ language ] !== undefined &&
			$.uls.data.languages[ language ].length === 1 ) ?
			$.uls.data.languages[ language ][ 0 ] : false;
	};

	/**
	 * Returns the script of the language.
	 * @param {string} language Language code
	 * @return {string}
	 */
	$.uls.data.getScript = function ( language ) {
		var target = $.uls.data.isRedirect( language );

		if ( target ) {
			return $.uls.data.getScript( target );
		}

		if ( !$.uls.data.languages[ language ] ) {
			// Undetermined
			return 'Zyyy';
		}

		return $.uls.data.languages[ language ][ 0 ];
	};

	/**
	 * Returns the regions in which a language is spoken.
	 * @param {string} language Language code
	 * @return {string|string[]}
	 */
	$.uls.data.getRegions = function ( language ) {
		var target = $.uls.data.isRedirect( language );

		if ( target ) {
			return $.uls.data.getRegions( target );
		}

		return ( $.uls.data.languages[ language ] && $.uls.data.languages[ language ][ 1 ] ) || 'UNKNOWN';
	};

	/**
	 * Returns the autonym of the language.
	 * @param {string} language Language code
	 * @return {string}
	 */
	$.uls.data.getAutonym = function ( language ) {
		var target = $.uls.data.isRedirect( language );

		if ( target ) {
			return $.uls.data.getAutonym( target );
		}

		return ( $.uls.data.languages[ language ] &&
			$.uls.data.languages[ language ][ 2 ] ) || language;
	};

	/**
	 * Returns all language codes and corresponding autonyms
	 * @return {string[]}
	 */
	$.uls.data.getAutonyms = function () {
		var language,
			autonymsByCode = {};

		for ( language in $.uls.data.languages ) {
			if ( $.uls.data.isRedirect( language ) ) {
				continue;
			}

			autonymsByCode[ language ] = $.uls.data.getAutonym( language );
		}

		return autonymsByCode;
	};

	/**
	 * Returns all languages written in script.
	 * @param {string} script string
	 * @return {string[]} languages codes
	 */
	$.uls.data.getLanguagesInScript = function ( script ) {
		return $.uls.data.getLanguagesInScripts( [ script ] );
	};

	/**
	 * Returns all languages written in the given scripts.
	 * @param {string[]} scripts
	 * @return {string[]} languages codes
	 */
	$.uls.data.getLanguagesInScripts = function ( scripts ) {
		var language, i,
			languagesInScripts = [];

		for ( language in $.uls.data.languages ) {
			if ( $.uls.data.isRedirect( language ) ) {
				continue;
			}

			for ( i = 0; i < scripts.length; i++ ) {
				if ( scripts[ i ] === $.uls.data.getScript( language ) ) {
					languagesInScripts.push( language );
					break;
				}
			}
		}

		return languagesInScripts;
	};

	/**
	 * Returns an associative array of languages in a region,
	 * grouped by script group.
	 * @param {string} region Region code
	 * @return {Object}
	 */
	$.uls.data.getLanguagesByScriptGroupInRegion = function ( region ) {
		return $.uls.data.getLanguagesByScriptGroupInRegions( [ region ] );
	};

	/**
	 * Get the given list of languages grouped by script.
	 * @param {string[]} languages Array of language codes to group
	 * @return {string[]} Array of language codes
	 */
	$.uls.data.getLanguagesByScriptGroup = function ( languages ) {
		var languagesByScriptGroup = {},
			language, languageIndex, resolvedRedirect, langScriptGroup;

		for ( languageIndex = 0; languageIndex < languages.length; languageIndex++ ) {
			language = languages[ languageIndex ];
			resolvedRedirect = $.uls.data.isRedirect( language ) || language;
			langScriptGroup = $.uls.data.getScriptGroupOfLanguage( resolvedRedirect );
			if ( !languagesByScriptGroup[ langScriptGroup ] ) {
				languagesByScriptGroup[ langScriptGroup ] = [];
			}
			languagesByScriptGroup[ langScriptGroup ].push( language );
		}
		return languagesByScriptGroup;
	};

	/**
	 * Returns an associative array of languages in several regions,
	 * grouped by script group.
	 * @param {string[]} regions region codes
	 * @return {Object}
	 */
	$.uls.data.getLanguagesByScriptGroupInRegions = function ( regions ) {
		var language, i, scriptGroup,
			languagesByScriptGroupInRegions = {};

		for ( language in $.uls.data.languages ) {
			if ( $.uls.data.isRedirect( language ) ) {
				continue;
			}

			for ( i = 0; i < regions.length; i++ ) {
				if ( $.uls.data.getRegions( language ).indexOf( regions[ i ] ) !== -1 ) {
					scriptGroup = $.uls.data.getScriptGroupOfLanguage( language );

					if ( languagesByScriptGroupInRegions[ scriptGroup ] === undefined ) {
						languagesByScriptGroupInRegions[ scriptGroup ] = [];
					}

					languagesByScriptGroupInRegions[ scriptGroup ].push( language );
					break;
				}
			}
		}

		return languagesByScriptGroupInRegions;
	};

	/**
	 * Returns the script group of a script or 'Other' if it doesn't
	 * belong to any group.
	 * @param {string} script Script code
	 * @return {string} script group name
	 */
	$.uls.data.getGroupOfScript = function ( script ) {
		var scriptGroup;

		for ( scriptGroup in $.uls.data.scriptgroups ) {
			if ( $.uls.data.scriptgroups[ scriptGroup ].indexOf( script ) !== -1 ) {
				return scriptGroup;
			}
		}

		return 'Other';
	};

	/**
	 * Returns the script group of a language.
	 * @param {string} language Language code
	 * @return {string} script group name
	 */
	$.uls.data.getScriptGroupOfLanguage = function ( language ) {
		return $.uls.data.getGroupOfScript( $.uls.data.getScript( language ) );
	};

	/**
	 * Return the list of languages sorted by script groups.
	 * @param {string[]} languages Array of language codes to sort
	 * @return {string[]} Array of language codes
	 */
	$.uls.data.sortByScriptGroup = function ( languages ) {
		var groupedLanguages, scriptGroups, i,
			allLanguages = [];

		groupedLanguages = $.uls.data.getLanguagesByScriptGroup( languages );
		scriptGroups = Object.keys( groupedLanguages ).sort();

		for ( i = 0; i < scriptGroups.length; i++ ) {
			allLanguages = allLanguages.concat( groupedLanguages[ scriptGroups[ i ] ] );
		}

		return allLanguages;
	};

	/**
	 * A callback for sorting languages by autonym.
	 * Can be used as an argument to a sort function.
	 * @param {string} a Language code
	 * @param {string} b Language code
	 * @return {number}
	 */
	$.uls.data.sortByAutonym = function ( a, b ) {
		var autonymA = $.uls.data.getAutonym( a ) || a,
			autonymB = $.uls.data.getAutonym( b ) || b;

		return ( autonymA.toLowerCase() < autonymB.toLowerCase() ) ? -1 : 1;
	};

	/**
	 * Check if a language is right-to-left.
	 * @param {string} language Language code
	 * @return {boolean}
	 */
	$.uls.data.isRtl = function ( language ) {
		return $.uls.data.rtlscripts.indexOf( $.uls.data.getScript( language ) ) !== -1;
	};

	/**
	 * Return the direction of the language
	 * @param {string} language Language code
	 * @return {string}
	 */
	$.uls.data.getDir = function ( language ) {
		return $.uls.data.isRtl( language ) ? 'rtl' : 'ltr';
	};

	/**
	 * Returns the languages spoken in a territory.
	 * @param {string} territory Territory code
	 * @return {string[]} list of language codes
	 */
	$.uls.data.getLanguagesInTerritory = function ( territory ) {
		return $.uls.data.territories[ territory ];
	};

	/**
	 * Adds a language in run time and sets its options as provided.
	 * If the target option is provided, the language is defined as a redirect.
	 * Other possible options are script, regions and autonym.
	 *
	 * @param {string} code New language code.
	 * @param {Object} options Language properties.
	 */
	$.uls.data.addLanguage = function ( code, options ) {
		if ( options.target ) {
			$.uls.data.languages[ code ] = [ options.target ];
		} else {
			$.uls.data.languages[ code ] = [ options.script, options.regions, options.autonym ];
		}
	};

	/**
	 * Removes a language from the langdb in run time.
	 *
	 * @param {string} code Language code to delete.
	 * @return {boolean} true if the language was removed, false otherwise.
	 */
	$.uls.data.deleteLanguage = function ( code ) {
		if ( $.uls.data.languages[ code ] ) {
			delete $.uls.data.languages[ code ];

			return true;
		}

		return false;
	};
}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery.uls/src/jquery.uls.languagefilter.js":
/*!******************************************************************!*\
  !*** ./node_modules/jquery.uls/src/jquery.uls.languagefilter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * jQuery language filter plugin.
 *
 * Copyright (C) 2012 Alolita Sharma, Amir Aharoni, Arun Ganesh, Brandon Harris,
 * Niklas Laxström, Pau Giner, Santhosh Thottingal, Siebrand Mazeland and other
 * contributors. See CREDITS for a list.
 *
 * UniversalLanguageSelector is dual licensed GPLv2 or later and MIT. You don't
 * have to do anything special to choose one license or the other and you don't
 * have to notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @file
 * @ingroup Extensions
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

/**
 * Usage: $( 'inputbox' ).languagefilter();
 * The values for autocompletion is from the options.languages or options.searchAPI.
 */
( function ( $ ) {
	'use strict';

	var LanguageFilter;

	/**
	 * Check if a prefix is visually prefix of a string
	 *
	 * @param {string} prefix
	 * @param {string} string
	 * @return {boolean}
	 */
	function isVisualPrefix( prefix, string ) {
		// Pre-base vowel signs of Indic languages. A vowel sign is called pre-base if
		// consonant + vowel becomes [vowel][consonant] when rendered. Eg: ക + െ => കെ
		var prebases = 'െേൈൊോൌெேைொோௌେୈୋୌિਿिিেৈোৌෙේෛොෝෞ';
		return prebases.indexOf( string[ prefix.length ] ) <= 0;
	}

	LanguageFilter = function ( element, options ) {
		this.$element = $( element );
		this.options = $.extend( {}, $.fn.languagefilter.defaults, options );
		this.$element.addClass( 'languagefilter' );
		this.resultCount = 0;
		this.$suggestion = this.$element.siblings( '.' + this.$element.data( 'suggestion' ) );
		this.$clear = this.$element.siblings( '.' + this.$element.data( 'clear' ) );
		this.selectedLanguage = null;
		this.init();
		this.listen();
	};

	LanguageFilter.prototype = {
		init: function () {
			this.search();
		},

		listen: function () {
			this.$element.on( 'keydown', this.keypress.bind( this ) );
			this.$element.on( 'input', $.fn.uls.debounce( this.onInputChange.bind( this ), 300 ) );

			if ( this.$clear.length ) {
				this.$clear.on( 'click', this.clear.bind( this ) );
			}

			this.toggleClear();
		},

		onInputChange: function () {
			this.selectedLanguage = null;

			if ( !this.$element.val() ) {
				this.clear();
			} else {
				this.options.lcd.empty();
				this.search();
			}

			this.toggleClear();
		},

		keypress: function ( e ) {
			var suggestion, query;

			switch ( e.keyCode ) {
				case 9: // Tab -> Autocomplete
					suggestion = this.$suggestion.val();

					if ( suggestion && suggestion !== this.$element.val() ) {
						this.$element.val( suggestion );
						e.preventDefault();
						e.stopPropagation();
					}
					break;
				case 13: // Enter
					if ( !this.options.onSelect ) {
						break;
					}

					// Avoid bubbling this 'enter' to background page elements
					e.preventDefault();
					e.stopPropagation();

					query = $.trim( this.$element.val() ).toLowerCase();

					if ( this.selectedLanguage ) {
						// this.selectLanguage will be populated from a matching search
						this.options.onSelect( this.selectedLanguage );
					} else if ( this.options.languages[ query ] ) {
						// Search is yet to happen (in timeout delay),
						// but we have a matching language code.
						this.options.onSelect( query );
					}

					break;
			}
		},

		/**
		 * Clears the current search removing
		 * clear buttons and suggestions.
		 */
		deactivate: function () {
			this.$element.val( '' );

			if ( !$.fn.uls.Constructor.prototype.isMobile() ) {
				this.$element.focus();
			}

			this.toggleClear();
			this.autofill();
		},

		/**
		 * Clears the search and shows all languages
		 */
		clear: function () {
			this.deactivate();
			this.search();
		},

		/**
		 * Toggles the visibility of clear icon depending
		 * on whether there is anything to clear.
		 */
		toggleClear: function () {
			if ( !this.$clear.length ) {
				return;
			}

			if ( this.$element.val() ) {
				this.$clear.show();
			} else {
				this.$clear.hide();
			}
		},

		search: function () {
			var languages = Object.keys( this.options.languages ),
				results = [],
				query = $.trim( this.$element.val() ).toLowerCase();

			if ( query === '' ) {
				this.options.lcd.setGroupByRegionOverride( null );
				this.resultHandler( query, languages );
				return;
			}

			this.options.lcd.setGroupByRegionOverride( false );
			// Local search results
			results = languages.filter( function ( langCode ) {
				return this.filter( langCode, query );
			}.bind( this ) );

			// Use the searchAPI if available, assuming that it has superior search results.
			if ( this.options.searchAPI ) {
				this.searchAPI( query )
					.done( this.resultHandler.bind( this ) )
					.fail( this.resultHandler.bind( this, query, results, undefined ) );
			} else {
				this.resultHandler( query, results );
			}
		},

		searchAPI: function ( query ) {
			return $.get( this.options.searchAPI, { search: query } ).then( function ( result ) {
				var autofillLabel,
					results = [];

				$.each( result.languagesearch, function ( apiCode, name ) {
					var code, redirect;

					if ( this.options.languages[ apiCode ] ) {
						code = apiCode;
					} else {
						redirect = $.uls.data.isRedirect( apiCode );
						if ( !redirect || !this.options.languages[ redirect ] ) {
							return;
						}
						code = redirect;
					}

					// Because of the redirect checking above, we might get duplicates.
					// For example if API returns both `sr` and `sr-cyrl`, the former
					// could get mapped to `sr-cyrl` and then we would have it twice.
					// The exact cases when this happens of course depends on what is in
					// options.languages, which might contain redirects such as `sr`. In
					// this case we only show `sr` if no other variants are there.
					// This also protects against broken search APIs returning duplicate
					// results, although that is not happening in practice.
					if ( results.indexOf( code ) === -1 ) {
						autofillLabel = autofillLabel || name;
						results.push( code );
					}
				}.bind( this ) );

				return $.Deferred().resolve( query, results, autofillLabel );
			}.bind( this ) );
		},

		/**
		 * Handler method to be called once search is over.
		 * Based on search result triggers resultsfound or noresults events
		 * @param {string} query
		 * @param {string[]} results
		 * @param {string} [autofillLabel]
		 */
		resultHandler: function ( query, results, autofillLabel ) {
			if ( results.length === 0 ) {
				this.$suggestion.val( '' );
				this.$element.trigger(
					'noresults.uls',
					{
						query: query,
						ulsPurpose: this.options.ulsPurpose
					}
				);
				return;
			}

			if ( query ) {
				this.selectedLanguage = results[ 0 ];
				this.autofill( results[ 0 ], autofillLabel );
			}

			results.map( this.render.bind( this ) );
			this.$element.trigger( 'resultsfound.uls', [ query, results.length ] );
		},

		autofill: function ( langCode, languageName ) {
			var autonym, userInput, suggestion;

			if ( !this.$suggestion.length ) {
				return;
			}

			if ( !this.$element.val() ) {
				this.$suggestion.val( '' );
				return;
			}

			languageName = languageName || this.options.languages[ langCode ];

			if ( !languageName ) {
				return;
			}

			userInput = this.$element.val();
			suggestion = userInput +
				languageName.substring( userInput.length, languageName.length );

			if ( suggestion.toLowerCase() !== languageName.toLowerCase() ) {
				// see if it was autonym match
				autonym = $.uls.data.getAutonym( langCode ) || '';
				suggestion = userInput + autonym.substring( userInput.length, autonym.length );

				if ( suggestion !== autonym ) {
					// Give up. It may be an ISO/script code match.
					suggestion = '';
				}
			}

			// Make sure that it is a visual prefix.
			if ( !isVisualPrefix( userInput, suggestion ) ) {
				suggestion = '';
			}

			this.$suggestion.val( suggestion );
		},

		render: function ( langCode ) {
			return this.options.lcd.append( langCode );
		},

		escapeRegex: function ( value ) {
			return value.replace( /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&' );
		},

		/**
		 * A search match happens if any of the following passes:
		 * a) Language name in current user interface language
		 * 'starts with' search string.
		 * b) Language autonym 'starts with' search string.
		 * c) ISO 639 code match with search string.
		 * d) ISO 15924 code for the script match the search string.
		 * @param {string} langCode
		 * @param {string} searchTerm
		 * @return {boolean}
		 */
		filter: function ( langCode, searchTerm ) {
			// FIXME script is ISO 15924 code. We might need actual name of script.
			var matcher = new RegExp( '^' + this.escapeRegex( searchTerm ), 'i' ),
				languageName = this.options.languages[ langCode ];

			return matcher.test( languageName ) ||
				matcher.test( $.uls.data.getAutonym( langCode ) ) ||
				matcher.test( langCode ) ||
				matcher.test( $.uls.data.getScript( langCode ) );
		}
	};

	$.fn.languagefilter = function ( option ) {
		return this.each( function () {
			var $this = $( this ),
				data = $this.data( 'languagefilter' ),
				options = typeof option === 'object' && option;

			if ( !data ) {
				$this.data( 'languagefilter', ( data = new LanguageFilter( this, options ) ) );
			}

			if ( typeof option === 'string' ) {
				data[ option ]();
			}
		} );
	};

	$.fn.languagefilter.defaults = {
		// LanguageCategoryDisplay
		lcd: undefined,
		// URL to which we append query parameter with the query value
		searchAPI: undefined,
		// What is this ULS used for.
		// Should be set for distinguishing between different instances of ULS
		// in the same application.
		ulsPurpose: '',
		// Object of language tags to language names
		languages: [],
		// Callback function when language is selected
		onSelect: undefined
	};

	$.fn.languagefilter.Constructor = LanguageFilter;

}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery.uls/src/jquery.uls.lcd.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery.uls/src/jquery.uls.lcd.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Universal Language Selector
 * Language category display component - Used for showing the search results,
 * grouped by regions, scripts
 *
 * Copyright (C) 2012 Alolita Sharma, Amir Aharoni, Arun Ganesh, Brandon Harris,
 * Niklas Laxström, Pau Giner, Santhosh Thottingal, Siebrand Mazeland and other
 * contributors. See CREDITS for a list.
 *
 * UniversalLanguageSelector is dual licensed GPLv2 or later and MIT. You don't
 * have to do anything special to choose one license or the other and you don't
 * have to notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @file
 * @ingroup Extensions
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */

( function ( $ ) {
	'use strict';

	// eslint-disable-next-line no-multi-str
	var noResultsTemplate = '<div class="uls-no-results-view"> \
		<h2 data-i18n="uls-no-results-found" class="uls-no-results-found-title">No results found</h2> \
		<div class="uls-no-results-suggestions"></div> \
		<div class="uls-no-found-more"> \
		<div data-i18n="uls-search-help">You can search by language name, script name, ISO code of language or you can browse by region.</div> \
		</div></div>';

	/**
	 * Language category display
	 * @param {Element} element The container element to which the languages to be displayed
	 * @param {Object} [options] Configuration object
	 * @cfg {Object} [languages] Selectable languages. Keyed by language code, values are autonyms.
	 * @cfg {string[]} [showRegions] Array of region codes to show. Default is
	 *  [ 'WW', 'AM', 'EU', 'ME', 'AF', 'AS', 'PA' ]
	 * @cfg {number} [itemsPerColumn] Number of languages per column.
	 * @cfg {number} [columns] Number of columns for languages. Default is 4.
	 * @cfg {Function} [languageDecorator] Callback function to be called when a language
	 *  link is prepared - for custom decoration.
	 * @cfg {Function|string[]} [quickList] The languages to display as suggestions for quick
	 *  selection.
	 * @cfg {Function} [clickhandler] Callback when language is selected.
	 * @cfg {jQuery|Function} [noResultsTemplate]
	 */
	function LanguageCategoryDisplay( element, options ) {
		this.$element = $( element );
		this.options = $.extend( {}, $.fn.lcd.defaults, options );
		// Ensure the internal region 'all' is always present
		if ( this.options.showRegions.indexOf( 'all' ) === -1 ) {
			this.options.showRegions.push( 'all' );
		}

		this.$element.addClass( 'uls-lcd' );
		this.regionLanguages = {};
		this.renderTimeout = null;
		this.cachedQuicklist = null;
		this.groupByRegionOverride = null;

		this.render();
		this.listen();
	}

	LanguageCategoryDisplay.prototype = {
		constructor: LanguageCategoryDisplay,

		/**
		 * Adds language to the language list.
		 * @param {string} langCode
		 * @param {string} [regionCode]
		 * @return {boolean} Whether the language was known and accepted
		 */
		append: function ( langCode, regionCode ) {
			var i, regions;

			if ( !$.uls.data.languages[ langCode ] ) {
				// Language is unknown or not in the list of languages for this context.
				return false;
			}

			if ( !this.isGroupingByRegionEnabled() ) {
				regions = [ 'all' ];

				// Make sure we do not get duplicates
				if ( this.regionLanguages.all.indexOf( langCode ) > -1 ) {
					return true;
				}
			} else {
				if ( regionCode ) {
					regions = [ regionCode ];
				} else {
					regions = $.uls.data.getRegions( langCode );
				}
			}

			for ( i = 0; i < regions.length; i++ ) {
				this.regionLanguages[ regions[ i ] ].push( langCode );
			}

			// Work around the bad interface, delay rendering until we have got
			// all the languages to speed up performance.
			clearTimeout( this.renderTimeout );
			this.renderTimeout = setTimeout( function () {
				this.renderRegions();
			}.bind( this ), 50 );

			return true;
		},

		/**
		 * Whether we should render languages grouped to geographic regions.
		 * @return {boolean}
		 */
		isGroupingByRegionEnabled: function () {
			if ( this.groupByRegionOverride !== null ) {
				return this.groupByRegionOverride;
			} else if ( this.options.groupByRegion !== 'auto' ) {
				return this.options.groupByRegion;
			} else {
				return this.options.columns > 1;
			}
		},

		/**
		 * Override the default region grouping setting.
		 * This is to allow LanguageFilter to disable grouping when displaying search results.
		 *
		 * @param {boolean|null} val True to force grouping, false to disable, null
		 * to undo override.
		 */
		setGroupByRegionOverride: function ( val ) {
			this.groupByRegionOverride = val;
		},

		render: function () {
			var $section,
				$quicklist = this.buildQuicklist(),
				regions = [],
				regionNames = {
					// These are fallback text when i18n library not present
					all: 'All languages', // Used if there is quicklist and no region grouping
					WW: 'Worldwide',
					SP: 'Special',
					AM: 'America',
					EU: 'Europe',
					ME: 'Middle East',
					AS: 'Asia',
					AF: 'Africa',
					PA: 'Pacific'
				};

			if ( $quicklist.length ) {
				regions.push( $quicklist );
			} else {
				// We use CSS to hide the header for 'all' when quicklist is NOT present
				this.$element.addClass( 'uls-lcd--no-quicklist' );
			}

			this.options.showRegions.forEach( function ( regionCode ) {
				this.regionLanguages[ regionCode ] = [];

				$section = $( '<div>' )
					.addClass( 'uls-lcd-region-section hide' )
					.attr( 'data-region', regionCode );

				$( '<h3>' )
					.attr( 'data-i18n', 'uls-region-' + regionCode )
					.addClass( 'uls-lcd-region-title' )
					.text( regionNames[ regionCode ] )
					.appendTo( $section );

				regions.push( $section );
			}.bind( this ) );

			this.$element.append( regions );

			this.i18n();
		},

		/**
		 * Renders a region and displays it if it has content.
		 */
		renderRegions: function () {
			var languages,
				lcd = this;

			this.$element.removeClass( 'uls-no-results' );
			this.$element.children( '.uls-lcd-region-section' ).each( function () {
				var $region = $( this ),
					regionCode = $region.data( 'region' );

				if ( $region.is( '.uls-lcd-quicklist' ) ) {
					return;
				}

				$region.children( '.uls-language-block' ).remove();

				languages = lcd.regionLanguages[ regionCode ];
				if ( !languages || languages.length === 0 ) {
					$region.addClass( 'hide' );
					return;
				}

				lcd.renderRegion(
					$region,
					languages,
					lcd.options.itemsPerColumn,
					lcd.options.columns
				);
				$region.removeClass( 'hide' );

				lcd.regionLanguages[ regionCode ] = [];
			} );

		},

		/**
		 * Adds given languages sorted into rows and columns into given element.
		 * @param {jQuery} $region Element to add language list.
		 * @param {Array} languages List of language codes.
		 * @param {number} itemsPerColumn How many languages fit in a column.
		 * @param {number} columnsPerRow How many columns fit in a row.
		 */
		renderRegion: function ( $region, languages, itemsPerColumn, columnsPerRow ) {
			var columnsClasses, i, lastItem, currentScript, nextScript, force,
				languagesCount = languages.length,
				items = [],
				columns = [],
				rows = [];

			languages = $.uls.data.sortByScriptGroup(
				languages.sort( $.uls.data.sortByAutonym )
			);

			if ( columnsPerRow === 1 ) {
				columnsClasses = 'twelve columns';
			} else if ( columnsPerRow === 2 ) {
				columnsClasses = 'six columns';
			} else {
				columnsClasses = 'three columns';
			}

			if ( this.options.columns === 1 ) {
				// For one-column narrow ULS, just render all the languages
				// in one simple list without separators or script groups
				for ( i = 0; i < languagesCount; i++ ) {
					items.push( this.renderItem( languages[ i ] ) );
				}

				columns.push( $( '<ul>' ).addClass( columnsClasses ).append( items ) );
				rows.push( $( '<div>' ).addClass( 'row uls-language-block' ).append( columns ) );
			} else {
				// For medium and wide ULS, clever column placement
				for ( i = 0; i < languagesCount; i++ ) {
					force = false;
					nextScript = $.uls.data.getScriptGroupOfLanguage( languages[ i + 1 ] );

					lastItem = languagesCount - i === 1;
					// Force column break if script changes and column has more than one
					// row already, but only if grouping by region
					if ( i === 0 || !this.isGroupingByRegionEnabled() ) {
						currentScript = $.uls.data.getScriptGroupOfLanguage( languages[ i ] );
					} else if ( currentScript !== nextScript && items.length > 1 ) {
						force = true;
					}
					currentScript = nextScript;

					items.push( this.renderItem( languages[ i ] ) );

					if ( items.length >= itemsPerColumn || lastItem || force ) {
						columns.push( $( '<ul>' ).addClass( columnsClasses ).append( items ) );
						items = [];
						if ( columns.length >= columnsPerRow || lastItem ) {
							rows.push( $( '<div>' ).addClass( 'row uls-language-block' ).append( columns ) );
							columns = [];
						}
					}
				}
			}

			$region.append( rows );
		},

		/**
		 * Creates dom node representing one item in language list.
		 * @param {string} code Language code
		 * @return {Element}
		 */
		renderItem: function ( code ) {
			var a, name, autonym, li;

			name = this.options.languages[ code ];
			autonym = $.uls.data.getAutonym( code ) || name || code;

			// Not using jQuery as this is performance hotspot
			li = document.createElement( 'li' );
			li.title = name;
			li.setAttribute( 'data-code', code );

			a = document.createElement( 'a' );
			a.appendChild( document.createTextNode( autonym ) );
			a.className = 'autonym';
			a.lang = code;
			a.dir = $.uls.data.getDir( code );

			li.appendChild( a );
			if ( this.options.languageDecorator ) {
				this.options.languageDecorator( $( a ), code );
			}
			return li;
		},

		i18n: function () {
			this.$element.find( '[data-i18n]' ).i18n();
		},

		/**
		 * Adds quicklist as a region.
		 */
		quicklist: function () {
			this.$element.find( '.uls-lcd-quicklist' ).removeClass( 'hide' );
		},

		buildQuicklist: function () {
			var quickList, $quickListSection, $quickListSectionTitle;

			if ( this.cachedQuicklist !== null ) {
				return this.cachedQuicklist;
			}

			if ( $.isFunction( this.options.quickList ) ) {
				this.options.quickList = this.options.quickList();
			}

			if ( !this.options.quickList.length ) {
				this.cachedQuicklist = $( [] );
				return this.cachedQuicklist;
			}

			// Pick only the first elements, because we don't have room for more
			quickList = this.options.quickList;
			quickList = quickList.slice( 0, 16 );
			quickList.sort( $.uls.data.sortByAutonym );

			$quickListSection = $( '<div>' )
				.addClass( 'uls-lcd-region-section uls-lcd-quicklist' );

			$quickListSectionTitle = $( '<h3>' )
				.attr( 'data-i18n', 'uls-common-languages' )
				.addClass( 'uls-lcd-region-title' )
				.text( 'Suggested languages' ); // This is placeholder text if jquery.i18n not present
			$quickListSection.append( $quickListSectionTitle );

			this.renderRegion(
				$quickListSection,
				quickList,
				this.options.itemsPerColumn,
				this.options.columns
			);

			$quickListSectionTitle.i18n();

			this.cachedQuicklist = $quickListSection;
			return this.cachedQuicklist;
		},

		show: function () {
			if ( !this.regionDivs ) {
				this.render();
			}
		},

		/**
		 * Called when a fresh search is started
		 */
		empty: function () {
			this.$element.addClass( 'uls-lcd--no-quicklist' );
			this.$element.find( '.uls-lcd-quicklist' ).addClass( 'hide' );
		},

		focus: function () {
			this.$element.focus();
		},

		/**
		 * No-results event handler
		 * @param {Event} event
		 * @param {Object} data Information about the failed search query
		 */
		noResults: function ( event, data ) {
			var $noResults;

			this.$element.addClass( 'uls-no-results' );

			this.$element.find( '.uls-no-results-view' ).remove();

			if ( typeof this.options.noResultsTemplate === 'function' ) {
				$noResults =
					this.options.noResultsTemplate.call( this, data.query );
			} else if ( this.options.noResultsTemplate instanceof jQuery ) {
				$noResults = this.options.noResultsTemplate;
			} else {
				throw new Error( 'noResultsTemplate option must be ' +
					'either jQuery or function returning jQuery' );
			}

			this.$element.append( $noResults.addClass( 'uls-no-results-view' ).i18n() );
		},

		listen: function () {
			var lcd = this;

			if ( this.options.clickhandler ) {
				this.$element.on( 'click', '.row li', function ( event ) {
					lcd.options.clickhandler.call( this, $( this ).data( 'code' ), event );
				} );
			}
		}
	};

	$.fn.lcd = function ( option ) {
		return this.each( function () {
			var $this = $( this ),
				data = $this.data( 'lcd' ),
				options = typeof option === 'object' && option;

			if ( !data ) {
				$this.data( 'lcd', ( data = new LanguageCategoryDisplay( this, options ) ) );
			}

			if ( typeof option === 'string' ) {
				data[ option ]();
			}
		} );
	};

	$.fn.lcd.defaults = {
		// List of languages to show
		languages: [],
		// List of regions to show
		showRegions: [ 'WW', 'AM', 'EU', 'ME', 'AF', 'AS', 'PA' ],
		// Whether to group by region, defaults to true when columns > 1
		groupByRegion: 'auto',
		// How many items per column until new "row" starts
		itemsPerColumn: 8,
		// Number of columns, only 1, 2 and 4 are supported
		columns: 4,
		// Callback function for language item styling
		languageDecorator: undefined,
		// Likely candidates
		quickList: [],
		// Callback function for language selection
		clickhandler: undefined,
		// Callback function when no search results.
		// If overloaded, it can accept the search string as an argument.
		noResultsTemplate: function () {
			var $suggestionsContainer, $suggestions,
				$noResultsTemplate = $( noResultsTemplate );

			$suggestions = this.buildQuicklist().clone();
			$suggestions.removeClass( 'hide' )
				.find( 'h3' )
				.data( 'i18n', 'uls-no-results-suggestion-title' )
				.text( 'You may be interested in:' )
				.i18n();
			$suggestionsContainer = $noResultsTemplate.find( '.uls-no-results-suggestions' );
			$suggestionsContainer.append( $suggestions );
			return $noResultsTemplate;
		}
	};

}( jQuery ) );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.js":
/*!**********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* @preserve
 * Leaflet 1.4.0, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
!function(t,i){ true?i(exports):undefined}(this,function(t){"use strict";function i(t){var i,e,n,o;for(e=1,n=arguments.length;e<n;e++){o=arguments[e];for(i in o)t[i]=o[i]}return t}function e(t,i){var e=Array.prototype.slice;if(t.bind)return t.bind.apply(t,e.call(arguments,1));var n=e.call(arguments,2);return function(){return t.apply(i,n.length?n.concat(e.call(arguments)):arguments)}}function n(t){return t._leaflet_id=t._leaflet_id||++ei,t._leaflet_id}function o(t,i,e){var n,o,s,r;return r=function(){n=!1,o&&(s.apply(e,o),o=!1)},s=function(){n?o=arguments:(t.apply(e,arguments),setTimeout(r,i),n=!0)}}function s(t,i,e){var n=i[1],o=i[0],s=n-o;return t===n&&e?t:((t-o)%s+s)%s+o}function r(){return!1}function a(t,i){var e=Math.pow(10,void 0===i?6:i);return Math.round(t*e)/e}function h(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function u(t){return h(t).split(/\s+/)}function l(t,i){t.hasOwnProperty("options")||(t.options=t.options?ii(t.options):{});for(var e in i)t.options[e]=i[e];return t.options}function c(t,i,e){var n=[];for(var o in t)n.push(encodeURIComponent(e?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(i&&-1!==i.indexOf("?")?"&":"?")+n.join("&")}function _(t,i){return t.replace(ni,function(t,e){var n=i[e];if(void 0===n)throw new Error("No value provided for variable "+t);return"function"==typeof n&&(n=n(i)),n})}function d(t,i){for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1}function p(t){return window["webkit"+t]||window["moz"+t]||window["ms"+t]}function m(t){var i=+new Date,e=Math.max(0,16-(i-ri));return ri=i+e,window.setTimeout(t,e)}function f(t,i,n){if(!n||ai!==m)return ai.call(window,e(t,i));t.call(i)}function g(t){t&&hi.call(window,t)}function v(){}function y(t){if("undefined"!=typeof L&&L&&L.Mixin){t=oi(t)?t:[t];for(var i=0;i<t.length;i++)t[i]===L.Mixin.Events&&console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",(new Error).stack)}}function x(t,i,e){this.x=e?Math.round(t):t,this.y=e?Math.round(i):i}function w(t,i,e){return t instanceof x?t:oi(t)?new x(t[0],t[1]):void 0===t||null===t?t:"object"==typeof t&&"x"in t&&"y"in t?new x(t.x,t.y):new x(t,i,e)}function P(t,i){if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n<o;n++)this.extend(e[n])}function b(t,i){return!t||t instanceof P?t:new P(t,i)}function T(t,i){if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n<o;n++)this.extend(e[n])}function z(t,i){return t instanceof T?t:new T(t,i)}function M(t,i,e){if(isNaN(t)||isNaN(i))throw new Error("Invalid LatLng object: ("+t+", "+i+")");this.lat=+t,this.lng=+i,void 0!==e&&(this.alt=+e)}function C(t,i,e){return t instanceof M?t:oi(t)&&"object"!=typeof t[0]?3===t.length?new M(t[0],t[1],t[2]):2===t.length?new M(t[0],t[1]):null:void 0===t||null===t?t:"object"==typeof t&&"lat"in t?new M(t.lat,"lng"in t?t.lng:t.lon,t.alt):void 0===i?null:new M(t,i,e)}function S(t,i,e,n){if(oi(t))return this._a=t[0],this._b=t[1],this._c=t[2],void(this._d=t[3]);this._a=t,this._b=i,this._c=e,this._d=n}function Z(t,i,e,n){return new S(t,i,e,n)}function E(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function k(t,i){var e,n,o,s,r,a,h="";for(e=0,o=t.length;e<o;e++){for(n=0,s=(r=t[e]).length;n<s;n++)a=r[n],h+=(n?"L":"M")+a.x+" "+a.y;h+=i?Ji?"z":"x":""}return h||"M0 0"}function B(t){return navigator.userAgent.toLowerCase().indexOf(t)>=0}function A(t,i,e,n){return"touchstart"===i?O(t,e,n):"touchmove"===i?W(t,e,n):"touchend"===i&&H(t,e,n),this}function I(t,i,e){var n=t["_leaflet_"+i+e];return"touchstart"===i?t.removeEventListener(te,n,!1):"touchmove"===i?t.removeEventListener(ie,n,!1):"touchend"===i&&(t.removeEventListener(ee,n,!1),t.removeEventListener(ne,n,!1)),this}function O(t,i,n){var o=e(function(t){if("mouse"!==t.pointerType&&t.MSPOINTER_TYPE_MOUSE&&t.pointerType!==t.MSPOINTER_TYPE_MOUSE){if(!(oe.indexOf(t.target.tagName)<0))return;Pt(t)}j(t,i)});t["_leaflet_touchstart"+n]=o,t.addEventListener(te,o,!1),re||(document.documentElement.addEventListener(te,R,!0),document.documentElement.addEventListener(ie,N,!0),document.documentElement.addEventListener(ee,D,!0),document.documentElement.addEventListener(ne,D,!0),re=!0)}function R(t){se[t.pointerId]=t,ae++}function N(t){se[t.pointerId]&&(se[t.pointerId]=t)}function D(t){delete se[t.pointerId],ae--}function j(t,i){t.touches=[];for(var e in se)t.touches.push(se[e]);t.changedTouches=[t],i(t)}function W(t,i,e){var n=function(t){(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons)&&j(t,i)};t["_leaflet_touchmove"+e]=n,t.addEventListener(ie,n,!1)}function H(t,i,e){var n=function(t){j(t,i)};t["_leaflet_touchend"+e]=n,t.addEventListener(ee,n,!1),t.addEventListener(ne,n,!1)}function F(t,i,e){function n(t){var i;if(Vi){if(!bi||"mouse"===t.pointerType)return;i=ae}else i=t.touches.length;if(!(i>1)){var e=Date.now(),n=e-(s||e);r=t.touches?t.touches[0]:t,a=n>0&&n<=h,s=e}}function o(t){if(a&&!r.cancelBubble){if(Vi){if(!bi||"mouse"===t.pointerType)return;var e,n,o={};for(n in r)e=r[n],o[n]=e&&e.bind?e.bind(r):e;r=o}r.type="dblclick",i(r),s=null}}var s,r,a=!1,h=250;return t[le+he+e]=n,t[le+ue+e]=o,t[le+"dblclick"+e]=i,t.addEventListener(he,n,!1),t.addEventListener(ue,o,!1),t.addEventListener("dblclick",i,!1),this}function U(t,i){var e=t[le+he+i],n=t[le+ue+i],o=t[le+"dblclick"+i];return t.removeEventListener(he,e,!1),t.removeEventListener(ue,n,!1),bi||t.removeEventListener("dblclick",o,!1),this}function V(t){return"string"==typeof t?document.getElementById(t):t}function q(t,i){var e=t.style[i]||t.currentStyle&&t.currentStyle[i];if((!e||"auto"===e)&&document.defaultView){var n=document.defaultView.getComputedStyle(t,null);e=n?n[i]:null}return"auto"===e?null:e}function G(t,i,e){var n=document.createElement(t);return n.className=i||"",e&&e.appendChild(n),n}function K(t){var i=t.parentNode;i&&i.removeChild(t)}function Y(t){for(;t.firstChild;)t.removeChild(t.firstChild)}function X(t){var i=t.parentNode;i&&i.lastChild!==t&&i.appendChild(t)}function J(t){var i=t.parentNode;i&&i.firstChild!==t&&i.insertBefore(t,i.firstChild)}function $(t,i){if(void 0!==t.classList)return t.classList.contains(i);var e=et(t);return e.length>0&&new RegExp("(^|\\s)"+i+"(\\s|$)").test(e)}function Q(t,i){if(void 0!==t.classList)for(var e=u(i),n=0,o=e.length;n<o;n++)t.classList.add(e[n]);else if(!$(t,i)){var s=et(t);it(t,(s?s+" ":"")+i)}}function tt(t,i){void 0!==t.classList?t.classList.remove(i):it(t,h((" "+et(t)+" ").replace(" "+i+" "," ")))}function it(t,i){void 0===t.className.baseVal?t.className=i:t.className.baseVal=i}function et(t){return t.correspondingElement&&(t=t.correspondingElement),void 0===t.className.baseVal?t.className:t.className.baseVal}function nt(t,i){"opacity"in t.style?t.style.opacity=i:"filter"in t.style&&ot(t,i)}function ot(t,i){var e=!1,n="DXImageTransform.Microsoft.Alpha";try{e=t.filters.item(n)}catch(t){if(1===i)return}i=Math.round(100*i),e?(e.Enabled=100!==i,e.Opacity=i):t.style.filter+=" progid:"+n+"(opacity="+i+")"}function st(t){for(var i=document.documentElement.style,e=0;e<t.length;e++)if(t[e]in i)return t[e];return!1}function rt(t,i,e){var n=i||new x(0,0);t.style[ce]=(Ri?"translate("+n.x+"px,"+n.y+"px)":"translate3d("+n.x+"px,"+n.y+"px,0)")+(e?" scale("+e+")":"")}function at(t,i){t._leaflet_pos=i,ji?rt(t,i):(t.style.left=i.x+"px",t.style.top=i.y+"px")}function ht(t){return t._leaflet_pos||new x(0,0)}function ut(){mt(window,"dragstart",Pt)}function lt(){ft(window,"dragstart",Pt)}function ct(t){for(;-1===t.tabIndex;)t=t.parentNode;t.style&&(_t(),me=t,fe=t.style.outline,t.style.outline="none",mt(window,"keydown",_t))}function _t(){me&&(me.style.outline=fe,me=void 0,fe=void 0,ft(window,"keydown",_t))}function dt(t){do{t=t.parentNode}while(!(t.offsetWidth&&t.offsetHeight||t===document.body));return t}function pt(t){var i=t.getBoundingClientRect();return{x:i.width/t.offsetWidth||1,y:i.height/t.offsetHeight||1,boundingClientRect:i}}function mt(t,i,e,n){if("object"==typeof i)for(var o in i)gt(t,o,i[o],e);else for(var s=0,r=(i=u(i)).length;s<r;s++)gt(t,i[s],e,n);return this}function ft(t,i,e,n){if("object"==typeof i)for(var o in i)vt(t,o,i[o],e);else if(i)for(var s=0,r=(i=u(i)).length;s<r;s++)vt(t,i[s],e,n);else{for(var a in t[ye])vt(t,a,t[ye][a]);delete t[ye]}return this}function gt(t,i,e,o){var s=i+n(e)+(o?"_"+n(o):"");if(t[ye]&&t[ye][s])return this;var r=function(i){return e.call(o||t,i||window.event)},a=r;Vi&&0===i.indexOf("touch")?A(t,i,r,s):!qi||"dblclick"!==i||!F||Vi&&Ei?"addEventListener"in t?"mousewheel"===i?t.addEventListener("onwheel"in t?"wheel":"mousewheel",r,!1):"mouseenter"===i||"mouseleave"===i?(r=function(i){i=i||window.event,Ct(t,i)&&a(i)},t.addEventListener("mouseenter"===i?"mouseover":"mouseout",r,!1)):("click"===i&&zi&&(r=function(t){St(t,a)}),t.addEventListener(i,r,!1)):"attachEvent"in t&&t.attachEvent("on"+i,r):F(t,r,s),t[ye]=t[ye]||{},t[ye][s]=r}function vt(t,i,e,o){var s=i+n(e)+(o?"_"+n(o):""),r=t[ye]&&t[ye][s];if(!r)return this;Vi&&0===i.indexOf("touch")?I(t,i,s):!qi||"dblclick"!==i||!U||Vi&&Ei?"removeEventListener"in t?"mousewheel"===i?t.removeEventListener("onwheel"in t?"wheel":"mousewheel",r,!1):t.removeEventListener("mouseenter"===i?"mouseover":"mouseleave"===i?"mouseout":i,r,!1):"detachEvent"in t&&t.detachEvent("on"+i,r):U(t,s),t[ye][s]=null}function yt(t){return t.stopPropagation?t.stopPropagation():t.originalEvent?t.originalEvent._stopped=!0:t.cancelBubble=!0,Mt(t),this}function xt(t){return gt(t,"mousewheel",yt),this}function wt(t){return mt(t,"mousedown touchstart dblclick",yt),gt(t,"click",zt),this}function Pt(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this}function Lt(t){return Pt(t),yt(t),this}function bt(t,i){if(!i)return new x(t.clientX,t.clientY);var e=pt(i),n=e.boundingClientRect;return new x((t.clientX-n.left)/e.x-i.clientLeft,(t.clientY-n.top)/e.y-i.clientTop)}function Tt(t){return bi?t.wheelDeltaY/2:t.deltaY&&0===t.deltaMode?-t.deltaY/xe:t.deltaY&&1===t.deltaMode?20*-t.deltaY:t.deltaY&&2===t.deltaMode?60*-t.deltaY:t.deltaX||t.deltaZ?0:t.wheelDelta?(t.wheelDeltaY||t.wheelDelta)/2:t.detail&&Math.abs(t.detail)<32765?20*-t.detail:t.detail?t.detail/-32765*60:0}function zt(t){we[t.type]=!0}function Mt(t){var i=we[t.type];return we[t.type]=!1,i}function Ct(t,i){var e=i.relatedTarget;if(!e)return!0;try{for(;e&&e!==t;)e=e.parentNode}catch(t){return!1}return e!==t}function St(t,i){var e=t.timeStamp||t.originalEvent&&t.originalEvent.timeStamp,n=ge&&e-ge;n&&n>100&&n<500||t.target._simulatedClick&&!t._simulated?Lt(t):(ge=e,i(t))}function Zt(t,i){if(!i||!t.length)return t.slice();var e=i*i;return t=At(t,e),t=kt(t,e)}function Et(t,i,e){return Math.sqrt(Dt(t,i,e,!0))}function kt(t,i){var e=t.length,n=new(typeof Uint8Array!=void 0+""?Uint8Array:Array)(e);n[0]=n[e-1]=1,Bt(t,n,i,0,e-1);var o,s=[];for(o=0;o<e;o++)n[o]&&s.push(t[o]);return s}function Bt(t,i,e,n,o){var s,r,a,h=0;for(r=n+1;r<=o-1;r++)(a=Dt(t[r],t[n],t[o],!0))>h&&(s=r,h=a);h>e&&(i[s]=1,Bt(t,i,e,n,s),Bt(t,i,e,s,o))}function At(t,i){for(var e=[t[0]],n=1,o=0,s=t.length;n<s;n++)Nt(t[n],t[o])>i&&(e.push(t[n]),o=n);return o<s-1&&e.push(t[s-1]),e}function It(t,i,e,n,o){var s,r,a,h=n?ke:Rt(t,e),u=Rt(i,e);for(ke=u;;){if(!(h|u))return[t,i];if(h&u)return!1;a=Rt(r=Ot(t,i,s=h||u,e,o),e),s===h?(t=r,h=a):(i=r,u=a)}}function Ot(t,i,e,n,o){var s,r,a=i.x-t.x,h=i.y-t.y,u=n.min,l=n.max;return 8&e?(s=t.x+a*(l.y-t.y)/h,r=l.y):4&e?(s=t.x+a*(u.y-t.y)/h,r=u.y):2&e?(s=l.x,r=t.y+h*(l.x-t.x)/a):1&e&&(s=u.x,r=t.y+h*(u.x-t.x)/a),new x(s,r,o)}function Rt(t,i){var e=0;return t.x<i.min.x?e|=1:t.x>i.max.x&&(e|=2),t.y<i.min.y?e|=4:t.y>i.max.y&&(e|=8),e}function Nt(t,i){var e=i.x-t.x,n=i.y-t.y;return e*e+n*n}function Dt(t,i,e,n){var o,s=i.x,r=i.y,a=e.x-s,h=e.y-r,u=a*a+h*h;return u>0&&((o=((t.x-s)*a+(t.y-r)*h)/u)>1?(s=e.x,r=e.y):o>0&&(s+=a*o,r+=h*o)),a=t.x-s,h=t.y-r,n?a*a+h*h:new x(s,r)}function jt(t){return!oi(t[0])||"object"!=typeof t[0][0]&&void 0!==t[0][0]}function Wt(t){return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),jt(t)}function Ht(t,i,e){var n,o,s,r,a,h,u,l,c,_=[1,4,2,8];for(o=0,u=t.length;o<u;o++)t[o]._code=Rt(t[o],i);for(r=0;r<4;r++){for(l=_[r],n=[],o=0,s=(u=t.length)-1;o<u;s=o++)a=t[o],h=t[s],a._code&l?h._code&l||((c=Ot(h,a,l,i,e))._code=Rt(c,i),n.push(c)):(h._code&l&&((c=Ot(h,a,l,i,e))._code=Rt(c,i),n.push(c)),n.push(a));t=n}return t}function Ft(t,i){var e,n,o,s,r="Feature"===t.type?t.geometry:t,a=r?r.coordinates:null,h=[],u=i&&i.pointToLayer,l=i&&i.coordsToLatLng||Ut;if(!a&&!r)return null;switch(r.type){case"Point":return e=l(a),u?u(t,e):new $e(e);case"MultiPoint":for(o=0,s=a.length;o<s;o++)e=l(a[o]),h.push(u?u(t,e):new $e(e));return new Ke(h);case"LineString":case"MultiLineString":return n=Vt(a,"LineString"===r.type?0:1,l),new nn(n,i);case"Polygon":case"MultiPolygon":return n=Vt(a,"Polygon"===r.type?1:2,l),new on(n,i);case"GeometryCollection":for(o=0,s=r.geometries.length;o<s;o++){var c=Ft({geometry:r.geometries[o],type:"Feature",properties:t.properties},i);c&&h.push(c)}return new Ke(h);default:throw new Error("Invalid GeoJSON object.")}}function Ut(t){return new M(t[1],t[0],t[2])}function Vt(t,i,e){for(var n,o=[],s=0,r=t.length;s<r;s++)n=i?Vt(t[s],i-1,e):(e||Ut)(t[s]),o.push(n);return o}function qt(t,i){return i="number"==typeof i?i:6,void 0!==t.alt?[a(t.lng,i),a(t.lat,i),a(t.alt,i)]:[a(t.lng,i),a(t.lat,i)]}function Gt(t,i,e,n){for(var o=[],s=0,r=t.length;s<r;s++)o.push(i?Gt(t[s],i-1,e,n):qt(t[s],n));return!i&&e&&o.push(o[0]),o}function Kt(t,e){return t.feature?i({},t.feature,{geometry:e}):Yt(e)}function Yt(t){return"Feature"===t.type||"FeatureCollection"===t.type?t:{type:"Feature",properties:{},geometry:t}}function Xt(t,i){return new sn(t,i)}function Jt(t,i){return new mn(t,i)}function $t(t){return Xi?new vn(t):null}function Qt(t){return Ji||$i?new Pn(t):null}var ti=Object.freeze;Object.freeze=function(t){return t};var ii=Object.create||function(){function t(){}return function(i){return t.prototype=i,new t}}(),ei=0,ni=/\{ *([\w_-]+) *\}/g,oi=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},si="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=",ri=0,ai=window.requestAnimationFrame||p("RequestAnimationFrame")||m,hi=window.cancelAnimationFrame||p("CancelAnimationFrame")||p("CancelRequestAnimationFrame")||function(t){window.clearTimeout(t)},ui=(Object.freeze||Object)({freeze:ti,extend:i,create:ii,bind:e,lastId:ei,stamp:n,throttle:o,wrapNum:s,falseFn:r,formatNum:a,trim:h,splitWords:u,setOptions:l,getParamString:c,template:_,isArray:oi,indexOf:d,emptyImageUrl:si,requestFn:ai,cancelFn:hi,requestAnimFrame:f,cancelAnimFrame:g});v.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()},n=e.__super__=this.prototype,o=ii(n);o.constructor=e,e.prototype=o;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&"__super__"!==s&&(e[s]=this[s]);return t.statics&&(i(e,t.statics),delete t.statics),t.includes&&(y(t.includes),i.apply(null,[o].concat(t.includes)),delete t.includes),o.options&&(t.options=i(ii(o.options),t.options)),i(o,t),o._initHooks=[],o.callInitHooks=function(){if(!this._initHooksCalled){n.callInitHooks&&n.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,i=o._initHooks.length;t<i;t++)o._initHooks[t].call(this)}},e},v.include=function(t){return i(this.prototype,t),this},v.mergeOptions=function(t){return i(this.prototype.options,t),this},v.addInitHook=function(t){var i=Array.prototype.slice.call(arguments,1),e="function"==typeof t?t:function(){this[t].apply(this,i)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(e),this};var li={on:function(t,i,e){if("object"==typeof t)for(var n in t)this._on(n,t[n],i);else for(var o=0,s=(t=u(t)).length;o<s;o++)this._on(t[o],i,e);return this},off:function(t,i,e){if(t)if("object"==typeof t)for(var n in t)this._off(n,t[n],i);else for(var o=0,s=(t=u(t)).length;o<s;o++)this._off(t[o],i,e);else delete this._events;return this},_on:function(t,i,e){this._events=this._events||{};var n=this._events[t];n||(n=[],this._events[t]=n),e===this&&(e=void 0);for(var o={fn:i,ctx:e},s=n,r=0,a=s.length;r<a;r++)if(s[r].fn===i&&s[r].ctx===e)return;s.push(o)},_off:function(t,i,e){var n,o,s;if(this._events&&(n=this._events[t]))if(i){if(e===this&&(e=void 0),n)for(o=0,s=n.length;o<s;o++){var a=n[o];if(a.ctx===e&&a.fn===i)return a.fn=r,this._firingCount&&(this._events[t]=n=n.slice()),void n.splice(o,1)}}else{for(o=0,s=n.length;o<s;o++)n[o].fn=r;delete this._events[t]}},fire:function(t,e,n){if(!this.listens(t,n))return this;var o=i({},e,{type:t,target:this,sourceTarget:e&&e.sourceTarget||this});if(this._events){var s=this._events[t];if(s){this._firingCount=this._firingCount+1||1;for(var r=0,a=s.length;r<a;r++){var h=s[r];h.fn.call(h.ctx||this,o)}this._firingCount--}}return n&&this._propagateEvent(o),this},listens:function(t,i){var e=this._events&&this._events[t];if(e&&e.length)return!0;if(i)for(var n in this._eventParents)if(this._eventParents[n].listens(t,i))return!0;return!1},once:function(t,i,n){if("object"==typeof t){for(var o in t)this.once(o,t[o],i);return this}var s=e(function(){this.off(t,i,n).off(t,s,n)},this);return this.on(t,i,n).on(t,s,n)},addEventParent:function(t){return this._eventParents=this._eventParents||{},this._eventParents[n(t)]=t,this},removeEventParent:function(t){return this._eventParents&&delete this._eventParents[n(t)],this},_propagateEvent:function(t){for(var e in this._eventParents)this._eventParents[e].fire(t.type,i({layer:t.target,propagatedFrom:t.target},t),!0)}};li.addEventListener=li.on,li.removeEventListener=li.clearAllEventListeners=li.off,li.addOneTimeEventListener=li.once,li.fireEvent=li.fire,li.hasEventListeners=li.listens;var ci=v.extend(li),_i=Math.trunc||function(t){return t>0?Math.floor(t):Math.ceil(t)};x.prototype={clone:function(){return new x(this.x,this.y)},add:function(t){return this.clone()._add(w(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(w(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},scaleBy:function(t){return new x(this.x*t.x,this.y*t.y)},unscaleBy:function(t){return new x(this.x/t.x,this.y/t.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=_i(this.x),this.y=_i(this.y),this},distanceTo:function(t){var i=(t=w(t)).x-this.x,e=t.y-this.y;return Math.sqrt(i*i+e*e)},equals:function(t){return(t=w(t)).x===this.x&&t.y===this.y},contains:function(t){return t=w(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+a(this.x)+", "+a(this.y)+")"}},P.prototype={extend:function(t){return t=w(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new x((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new x(this.min.x,this.max.y)},getTopRight:function(){return new x(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var i,e;return(t="number"==typeof t[0]||t instanceof x?w(t):b(t))instanceof P?(i=t.min,e=t.max):i=e=t,i.x>=this.min.x&&e.x<=this.max.x&&i.y>=this.min.y&&e.y<=this.max.y},intersects:function(t){t=b(t);var i=this.min,e=this.max,n=t.min,o=t.max,s=o.x>=i.x&&n.x<=e.x,r=o.y>=i.y&&n.y<=e.y;return s&&r},overlaps:function(t){t=b(t);var i=this.min,e=this.max,n=t.min,o=t.max,s=o.x>i.x&&n.x<e.x,r=o.y>i.y&&n.y<e.y;return s&&r},isValid:function(){return!(!this.min||!this.max)}},T.prototype={extend:function(t){var i,e,n=this._southWest,o=this._northEast;if(t instanceof M)i=t,e=t;else{if(!(t instanceof T))return t?this.extend(C(t)||z(t)):this;if(i=t._southWest,e=t._northEast,!i||!e)return this}return n||o?(n.lat=Math.min(i.lat,n.lat),n.lng=Math.min(i.lng,n.lng),o.lat=Math.max(e.lat,o.lat),o.lng=Math.max(e.lng,o.lng)):(this._southWest=new M(i.lat,i.lng),this._northEast=new M(e.lat,e.lng)),this},pad:function(t){var i=this._southWest,e=this._northEast,n=Math.abs(i.lat-e.lat)*t,o=Math.abs(i.lng-e.lng)*t;return new T(new M(i.lat-n,i.lng-o),new M(e.lat+n,e.lng+o))},getCenter:function(){return new M((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new M(this.getNorth(),this.getWest())},getSouthEast:function(){return new M(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof M||"lat"in t?C(t):z(t);var i,e,n=this._southWest,o=this._northEast;return t instanceof T?(i=t.getSouthWest(),e=t.getNorthEast()):i=e=t,i.lat>=n.lat&&e.lat<=o.lat&&i.lng>=n.lng&&e.lng<=o.lng},intersects:function(t){t=z(t);var i=this._southWest,e=this._northEast,n=t.getSouthWest(),o=t.getNorthEast(),s=o.lat>=i.lat&&n.lat<=e.lat,r=o.lng>=i.lng&&n.lng<=e.lng;return s&&r},overlaps:function(t){t=z(t);var i=this._southWest,e=this._northEast,n=t.getSouthWest(),o=t.getNorthEast(),s=o.lat>i.lat&&n.lat<e.lat,r=o.lng>i.lng&&n.lng<e.lng;return s&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t,i){return!!t&&(t=z(t),this._southWest.equals(t.getSouthWest(),i)&&this._northEast.equals(t.getNorthEast(),i))},isValid:function(){return!(!this._southWest||!this._northEast)}},M.prototype={equals:function(t,i){return!!t&&(t=C(t),Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng))<=(void 0===i?1e-9:i))},toString:function(t){return"LatLng("+a(this.lat,t)+", "+a(this.lng,t)+")"},distanceTo:function(t){return pi.distance(this,C(t))},wrap:function(){return pi.wrapLatLng(this)},toBounds:function(t){var i=180*t/40075017,e=i/Math.cos(Math.PI/180*this.lat);return z([this.lat-i,this.lng-e],[this.lat+i,this.lng+e])},clone:function(){return new M(this.lat,this.lng,this.alt)}};var di={latLngToPoint:function(t,i){var e=this.projection.project(t),n=this.scale(i);return this.transformation._transform(e,n)},pointToLatLng:function(t,i){var e=this.scale(i),n=this.transformation.untransform(t,e);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},unproject:function(t){return this.projection.unproject(t)},scale:function(t){return 256*Math.pow(2,t)},zoom:function(t){return Math.log(t/256)/Math.LN2},getProjectedBounds:function(t){if(this.infinite)return null;var i=this.projection.bounds,e=this.scale(t);return new P(this.transformation.transform(i.min,e),this.transformation.transform(i.max,e))},infinite:!1,wrapLatLng:function(t){var i=this.wrapLng?s(t.lng,this.wrapLng,!0):t.lng;return new M(this.wrapLat?s(t.lat,this.wrapLat,!0):t.lat,i,t.alt)},wrapLatLngBounds:function(t){var i=t.getCenter(),e=this.wrapLatLng(i),n=i.lat-e.lat,o=i.lng-e.lng;if(0===n&&0===o)return t;var s=t.getSouthWest(),r=t.getNorthEast();return new T(new M(s.lat-n,s.lng-o),new M(r.lat-n,r.lng-o))}},pi=i({},di,{wrapLng:[-180,180],R:6371e3,distance:function(t,i){var e=Math.PI/180,n=t.lat*e,o=i.lat*e,s=Math.sin((i.lat-t.lat)*e/2),r=Math.sin((i.lng-t.lng)*e/2),a=s*s+Math.cos(n)*Math.cos(o)*r*r,h=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));return this.R*h}}),mi={R:6378137,MAX_LATITUDE:85.0511287798,project:function(t){var i=Math.PI/180,e=this.MAX_LATITUDE,n=Math.max(Math.min(e,t.lat),-e),o=Math.sin(n*i);return new x(this.R*t.lng*i,this.R*Math.log((1+o)/(1-o))/2)},unproject:function(t){var i=180/Math.PI;return new M((2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*i,t.x*i/this.R)},bounds:function(){var t=6378137*Math.PI;return new P([-t,-t],[t,t])}()};S.prototype={transform:function(t,i){return this._transform(t.clone(),i)},_transform:function(t,i){return i=i||1,t.x=i*(this._a*t.x+this._b),t.y=i*(this._c*t.y+this._d),t},untransform:function(t,i){return i=i||1,new x((t.x/i-this._b)/this._a,(t.y/i-this._d)/this._c)}};var fi,gi,vi,yi=i({},pi,{code:"EPSG:3857",projection:mi,transformation:function(){var t=.5/(Math.PI*mi.R);return Z(t,.5,-t,.5)}()}),xi=i({},yi,{code:"EPSG:900913"}),wi=document.documentElement.style,Pi="ActiveXObject"in window,Li=Pi&&!document.addEventListener,bi="msLaunchUri"in navigator&&!("documentMode"in document),Ti=B("webkit"),zi=B("android"),Mi=B("android 2")||B("android 3"),Ci=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),Si=zi&&B("Google")&&Ci<537&&!("AudioNode"in window),Zi=!!window.opera,Ei=B("chrome"),ki=B("gecko")&&!Ti&&!Zi&&!Pi,Bi=!Ei&&B("safari"),Ai=B("phantom"),Ii="OTransition"in wi,Oi=0===navigator.platform.indexOf("Win"),Ri=Pi&&"transition"in wi,Ni="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!Mi,Di="MozPerspective"in wi,ji=!window.L_DISABLE_3D&&(Ri||Ni||Di)&&!Ii&&!Ai,Wi="undefined"!=typeof orientation||B("mobile"),Hi=Wi&&Ti,Fi=Wi&&Ni,Ui=!window.PointerEvent&&window.MSPointerEvent,Vi=!(!window.PointerEvent&&!Ui),qi=!window.L_NO_TOUCH&&(Vi||"ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch),Gi=Wi&&Zi,Ki=Wi&&ki,Yi=(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI)>1,Xi=!!document.createElement("canvas").getContext,Ji=!(!document.createElementNS||!E("svg").createSVGRect),$i=!Ji&&function(){try{var t=document.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(t){return!1}}(),Qi=(Object.freeze||Object)({ie:Pi,ielt9:Li,edge:bi,webkit:Ti,android:zi,android23:Mi,androidStock:Si,opera:Zi,chrome:Ei,gecko:ki,safari:Bi,phantom:Ai,opera12:Ii,win:Oi,ie3d:Ri,webkit3d:Ni,gecko3d:Di,any3d:ji,mobile:Wi,mobileWebkit:Hi,mobileWebkit3d:Fi,msPointer:Ui,pointer:Vi,touch:qi,mobileOpera:Gi,mobileGecko:Ki,retina:Yi,canvas:Xi,svg:Ji,vml:$i}),te=Ui?"MSPointerDown":"pointerdown",ie=Ui?"MSPointerMove":"pointermove",ee=Ui?"MSPointerUp":"pointerup",ne=Ui?"MSPointerCancel":"pointercancel",oe=["INPUT","SELECT","OPTION"],se={},re=!1,ae=0,he=Ui?"MSPointerDown":Vi?"pointerdown":"touchstart",ue=Ui?"MSPointerUp":Vi?"pointerup":"touchend",le="_leaflet_",ce=st(["transform","webkitTransform","OTransform","MozTransform","msTransform"]),_e=st(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),de="webkitTransition"===_e||"OTransition"===_e?_e+"End":"transitionend";if("onselectstart"in document)fi=function(){mt(window,"selectstart",Pt)},gi=function(){ft(window,"selectstart",Pt)};else{var pe=st(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);fi=function(){if(pe){var t=document.documentElement.style;vi=t[pe],t[pe]="none"}},gi=function(){pe&&(document.documentElement.style[pe]=vi,vi=void 0)}}var me,fe,ge,ve=(Object.freeze||Object)({TRANSFORM:ce,TRANSITION:_e,TRANSITION_END:de,get:V,getStyle:q,create:G,remove:K,empty:Y,toFront:X,toBack:J,hasClass:$,addClass:Q,removeClass:tt,setClass:it,getClass:et,setOpacity:nt,testProp:st,setTransform:rt,setPosition:at,getPosition:ht,disableTextSelection:fi,enableTextSelection:gi,disableImageDrag:ut,enableImageDrag:lt,preventOutline:ct,restoreOutline:_t,getSizedParentNode:dt,getScale:pt}),ye="_leaflet_events",xe=Oi&&Ei?2*window.devicePixelRatio:ki?window.devicePixelRatio:1,we={},Pe=(Object.freeze||Object)({on:mt,off:ft,stopPropagation:yt,disableScrollPropagation:xt,disableClickPropagation:wt,preventDefault:Pt,stop:Lt,getMousePosition:bt,getWheelDelta:Tt,fakeStop:zt,skipped:Mt,isExternalTarget:Ct,addListener:mt,removeListener:ft}),Le=ci.extend({run:function(t,i,e,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=e||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=ht(t),this._offset=i.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=f(this._animate,this),this._step()},_step:function(t){var i=+new Date-this._startTime,e=1e3*this._duration;i<e?this._runFrame(this._easeOut(i/e),t):(this._runFrame(1),this._complete())},_runFrame:function(t,i){var e=this._startPos.add(this._offset.multiplyBy(t));i&&e._round(),at(this._el,e),this.fire("step")},_complete:function(){g(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),be=ci.extend({options:{crs:yi,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(t,i){i=l(this,i),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this._initContainer(t),this._initLayout(),this._onResize=e(this._onResize,this),this._initEvents(),i.maxBounds&&this.setMaxBounds(i.maxBounds),void 0!==i.zoom&&(this._zoom=this._limitZoom(i.zoom)),i.center&&void 0!==i.zoom&&this.setView(C(i.center),i.zoom,{reset:!0}),this.callInitHooks(),this._zoomAnimated=_e&&ji&&!Gi&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),mt(this._proxy,de,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(t,e,n){return e=void 0===e?this._zoom:this._limitZoom(e),t=this._limitCenter(C(t),e,this.options.maxBounds),n=n||{},this._stop(),this._loaded&&!n.reset&&!0!==n&&(void 0!==n.animate&&(n.zoom=i({animate:n.animate},n.zoom),n.pan=i({animate:n.animate,duration:n.duration},n.pan)),this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan))?(clearTimeout(this._sizeTimer),this):(this._resetView(t,e),this)},setZoom:function(t,i){return this._loaded?this.setView(this.getCenter(),t,{zoom:i}):(this._zoom=t,this)},zoomIn:function(t,i){return t=t||(ji?this.options.zoomDelta:1),this.setZoom(this._zoom+t,i)},zoomOut:function(t,i){return t=t||(ji?this.options.zoomDelta:1),this.setZoom(this._zoom-t,i)},setZoomAround:function(t,i,e){var n=this.getZoomScale(i),o=this.getSize().divideBy(2),s=(t instanceof x?t:this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1-1/n),r=this.containerPointToLatLng(o.add(s));return this.setView(r,i,{zoom:e})},_getBoundsCenterZoom:function(t,i){i=i||{},t=t.getBounds?t.getBounds():z(t);var e=w(i.paddingTopLeft||i.padding||[0,0]),n=w(i.paddingBottomRight||i.padding||[0,0]),o=this.getBoundsZoom(t,!1,e.add(n));if((o="number"==typeof i.maxZoom?Math.min(i.maxZoom,o):o)===1/0)return{center:t.getCenter(),zoom:o};var s=n.subtract(e).divideBy(2),r=this.project(t.getSouthWest(),o),a=this.project(t.getNorthEast(),o);return{center:this.unproject(r.add(a).divideBy(2).add(s),o),zoom:o}},fitBounds:function(t,i){if(!(t=z(t)).isValid())throw new Error("Bounds are not valid.");var e=this._getBoundsCenterZoom(t,i);return this.setView(e.center,e.zoom,i)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,i){return this.setView(t,this._zoom,{pan:i})},panBy:function(t,i){if(t=w(t).round(),i=i||{},!t.x&&!t.y)return this.fire("moveend");if(!0!==i.animate&&!this.getSize().contains(t))return this._resetView(this.unproject(this.project(this.getCenter()).add(t)),this.getZoom()),this;if(this._panAnim||(this._panAnim=new Le,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),i.noMoveStart||this.fire("movestart"),!1!==i.animate){Q(this._mapPane,"leaflet-pan-anim");var e=this._getMapPanePos().subtract(t).round();this._panAnim.run(this._mapPane,e,i.duration||.25,i.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},flyTo:function(t,i,e){function n(t){var i=(g*g-m*m+(t?-1:1)*x*x*v*v)/(2*(t?g:m)*x*v),e=Math.sqrt(i*i+1)-i;return e<1e-9?-18:Math.log(e)}function o(t){return(Math.exp(t)-Math.exp(-t))/2}function s(t){return(Math.exp(t)+Math.exp(-t))/2}function r(t){return o(t)/s(t)}function a(t){return m*(s(w)/s(w+y*t))}function h(t){return m*(s(w)*r(w+y*t)-o(w))/x}function u(t){return 1-Math.pow(1-t,1.5)}function l(){var e=(Date.now()-P)/b,n=u(e)*L;e<=1?(this._flyToFrame=f(l,this),this._move(this.unproject(c.add(_.subtract(c).multiplyBy(h(n)/v)),p),this.getScaleZoom(m/a(n),p),{flyTo:!0})):this._move(t,i)._moveEnd(!0)}if(!1===(e=e||{}).animate||!ji)return this.setView(t,i,e);this._stop();var c=this.project(this.getCenter()),_=this.project(t),d=this.getSize(),p=this._zoom;t=C(t),i=void 0===i?p:i;var m=Math.max(d.x,d.y),g=m*this.getZoomScale(p,i),v=_.distanceTo(c)||1,y=1.42,x=y*y,w=n(0),P=Date.now(),L=(n(1)-w)/y,b=e.duration?1e3*e.duration:1e3*L*.8;return this._moveStart(!0,e.noMoveStart),l.call(this),this},flyToBounds:function(t,i){var e=this._getBoundsCenterZoom(t,i);return this.flyTo(e.center,e.zoom,i)},setMaxBounds:function(t){return(t=z(t)).isValid()?(this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this.options.maxBounds=t,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this.off("moveend",this._panInsideMaxBounds))},setMinZoom:function(t){var i=this.options.minZoom;return this.options.minZoom=t,this._loaded&&i!==t&&(this.fire("zoomlevelschange"),this.getZoom()<this.options.minZoom)?this.setZoom(t):this},setMaxZoom:function(t){var i=this.options.maxZoom;return this.options.maxZoom=t,this._loaded&&i!==t&&(this.fire("zoomlevelschange"),this.getZoom()>this.options.maxZoom)?this.setZoom(t):this},panInsideBounds:function(t,i){this._enforcingBounds=!0;var e=this.getCenter(),n=this._limitCenter(e,this._zoom,z(t));return e.equals(n)||this.panTo(n,i),this._enforcingBounds=!1,this},panInside:function(t,i){var e=w((i=i||{}).paddingTopLeft||i.padding||[0,0]),n=w(i.paddingBottomRight||i.padding||[0,0]),o=this.getCenter(),s=this.project(o),r=this.project(t),a=this.getPixelBounds(),h=a.getSize().divideBy(2),u=b([a.min.add(e),a.max.subtract(n)]);if(!u.contains(r)){this._enforcingBounds=!0;var l=s.subtract(r),c=w(r.x+l.x,r.y+l.y);(r.x<u.min.x||r.x>u.max.x)&&(c.x=s.x-l.x,l.x>0?c.x+=h.x-e.x:c.x-=h.x-n.x),(r.y<u.min.y||r.y>u.max.y)&&(c.y=s.y-l.y,l.y>0?c.y+=h.y-e.y:c.y-=h.y-n.y),this.panTo(this.unproject(c),i),this._enforcingBounds=!1}return this},invalidateSize:function(t){if(!this._loaded)return this;t=i({animate:!1,pan:!0},!0===t?{animate:!0}:t);var n=this.getSize();this._sizeChanged=!0,this._lastCenter=null;var o=this.getSize(),s=n.divideBy(2).round(),r=o.divideBy(2).round(),a=s.subtract(r);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(e(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:n,newSize:o})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},locate:function(t){if(t=this._locateOptions=i({timeout:1e4,watch:!1},t),!("geolocation"in navigator))return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var n=e(this._handleGeolocationResponse,this),o=e(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(n,o,t):navigator.geolocation.getCurrentPosition(n,o,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var i=t.code,e=t.message||(1===i?"permission denied":2===i?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:i,message:"Geolocation error: "+e+"."})},_handleGeolocationResponse:function(t){var i=new M(t.coords.latitude,t.coords.longitude),e=i.toBounds(2*t.coords.accuracy),n=this._locateOptions;if(n.setView){var o=this.getBoundsZoom(e);this.setView(i,n.maxZoom?Math.min(o,n.maxZoom):o)}var s={latlng:i,bounds:e,timestamp:t.timestamp};for(var r in t.coords)"number"==typeof t.coords[r]&&(s[r]=t.coords[r]);this.fire("locationfound",s)},addHandler:function(t,i){if(!i)return this;var e=this[t]=new i(this);return this._handlers.push(e),this.options[t]&&e.enable(),this},remove:function(){if(this._initEvents(!0),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch(t){this._container._leaflet_id=void 0,this._containerId=void 0}void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),K(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._resizeRequest&&(g(this._resizeRequest),this._resizeRequest=null),this._clearHandlers(),this._loaded&&this.fire("unload");var t;for(t in this._layers)this._layers[t].remove();for(t in this._panes)K(this._panes[t]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(t,i){var e=G("div","leaflet-pane"+(t?" leaflet-"+t.replace("Pane","")+"-pane":""),i||this._mapPane);return t&&(this._panes[t]=e),e},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds();return new T(this.unproject(t.getBottomLeft()),this.unproject(t.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,i,e){t=z(t),e=w(e||[0,0]);var n=this.getZoom()||0,o=this.getMinZoom(),s=this.getMaxZoom(),r=t.getNorthWest(),a=t.getSouthEast(),h=this.getSize().subtract(e),u=b(this.project(a,n),this.project(r,n)).getSize(),l=ji?this.options.zoomSnap:1,c=h.x/u.x,_=h.y/u.y,d=i?Math.max(c,_):Math.min(c,_);return n=this.getScaleZoom(d,n),l&&(n=Math.round(n/(l/100))*(l/100),n=i?Math.ceil(n/l)*l:Math.floor(n/l)*l),Math.max(o,Math.min(s,n))},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new x(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(t,i){var e=this._getTopLeftPoint(t,i);return new P(e,e.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(t){return this.options.crs.getProjectedBounds(void 0===t?this.getZoom():t)},getPane:function(t){return"string"==typeof t?this._panes[t]:t},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t,i){var e=this.options.crs;return i=void 0===i?this._zoom:i,e.scale(t)/e.scale(i)},getScaleZoom:function(t,i){var e=this.options.crs;i=void 0===i?this._zoom:i;var n=e.zoom(t*e.scale(i));return isNaN(n)?1/0:n},project:function(t,i){return i=void 0===i?this._zoom:i,this.options.crs.latLngToPoint(C(t),i)},unproject:function(t,i){return i=void 0===i?this._zoom:i,this.options.crs.pointToLatLng(w(t),i)},layerPointToLatLng:function(t){var i=w(t).add(this.getPixelOrigin());return this.unproject(i)},latLngToLayerPoint:function(t){return this.project(C(t))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(t){return this.options.crs.wrapLatLng(C(t))},wrapLatLngBounds:function(t){return this.options.crs.wrapLatLngBounds(z(t))},distance:function(t,i){return this.options.crs.distance(C(t),C(i))},containerPointToLayerPoint:function(t){return w(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return w(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var i=this.containerPointToLayerPoint(w(t));return this.layerPointToLatLng(i)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(C(t)))},mouseEventToContainerPoint:function(t){return bt(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var i=this._container=V(t);if(!i)throw new Error("Map container not found.");if(i._leaflet_id)throw new Error("Map container is already initialized.");mt(i,"scroll",this._onScroll,this),this._containerId=n(i)},_initLayout:function(){var t=this._container;this._fadeAnimated=this.options.fadeAnimation&&ji,Q(t,"leaflet-container"+(qi?" leaflet-touch":"")+(Yi?" leaflet-retina":"")+(Li?" leaflet-oldie":"")+(Bi?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":""));var i=q(t,"position");"absolute"!==i&&"relative"!==i&&"fixed"!==i&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),at(this._mapPane,new x(0,0)),this.createPane("tilePane"),this.createPane("shadowPane"),this.createPane("overlayPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(Q(t.markerPane,"leaflet-zoom-hide"),Q(t.shadowPane,"leaflet-zoom-hide"))},_resetView:function(t,i){at(this._mapPane,new x(0,0));var e=!this._loaded;this._loaded=!0,i=this._limitZoom(i),this.fire("viewprereset");var n=this._zoom!==i;this._moveStart(n,!1)._move(t,i)._moveEnd(n),this.fire("viewreset"),e&&this.fire("load")},_moveStart:function(t,i){return t&&this.fire("zoomstart"),i||this.fire("movestart"),this},_move:function(t,i,e){void 0===i&&(i=this._zoom);var n=this._zoom!==i;return this._zoom=i,this._lastCenter=t,this._pixelOrigin=this._getNewPixelOrigin(t),(n||e&&e.pinch)&&this.fire("zoom",e),this.fire("move",e)},_moveEnd:function(t){return t&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return g(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(t){at(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(t){this._targets={},this._targets[n(this._container)]=this;var i=t?ft:mt;i(this._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress",this._handleDOMEvent,this),this.options.trackResize&&i(window,"resize",this._onResize,this),ji&&this.options.transform3DLimit&&(t?this.off:this.on).call(this,"moveend",this._onMoveEnd)},_onResize:function(){g(this._resizeRequest),this._resizeRequest=f(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var t=this._getMapPanePos();Math.max(Math.abs(t.x),Math.abs(t.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(t,i){for(var e,o=[],s="mouseout"===i||"mouseover"===i,r=t.target||t.srcElement,a=!1;r;){if((e=this._targets[n(r)])&&("click"===i||"preclick"===i)&&!t._simulated&&this._draggableMoved(e)){a=!0;break}if(e&&e.listens(i,!0)){if(s&&!Ct(r,t))break;if(o.push(e),s)break}if(r===this._container)break;r=r.parentNode}return o.length||a||s||!Ct(r,t)||(o=[this]),o},_handleDOMEvent:function(t){if(this._loaded&&!Mt(t)){var i=t.type;"mousedown"!==i&&"keypress"!==i||ct(t.target||t.srcElement),this._fireDOMEvent(t,i)}},_mouseEvents:["click","dblclick","mouseover","mouseout","contextmenu"],_fireDOMEvent:function(t,e,n){if("click"===t.type){var o=i({},t);o.type="preclick",this._fireDOMEvent(o,o.type,n)}if(!t._stopped&&(n=(n||[]).concat(this._findEventTargets(t,e))).length){var s=n[0];"contextmenu"===e&&s.listens(e,!0)&&Pt(t);var r={originalEvent:t};if("keypress"!==t.type){var a=s.getLatLng&&(!s._radius||s._radius<=10);r.containerPoint=a?this.latLngToContainerPoint(s.getLatLng()):this.mouseEventToContainerPoint(t),r.layerPoint=this.containerPointToLayerPoint(r.containerPoint),r.latlng=a?s.getLatLng():this.layerPointToLatLng(r.layerPoint)}for(var h=0;h<n.length;h++)if(n[h].fire(e,r,!0),r.originalEvent._stopped||!1===n[h].options.bubblingMouseEvents&&-1!==d(this._mouseEvents,e))return}},_draggableMoved:function(t){return(t=t.dragging&&t.dragging.enabled()?t:this).dragging&&t.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var t=0,i=this._handlers.length;t<i;t++)this._handlers[t].disable()},whenReady:function(t,i){return this._loaded?t.call(i||this,{target:this}):this.on("load",t,i),this},_getMapPanePos:function(){return ht(this._mapPane)||new x(0,0)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(t,i){return(t&&void 0!==i?this._getNewPixelOrigin(t,i):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(t,i){var e=this.getSize()._divideBy(2);return this.project(t,i)._subtract(e)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(t,i,e){var n=this._getNewPixelOrigin(e,i);return this.project(t,i)._subtract(n)},_latLngBoundsToNewLayerBounds:function(t,i,e){var n=this._getNewPixelOrigin(e,i);return b([this.project(t.getSouthWest(),i)._subtract(n),this.project(t.getNorthWest(),i)._subtract(n),this.project(t.getSouthEast(),i)._subtract(n),this.project(t.getNorthEast(),i)._subtract(n)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,i,e){if(!e)return t;var n=this.project(t,i),o=this.getSize().divideBy(2),s=new P(n.subtract(o),n.add(o)),r=this._getBoundsOffset(s,e,i);return r.round().equals([0,0])?t:this.unproject(n.add(r),i)},_limitOffset:function(t,i){if(!i)return t;var e=this.getPixelBounds(),n=new P(e.min.add(t),e.max.add(t));return t.add(this._getBoundsOffset(n,i))},_getBoundsOffset:function(t,i,e){var n=b(this.project(i.getNorthEast(),e),this.project(i.getSouthWest(),e)),o=n.min.subtract(t.min),s=n.max.subtract(t.max);return new x(this._rebound(o.x,-s.x),this._rebound(o.y,-s.y))},_rebound:function(t,i){return t+i>0?Math.round(t-i)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(i))},_limitZoom:function(t){var i=this.getMinZoom(),e=this.getMaxZoom(),n=ji?this.options.zoomSnap:1;return n&&(t=Math.round(t/n)*n),Math.max(i,Math.min(e,t))},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){tt(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,i){var e=this._getCenterOffset(t)._trunc();return!(!0!==(i&&i.animate)&&!this.getSize().contains(e))&&(this.panBy(e,i),!0)},_createAnimProxy:function(){var t=this._proxy=G("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(t),this.on("zoomanim",function(t){var i=ce,e=this._proxy.style[i];rt(this._proxy,this.project(t.center,t.zoom),this.getZoomScale(t.zoom,1)),e===this._proxy.style[i]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",function(){var t=this.getCenter(),i=this.getZoom();rt(this._proxy,this.project(t,i),this.getZoomScale(i,1))},this),this._on("unload",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){K(this._proxy),delete this._proxy},_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,i,e){if(this._animatingZoom)return!0;if(e=e||{},!this._zoomAnimated||!1===e.animate||this._nothingToAnimate()||Math.abs(i-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(i),o=this._getCenterOffset(t)._divideBy(1-1/n);return!(!0!==e.animate&&!this.getSize().contains(o))&&(f(function(){this._moveStart(!0,!1)._animateZoom(t,i,!0)},this),!0)},_animateZoom:function(t,i,n,o){this._mapPane&&(n&&(this._animatingZoom=!0,this._animateToCenter=t,this._animateToZoom=i,Q(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:t,zoom:i,noUpdate:o}),setTimeout(e(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&tt(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom),f(function(){this._moveEnd(!0)},this))}}),Te=v.extend({options:{position:"topright"},initialize:function(t){l(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var i=this._map;return i&&i.removeControl(this),this.options.position=t,i&&i.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this.remove(),this._map=t;var i=this._container=this.onAdd(t),e=this.getPosition(),n=t._controlCorners[e];return Q(i,"leaflet-control"),-1!==e.indexOf("bottom")?n.insertBefore(i,n.firstChild):n.appendChild(i),this},remove:function(){return this._map?(K(this._container),this.onRemove&&this.onRemove(this._map),this._map=null,this):this},_refocusOnMap:function(t){this._map&&t&&t.screenX>0&&t.screenY>0&&this._map.getContainer().focus()}}),ze=function(t){return new Te(t)};be.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.remove(),this},_initControlPos:function(){function t(t,o){var s=e+t+" "+e+o;i[t+o]=G("div",s,n)}var i=this._controlCorners={},e="leaflet-",n=this._controlContainer=G("div",e+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){for(var t in this._controlCorners)K(this._controlCorners[t]);K(this._controlContainer),delete this._controlCorners,delete this._controlContainer}});var Me=Te.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(t,i,e,n){return e<n?-1:n<e?1:0}},initialize:function(t,i,e){l(this,e),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in i)this._addLayer(i[n],n,!0)},onAdd:function(t){this._initLayout(),this._update(),this._map=t,t.on("zoomend",this._checkDisabledLayers,this);for(var i=0;i<this._layers.length;i++)this._layers[i].layer.on("add remove",this._onLayerChange,this);return this._container},addTo:function(t){return Te.prototype.addTo.call(this,t),this._expandIfNotCollapsed()},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var t=0;t<this._layers.length;t++)this._layers[t].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(t,i){return this._addLayer(t,i),this._map?this._update():this},addOverlay:function(t,i){return this._addLayer(t,i,!0),this._map?this._update():this},removeLayer:function(t){t.off("add remove",this._onLayerChange,this);var i=this._getLayer(n(t));return i&&this._layers.splice(this._layers.indexOf(i),1),this._map?this._update():this},expand:function(){Q(this._container,"leaflet-control-layers-expanded"),this._section.style.height=null;var t=this._map.getSize().y-(this._container.offsetTop+50);return t<this._section.clientHeight?(Q(this._section,"leaflet-control-layers-scrollbar"),this._section.style.height=t+"px"):tt(this._section,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return tt(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var t="leaflet-control-layers",i=this._container=G("div",t),e=this.options.collapsed;i.setAttribute("aria-haspopup",!0),wt(i),xt(i);var n=this._section=G("section",t+"-list");e&&(this._map.on("click",this.collapse,this),zi||mt(i,{mouseenter:this.expand,mouseleave:this.collapse},this));var o=this._layersLink=G("a",t+"-toggle",i);o.href="#",o.title="Layers",qi?(mt(o,"click",Lt),mt(o,"click",this.expand,this)):mt(o,"focus",this.expand,this),e||this.expand(),this._baseLayersList=G("div",t+"-base",n),this._separator=G("div",t+"-separator",n),this._overlaysList=G("div",t+"-overlays",n),i.appendChild(n)},_getLayer:function(t){for(var i=0;i<this._layers.length;i++)if(this._layers[i]&&n(this._layers[i].layer)===t)return this._layers[i]},_addLayer:function(t,i,n){this._map&&t.on("add remove",this._onLayerChange,this),this._layers.push({layer:t,name:i,overlay:n}),this.options.sortLayers&&this._layers.sort(e(function(t,i){return this.options.sortFunction(t.layer,i.layer,t.name,i.name)},this)),this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(!this._container)return this;Y(this._baseLayersList),Y(this._overlaysList),this._layerControlInputs=[];var t,i,e,n,o=0;for(e=0;e<this._layers.length;e++)n=this._layers[e],this._addItem(n),i=i||n.overlay,t=t||!n.overlay,o+=n.overlay?0:1;return this.options.hideSingleBase&&(t=t&&o>1,this._baseLayersList.style.display=t?"":"none"),this._separator.style.display=i&&t?"":"none",this},_onLayerChange:function(t){this._handlingClick||this._update();var i=this._getLayer(n(t.target)),e=i.overlay?"add"===t.type?"overlayadd":"overlayremove":"add"===t.type?"baselayerchange":null;e&&this._map.fire(e,i)},_createRadioElement:function(t,i){var e='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"'+(i?' checked="checked"':"")+"/>",n=document.createElement("div");return n.innerHTML=e,n.firstChild},_addItem:function(t){var i,e=document.createElement("label"),o=this._map.hasLayer(t.layer);t.overlay?((i=document.createElement("input")).type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=o):i=this._createRadioElement("leaflet-base-layers",o),this._layerControlInputs.push(i),i.layerId=n(t.layer),mt(i,"click",this._onInputClick,this);var s=document.createElement("span");s.innerHTML=" "+t.name;var r=document.createElement("div");return e.appendChild(r),r.appendChild(i),r.appendChild(s),(t.overlay?this._overlaysList:this._baseLayersList).appendChild(e),this._checkDisabledLayers(),e},_onInputClick:function(){var t,i,e=this._layerControlInputs,n=[],o=[];this._handlingClick=!0;for(var s=e.length-1;s>=0;s--)t=e[s],i=this._getLayer(t.layerId).layer,t.checked?n.push(i):t.checked||o.push(i);for(s=0;s<o.length;s++)this._map.hasLayer(o[s])&&this._map.removeLayer(o[s]);for(s=0;s<n.length;s++)this._map.hasLayer(n[s])||this._map.addLayer(n[s]);this._handlingClick=!1,this._refocusOnMap()},_checkDisabledLayers:function(){for(var t,i,e=this._layerControlInputs,n=this._map.getZoom(),o=e.length-1;o>=0;o--)t=e[o],i=this._getLayer(t.layerId).layer,t.disabled=void 0!==i.options.minZoom&&n<i.options.minZoom||void 0!==i.options.maxZoom&&n>i.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expand:function(){return this.expand()},_collapse:function(){return this.collapse()}}),Ce=Te.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"&#x2212;",zoomOutTitle:"Zoom out"},onAdd:function(t){var i="leaflet-control-zoom",e=G("div",i+" leaflet-bar"),n=this.options;return this._zoomInButton=this._createButton(n.zoomInText,n.zoomInTitle,i+"-in",e,this._zoomIn),this._zoomOutButton=this._createButton(n.zoomOutText,n.zoomOutTitle,i+"-out",e,this._zoomOut),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),e},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(t){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(t.shiftKey?3:1))},_zoomOut:function(t){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(t.shiftKey?3:1))},_createButton:function(t,i,e,n,o){var s=G("a",e,n);return s.innerHTML=t,s.href="#",s.title=i,s.setAttribute("role","button"),s.setAttribute("aria-label",i),wt(s),mt(s,"click",Lt),mt(s,"click",o,this),mt(s,"click",this._refocusOnMap,this),s},_updateDisabled:function(){var t=this._map,i="leaflet-disabled";tt(this._zoomInButton,i),tt(this._zoomOutButton,i),(this._disabled||t._zoom===t.getMinZoom())&&Q(this._zoomOutButton,i),(this._disabled||t._zoom===t.getMaxZoom())&&Q(this._zoomInButton,i)}});be.mergeOptions({zoomControl:!0}),be.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new Ce,this.addControl(this.zoomControl))});var Se=Te.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(t){var i=G("div","leaflet-control-scale"),e=this.options;return this._addScales(e,"leaflet-control-scale-line",i),t.on(e.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,i,e){t.metric&&(this._mScale=G("div",i,e)),t.imperial&&(this._iScale=G("div",i,e))},_update:function(){var t=this._map,i=t.getSize().y/2,e=t.distance(t.containerPointToLatLng([0,i]),t.containerPointToLatLng([this.options.maxWidth,i]));this._updateScales(e)},_updateScales:function(t){this.options.metric&&t&&this._updateMetric(t),this.options.imperial&&t&&this._updateImperial(t)},_updateMetric:function(t){var i=this._getRoundNum(t),e=i<1e3?i+" m":i/1e3+" km";this._updateScale(this._mScale,e,i/t)},_updateImperial:function(t){var i,e,n,o=3.2808399*t;o>5280?(i=o/5280,e=this._getRoundNum(i),this._updateScale(this._iScale,e+" mi",e/i)):(n=this._getRoundNum(o),this._updateScale(this._iScale,n+" ft",n/o))},_updateScale:function(t,i,e){t.style.width=Math.round(this.options.maxWidth*e)+"px",t.innerHTML=i},_getRoundNum:function(t){var i=Math.pow(10,(Math.floor(t)+"").length-1),e=t/i;return e=e>=10?10:e>=5?5:e>=3?3:e>=2?2:1,i*e}}),Ze=Te.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){l(this,t),this._attributions={}},onAdd:function(t){t.attributionControl=this,this._container=G("div","leaflet-control-attribution"),wt(this._container);for(var i in t._layers)t._layers[i].getAttribution&&this.addAttribution(t._layers[i].getAttribution());return this._update(),this._container},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):this},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):this},_update:function(){if(this._map){var t=[];for(var i in this._attributions)this._attributions[i]&&t.push(i);var e=[];this.options.prefix&&e.push(this.options.prefix),t.length&&e.push(t.join(", ")),this._container.innerHTML=e.join(" | ")}}});be.mergeOptions({attributionControl:!0}),be.addInitHook(function(){this.options.attributionControl&&(new Ze).addTo(this)});Te.Layers=Me,Te.Zoom=Ce,Te.Scale=Se,Te.Attribution=Ze,ze.layers=function(t,i,e){return new Me(t,i,e)},ze.zoom=function(t){return new Ce(t)},ze.scale=function(t){return new Se(t)},ze.attribution=function(t){return new Ze(t)};var Ee=v.extend({initialize:function(t){this._map=t},enable:function(){return this._enabled?this:(this._enabled=!0,this.addHooks(),this)},disable:function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},enabled:function(){return!!this._enabled}});Ee.addTo=function(t,i){return t.addHandler(i,this),this};var ke,Be={Events:li},Ae=qi?"touchstart mousedown":"mousedown",Ie={mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},Oe={mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"},Re=ci.extend({options:{clickTolerance:3},initialize:function(t,i,e,n){l(this,n),this._element=t,this._dragStartTarget=i||t,this._preventOutline=e},enable:function(){this._enabled||(mt(this._dragStartTarget,Ae,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(Re._dragging===this&&this.finishDrag(),ft(this._dragStartTarget,Ae,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(t){if(!t._simulated&&this._enabled&&(this._moved=!1,!$(this._element,"leaflet-zoom-anim")&&!(Re._dragging||t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(Re._dragging=this,this._preventOutline&&ct(this._element),ut(),fi(),this._moving)))){this.fire("down");var i=t.touches?t.touches[0]:t,e=dt(this._element);this._startPoint=new x(i.clientX,i.clientY),this._parentScale=pt(e),mt(document,Oe[t.type],this._onMove,this),mt(document,Ie[t.type],this._onUp,this)}},_onMove:function(t){if(!t._simulated&&this._enabled)if(t.touches&&t.touches.length>1)this._moved=!0;else{var i=t.touches&&1===t.touches.length?t.touches[0]:t,e=new x(i.clientX,i.clientY)._subtract(this._startPoint);(e.x||e.y)&&(Math.abs(e.x)+Math.abs(e.y)<this.options.clickTolerance||(e.x/=this._parentScale.x,e.y/=this._parentScale.y,Pt(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=ht(this._element).subtract(e),Q(document.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,window.SVGElementInstance&&this._lastTarget instanceof SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),Q(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(e),this._moving=!0,g(this._animRequest),this._lastEvent=t,this._animRequest=f(this._updatePosition,this,!0)))}},_updatePosition:function(){var t={originalEvent:this._lastEvent};this.fire("predrag",t),at(this._element,this._newPos),this.fire("drag",t)},_onUp:function(t){!t._simulated&&this._enabled&&this.finishDrag()},finishDrag:function(){tt(document.body,"leaflet-dragging"),this._lastTarget&&(tt(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in Oe)ft(document,Oe[t],this._onMove,this),ft(document,Ie[t],this._onUp,this);lt(),gi(),this._moved&&this._moving&&(g(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1,Re._dragging=!1}}),Ne=(Object.freeze||Object)({simplify:Zt,pointToSegmentDistance:Et,closestPointOnSegment:function(t,i,e){return Dt(t,i,e)},clipSegment:It,_getEdgeIntersection:Ot,_getBitCode:Rt,_sqClosestPointOnSegment:Dt,isFlat:jt,_flat:Wt}),De=(Object.freeze||Object)({clipPolygon:Ht}),je={project:function(t){return new x(t.lng,t.lat)},unproject:function(t){return new M(t.y,t.x)},bounds:new P([-180,-90],[180,90])},We={R:6378137,R_MINOR:6356752.314245179,bounds:new P([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(t){var i=Math.PI/180,e=this.R,n=t.lat*i,o=this.R_MINOR/e,s=Math.sqrt(1-o*o),r=s*Math.sin(n),a=Math.tan(Math.PI/4-n/2)/Math.pow((1-r)/(1+r),s/2);return n=-e*Math.log(Math.max(a,1e-10)),new x(t.lng*i*e,n)},unproject:function(t){for(var i,e=180/Math.PI,n=this.R,o=this.R_MINOR/n,s=Math.sqrt(1-o*o),r=Math.exp(-t.y/n),a=Math.PI/2-2*Math.atan(r),h=0,u=.1;h<15&&Math.abs(u)>1e-7;h++)i=s*Math.sin(a),i=Math.pow((1-i)/(1+i),s/2),a+=u=Math.PI/2-2*Math.atan(r*i)-a;return new M(a*e,t.x*e/n)}},He=(Object.freeze||Object)({LonLat:je,Mercator:We,SphericalMercator:mi}),Fe=i({},pi,{code:"EPSG:3395",projection:We,transformation:function(){var t=.5/(Math.PI*We.R);return Z(t,.5,-t,.5)}()}),Ue=i({},pi,{code:"EPSG:4326",projection:je,transformation:Z(1/180,1,-1/180,.5)}),Ve=i({},di,{projection:je,transformation:Z(1,0,-1,0),scale:function(t){return Math.pow(2,t)},zoom:function(t){return Math.log(t)/Math.LN2},distance:function(t,i){var e=i.lng-t.lng,n=i.lat-t.lat;return Math.sqrt(e*e+n*n)},infinite:!0});di.Earth=pi,di.EPSG3395=Fe,di.EPSG3857=yi,di.EPSG900913=xi,di.EPSG4326=Ue,di.Simple=Ve;var qe=ci.extend({options:{pane:"overlayPane",attribution:null,bubblingMouseEvents:!0},addTo:function(t){return t.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(t){return t&&t.removeLayer(this),this},getPane:function(t){return this._map.getPane(t?this.options[t]||t:this.options.pane)},addInteractiveTarget:function(t){return this._map._targets[n(t)]=this,this},removeInteractiveTarget:function(t){return delete this._map._targets[n(t)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(t){var i=t.target;if(i.hasLayer(this)){if(this._map=i,this._zoomAnimated=i._zoomAnimated,this.getEvents){var e=this.getEvents();i.on(e,this),this.once("remove",function(){i.off(e,this)},this)}this.onAdd(i),this.getAttribution&&i.attributionControl&&i.attributionControl.addAttribution(this.getAttribution()),this.fire("add"),i.fire("layeradd",{layer:this})}}});be.include({addLayer:function(t){if(!t._layerAdd)throw new Error("The provided object is not a Layer.");var i=n(t);return this._layers[i]?this:(this._layers[i]=t,t._mapToAdd=this,t.beforeAdd&&t.beforeAdd(this),this.whenReady(t._layerAdd,t),this)},removeLayer:function(t){var i=n(t);return this._layers[i]?(this._loaded&&t.onRemove(this),t.getAttribution&&this.attributionControl&&this.attributionControl.removeAttribution(t.getAttribution()),delete this._layers[i],this._loaded&&(this.fire("layerremove",{layer:t}),t.fire("remove")),t._map=t._mapToAdd=null,this):this},hasLayer:function(t){return!!t&&n(t)in this._layers},eachLayer:function(t,i){for(var e in this._layers)t.call(i,this._layers[e]);return this},_addLayers:function(t){for(var i=0,e=(t=t?oi(t)?t:[t]:[]).length;i<e;i++)this.addLayer(t[i])},_addZoomLimit:function(t){!isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[n(t)]=t,this._updateZoomLevels())},_removeZoomLimit:function(t){var i=n(t);this._zoomBoundLayers[i]&&(delete this._zoomBoundLayers[i],this._updateZoomLevels())},_updateZoomLevels:function(){var t=1/0,i=-1/0,e=this._getZoomSpan();for(var n in this._zoomBoundLayers){var o=this._zoomBoundLayers[n].options;t=void 0===o.minZoom?t:Math.min(t,o.minZoom),i=void 0===o.maxZoom?i:Math.max(i,o.maxZoom)}this._layersMaxZoom=i===-1/0?void 0:i,this._layersMinZoom=t===1/0?void 0:t,e!==this._getZoomSpan()&&this.fire("zoomlevelschange"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}});var Ge=qe.extend({initialize:function(t,i){l(this,i),this._layers={};var e,n;if(t)for(e=0,n=t.length;e<n;e++)this.addLayer(t[e])},addLayer:function(t){var i=this.getLayerId(t);return this._layers[i]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var i=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[i]&&this._map.removeLayer(this._layers[i]),delete this._layers[i],this},hasLayer:function(t){return!!t&&(t in this._layers||this.getLayerId(t)in this._layers)},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(t){var i,e,n=Array.prototype.slice.call(arguments,1);for(i in this._layers)(e=this._layers[i])[t]&&e[t].apply(e,n);return this},onAdd:function(t){this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t)},eachLayer:function(t,i){for(var e in this._layers)t.call(i,this._layers[e]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];return this.eachLayer(t.push,t),t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return n(t)}}),Ke=Ge.extend({addLayer:function(t){return this.hasLayer(t)?this:(t.addEventParent(this),Ge.prototype.addLayer.call(this,t),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.removeEventParent(this),Ge.prototype.removeLayer.call(this,t),this.fire("layerremove",{layer:t})):this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new T;for(var i in this._layers){var e=this._layers[i];t.extend(e.getBounds?e.getBounds():e.getLatLng())}return t}}),Ye=v.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0]},initialize:function(t){l(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,i){var e=this._getIconUrl(t);if(!e){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n=this._createImg(e,i&&"IMG"===i.tagName?i:null);return this._setIconStyles(n,t),n},_setIconStyles:function(t,i){var e=this.options,n=e[i+"Size"];"number"==typeof n&&(n=[n,n]);var o=w(n),s=w("shadow"===i&&e.shadowAnchor||e.iconAnchor||o&&o.divideBy(2,!0));t.className="leaflet-marker-"+i+" "+(e.className||""),s&&(t.style.marginLeft=-s.x+"px",t.style.marginTop=-s.y+"px"),o&&(t.style.width=o.x+"px",t.style.height=o.y+"px")},_createImg:function(t,i){return i=i||document.createElement("img"),i.src=t,i},_getIconUrl:function(t){return Yi&&this.options[t+"RetinaUrl"]||this.options[t+"Url"]}}),Xe=Ye.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(t){return Xe.imagePath||(Xe.imagePath=this._detectIconPath()),(this.options.imagePath||Xe.imagePath)+Ye.prototype._getIconUrl.call(this,t)},_detectIconPath:function(){var t=G("div","leaflet-default-icon-path",document.body),i=q(t,"background-image")||q(t,"backgroundImage");return document.body.removeChild(t),i=null===i||0!==i.indexOf("url")?"":i.replace(/^url\(["']?/,"").replace(/marker-icon\.png["']?\)$/,"")}}),Je=Ee.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new Re(t,t,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),Q(t,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&tt(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(t){var i=this._marker,e=i._map,n=this._marker.options.autoPanSpeed,o=this._marker.options.autoPanPadding,s=ht(i._icon),r=e.getPixelBounds(),a=e.getPixelOrigin(),h=b(r.min._subtract(a).add(o),r.max._subtract(a).subtract(o));if(!h.contains(s)){var u=w((Math.max(h.max.x,s.x)-h.max.x)/(r.max.x-h.max.x)-(Math.min(h.min.x,s.x)-h.min.x)/(r.min.x-h.min.x),(Math.max(h.max.y,s.y)-h.max.y)/(r.max.y-h.max.y)-(Math.min(h.min.y,s.y)-h.min.y)/(r.min.y-h.min.y)).multiplyBy(n);e.panBy(u,{animate:!1}),this._draggable._newPos._add(u),this._draggable._startPos._add(u),at(i._icon,this._draggable._newPos),this._onDrag(t),this._panRequest=f(this._adjustPan.bind(this,t))}},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup().fire("movestart").fire("dragstart")},_onPreDrag:function(t){this._marker.options.autoPan&&(g(this._panRequest),this._panRequest=f(this._adjustPan.bind(this,t)))},_onDrag:function(t){var i=this._marker,e=i._shadow,n=ht(i._icon),o=i._map.layerPointToLatLng(n);e&&at(e,n),i._latlng=o,t.latlng=o,t.oldLatLng=this._oldLatLng,i.fire("move",t).fire("drag",t)},_onDragEnd:function(t){g(this._panRequest),delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",t)}}),$e=qe.extend({options:{icon:new Xe,interactive:!0,keyboard:!0,title:"",alt:"",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",bubblingMouseEvents:!1,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10},initialize:function(t,i){l(this,i),this._latlng=C(t)},onAdd:function(t){this._zoomAnimated=this._zoomAnimated&&t.options.markerZoomAnimation,this._zoomAnimated&&t.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(t){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&t.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(t){var i=this._latlng;return this._latlng=C(t),this.update(),this.fire("move",{oldLatLng:i,latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update()},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){if(this._icon&&this._map){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,i="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),e=t.icon.createIcon(this._icon),n=!1;e!==this._icon&&(this._icon&&this._removeIcon(),n=!0,t.title&&(e.title=t.title),"IMG"===e.tagName&&(e.alt=t.alt||"")),Q(e,i),t.keyboard&&(e.tabIndex="0"),this._icon=e,t.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex});var o=t.icon.createShadow(this._shadow),s=!1;o!==this._shadow&&(this._removeShadow(),s=!0),o&&(Q(o,i),o.alt=""),this._shadow=o,t.opacity<1&&this._updateOpacity(),n&&this.getPane().appendChild(this._icon),this._initInteraction(),o&&s&&this.getPane("shadowPane").appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),K(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&K(this._shadow),this._shadow=null},_setPos:function(t){at(this._icon,t),this._shadow&&at(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(i)},_initInteraction:function(){if(this.options.interactive&&(Q(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),Je)){var t=this.options.draggable;this.dragging&&(t=this.dragging.enabled(),this.dragging.disable()),this.dragging=new Je(this),t&&this.dragging.enable()}},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var t=this.options.opacity;nt(this._icon,t),this._shadow&&nt(this._shadow,t)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}}),Qe=qe.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(t){this._renderer=t.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(t){return l(this,t),this._renderer&&this._renderer._updateStyle(this),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+this._renderer.options.tolerance}}),tn=Qe.extend({options:{fill:!0,radius:10},initialize:function(t,i){l(this,i),this._latlng=C(t),this._radius=this.options.radius},setLatLng:function(t){return this._latlng=C(t),this.redraw(),this.fire("move",{latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius},setStyle:function(t){var i=t&&t.radius||this._radius;return Qe.prototype.setStyle.call(this,t),this.setRadius(i),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var t=this._radius,i=this._radiusY||t,e=this._clickTolerance(),n=[t+e,i+e];this._pxBounds=new P(this._point.subtract(n),this._point.add(n))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(t){return t.distanceTo(this._point)<=this._radius+this._clickTolerance()}}),en=tn.extend({initialize:function(t,e,n){if("number"==typeof e&&(e=i({},n,{radius:e})),l(this,e),this._latlng=C(t),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(t){return this._mRadius=t,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var t=[this._radius,this._radiusY||this._radius];return new T(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))},setStyle:Qe.prototype.setStyle,_project:function(){var t=this._latlng.lng,i=this._latlng.lat,e=this._map,n=e.options.crs;if(n.distance===pi.distance){var o=Math.PI/180,s=this._mRadius/pi.R/o,r=e.project([i+s,t]),a=e.project([i-s,t]),h=r.add(a).divideBy(2),u=e.unproject(h).lat,l=Math.acos((Math.cos(s*o)-Math.sin(i*o)*Math.sin(u*o))/(Math.cos(i*o)*Math.cos(u*o)))/o;(isNaN(l)||0===l)&&(l=s/Math.cos(Math.PI/180*i)),this._point=h.subtract(e.getPixelOrigin()),this._radius=isNaN(l)?0:h.x-e.project([u,t-l]).x,this._radiusY=h.y-r.y}else{var c=n.unproject(n.project(this._latlng).subtract([this._mRadius,0]));this._point=e.latLngToLayerPoint(this._latlng),this._radius=this._point.x-e.latLngToLayerPoint(c).x}this._updateBounds()}}),nn=Qe.extend({options:{smoothFactor:1,noClip:!1},initialize:function(t,i){l(this,i),this._setLatLngs(t)},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(t){for(var i,e,n=1/0,o=null,s=Dt,r=0,a=this._parts.length;r<a;r++)for(var h=this._parts[r],u=1,l=h.length;u<l;u++){var c=s(t,i=h[u-1],e=h[u],!0);c<n&&(n=c,o=s(t,i,e))}return o&&(o.distance=Math.sqrt(n)),o},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,i,e,n,o,s,r,a=this._rings[0],h=a.length;if(!h)return null;for(t=0,i=0;t<h-1;t++)i+=a[t].distanceTo(a[t+1])/2;if(0===i)return this._map.layerPointToLatLng(a[0]);for(t=0,n=0;t<h-1;t++)if(o=a[t],s=a[t+1],e=o.distanceTo(s),(n+=e)>i)return r=(n-i)/e,this._map.layerPointToLatLng([s.x-r*(s.x-o.x),s.y-r*(s.y-o.y)])},getBounds:function(){return this._bounds},addLatLng:function(t,i){return i=i||this._defaultShape(),t=C(t),i.push(t),this._bounds.extend(t),this.redraw()},_setLatLngs:function(t){this._bounds=new T,this._latlngs=this._convertLatLngs(t)},_defaultShape:function(){return jt(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(t){for(var i=[],e=jt(t),n=0,o=t.length;n<o;n++)e?(i[n]=C(t[n]),this._bounds.extend(i[n])):i[n]=this._convertLatLngs(t[n]);return i},_project:function(){var t=new P;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,t);var i=this._clickTolerance(),e=new x(i,i);this._bounds.isValid()&&t.isValid()&&(t.min._subtract(e),t.max._add(e),this._pxBounds=t)},_projectLatlngs:function(t,i,e){var n,o,s=t[0]instanceof M,r=t.length;if(s){for(o=[],n=0;n<r;n++)o[n]=this._map.latLngToLayerPoint(t[n]),e.extend(o[n]);i.push(o)}else for(n=0;n<r;n++)this._projectLatlngs(t[n],i,e)},_clipPoints:function(){var t=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else{var i,e,n,o,s,r,a,h=this._parts;for(i=0,n=0,o=this._rings.length;i<o;i++)for(e=0,s=(a=this._rings[i]).length;e<s-1;e++)(r=It(a[e],a[e+1],t,e,!0))&&(h[n]=h[n]||[],h[n].push(r[0]),r[1]===a[e+1]&&e!==s-2||(h[n].push(r[1]),n++))}},_simplifyPoints:function(){for(var t=this._parts,i=this.options.smoothFactor,e=0,n=t.length;e<n;e++)t[e]=Zt(t[e],i)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(t,i){var e,n,o,s,r,a,h=this._clickTolerance();if(!this._pxBounds||!this._pxBounds.contains(t))return!1;for(e=0,s=this._parts.length;e<s;e++)for(n=0,o=(r=(a=this._parts[e]).length)-1;n<r;o=n++)if((i||0!==n)&&Et(t,a[o],a[n])<=h)return!0;return!1}});nn._flat=Wt;var on=nn.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,i,e,n,o,s,r,a,h,u=this._rings[0],l=u.length;if(!l)return null;for(s=r=a=0,t=0,i=l-1;t<l;i=t++)e=u[t],n=u[i],o=e.y*n.x-n.y*e.x,r+=(e.x+n.x)*o,a+=(e.y+n.y)*o,s+=3*o;return h=0===s?u[0]:[r/s,a/s],this._map.layerPointToLatLng(h)},_convertLatLngs:function(t){var i=nn.prototype._convertLatLngs.call(this,t),e=i.length;return e>=2&&i[0]instanceof M&&i[0].equals(i[e-1])&&i.pop(),i},_setLatLngs:function(t){nn.prototype._setLatLngs.call(this,t),jt(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return jt(this._latlngs[0])?this._latlngs[0]:this._latlngs[0][0]},_clipPoints:function(){var t=this._renderer._bounds,i=this.options.weight,e=new x(i,i);if(t=new P(t.min.subtract(e),t.max.add(e)),this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var n,o=0,s=this._rings.length;o<s;o++)(n=Ht(this._rings[o],t,!0)).length&&this._parts.push(n)},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(t){var i,e,n,o,s,r,a,h,u=!1;if(!this._pxBounds||!this._pxBounds.contains(t))return!1;for(o=0,a=this._parts.length;o<a;o++)for(s=0,r=(h=(i=this._parts[o]).length)-1;s<h;r=s++)e=i[s],n=i[r],e.y>t.y!=n.y>t.y&&t.x<(n.x-e.x)*(t.y-e.y)/(n.y-e.y)+e.x&&(u=!u);return u||nn.prototype._containsPoint.call(this,t,!0)}}),sn=Ke.extend({initialize:function(t,i){l(this,i),this._layers={},t&&this.addData(t)},addData:function(t){var i,e,n,o=oi(t)?t:t.features;if(o){for(i=0,e=o.length;i<e;i++)((n=o[i]).geometries||n.geometry||n.features||n.coordinates)&&this.addData(n);return this}var s=this.options;if(s.filter&&!s.filter(t))return this;var r=Ft(t,s);return r?(r.feature=Yt(t),r.defaultOptions=r.options,this.resetStyle(r),s.onEachFeature&&s.onEachFeature(t,r),this.addLayer(r)):this},resetStyle:function(t){return t.options=i({},t.defaultOptions),this._setLayerStyle(t,this.options.style),this},setStyle:function(t){return this.eachLayer(function(i){this._setLayerStyle(i,t)},this)},_setLayerStyle:function(t,i){"function"==typeof i&&(i=i(t.feature)),t.setStyle&&t.setStyle(i)}}),rn={toGeoJSON:function(t){return Kt(this,{type:"Point",coordinates:qt(this.getLatLng(),t)})}};$e.include(rn),en.include(rn),tn.include(rn),nn.include({toGeoJSON:function(t){var i=!jt(this._latlngs),e=Gt(this._latlngs,i?1:0,!1,t);return Kt(this,{type:(i?"Multi":"")+"LineString",coordinates:e})}}),on.include({toGeoJSON:function(t){var i=!jt(this._latlngs),e=i&&!jt(this._latlngs[0]),n=Gt(this._latlngs,e?2:i?1:0,!0,t);return i||(n=[n]),Kt(this,{type:(e?"Multi":"")+"Polygon",coordinates:n})}}),Ge.include({toMultiPoint:function(t){var i=[];return this.eachLayer(function(e){i.push(e.toGeoJSON(t).geometry.coordinates)}),Kt(this,{type:"MultiPoint",coordinates:i})},toGeoJSON:function(t){var i=this.feature&&this.feature.geometry&&this.feature.geometry.type;if("MultiPoint"===i)return this.toMultiPoint(t);var e="GeometryCollection"===i,n=[];return this.eachLayer(function(i){if(i.toGeoJSON){var o=i.toGeoJSON(t);if(e)n.push(o.geometry);else{var s=Yt(o);"FeatureCollection"===s.type?n.push.apply(n,s.features):n.push(s)}}}),e?Kt(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}});var an=Xt,hn=qe.extend({options:{opacity:1,alt:"",interactive:!1,crossOrigin:!1,errorOverlayUrl:"",zIndex:1,className:""},initialize:function(t,i,e){this._url=t,this._bounds=z(i),l(this,e)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(Q(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){K(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(t){return this.options.opacity=t,this._image&&this._updateOpacity(),this},setStyle:function(t){return t.opacity&&this.setOpacity(t.opacity),this},bringToFront:function(){return this._map&&X(this._image),this},bringToBack:function(){return this._map&&J(this._image),this},setUrl:function(t){return this._url=t,this._image&&(this._image.src=t),this},setBounds:function(t){return this._bounds=z(t),this._map&&this._reset(),this},getEvents:function(){var t={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var t="IMG"===this._url.tagName,i=this._image=t?this._url:G("img");Q(i,"leaflet-image-layer"),this._zoomAnimated&&Q(i,"leaflet-zoom-animated"),this.options.className&&Q(i,this.options.className),i.onselectstart=r,i.onmousemove=r,i.onload=e(this.fire,this,"load"),i.onerror=e(this._overlayOnError,this,"error"),(this.options.crossOrigin||""===this.options.crossOrigin)&&(i.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),this.options.zIndex&&this._updateZIndex(),t?this._url=i.src:(i.src=this._url,i.alt=this.options.alt)},_animateZoom:function(t){var i=this._map.getZoomScale(t.zoom),e=this._map._latLngBoundsToNewLayerBounds(this._bounds,t.zoom,t.center).min;rt(this._image,e,i)},_reset:function(){var t=this._image,i=new P(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),e=i.getSize();at(t,i.min),t.style.width=e.x+"px",t.style.height=e.y+"px"},_updateOpacity:function(){nt(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire("error");var t=this.options.errorOverlayUrl;t&&this._url!==t&&(this._url=t,this._image.src=t)}}),un=hn.extend({options:{autoplay:!0,loop:!0},_initImage:function(){var t="VIDEO"===this._url.tagName,i=this._image=t?this._url:G("video");if(Q(i,"leaflet-image-layer"),this._zoomAnimated&&Q(i,"leaflet-zoom-animated"),i.onselectstart=r,i.onmousemove=r,i.onloadeddata=e(this.fire,this,"load"),t){for(var n=i.getElementsByTagName("source"),o=[],s=0;s<n.length;s++)o.push(n[s].src);this._url=n.length>0?o:[i.src]}else{oi(this._url)||(this._url=[this._url]),i.autoplay=!!this.options.autoplay,i.loop=!!this.options.loop;for(var a=0;a<this._url.length;a++){var h=G("source");h.src=this._url[a],i.appendChild(h)}}}}),ln=qe.extend({options:{offset:[0,7],className:"",pane:"popupPane"},initialize:function(t,i){l(this,t),this._source=i},onAdd:function(t){this._zoomAnimated=t._zoomAnimated,this._container||this._initLayout(),t._fadeAnimated&&nt(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),t._fadeAnimated&&nt(this._container,1),this.bringToFront()},onRemove:function(t){t._fadeAnimated?(nt(this._container,0),this._removeTimeout=setTimeout(e(K,void 0,this._container),200)):K(this._container)},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=C(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var t={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&X(this._container),this},bringToBack:function(){return this._map&&J(this._container),this},_updateContent:function(){if(this._content){var t=this._contentNode,i="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof i)t.innerHTML=i;else{for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(i)}this.fire("contentupdate")}},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),i=w(this.options.offset),e=this._getAnchor();this._zoomAnimated?at(this._container,t.add(e)):i=i.add(t).add(e);var n=this._containerBottom=-i.y,o=this._containerLeft=-Math.round(this._containerWidth/2)+i.x;this._container.style.bottom=n+"px",this._container.style.left=o+"px"}},_getAnchor:function(){return[0,0]}}),cn=ln.extend({options:{maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:""},openOn:function(t){return t.openPopup(this),this},onAdd:function(t){ln.prototype.onAdd.call(this,t),t.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof Qe||this._source.on("preclick",yt))},onRemove:function(t){ln.prototype.onRemove.call(this,t),t.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof Qe||this._source.off("preclick",yt))},getEvents:function(){var t=ln.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t="leaflet-popup",i=this._container=G("div",t+" "+(this.options.className||"")+" leaflet-zoom-animated"),e=this._wrapper=G("div",t+"-content-wrapper",i);if(this._contentNode=G("div",t+"-content",e),wt(e),xt(this._contentNode),mt(e,"contextmenu",yt),this._tipContainer=G("div",t+"-tip-container",i),this._tip=G("div",t+"-tip",this._tipContainer),this.options.closeButton){var n=this._closeButton=G("a",t+"-close-button",i);n.href="#close",n.innerHTML="&#215;",mt(n,"click",this._onCloseButtonClick,this)}},_updateLayout:function(){var t=this._contentNode,i=t.style;i.width="",i.whiteSpace="nowrap";var e=t.offsetWidth;e=Math.min(e,this.options.maxWidth),e=Math.max(e,this.options.minWidth),i.width=e+1+"px",i.whiteSpace="",i.height="";var n=t.offsetHeight,o=this.options.maxHeight;o&&n>o?(i.height=o+"px",Q(t,"leaflet-popup-scrolled")):tt(t,"leaflet-popup-scrolled"),this._containerWidth=this._container.offsetWidth},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center),e=this._getAnchor();at(this._container,i.add(e))},_adjustPan:function(){if(this.options.autoPan){this._map._panAnim&&this._map._panAnim.stop();var t=this._map,i=parseInt(q(this._container,"marginBottom"),10)||0,e=this._container.offsetHeight+i,n=this._containerWidth,o=new x(this._containerLeft,-e-this._containerBottom);o._add(ht(this._container));var s=t.layerPointToContainerPoint(o),r=w(this.options.autoPanPadding),a=w(this.options.autoPanPaddingTopLeft||r),h=w(this.options.autoPanPaddingBottomRight||r),u=t.getSize(),l=0,c=0;s.x+n+h.x>u.x&&(l=s.x+n-u.x+h.x),s.x-l-a.x<0&&(l=s.x-a.x),s.y+e+h.y>u.y&&(c=s.y+e-u.y+h.y),s.y-c-a.y<0&&(c=s.y-a.y),(l||c)&&t.fire("autopanstart").panBy([l,c])}},_onCloseButtonClick:function(t){this._close(),Lt(t)},_getAnchor:function(){return w(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}});be.mergeOptions({closePopupOnClick:!0}),be.include({openPopup:function(t,i,e){return t instanceof cn||(t=new cn(e).setContent(t)),i&&t.setLatLng(i),this.hasLayer(t)?this:(this._popup&&this._popup.options.autoClose&&this.closePopup(),this._popup=t,this.addLayer(t))},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&this.removeLayer(t),this}}),qe.include({bindPopup:function(t,i){return t instanceof cn?(l(t,i),this._popup=t,t._source=this):(this._popup&&!i||(this._popup=new cn(i,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(t,i){if(t instanceof qe||(i=t,t=this),t instanceof Ke)for(var e in this._layers){t=this._layers[e];break}return i||(i=t.getCenter?t.getCenter():t.getLatLng()),this._popup&&this._map&&(this._popup._source=t,this._popup.update(),this._map.openPopup(this._popup,i)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(t){return this._popup&&(this._popup._map?this.closePopup():this.openPopup(t)),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},getPopup:function(){return this._popup},_openPopup:function(t){var i=t.layer||t.target;this._popup&&this._map&&(Lt(t),i instanceof Qe?this.openPopup(t.layer||t.target,t.latlng):this._map.hasLayer(this._popup)&&this._popup._source===i?this.closePopup():this.openPopup(i,t.latlng))},_movePopup:function(t){this._popup.setLatLng(t.latlng)},_onKeyPress:function(t){13===t.originalEvent.keyCode&&this._openPopup(t)}});var _n=ln.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,interactive:!1,opacity:.9},onAdd:function(t){ln.prototype.onAdd.call(this,t),this.setOpacity(this.options.opacity),t.fire("tooltipopen",{tooltip:this}),this._source&&this._source.fire("tooltipopen",{tooltip:this},!0)},onRemove:function(t){ln.prototype.onRemove.call(this,t),t.fire("tooltipclose",{tooltip:this}),this._source&&this._source.fire("tooltipclose",{tooltip:this},!0)},getEvents:function(){var t=ln.prototype.getEvents.call(this);return qi&&!this.options.permanent&&(t.preclick=this._close),t},_close:function(){this._map&&this._map.closeTooltip(this)},_initLayout:function(){var t="leaflet-tooltip "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide");this._contentNode=this._container=G("div",t)},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(t){var i=this._map,e=this._container,n=i.latLngToContainerPoint(i.getCenter()),o=i.layerPointToContainerPoint(t),s=this.options.direction,r=e.offsetWidth,a=e.offsetHeight,h=w(this.options.offset),u=this._getAnchor();"top"===s?t=t.add(w(-r/2+h.x,-a+h.y+u.y,!0)):"bottom"===s?t=t.subtract(w(r/2-h.x,-h.y,!0)):"center"===s?t=t.subtract(w(r/2+h.x,a/2-u.y+h.y,!0)):"right"===s||"auto"===s&&o.x<n.x?(s="right",t=t.add(w(h.x+u.x,u.y-a/2+h.y,!0))):(s="left",t=t.subtract(w(r+u.x-h.x,a/2-u.y-h.y,!0))),tt(e,"leaflet-tooltip-right"),tt(e,"leaflet-tooltip-left"),tt(e,"leaflet-tooltip-top"),tt(e,"leaflet-tooltip-bottom"),Q(e,"leaflet-tooltip-"+s),at(e,t)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},setOpacity:function(t){this.options.opacity=t,this._container&&nt(this._container,t)},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPosition(i)},_getAnchor:function(){return w(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}});be.include({openTooltip:function(t,i,e){return t instanceof _n||(t=new _n(e).setContent(t)),i&&t.setLatLng(i),this.hasLayer(t)?this:this.addLayer(t)},closeTooltip:function(t){return t&&this.removeLayer(t),this}}),qe.include({bindTooltip:function(t,i){return t instanceof _n?(l(t,i),this._tooltip=t,t._source=this):(this._tooltip&&!i||(this._tooltip=new _n(i,this)),this._tooltip.setContent(t)),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(t){if(t||!this._tooltipHandlersAdded){var i=t?"off":"on",e={remove:this.closeTooltip,move:this._moveTooltip};this._tooltip.options.permanent?e.add=this._openTooltip:(e.mouseover=this._openTooltip,e.mouseout=this.closeTooltip,this._tooltip.options.sticky&&(e.mousemove=this._moveTooltip),qi&&(e.click=this._openTooltip)),this[i](e),this._tooltipHandlersAdded=!t}},openTooltip:function(t,i){if(t instanceof qe||(i=t,t=this),t instanceof Ke)for(var e in this._layers){t=this._layers[e];break}return i||(i=t.getCenter?t.getCenter():t.getLatLng()),this._tooltip&&this._map&&(this._tooltip._source=t,this._tooltip.update(),this._map.openTooltip(this._tooltip,i),this._tooltip.options.interactive&&this._tooltip._container&&(Q(this._tooltip._container,"leaflet-clickable"),this.addInteractiveTarget(this._tooltip._container))),this},closeTooltip:function(){return this._tooltip&&(this._tooltip._close(),this._tooltip.options.interactive&&this._tooltip._container&&(tt(this._tooltip._container,"leaflet-clickable"),this.removeInteractiveTarget(this._tooltip._container))),this},toggleTooltip:function(t){return this._tooltip&&(this._tooltip._map?this.closeTooltip():this.openTooltip(t)),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(t){return this._tooltip&&this._tooltip.setContent(t),this},getTooltip:function(){return this._tooltip},_openTooltip:function(t){var i=t.layer||t.target;this._tooltip&&this._map&&this.openTooltip(i,this._tooltip.options.sticky?t.latlng:void 0)},_moveTooltip:function(t){var i,e,n=t.latlng;this._tooltip.options.sticky&&t.originalEvent&&(i=this._map.mouseEventToContainerPoint(t.originalEvent),e=this._map.containerPointToLayerPoint(i),n=this._map.layerPointToLatLng(e)),this._tooltip.setLatLng(n)}});var dn=Ye.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:document.createElement("div"),e=this.options;if(i.innerHTML=!1!==e.html?e.html:"",e.bgPos){var n=w(e.bgPos);i.style.backgroundPosition=-n.x+"px "+-n.y+"px"}return this._setIconStyles(i,"icon"),i},createShadow:function(){return null}});Ye.Default=Xe;var pn=qe.extend({options:{tileSize:256,opacity:1,updateWhenIdle:Wi,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(t){l(this,t)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView(),this._update()},beforeAdd:function(t){t._addZoomLimit(this)},onRemove:function(t){this._removeAllTiles(),K(this._container),t._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(X(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(J(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){return this._map&&(this._removeAllTiles(),this._update()),this},getEvents:function(){var t={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=o(this._onMoveEnd,this.options.updateInterval,this)),t.move=this._onMove),this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},createTile:function(){return document.createElement("div")},getTileSize:function(){var t=this.options.tileSize;return t instanceof x?t:new x(t,t)},_updateZIndex:function(){this._container&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t){for(var i,e=this.getPane().children,n=-t(-1/0,1/0),o=0,s=e.length;o<s;o++)i=e[o].style.zIndex,e[o]!==this._container&&i&&(n=t(n,+i));isFinite(n)&&(this.options.zIndex=n+t(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!Li){nt(this._container,this.options.opacity);var t=+new Date,i=!1,e=!1;for(var n in this._tiles){var o=this._tiles[n];if(o.current&&o.loaded){var s=Math.min(1,(t-o.loaded)/200);nt(o.el,s),s<1?i=!0:(o.active?e=!0:this._onOpaqueTile(o),o.active=!0)}}e&&!this._noPrune&&this._pruneTiles(),i&&(g(this._fadeFrame),this._fadeFrame=f(this._updateOpacity,this))}},_onOpaqueTile:r,_initContainer:function(){this._container||(this._container=G("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var t=this._tileZoom,i=this.options.maxZoom;if(void 0!==t){for(var e in this._levels)this._levels[e].el.children.length||e===t?(this._levels[e].el.style.zIndex=i-Math.abs(t-e),this._onUpdateLevel(e)):(K(this._levels[e].el),this._removeTilesAtZoom(e),this._onRemoveLevel(e),delete this._levels[e]);var n=this._levels[t],o=this._map;return n||((n=this._levels[t]={}).el=G("div","leaflet-tile-container leaflet-zoom-animated",this._container),n.el.style.zIndex=i,n.origin=o.project(o.unproject(o.getPixelOrigin()),t).round(),n.zoom=t,this._setZoomTransform(n,o.getCenter(),o.getZoom()),n.el.offsetWidth,this._onCreateLevel(n)),this._level=n,n}},_onUpdateLevel:r,_onRemoveLevel:r,_onCreateLevel:r,_pruneTiles:function(){if(this._map){var t,i,e=this._map.getZoom();if(e>this.options.maxZoom||e<this.options.minZoom)this._removeAllTiles();else{for(t in this._tiles)(i=this._tiles[t]).retain=i.current;for(t in this._tiles)if((i=this._tiles[t]).current&&!i.active){var n=i.coords;this._retainParent(n.x,n.y,n.z,n.z-5)||this._retainChildren(n.x,n.y,n.z,n.z+2)}for(t in this._tiles)this._tiles[t].retain||this._removeTile(t)}}},_removeTilesAtZoom:function(t){for(var i in this._tiles)this._tiles[i].coords.z===t&&this._removeTile(i)},_removeAllTiles:function(){for(var t in this._tiles)this._removeTile(t)},_invalidateAll:function(){for(var t in this._levels)K(this._levels[t].el),this._onRemoveLevel(t),delete this._levels[t];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(t,i,e,n){var o=Math.floor(t/2),s=Math.floor(i/2),r=e-1,a=new x(+o,+s);a.z=+r;var h=this._tileCoordsToKey(a),u=this._tiles[h];return u&&u.active?(u.retain=!0,!0):(u&&u.loaded&&(u.retain=!0),r>n&&this._retainParent(o,s,r,n))},_retainChildren:function(t,i,e,n){for(var o=2*t;o<2*t+2;o++)for(var s=2*i;s<2*i+2;s++){var r=new x(o,s);r.z=e+1;var a=this._tileCoordsToKey(r),h=this._tiles[a];h&&h.active?h.retain=!0:(h&&h.loaded&&(h.retain=!0),e+1<n&&this._retainChildren(o,s,e+1,n))}},_resetView:function(t){var i=t&&(t.pinch||t.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),i,i)},_animateZoom:function(t){this._setView(t.center,t.zoom,!0,t.noUpdate)},_clampZoom:function(t){var i=this.options;return void 0!==i.minNativeZoom&&t<i.minNativeZoom?i.minNativeZoom:void 0!==i.maxNativeZoom&&i.maxNativeZoom<t?i.maxNativeZoom:t},_setView:function(t,i,e,n){var o=this._clampZoom(Math.round(i));(void 0!==this.options.maxZoom&&o>this.options.maxZoom||void 0!==this.options.minZoom&&o<this.options.minZoom)&&(o=void 0);var s=this.options.updateWhenZooming&&o!==this._tileZoom;n&&!s||(this._tileZoom=o,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==o&&this._update(t),e||this._pruneTiles(),this._noPrune=!!e),this._setZoomTransforms(t,i)},_setZoomTransforms:function(t,i){for(var e in this._levels)this._setZoomTransform(this._levels[e],t,i)},_setZoomTransform:function(t,i,e){var n=this._map.getZoomScale(e,t.zoom),o=t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(i,e)).round();ji?rt(t.el,o,n):at(t.el,o)},_resetGrid:function(){var t=this._map,i=t.options.crs,e=this._tileSize=this.getTileSize(),n=this._tileZoom,o=this._map.getPixelWorldBounds(this._tileZoom);o&&(this._globalTileRange=this._pxBoundsToTileRange(o)),this._wrapX=i.wrapLng&&!this.options.noWrap&&[Math.floor(t.project([0,i.wrapLng[0]],n).x/e.x),Math.ceil(t.project([0,i.wrapLng[1]],n).x/e.y)],this._wrapY=i.wrapLat&&!this.options.noWrap&&[Math.floor(t.project([i.wrapLat[0],0],n).y/e.x),Math.ceil(t.project([i.wrapLat[1],0],n).y/e.y)]},_onMoveEnd:function(){this._map&&!this._map._animatingZoom&&this._update()},_getTiledPixelBounds:function(t){var i=this._map,e=i._animatingZoom?Math.max(i._animateToZoom,i.getZoom()):i.getZoom(),n=i.getZoomScale(e,this._tileZoom),o=i.project(t,this._tileZoom).floor(),s=i.getSize().divideBy(2*n);return new P(o.subtract(s),o.add(s))},_update:function(t){var i=this._map;if(i){var e=this._clampZoom(i.getZoom());if(void 0===t&&(t=i.getCenter()),void 0!==this._tileZoom){var n=this._getTiledPixelBounds(t),o=this._pxBoundsToTileRange(n),s=o.getCenter(),r=[],a=this.options.keepBuffer,h=new P(o.getBottomLeft().subtract([a,-a]),o.getTopRight().add([a,-a]));if(!(isFinite(o.min.x)&&isFinite(o.min.y)&&isFinite(o.max.x)&&isFinite(o.max.y)))throw new Error("Attempted to load an infinite number of tiles");for(var u in this._tiles){var l=this._tiles[u].coords;l.z===this._tileZoom&&h.contains(new x(l.x,l.y))||(this._tiles[u].current=!1)}if(Math.abs(e-this._tileZoom)>1)this._setView(t,e);else{for(var c=o.min.y;c<=o.max.y;c++)for(var _=o.min.x;_<=o.max.x;_++){var d=new x(_,c);if(d.z=this._tileZoom,this._isValidTile(d)){var p=this._tiles[this._tileCoordsToKey(d)];p?p.current=!0:r.push(d)}}if(r.sort(function(t,i){return t.distanceTo(s)-i.distanceTo(s)}),0!==r.length){this._loading||(this._loading=!0,this.fire("loading"));var m=document.createDocumentFragment();for(_=0;_<r.length;_++)this._addTile(r[_],m);this._level.el.appendChild(m)}}}}},_isValidTile:function(t){var i=this._map.options.crs;if(!i.infinite){var e=this._globalTileRange;if(!i.wrapLng&&(t.x<e.min.x||t.x>e.max.x)||!i.wrapLat&&(t.y<e.min.y||t.y>e.max.y))return!1}if(!this.options.bounds)return!0;var n=this._tileCoordsToBounds(t);return z(this.options.bounds).overlaps(n)},_keyToBounds:function(t){return this._tileCoordsToBounds(this._keyToTileCoords(t))},_tileCoordsToNwSe:function(t){var i=this._map,e=this.getTileSize(),n=t.scaleBy(e),o=n.add(e);return[i.unproject(n,t.z),i.unproject(o,t.z)]},_tileCoordsToBounds:function(t){var i=this._tileCoordsToNwSe(t),e=new T(i[0],i[1]);return this.options.noWrap||(e=this._map.wrapLatLngBounds(e)),e},_tileCoordsToKey:function(t){return t.x+":"+t.y+":"+t.z},_keyToTileCoords:function(t){var i=t.split(":"),e=new x(+i[0],+i[1]);return e.z=+i[2],e},_removeTile:function(t){var i=this._tiles[t];i&&(K(i.el),delete this._tiles[t],this.fire("tileunload",{tile:i.el,coords:this._keyToTileCoords(t)}))},_initTile:function(t){Q(t,"leaflet-tile");var i=this.getTileSize();t.style.width=i.x+"px",t.style.height=i.y+"px",t.onselectstart=r,t.onmousemove=r,Li&&this.options.opacity<1&&nt(t,this.options.opacity),zi&&!Mi&&(t.style.WebkitBackfaceVisibility="hidden")},_addTile:function(t,i){var n=this._getTilePos(t),o=this._tileCoordsToKey(t),s=this.createTile(this._wrapCoords(t),e(this._tileReady,this,t));this._initTile(s),this.createTile.length<2&&f(e(this._tileReady,this,t,null,s)),at(s,n),this._tiles[o]={el:s,coords:t,current:!0},i.appendChild(s),this.fire("tileloadstart",{tile:s,coords:t})},_tileReady:function(t,i,n){i&&this.fire("tileerror",{error:i,tile:n,coords:t});var o=this._tileCoordsToKey(t);(n=this._tiles[o])&&(n.loaded=+new Date,this._map._fadeAnimated?(nt(n.el,0),g(this._fadeFrame),this._fadeFrame=f(this._updateOpacity,this)):(n.active=!0,this._pruneTiles()),i||(Q(n.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:n.el,coords:t})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),Li||!this._map._fadeAnimated?f(this._pruneTiles,this):setTimeout(e(this._pruneTiles,this),250)))},_getTilePos:function(t){return t.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(t){var i=new x(this._wrapX?s(t.x,this._wrapX):t.x,this._wrapY?s(t.y,this._wrapY):t.y);return i.z=t.z,i},_pxBoundsToTileRange:function(t){var i=this.getTileSize();return new P(t.min.unscaleBy(i).floor(),t.max.unscaleBy(i).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var t in this._tiles)if(!this._tiles[t].loaded)return!1;return!0}}),mn=pn.extend({options:{minZoom:0,maxZoom:18,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1},initialize:function(t,i){this._url=t,(i=l(this,i)).detectRetina&&Yi&&i.maxZoom>0&&(i.tileSize=Math.floor(i.tileSize/2),i.zoomReverse?(i.zoomOffset--,i.minZoom++):(i.zoomOffset++,i.maxZoom--),i.minZoom=Math.max(0,i.minZoom)),"string"==typeof i.subdomains&&(i.subdomains=i.subdomains.split("")),zi||this.on("tileunload",this._onTileRemove)},setUrl:function(t,i){return this._url===t&&void 0===i&&(i=!0),this._url=t,i||this.redraw(),this},createTile:function(t,i){var n=document.createElement("img");return mt(n,"load",e(this._tileOnLoad,this,i,n)),mt(n,"error",e(this._tileOnError,this,i,n)),(this.options.crossOrigin||""===this.options.crossOrigin)&&(n.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),n.alt="",n.setAttribute("role","presentation"),n.src=this.getTileUrl(t),n},getTileUrl:function(t){var e={r:Yi?"@2x":"",s:this._getSubdomain(t),x:t.x,y:t.y,z:this._getZoomForUrl()};if(this._map&&!this._map.options.crs.infinite){var n=this._globalTileRange.max.y-t.y;this.options.tms&&(e.y=n),e["-y"]=n}return _(this._url,i(e,this.options))},_tileOnLoad:function(t,i){Li?setTimeout(e(t,this,null,i),0):t(null,i)},_tileOnError:function(t,i,e){var n=this.options.errorTileUrl;n&&i.getAttribute("src")!==n&&(i.src=n),t(e,i)},_onTileRemove:function(t){t.tile.onload=null},_getZoomForUrl:function(){var t=this._tileZoom,i=this.options.maxZoom,e=this.options.zoomReverse,n=this.options.zoomOffset;return e&&(t=i-t),t+n},_getSubdomain:function(t){var i=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[i]},_abortLoading:function(){var t,i;for(t in this._tiles)this._tiles[t].coords.z!==this._tileZoom&&((i=this._tiles[t].el).onload=r,i.onerror=r,i.complete||(i.src=si,K(i),delete this._tiles[t]))},_removeTile:function(t){var i=this._tiles[t];if(i)return Si||i.el.setAttribute("src",si),pn.prototype._removeTile.call(this,t)},_tileReady:function(t,i,e){if(this._map&&(!e||e.getAttribute("src")!==si))return pn.prototype._tileReady.call(this,t,i,e)}}),fn=mn.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(t,e){this._url=t;var n=i({},this.defaultWmsParams);for(var o in e)o in this.options||(n[o]=e[o]);var s=(e=l(this,e)).detectRetina&&Yi?2:1,r=this.getTileSize();n.width=r.x*s,n.height=r.y*s,this.wmsParams=n},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var i=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[i]=this._crs.code,mn.prototype.onAdd.call(this,t)},getTileUrl:function(t){var i=this._tileCoordsToNwSe(t),e=this._crs,n=b(e.project(i[0]),e.project(i[1])),o=n.min,s=n.max,r=(this._wmsVersion>=1.3&&this._crs===Ue?[o.y,o.x,s.y,s.x]:[o.x,o.y,s.x,s.y]).join(","),a=mn.prototype.getTileUrl.call(this,t);return a+c(this.wmsParams,a,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+r},setParams:function(t,e){return i(this.wmsParams,t),e||this.redraw(),this}});mn.WMS=fn,Jt.wms=function(t,i){return new fn(t,i)};var gn=qe.extend({options:{padding:.1,tolerance:0},initialize:function(t){l(this,t),n(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),this._zoomAnimated&&Q(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update(),this.on("update",this._updatePaths,this)},onRemove:function(){this.off("update",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var t={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t},_onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(t,i){var e=this._map.getZoomScale(i,this._zoom),n=ht(this._container),o=this._map.getSize().multiplyBy(.5+this.options.padding),s=this._map.project(this._center,i),r=this._map.project(t,i).subtract(s),a=o.multiplyBy(-e).add(n).add(o).subtract(r);ji?rt(this._container,a,e):at(this._container,a)},_reset:function(){this._update(),this._updateTransform(this._center,this._zoom);for(var t in this._layers)this._layers[t]._reset()},_onZoomEnd:function(){for(var t in this._layers)this._layers[t]._project()},_updatePaths:function(){for(var t in this._layers)this._layers[t]._update()},_update:function(){var t=this.options.padding,i=this._map.getSize(),e=this._map.containerPointToLayerPoint(i.multiplyBy(-t)).round();this._bounds=new P(e,e.add(i.multiplyBy(1+2*t)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),vn=gn.extend({getEvents:function(){var t=gn.prototype.getEvents.call(this);return t.viewprereset=this._onViewPreReset,t},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){gn.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var t=this._container=document.createElement("canvas");mt(t,"mousemove",o(this._onMouseMove,32,this),this),mt(t,"click dblclick mousedown mouseup contextmenu",this._onClick,this),mt(t,"mouseout",this._handleMouseOut,this),this._ctx=t.getContext("2d")},_destroyContainer:function(){g(this._redrawRequest),delete this._ctx,K(this._container),ft(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){this._redrawBounds=null;for(var t in this._layers)this._layers[t]._update();this._redraw()}},_update:function(){if(!this._map._animatingZoom||!this._bounds){gn.prototype._update.call(this);var t=this._bounds,i=this._container,e=t.getSize(),n=Yi?2:1;at(i,t.min),i.width=n*e.x,i.height=n*e.y,i.style.width=e.x+"px",i.style.height=e.y+"px",Yi&&this._ctx.scale(2,2),this._ctx.translate(-t.min.x,-t.min.y),this.fire("update")}},_reset:function(){gn.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(t){this._updateDashArray(t),this._layers[n(t)]=t;var i=t._order={layer:t,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=i),this._drawLast=i,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(t){this._requestRedraw(t)},_removePath:function(t){var i=t._order,e=i.next,o=i.prev;e?e.prev=o:this._drawLast=o,o?o.next=e:this._drawFirst=e,delete t._order,delete this._layers[n(t)],this._requestRedraw(t)},_updatePath:function(t){this._extendRedrawBounds(t),t._project(),t._update(),this._requestRedraw(t)},_updateStyle:function(t){this._updateDashArray(t),this._requestRedraw(t)},_updateDashArray:function(t){if("string"==typeof t.options.dashArray){var i,e,n=t.options.dashArray.split(/[, ]+/),o=[];for(e=0;e<n.length;e++){if(i=Number(n[e]),isNaN(i))return;o.push(i)}t.options._dashArray=o}else t.options._dashArray=t.options.dashArray},_requestRedraw:function(t){this._map&&(this._extendRedrawBounds(t),this._redrawRequest=this._redrawRequest||f(this._redraw,this))},_extendRedrawBounds:function(t){if(t._pxBounds){var i=(t.options.weight||0)+1;this._redrawBounds=this._redrawBounds||new P,this._redrawBounds.extend(t._pxBounds.min.subtract([i,i])),this._redrawBounds.extend(t._pxBounds.max.add([i,i]))}},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var t=this._redrawBounds;if(t){var i=t.getSize();this._ctx.clearRect(t.min.x,t.min.y,i.x,i.y)}else this._ctx.clearRect(0,0,this._container.width,this._container.height)},_draw:function(){var t,i=this._redrawBounds;if(this._ctx.save(),i){var e=i.getSize();this._ctx.beginPath(),this._ctx.rect(i.min.x,i.min.y,e.x,e.y),this._ctx.clip()}this._drawing=!0;for(var n=this._drawFirst;n;n=n.next)t=n.layer,(!i||t._pxBounds&&t._pxBounds.intersects(i))&&t._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(t,i){if(this._drawing){var e,n,o,s,r=t._parts,a=r.length,h=this._ctx;if(a){for(h.beginPath(),e=0;e<a;e++){for(n=0,o=r[e].length;n<o;n++)s=r[e][n],h[n?"lineTo":"moveTo"](s.x,s.y);i&&h.closePath()}this._fillStroke(h,t)}}},_updateCircle:function(t){if(this._drawing&&!t._empty()){var i=t._point,e=this._ctx,n=Math.max(Math.round(t._radius),1),o=(Math.max(Math.round(t._radiusY),1)||n)/n;1!==o&&(e.save(),e.scale(1,o)),e.beginPath(),e.arc(i.x,i.y/o,n,0,2*Math.PI,!1),1!==o&&e.restore(),this._fillStroke(e,t)}},_fillStroke:function(t,i){var e=i.options;e.fill&&(t.globalAlpha=e.fillOpacity,t.fillStyle=e.fillColor||e.color,t.fill(e.fillRule||"evenodd")),e.stroke&&0!==e.weight&&(t.setLineDash&&t.setLineDash(i.options&&i.options._dashArray||[]),t.globalAlpha=e.opacity,t.lineWidth=e.weight,t.strokeStyle=e.color,t.lineCap=e.lineCap,t.lineJoin=e.lineJoin,t.stroke())},_onClick:function(t){for(var i,e,n=this._map.mouseEventToLayerPoint(t),o=this._drawFirst;o;o=o.next)(i=o.layer).options.interactive&&i._containsPoint(n)&&!this._map._draggableMoved(i)&&(e=i);e&&(zt(t),this._fireEvent([e],t))},_onMouseMove:function(t){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var i=this._map.mouseEventToLayerPoint(t);this._handleMouseHover(t,i)}},_handleMouseOut:function(t){var i=this._hoveredLayer;i&&(tt(this._container,"leaflet-interactive"),this._fireEvent([i],t,"mouseout"),this._hoveredLayer=null)},_handleMouseHover:function(t,i){for(var e,n,o=this._drawFirst;o;o=o.next)(e=o.layer).options.interactive&&e._containsPoint(i)&&(n=e);n!==this._hoveredLayer&&(this._handleMouseOut(t),n&&(Q(this._container,"leaflet-interactive"),this._fireEvent([n],t,"mouseover"),this._hoveredLayer=n)),this._hoveredLayer&&this._fireEvent([this._hoveredLayer],t)},_fireEvent:function(t,i,e){this._map._fireDOMEvent(i,e||i.type,t)},_bringToFront:function(t){var i=t._order;if(i){var e=i.next,n=i.prev;e&&(e.prev=n,n?n.next=e:e&&(this._drawFirst=e),i.prev=this._drawLast,this._drawLast.next=i,i.next=null,this._drawLast=i,this._requestRedraw(t))}},_bringToBack:function(t){var i=t._order;if(i){var e=i.next,n=i.prev;n&&(n.next=e,e?e.prev=n:n&&(this._drawLast=n),i.prev=null,i.next=this._drawFirst,this._drawFirst.prev=i,this._drawFirst=i,this._requestRedraw(t))}}}),yn=function(){try{return document.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return document.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return document.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),xn={_initContainer:function(){this._container=G("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(gn.prototype._update.call(this),this.fire("update"))},_initPath:function(t){var i=t._container=yn("shape");Q(i,"leaflet-vml-shape "+(this.options.className||"")),i.coordsize="1 1",t._path=yn("path"),i.appendChild(t._path),this._updateStyle(t),this._layers[n(t)]=t},_addPath:function(t){var i=t._container;this._container.appendChild(i),t.options.interactive&&t.addInteractiveTarget(i)},_removePath:function(t){var i=t._container;K(i),t.removeInteractiveTarget(i),delete this._layers[n(t)]},_updateStyle:function(t){var i=t._stroke,e=t._fill,n=t.options,o=t._container;o.stroked=!!n.stroke,o.filled=!!n.fill,n.stroke?(i||(i=t._stroke=yn("stroke")),o.appendChild(i),i.weight=n.weight+"px",i.color=n.color,i.opacity=n.opacity,n.dashArray?i.dashStyle=oi(n.dashArray)?n.dashArray.join(" "):n.dashArray.replace(/( *, *)/g," "):i.dashStyle="",i.endcap=n.lineCap.replace("butt","flat"),i.joinstyle=n.lineJoin):i&&(o.removeChild(i),t._stroke=null),n.fill?(e||(e=t._fill=yn("fill")),o.appendChild(e),e.color=n.fillColor||n.color,e.opacity=n.fillOpacity):e&&(o.removeChild(e),t._fill=null)},_updateCircle:function(t){var i=t._point.round(),e=Math.round(t._radius),n=Math.round(t._radiusY||e);this._setPath(t,t._empty()?"M0 0":"AL "+i.x+","+i.y+" "+e+","+n+" 0,23592600")},_setPath:function(t,i){t._path.v=i},_bringToFront:function(t){X(t._container)},_bringToBack:function(t){J(t._container)}},wn=$i?yn:E,Pn=gn.extend({getEvents:function(){var t=gn.prototype.getEvents.call(this);return t.zoomstart=this._onZoomStart,t},_initContainer:function(){this._container=wn("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=wn("g"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){K(this._container),ft(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_onZoomStart:function(){this._update()},_update:function(){if(!this._map._animatingZoom||!this._bounds){gn.prototype._update.call(this);var t=this._bounds,i=t.getSize(),e=this._container;this._svgSize&&this._svgSize.equals(i)||(this._svgSize=i,e.setAttribute("width",i.x),e.setAttribute("height",i.y)),at(e,t.min),e.setAttribute("viewBox",[t.min.x,t.min.y,i.x,i.y].join(" ")),this.fire("update")}},_initPath:function(t){var i=t._path=wn("path");t.options.className&&Q(i,t.options.className),t.options.interactive&&Q(i,"leaflet-interactive"),this._updateStyle(t),this._layers[n(t)]=t},_addPath:function(t){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(t._path),t.addInteractiveTarget(t._path)},_removePath:function(t){K(t._path),t.removeInteractiveTarget(t._path),delete this._layers[n(t)]},_updatePath:function(t){t._project(),t._update()},_updateStyle:function(t){var i=t._path,e=t.options;i&&(e.stroke?(i.setAttribute("stroke",e.color),i.setAttribute("stroke-opacity",e.opacity),i.setAttribute("stroke-width",e.weight),i.setAttribute("stroke-linecap",e.lineCap),i.setAttribute("stroke-linejoin",e.lineJoin),e.dashArray?i.setAttribute("stroke-dasharray",e.dashArray):i.removeAttribute("stroke-dasharray"),e.dashOffset?i.setAttribute("stroke-dashoffset",e.dashOffset):i.removeAttribute("stroke-dashoffset")):i.setAttribute("stroke","none"),e.fill?(i.setAttribute("fill",e.fillColor||e.color),i.setAttribute("fill-opacity",e.fillOpacity),i.setAttribute("fill-rule",e.fillRule||"evenodd")):i.setAttribute("fill","none"))},_updatePoly:function(t,i){this._setPath(t,k(t._parts,i))},_updateCircle:function(t){var i=t._point,e=Math.max(Math.round(t._radius),1),n="a"+e+","+(Math.max(Math.round(t._radiusY),1)||e)+" 0 1,0 ",o=t._empty()?"M0 0":"M"+(i.x-e)+","+i.y+n+2*e+",0 "+n+2*-e+",0 ";this._setPath(t,o)},_setPath:function(t,i){t._path.setAttribute("d",i)},_bringToFront:function(t){X(t._path)},_bringToBack:function(t){J(t._path)}});$i&&Pn.include(xn),be.include({getRenderer:function(t){var i=t.options.renderer||this._getPaneRenderer(t.options.pane)||this.options.renderer||this._renderer;return i||(i=this._renderer=this._createRenderer()),this.hasLayer(i)||this.addLayer(i),i},_getPaneRenderer:function(t){if("overlayPane"===t||void 0===t)return!1;var i=this._paneRenderers[t];return void 0===i&&(i=this._createRenderer({pane:t}),this._paneRenderers[t]=i),i},_createRenderer:function(t){return this.options.preferCanvas&&$t(t)||Qt(t)}});var Ln=on.extend({initialize:function(t,i){on.prototype.initialize.call(this,this._boundsToLatLngs(t),i)},setBounds:function(t){return this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=z(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}});Pn.create=wn,Pn.pointsToPath=k,sn.geometryToLayer=Ft,sn.coordsToLatLng=Ut,sn.coordsToLatLngs=Vt,sn.latLngToCoords=qt,sn.latLngsToCoords=Gt,sn.getFeature=Kt,sn.asFeature=Yt,be.mergeOptions({boxZoom:!0});var bn=Ee.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._resetStateTimeout=0,t.on("unload",this._destroy,this)},addHooks:function(){mt(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){ft(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){K(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(t){if(!t.shiftKey||1!==t.which&&1!==t.button)return!1;this._clearDeferredResetState(),this._resetState(),fi(),ut(),this._startPoint=this._map.mouseEventToContainerPoint(t),mt(document,{contextmenu:Lt,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(t){this._moved||(this._moved=!0,this._box=G("div","leaflet-zoom-box",this._container),Q(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(t);var i=new P(this._point,this._startPoint),e=i.getSize();at(this._box,i.min),this._box.style.width=e.x+"px",this._box.style.height=e.y+"px"},_finish:function(){this._moved&&(K(this._box),tt(this._container,"leaflet-crosshair")),gi(),lt(),ft(document,{contextmenu:Lt,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(t){if((1===t.which||1===t.button)&&(this._finish(),this._moved)){this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(e(this._resetState,this),0);var i=new T(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));this._map.fitBounds(i).fire("boxzoomend",{boxZoomBounds:i})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}});be.addInitHook("addHandler","boxZoom",bn),be.mergeOptions({doubleClickZoom:!0});var Tn=Ee.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var i=this._map,e=i.getZoom(),n=i.options.zoomDelta,o=t.originalEvent.shiftKey?e-n:e+n;"center"===i.options.doubleClickZoom?i.setZoom(o):i.setZoomAround(t.containerPoint,o)}});be.addInitHook("addHandler","doubleClickZoom",Tn),be.mergeOptions({dragging:!0,inertia:!Mi,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0});var zn=Ee.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new Re(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),t.on("zoomend",this._onZoomEnd,this),t.whenReady(this._onZoomEnd,this))}Q(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){tt(this._map._container,"leaflet-grab"),tt(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var t=this._map;if(t._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity){var i=z(this._map.options.maxBounds);this._offsetLimit=b(this._map.latLngToContainerPoint(i.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(i.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))}else this._offsetLimit=null;t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(t){if(this._map.options.inertia){var i=this._lastTime=+new Date,e=this._lastPos=this._draggable._absPos||this._draggable._newPos;this._positions.push(e),this._times.push(i),this._prunePositions(i)}this._map.fire("move",t).fire("drag",t)},_prunePositions:function(t){for(;this._positions.length>1&&t-this._times[0]>50;)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var t=this._map.getSize().divideBy(2),i=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=i.subtract(t).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(t,i){return t-(t-i)*this._viscosity},_onPreDragLimit:function(){if(this._viscosity&&this._offsetLimit){var t=this._draggable._newPos.subtract(this._draggable._startPos),i=this._offsetLimit;t.x<i.min.x&&(t.x=this._viscousLimit(t.x,i.min.x)),t.y<i.min.y&&(t.y=this._viscousLimit(t.y,i.min.y)),t.x>i.max.x&&(t.x=this._viscousLimit(t.x,i.max.x)),t.y>i.max.y&&(t.y=this._viscousLimit(t.y,i.max.y)),this._draggable._newPos=this._draggable._startPos.add(t)}},_onPreDragWrap:function(){var t=this._worldWidth,i=Math.round(t/2),e=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-i+e)%t+i-e,s=(n+i+e)%t-i-e,r=Math.abs(o+e)<Math.abs(s+e)?o:s;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=r},_onDragEnd:function(t){var i=this._map,e=i.options,n=!e.inertia||this._times.length<2;if(i.fire("dragend",t),n)i.fire("moveend");else{this._prunePositions(+new Date);var o=this._lastPos.subtract(this._positions[0]),s=(this._lastTime-this._times[0])/1e3,r=e.easeLinearity,a=o.multiplyBy(r/s),h=a.distanceTo([0,0]),u=Math.min(e.inertiaMaxSpeed,h),l=a.multiplyBy(u/h),c=u/(e.inertiaDeceleration*r),_=l.multiplyBy(-c/2).round();_.x||_.y?(_=i._limitOffset(_,i.options.maxBounds),f(function(){i.panBy(_,{duration:c,easeLinearity:r,noMoveStart:!0,animate:!0})})):i.fire("moveend")}}});be.addInitHook("addHandler","dragging",zn),be.mergeOptions({keyboard:!0,keyboardPanDelta:80});var Mn=Ee.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(t){this._map=t,this._setPanDelta(t.options.keyboardPanDelta),this._setZoomDelta(t.options.zoomDelta)},addHooks:function(){var t=this._map._container;t.tabIndex<=0&&(t.tabIndex="0"),mt(t,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),ft(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){if(!this._focused){var t=document.body,i=document.documentElement,e=t.scrollTop||i.scrollTop,n=t.scrollLeft||i.scrollLeft;this._map._container.focus(),window.scrollTo(n,e)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(t){var i,e,n=this._panKeys={},o=this.keyCodes;for(i=0,e=o.left.length;i<e;i++)n[o.left[i]]=[-1*t,0];for(i=0,e=o.right.length;i<e;i++)n[o.right[i]]=[t,0];for(i=0,e=o.down.length;i<e;i++)n[o.down[i]]=[0,t];for(i=0,e=o.up.length;i<e;i++)n[o.up[i]]=[0,-1*t]},_setZoomDelta:function(t){var i,e,n=this._zoomKeys={},o=this.keyCodes;for(i=0,e=o.zoomIn.length;i<e;i++)n[o.zoomIn[i]]=t;for(i=0,e=o.zoomOut.length;i<e;i++)n[o.zoomOut[i]]=-t},_addHooks:function(){mt(document,"keydown",this._onKeyDown,this)},_removeHooks:function(){ft(document,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var i,e=t.keyCode,n=this._map;if(e in this._panKeys)n._panAnim&&n._panAnim._inProgress||(i=this._panKeys[e],t.shiftKey&&(i=w(i).multiplyBy(3)),n.panBy(i),n.options.maxBounds&&n.panInsideBounds(n.options.maxBounds));else if(e in this._zoomKeys)n.setZoom(n.getZoom()+(t.shiftKey?3:1)*this._zoomKeys[e]);else{if(27!==e||!n._popup||!n._popup.options.closeOnEscapeKey)return;n.closePopup()}Lt(t)}}});be.addInitHook("addHandler","keyboard",Mn),be.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60});var Cn=Ee.extend({addHooks:function(){mt(this._map._container,"mousewheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){ft(this._map._container,"mousewheel",this._onWheelScroll,this)},_onWheelScroll:function(t){var i=Tt(t),n=this._map.options.wheelDebounceTime;this._delta+=i,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var o=Math.max(n-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(e(this._performZoom,this),o),Lt(t)},_performZoom:function(){var t=this._map,i=t.getZoom(),e=this._map.options.zoomSnap||0;t._stop();var n=this._delta/(4*this._map.options.wheelPxPerZoomLevel),o=4*Math.log(2/(1+Math.exp(-Math.abs(n))))/Math.LN2,s=e?Math.ceil(o/e)*e:o,r=t._limitZoom(i+(this._delta>0?s:-s))-i;this._delta=0,this._startTime=null,r&&("center"===t.options.scrollWheelZoom?t.setZoom(i+r):t.setZoomAround(this._lastMousePos,i+r))}});be.addInitHook("addHandler","scrollWheelZoom",Cn),be.mergeOptions({tap:!0,tapTolerance:15});var Sn=Ee.extend({addHooks:function(){mt(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){ft(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(Pt(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new x(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&Q(n,"leaflet-active"),this._holdTimeout=setTimeout(e(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),this._simulateEvent("mousedown",i),mt(document,{touchmove:this._onMove,touchend:this._onUp},this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),ft(document,{touchmove:this._onMove,touchend:this._onUp},this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],e=i.target;e&&e.tagName&&"a"===e.tagName.toLowerCase()&&tt(e,"leaflet-active"),this._simulateEvent("mouseup",i),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var i=t.touches[0];this._newPos=new x(i.clientX,i.clientY),this._simulateEvent("mousemove",i)},_simulateEvent:function(t,i){var e=document.createEvent("MouseEvents");e._simulated=!0,i.target._simulatedClick=!0,e.initMouseEvent(t,!0,!0,window,1,i.screenX,i.screenY,i.clientX,i.clientY,!1,!1,!1,!1,0,null),i.target.dispatchEvent(e)}});qi&&!Vi&&be.addInitHook("addHandler","tap",Sn),be.mergeOptions({touchZoom:qi&&!Mi,bounceAtZoomLimits:!0});var Zn=Ee.extend({addHooks:function(){Q(this._map._container,"leaflet-touch-zoom"),mt(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){tt(this._map._container,"leaflet-touch-zoom"),ft(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var e=i.mouseEventToContainerPoint(t.touches[0]),n=i.mouseEventToContainerPoint(t.touches[1]);this._centerPoint=i.getSize()._divideBy(2),this._startLatLng=i.containerPointToLatLng(this._centerPoint),"center"!==i.options.touchZoom&&(this._pinchStartLatLng=i.containerPointToLatLng(e.add(n)._divideBy(2))),this._startDist=e.distanceTo(n),this._startZoom=i.getZoom(),this._moved=!1,this._zooming=!0,i._stop(),mt(document,"touchmove",this._onTouchMove,this),mt(document,"touchend",this._onTouchEnd,this),Pt(t)}},_onTouchMove:function(t){if(t.touches&&2===t.touches.length&&this._zooming){var i=this._map,n=i.mouseEventToContainerPoint(t.touches[0]),o=i.mouseEventToContainerPoint(t.touches[1]),s=n.distanceTo(o)/this._startDist;if(this._zoom=i.getScaleZoom(s,this._startZoom),!i.options.bounceAtZoomLimits&&(this._zoom<i.getMinZoom()&&s<1||this._zoom>i.getMaxZoom()&&s>1)&&(this._zoom=i._limitZoom(this._zoom)),"center"===i.options.touchZoom){if(this._center=this._startLatLng,1===s)return}else{var r=n._add(o)._divideBy(2)._subtract(this._centerPoint);if(1===s&&0===r.x&&0===r.y)return;this._center=i.unproject(i.project(this._pinchStartLatLng,this._zoom).subtract(r),this._zoom)}this._moved||(i._moveStart(!0,!1),this._moved=!0),g(this._animRequest);var a=e(i._move,i,this._center,this._zoom,{pinch:!0,round:!1});this._animRequest=f(a,this,!0),Pt(t)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,g(this._animRequest),ft(document,"touchmove",this._onTouchMove),ft(document,"touchend",this._onTouchEnd),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}});be.addInitHook("addHandler","touchZoom",Zn),be.BoxZoom=bn,be.DoubleClickZoom=Tn,be.Drag=zn,be.Keyboard=Mn,be.ScrollWheelZoom=Cn,be.Tap=Sn,be.TouchZoom=Zn,Object.freeze=ti,t.version="1.4.0",t.Control=Te,t.control=ze,t.Browser=Qi,t.Evented=ci,t.Mixin=Be,t.Util=ui,t.Class=v,t.Handler=Ee,t.extend=i,t.bind=e,t.stamp=n,t.setOptions=l,t.DomEvent=Pe,t.DomUtil=ve,t.PosAnimation=Le,t.Draggable=Re,t.LineUtil=Ne,t.PolyUtil=De,t.Point=x,t.point=w,t.Bounds=P,t.bounds=b,t.Transformation=S,t.transformation=Z,t.Projection=He,t.LatLng=M,t.latLng=C,t.LatLngBounds=T,t.latLngBounds=z,t.CRS=di,t.GeoJSON=sn,t.geoJSON=Xt,t.geoJson=an,t.Layer=qe,t.LayerGroup=Ge,t.layerGroup=function(t,i){return new Ge(t,i)},t.FeatureGroup=Ke,t.featureGroup=function(t){return new Ke(t)},t.ImageOverlay=hn,t.imageOverlay=function(t,i,e){return new hn(t,i,e)},t.VideoOverlay=un,t.videoOverlay=function(t,i,e){return new un(t,i,e)},t.DivOverlay=ln,t.Popup=cn,t.popup=function(t,i){return new cn(t,i)},t.Tooltip=_n,t.tooltip=function(t,i){return new _n(t,i)},t.Icon=Ye,t.icon=function(t){return new Ye(t)},t.DivIcon=dn,t.divIcon=function(t){return new dn(t)},t.Marker=$e,t.marker=function(t,i){return new $e(t,i)},t.TileLayer=mn,t.tileLayer=Jt,t.GridLayer=pn,t.gridLayer=function(t){return new pn(t)},t.SVG=Pn,t.svg=Qt,t.Renderer=gn,t.Canvas=vn,t.canvas=$t,t.Path=Qe,t.CircleMarker=tn,t.circleMarker=function(t,i){return new tn(t,i)},t.Circle=en,t.circle=function(t,i,e){return new en(t,i,e)},t.Polyline=nn,t.polyline=function(t,i){return new nn(t,i)},t.Polygon=on,t.polygon=function(t,i){return new on(t,i)},t.Rectangle=Ln,t.rectangle=function(t,i){return new Ln(t,i)},t.Map=be,t.map=function(t,i){return new be(t,i)};var En=window.L;t.noConflict=function(){return window.L=En,this},window.L=t});

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-core-wikimediaui.css":
/*!****************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-core-wikimediaui.css ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-widgets-wikimediaui.css":
/*!*******************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-widgets-wikimediaui.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-interactions.css":
/*!******************************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-interactions.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-movement.css":
/*!**************************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-movement.css ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-wikimedia.css":
/*!***************************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-wikimedia.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui-wikimediaui.js":
/*!**********************************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(OO) {/*!
 * OOUI v0.30.2
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2019 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2019-01-23T01:14:20Z
 */
( function ( OO ) {

'use strict';

/**
 * @class
 * @extends OO.ui.Theme
 *
 * @constructor
 */
OO.ui.WikimediaUITheme = function OoUiWikimediaUITheme() {
	// Parent constructor
	OO.ui.WikimediaUITheme.parent.call( this );
};

/* Setup */

OO.inheritClass( OO.ui.WikimediaUITheme, OO.ui.Theme );

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.WikimediaUITheme.prototype.getElementClasses = function ( element ) {
	// Parent method
	var variant, isFramed, isActive, isToolOrGroup,
		variants = {
			warning: false,
			invert: false,
			progressive: false,
			destructive: false
		},
		// Parent method
		classes = OO.ui.WikimediaUITheme.parent.prototype.getElementClasses.call( this, element );

	if (
		element instanceof OO.ui.IconWidget &&
		element.$element.hasClass( 'oo-ui-checkboxInputWidget-checkIcon' )
	) {
		// Icon on CheckboxInputWidget
		variants.invert = true;
	} else if ( element.supports( [ 'hasFlag' ] ) ) {
		isFramed = element.supports( [ 'isFramed' ] ) && element.isFramed();
		isActive = element.supports( [ 'isActive' ] ) && element.isActive();
		isToolOrGroup =
			// Check if the class exists, as classes that are not in the 'core' module may not be loaded
			( OO.ui.Tool && element instanceof OO.ui.Tool ) ||
			( OO.ui.ToolGroup && element instanceof OO.ui.ToolGroup );
		if (
			// Button with a dark background
			isFramed && ( isActive || element.isDisabled() || element.hasFlag( 'primary' ) ) ||
			// Toolbar with a dark background
			isToolOrGroup && element.hasFlag( 'primary' )
		) {
			// … use white icon / indicator, regardless of other flags
			variants.invert = true;
		} else if ( !isFramed && element.isDisabled() ) {
			// Frameless disabled button, always use black icon / indicator regardless of other flags
			variants.invert = false;
		} else if ( !element.isDisabled() ) {
			// Any other kind of button, use the right colored icon / indicator if available
			variants.progressive = element.hasFlag( 'progressive' ) ||
				// Active tools/toolgroups
				( isToolOrGroup && isActive ) ||
				// Pressed or selected outline/menu option widgets
				(
					(
						element instanceof OO.ui.MenuOptionWidget ||
						// Check if the class exists, as classes that are not in the 'core' module may not be loaded
						( OO.ui.OutlineOptionWidget && element instanceof OO.ui.OutlineOptionWidget )
					) &&
					( element.isPressed() || element.isSelected() )
				);

			variants.destructive = element.hasFlag( 'destructive' );
			variants.warning = element.hasFlag( 'warning' );
		}
	}

	for ( variant in variants ) {
		classes[ variants[ variant ] ? 'on' : 'off' ].push( 'oo-ui-image-' + variant );
	}

	return classes;
};

/**
 * @inheritdoc
 */
OO.ui.WikimediaUITheme.prototype.getDialogTransitionDuration = function () {
	return 250;
};

/* Instantiation */

OO.ui.theme = new OO.ui.WikimediaUITheme();

}( OO ) );

//# sourceMappingURL=oojs-ui-wikimediaui.js.map.json
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! oojs */ "./node_modules/oojs/dist/oojs.js")))

/***/ }),

/***/ "./node_modules/oojs-ui/dist/oojs-ui.js":
/*!**********************************************!*\
  !*** ./node_modules/oojs-ui/dist/oojs-ui.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(OO, $) {/*!
 * OOUI v0.30.2
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2019 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2019-01-23T01:14:20Z
 */
( function ( OO ) {

'use strict';

/**
 * Namespace for all classes, static methods and static properties.
 *
 * @class
 * @singleton
 */
OO.ui = {};

OO.ui.bind = $.proxy;

/**
 * @property {Object}
 */
OO.ui.Keys = {
	UNDEFINED: 0,
	BACKSPACE: 8,
	DELETE: 46,
	LEFT: 37,
	RIGHT: 39,
	UP: 38,
	DOWN: 40,
	ENTER: 13,
	END: 35,
	HOME: 36,
	TAB: 9,
	PAGEUP: 33,
	PAGEDOWN: 34,
	ESCAPE: 27,
	SHIFT: 16,
	SPACE: 32
};

/**
 * Constants for MouseEvent.which
 *
 * @property {Object}
 */
OO.ui.MouseButtons = {
	LEFT: 1,
	MIDDLE: 2,
	RIGHT: 3
};

/**
 * @property {number}
 * @private
 */
OO.ui.elementId = 0;

/**
 * Generate a unique ID for element
 *
 * @return {string} ID
 */
OO.ui.generateElementId = function () {
	OO.ui.elementId++;
	return 'ooui-' + OO.ui.elementId;
};

/**
 * Check if an element is focusable.
 * Inspired by :focusable in jQueryUI v1.11.4 - 2015-04-14
 *
 * @param {jQuery} $element Element to test
 * @return {boolean} Element is focusable
 */
OO.ui.isFocusableElement = function ( $element ) {
	var nodeName,
		element = $element[ 0 ];

	// Anything disabled is not focusable
	if ( element.disabled ) {
		return false;
	}

	// Check if the element is visible
	if ( !(
		// This is quicker than calling $element.is( ':visible' )
		$.expr.pseudos.visible( element ) &&
		// Check that all parents are visible
		!$element.parents().addBack().filter( function () {
			return $.css( this, 'visibility' ) === 'hidden';
		} ).length
	) ) {
		return false;
	}

	// Check if the element is ContentEditable, which is the string 'true'
	if ( element.contentEditable === 'true' ) {
		return true;
	}

	// Anything with a non-negative numeric tabIndex is focusable.
	// Use .prop to avoid browser bugs
	if ( $element.prop( 'tabIndex' ) >= 0 ) {
		return true;
	}

	// Some element types are naturally focusable
	// (indexOf is much faster than regex in Chrome and about the
	// same in FF: https://jsperf.com/regex-vs-indexof-array2)
	nodeName = element.nodeName.toLowerCase();
	if ( [ 'input', 'select', 'textarea', 'button', 'object' ].indexOf( nodeName ) !== -1 ) {
		return true;
	}

	// Links and areas are focusable if they have an href
	if ( ( nodeName === 'a' || nodeName === 'area' ) && $element.attr( 'href' ) !== undefined ) {
		return true;
	}

	return false;
};

/**
 * Find a focusable child
 *
 * @param {jQuery} $container Container to search in
 * @param {boolean} [backwards] Search backwards
 * @return {jQuery} Focusable child, or an empty jQuery object if none found
 */
OO.ui.findFocusable = function ( $container, backwards ) {
	var $focusable = $( [] ),
		// $focusableCandidates is a superset of things that
		// could get matched by isFocusableElement
		$focusableCandidates = $container
			.find( 'input, select, textarea, button, object, a, area, [contenteditable], [tabindex]' );

	if ( backwards ) {
		$focusableCandidates = Array.prototype.reverse.call( $focusableCandidates );
	}

	$focusableCandidates.each( function () {
		var $this = $( this );
		if ( OO.ui.isFocusableElement( $this ) ) {
			$focusable = $this;
			return false;
		}
	} );
	return $focusable;
};

/**
 * Get the user's language and any fallback languages.
 *
 * These language codes are used to localize user interface elements in the user's language.
 *
 * In environments that provide a localization system, this function should be overridden to
 * return the user's language(s). The default implementation returns English (en) only.
 *
 * @return {string[]} Language codes, in descending order of priority
 */
OO.ui.getUserLanguages = function () {
	return [ 'en' ];
};

/**
 * Get a value in an object keyed by language code.
 *
 * @param {Object.<string,Mixed>} obj Object keyed by language code
 * @param {string|null} [lang] Language code, if omitted or null defaults to any user language
 * @param {string} [fallback] Fallback code, used if no matching language can be found
 * @return {Mixed} Local value
 */
OO.ui.getLocalValue = function ( obj, lang, fallback ) {
	var i, len, langs;

	// Requested language
	if ( obj[ lang ] ) {
		return obj[ lang ];
	}
	// Known user language
	langs = OO.ui.getUserLanguages();
	for ( i = 0, len = langs.length; i < len; i++ ) {
		lang = langs[ i ];
		if ( obj[ lang ] ) {
			return obj[ lang ];
		}
	}
	// Fallback language
	if ( obj[ fallback ] ) {
		return obj[ fallback ];
	}
	// First existing language
	for ( lang in obj ) {
		return obj[ lang ];
	}

	return undefined;
};

/**
 * Check if a node is contained within another node
 *
 * Similar to jQuery#contains except a list of containers can be supplied
 * and a boolean argument allows you to include the container in the match list
 *
 * @param {HTMLElement|HTMLElement[]} containers Container node(s) to search in
 * @param {HTMLElement} contained Node to find
 * @param {boolean} [matchContainers] Include the container(s) in the list of nodes to match, otherwise only match descendants
 * @return {boolean} The node is in the list of target nodes
 */
OO.ui.contains = function ( containers, contained, matchContainers ) {
	var i;
	if ( !Array.isArray( containers ) ) {
		containers = [ containers ];
	}
	for ( i = containers.length - 1; i >= 0; i-- ) {
		if ( ( matchContainers && contained === containers[ i ] ) || $.contains( containers[ i ], contained ) ) {
			return true;
		}
	}
	return false;
};

/**
 * Return a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * Ported from: http://underscorejs.org/underscore.js
 *
 * @param {Function} func Function to debounce
 * @param {number} [wait=0] Wait period in milliseconds
 * @param {boolean} [immediate] Trigger on leading edge
 * @return {Function} Debounced function
 */
OO.ui.debounce = function ( func, wait, immediate ) {
	var timeout;
	return function () {
		var context = this,
			args = arguments,
			later = function () {
				timeout = null;
				if ( !immediate ) {
					func.apply( context, args );
				}
			};
		if ( immediate && !timeout ) {
			func.apply( context, args );
		}
		if ( !timeout || wait ) {
			clearTimeout( timeout );
			timeout = setTimeout( later, wait );
		}
	};
};

/**
 * Puts a console warning with provided message.
 *
 * @param {string} message Message
 */
OO.ui.warnDeprecation = function ( message ) {
	if ( OO.getProp( window, 'console', 'warn' ) !== undefined ) {
		// eslint-disable-next-line no-console
		console.warn( message );
	}
};

/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. If called again during that window, it will
 * wait until the window ends and then trigger itself again.
 *
 * As it's not knowable to the caller whether the function will actually run
 * when the wrapper is called, return values from the function are entirely
 * discarded.
 *
 * @param {Function} func Function to throttle
 * @param {number} wait Throttle window length, in milliseconds
 * @return {Function} Throttled function
 */
OO.ui.throttle = function ( func, wait ) {
	var context, args, timeout,
		previous = 0,
		run = function () {
			timeout = null;
			previous = OO.ui.now();
			func.apply( context, args );
		};
	return function () {
		// Check how long it's been since the last time the function was
		// called, and whether it's more or less than the requested throttle
		// period. If it's less, run the function immediately. If it's more,
		// set a timeout for the remaining time -- but don't replace an
		// existing timeout, since that'd indefinitely prolong the wait.
		var remaining = wait - ( OO.ui.now() - previous );
		context = this;
		args = arguments;
		if ( remaining <= 0 ) {
			// Note: unless wait was ridiculously large, this means we'll
			// automatically run the first time the function was called in a
			// given period. (If you provide a wait period larger than the
			// current Unix timestamp, you *deserve* unexpected behavior.)
			clearTimeout( timeout );
			run();
		} else if ( !timeout ) {
			timeout = setTimeout( run, remaining );
		}
	};
};

/**
 * A (possibly faster) way to get the current timestamp as an integer
 *
 * @return {number} Current timestamp, in milliseconds since the Unix epoch
 */
OO.ui.now = Date.now || function () {
	return new Date().getTime();
};

/**
 * Reconstitute a JavaScript object corresponding to a widget created by
 * the PHP implementation.
 *
 * This is an alias for `OO.ui.Element.static.infuse()`.
 *
 * @param {string|HTMLElement|jQuery} idOrNode
 *   A DOM id (if a string) or node for the widget to infuse.
 * @param {Object} [config] Configuration options
 * @return {OO.ui.Element}
 *   The `OO.ui.Element` corresponding to this (infusable) document node.
 */
OO.ui.infuse = function ( idOrNode, config ) {
	return OO.ui.Element.static.infuse( idOrNode, config );
};

( function () {
	/**
	 * Message store for the default implementation of OO.ui.msg
	 *
	 * Environments that provide a localization system should not use this, but should override
	 * OO.ui.msg altogether.
	 *
	 * @private
	 */
	var messages = {
		// Tool tip for a button that moves items in a list down one place
		'ooui-outline-control-move-down': 'Move item down',
		// Tool tip for a button that moves items in a list up one place
		'ooui-outline-control-move-up': 'Move item up',
		// Tool tip for a button that removes items from a list
		'ooui-outline-control-remove': 'Remove item',
		// Label for the toolbar group that contains a list of all other available tools
		'ooui-toolbar-more': 'More',
		// Label for the fake tool that expands the full list of tools in a toolbar group
		'ooui-toolgroup-expand': 'More',
		// Label for the fake tool that collapses the full list of tools in a toolbar group
		'ooui-toolgroup-collapse': 'Fewer',
		// Default label for the tooltip for the button that removes a tag item
		'ooui-item-remove': 'Remove',
		// Default label for the accept button of a confirmation dialog
		'ooui-dialog-message-accept': 'OK',
		// Default label for the reject button of a confirmation dialog
		'ooui-dialog-message-reject': 'Cancel',
		// Title for process dialog error description
		'ooui-dialog-process-error': 'Something went wrong',
		// Label for process dialog dismiss error button, visible when describing errors
		'ooui-dialog-process-dismiss': 'Dismiss',
		// Label for process dialog retry action button, visible when describing only recoverable errors
		'ooui-dialog-process-retry': 'Try again',
		// Label for process dialog retry action button, visible when describing only warnings
		'ooui-dialog-process-continue': 'Continue',
		// Label for button in combobox input that triggers its dropdown
		'ooui-combobox-button-label': 'Dropdown for combobox',
		// Label for the file selection widget's select file button
		'ooui-selectfile-button-select': 'Select a file',
		// Label for the file selection widget if file selection is not supported
		'ooui-selectfile-not-supported': 'File selection is not supported',
		// Label for the file selection widget when no file is currently selected
		'ooui-selectfile-placeholder': 'No file is selected',
		// Label for the file selection widget's drop target
		'ooui-selectfile-dragdrop-placeholder': 'Drop file here',
		// Label for the help icon attached to a form field
		'ooui-field-help': 'Help'
	};

	/**
	 * Get a localized message.
	 *
	 * After the message key, message parameters may optionally be passed. In the default implementation,
	 * any occurrences of $1 are replaced with the first parameter, $2 with the second parameter, etc.
	 * Alternative implementations of OO.ui.msg may use any substitution system they like, as long as
	 * they support unnamed, ordered message parameters.
	 *
	 * In environments that provide a localization system, this function should be overridden to
	 * return the message translated in the user's language. The default implementation always returns
	 * English messages. An example of doing this with [jQuery.i18n](https://github.com/wikimedia/jquery.i18n)
	 * follows.
	 *
	 *     @example
	 *     var i, iLen, button,
	 *         messagePath = 'oojs-ui/dist/i18n/',
	 *         languages = [ $.i18n().locale, 'ur', 'en' ],
	 *         languageMap = {};
	 *
	 *     for ( i = 0, iLen = languages.length; i < iLen; i++ ) {
	 *         languageMap[ languages[ i ] ] = messagePath + languages[ i ].toLowerCase() + '.json';
	 *     }
	 *
	 *     $.i18n().load( languageMap ).done( function() {
	 *         // Replace the built-in `msg` only once we've loaded the internationalization.
	 *         // OOUI uses `OO.ui.deferMsg` for all initially-loaded messages. So long as
	 *         // you put off creating any widgets until this promise is complete, no English
	 *         // will be displayed.
	 *         OO.ui.msg = $.i18n;
	 *
	 *         // A button displaying "OK" in the default locale
	 *         button = new OO.ui.ButtonWidget( {
	 *             label: OO.ui.msg( 'ooui-dialog-message-accept' ),
	 *             icon: 'check'
	 *         } );
	 *         $( document.body ).append( button.$element );
	 *
	 *         // A button displaying "OK" in Urdu
	 *         $.i18n().locale = 'ur';
	 *         button = new OO.ui.ButtonWidget( {
	 *             label: OO.ui.msg( 'ooui-dialog-message-accept' ),
	 *             icon: 'check'
	 *         } );
	 *         $( document.body ).append( button.$element );
	 *     } );
	 *
	 * @param {string} key Message key
	 * @param {...Mixed} [params] Message parameters
	 * @return {string} Translated message with parameters substituted
	 */
	OO.ui.msg = function ( key ) {
		var message = messages[ key ],
			params = Array.prototype.slice.call( arguments, 1 );
		if ( typeof message === 'string' ) {
			// Perform $1 substitution
			message = message.replace( /\$(\d+)/g, function ( unused, n ) {
				var i = parseInt( n, 10 );
				return params[ i - 1 ] !== undefined ? params[ i - 1 ] : '$' + n;
			} );
		} else {
			// Return placeholder if message not found
			message = '[' + key + ']';
		}
		return message;
	};
}() );

/**
 * Package a message and arguments for deferred resolution.
 *
 * Use this when you are statically specifying a message and the message may not yet be present.
 *
 * @param {string} key Message key
 * @param {...Mixed} [params] Message parameters
 * @return {Function} Function that returns the resolved message when executed
 */
OO.ui.deferMsg = function () {
	var args = arguments;
	return function () {
		return OO.ui.msg.apply( OO.ui, args );
	};
};

/**
 * Resolve a message.
 *
 * If the message is a function it will be executed, otherwise it will pass through directly.
 *
 * @param {Function|string} msg Deferred message, or message text
 * @return {string} Resolved message
 */
OO.ui.resolveMsg = function ( msg ) {
	if ( typeof msg === 'function' ) {
		return msg();
	}
	return msg;
};

/**
 * @param {string} url
 * @return {boolean}
 */
OO.ui.isSafeUrl = function ( url ) {
	// Keep this function in sync with php/Tag.php
	var i, protocolWhitelist;

	function stringStartsWith( haystack, needle ) {
		return haystack.substr( 0, needle.length ) === needle;
	}

	protocolWhitelist = [
		'bitcoin', 'ftp', 'ftps', 'geo', 'git', 'gopher', 'http', 'https', 'irc', 'ircs',
		'magnet', 'mailto', 'mms', 'news', 'nntp', 'redis', 'sftp', 'sip', 'sips', 'sms', 'ssh',
		'svn', 'tel', 'telnet', 'urn', 'worldwind', 'xmpp'
	];

	if ( url === '' ) {
		return true;
	}

	for ( i = 0; i < protocolWhitelist.length; i++ ) {
		if ( stringStartsWith( url, protocolWhitelist[ i ] + ':' ) ) {
			return true;
		}
	}

	// This matches '//' too
	if ( stringStartsWith( url, '/' ) || stringStartsWith( url, './' ) ) {
		return true;
	}
	if ( stringStartsWith( url, '?' ) || stringStartsWith( url, '#' ) ) {
		return true;
	}

	return false;
};

/**
 * Check if the user has a 'mobile' device.
 *
 * For our purposes this means the user is primarily using an
 * on-screen keyboard, touch input instead of a mouse and may
 * have a physically small display.
 *
 * It is left up to implementors to decide how to compute this
 * so the default implementation always returns false.
 *
 * @return {boolean} User is on a mobile device
 */
OO.ui.isMobile = function () {
	return false;
};

/**
 * Get the additional spacing that should be taken into account when displaying elements that are
 * clipped to the viewport, e.g. dropdown menus and popups. This is meant to be overridden to avoid
 * such menus overlapping any fixed headers/toolbars/navigation used by the site.
 *
 * @return {Object} Object with the properties 'top', 'right', 'bottom', 'left', each representing
 *     the extra spacing from that edge of viewport (in pixels)
 */
OO.ui.getViewportSpacing = function () {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0
	};
};

/**
 * Get the default overlay, which is used by various widgets when they are passed `$overlay: true`.
 * See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 *
 * @return {jQuery} Default overlay node
 */
OO.ui.getDefaultOverlay = function () {
	if ( !OO.ui.$defaultOverlay ) {
		OO.ui.$defaultOverlay = $( '<div>' ).addClass( 'oo-ui-defaultOverlay' );
		$( document.body ).append( OO.ui.$defaultOverlay );
	}
	return OO.ui.$defaultOverlay;
};

/*!
 * Mixin namespace.
 */

/**
 * Namespace for OOUI mixins.
 *
 * Mixins are named according to the type of object they are intended to
 * be mixed in to.  For example, OO.ui.mixin.GroupElement is intended to be
 * mixed in to an instance of OO.ui.Element, and OO.ui.mixin.GroupWidget
 * is intended to be mixed in to an instance of OO.ui.Widget.
 *
 * @class
 * @singleton
 */
OO.ui.mixin = {};

/**
 * Each Element represents a rendering in the DOM—a button or an icon, for example, or anything
 * that is visible to a user. Unlike {@link OO.ui.Widget widgets}, plain elements usually do not have events
 * connected to them and can't be interacted with.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string[]} [classes] The names of the CSS classes to apply to the element. CSS styles are added
 *  to the top level (e.g., the outermost div) of the element. See the [OOUI documentation on MediaWiki][2]
 *  for an example.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#cssExample
 * @cfg {string} [id] The HTML id attribute used in the rendered tag.
 * @cfg {string} [text] Text to insert
 * @cfg {Array} [content] An array of content elements to append (after #text).
 *  Strings will be html-escaped; use an OO.ui.HtmlSnippet to append raw HTML.
 *  Instances of OO.ui.Element will have their $element appended.
 * @cfg {jQuery} [$content] Content elements to append (after #text).
 * @cfg {jQuery} [$element] Wrapper element. Defaults to a new element with #getTagName.
 * @cfg {Mixed} [data] Custom data of any type or combination of types (e.g., string, number, array, object).
 *  Data can also be specified with the #setData method.
 */
OO.ui.Element = function OoUiElement( config ) {
	if ( OO.ui.isDemo ) {
		this.initialConfig = config;
	}
	// Configuration initialization
	config = config || {};

	// Properties
	this.$ = $;
	this.elementId = null;
	this.visible = true;
	this.data = config.data;
	this.$element = config.$element ||
		$( document.createElement( this.getTagName() ) );
	this.elementGroup = null;

	// Initialization
	if ( Array.isArray( config.classes ) ) {
		this.$element.addClass( config.classes );
	}
	if ( config.id ) {
		this.setElementId( config.id );
	}
	if ( config.text ) {
		this.$element.text( config.text );
	}
	if ( config.content ) {
		// The `content` property treats plain strings as text; use an
		// HtmlSnippet to append HTML content.  `OO.ui.Element`s get their
		// appropriate $element appended.
		this.$element.append( config.content.map( function ( v ) {
			if ( typeof v === 'string' ) {
				// Escape string so it is properly represented in HTML.
				return document.createTextNode( v );
			} else if ( v instanceof OO.ui.HtmlSnippet ) {
				// Bypass escaping.
				return v.toString();
			} else if ( v instanceof OO.ui.Element ) {
				return v.$element;
			}
			return v;
		} ) );
	}
	if ( config.$content ) {
		// The `$content` property treats plain strings as HTML.
		this.$element.append( config.$content );
	}
};

/* Setup */

OO.initClass( OO.ui.Element );

/* Static Properties */

/**
 * The name of the HTML tag used by the element.
 *
 * The static value may be ignored if the #getTagName method is overridden.
 *
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Element.static.tagName = 'div';

/* Static Methods */

/**
 * Reconstitute a JavaScript object corresponding to a widget created
 * by the PHP implementation.
 *
 * @param {string|HTMLElement|jQuery} idOrNode
 *   A DOM id (if a string) or node for the widget to infuse.
 * @param {Object} [config] Configuration options
 * @return {OO.ui.Element}
 *   The `OO.ui.Element` corresponding to this (infusable) document node.
 *   For `Tag` objects emitted on the HTML side (used occasionally for content)
 *   the value returned is a newly-created Element wrapping around the existing
 *   DOM node.
 */
OO.ui.Element.static.infuse = function ( idOrNode, config ) {
	var obj = OO.ui.Element.static.unsafeInfuse( idOrNode, config, false );

	if ( typeof idOrNode === 'string' ) {
		// IDs deprecated since 0.29.7
		OO.ui.warnDeprecation(
			'Passing a string ID to infuse is deprecated. Use an HTMLElement or jQuery collection instead.'
		);
	}
	// Verify that the type matches up.
	// FIXME: uncomment after T89721 is fixed, see T90929.
	/*
	if ( !( obj instanceof this['class'] ) ) {
		throw new Error( 'Infusion type mismatch!' );
	}
	*/
	return obj;
};

/**
 * Implementation helper for `infuse`; skips the type check and has an
 * extra property so that only the top-level invocation touches the DOM.
 *
 * @private
 * @param {string|HTMLElement|jQuery} idOrNode
 * @param {Object} [config] Configuration options
 * @param {jQuery.Promise} [domPromise] A promise that will be resolved
 *     when the top-level widget of this infusion is inserted into DOM,
 *     replacing the original node; only used internally.
 * @return {OO.ui.Element}
 */
OO.ui.Element.static.unsafeInfuse = function ( idOrNode, config, domPromise ) {
	// look for a cached result of a previous infusion.
	var id, $elem, error, data, cls, parts, parent, obj, top, state, infusedChildren;
	if ( typeof idOrNode === 'string' ) {
		id = idOrNode;
		$elem = $( document.getElementById( id ) );
	} else {
		$elem = $( idOrNode );
		id = $elem.attr( 'id' );
	}
	if ( !$elem.length ) {
		if ( typeof idOrNode === 'string' ) {
			error = 'Widget not found: ' + idOrNode;
		} else if ( idOrNode && idOrNode.selector ) {
			error = 'Widget not found: ' + idOrNode.selector;
		} else {
			error = 'Widget not found';
		}
		throw new Error( error );
	}
	if ( $elem[ 0 ].oouiInfused ) {
		$elem = $elem[ 0 ].oouiInfused;
	}
	data = $elem.data( 'ooui-infused' );
	if ( data ) {
		// cached!
		if ( data === true ) {
			throw new Error( 'Circular dependency! ' + id );
		}
		if ( domPromise ) {
			// pick up dynamic state, like focus, value of form inputs, scroll position, etc.
			state = data.constructor.static.gatherPreInfuseState( $elem, data );
			// restore dynamic state after the new element is re-inserted into DOM under infused parent
			domPromise.done( data.restorePreInfuseState.bind( data, state ) );
			infusedChildren = $elem.data( 'ooui-infused-children' );
			if ( infusedChildren && infusedChildren.length ) {
				infusedChildren.forEach( function ( data ) {
					var state = data.constructor.static.gatherPreInfuseState( $elem, data );
					domPromise.done( data.restorePreInfuseState.bind( data, state ) );
				} );
			}
		}
		return data;
	}
	data = $elem.attr( 'data-ooui' );
	if ( !data ) {
		throw new Error( 'No infusion data found: ' + id );
	}
	try {
		data = JSON.parse( data );
	} catch ( _ ) {
		data = null;
	}
	if ( !( data && data._ ) ) {
		throw new Error( 'No valid infusion data found: ' + id );
	}
	if ( data._ === 'Tag' ) {
		// Special case: this is a raw Tag; wrap existing node, don't rebuild.
		return new OO.ui.Element( $.extend( {}, config, { $element: $elem } ) );
	}
	parts = data._.split( '.' );
	cls = OO.getProp.apply( OO, [ window ].concat( parts ) );
	if ( cls === undefined ) {
		throw new Error( 'Unknown widget type: id: ' + id + ', class: ' + data._ );
	}

	// Verify that we're creating an OO.ui.Element instance
	parent = cls.parent;

	while ( parent !== undefined ) {
		if ( parent === OO.ui.Element ) {
			// Safe
			break;
		}

		parent = parent.parent;
	}

	if ( parent !== OO.ui.Element ) {
		throw new Error( 'Unknown widget type: id: ' + id + ', class: ' + data._ );
	}

	if ( !domPromise ) {
		top = $.Deferred();
		domPromise = top.promise();
	}
	$elem.data( 'ooui-infused', true ); // prevent loops
	data.id = id; // implicit
	infusedChildren = [];
	data = OO.copy( data, null, function deserialize( value ) {
		var infused;
		if ( OO.isPlainObject( value ) ) {
			if ( value.tag ) {
				infused = OO.ui.Element.static.unsafeInfuse( value.tag, config, domPromise );
				infusedChildren.push( infused );
				// Flatten the structure
				infusedChildren.push.apply( infusedChildren, infused.$element.data( 'ooui-infused-children' ) || [] );
				infused.$element.removeData( 'ooui-infused-children' );
				return infused;
			}
			if ( value.html !== undefined ) {
				return new OO.ui.HtmlSnippet( value.html );
			}
		}
	} );
	// allow widgets to reuse parts of the DOM
	data = cls.static.reusePreInfuseDOM( $elem[ 0 ], data );
	// pick up dynamic state, like focus, value of form inputs, scroll position, etc.
	state = cls.static.gatherPreInfuseState( $elem[ 0 ], data );
	// rebuild widget
	// eslint-disable-next-line new-cap
	obj = new cls( $.extend( {}, config, data ) );
	// If anyone is holding a reference to the old DOM element,
	// let's allow them to OO.ui.infuse() it and do what they expect, see T105828.
	// Do not use jQuery.data(), as using it on detached nodes leaks memory in 1.x line by design.
	$elem[ 0 ].oouiInfused = obj.$element;
	// now replace old DOM with this new DOM.
	if ( top ) {
		// An efficient constructor might be able to reuse the entire DOM tree of the original element,
		// so only mutate the DOM if we need to.
		if ( $elem[ 0 ] !== obj.$element[ 0 ] ) {
			$elem.replaceWith( obj.$element );
		}
		top.resolve();
	}
	obj.$element.data( 'ooui-infused', obj );
	obj.$element.data( 'ooui-infused-children', infusedChildren );
	// set the 'data-ooui' attribute so we can identify infused widgets
	obj.$element.attr( 'data-ooui', '' );
	// restore dynamic state after the new element is inserted into DOM
	domPromise.done( obj.restorePreInfuseState.bind( obj, state ) );
	return obj;
};

/**
 * Pick out parts of `node`'s DOM to be reused when infusing a widget.
 *
 * This method **must not** make any changes to the DOM, only find interesting pieces and add them
 * to `config` (which should then be returned). Actual DOM juggling should then be done by the
 * constructor, which will be given the enhanced config.
 *
 * @protected
 * @param {HTMLElement} node
 * @param {Object} config
 * @return {Object}
 */
OO.ui.Element.static.reusePreInfuseDOM = function ( node, config ) {
	return config;
};

/**
 * Gather the dynamic state (focus, value of form inputs, scroll position, etc.) of an HTML DOM node
 * (and its children) that represent an Element of the same class and the given configuration,
 * generated by the PHP implementation.
 *
 * This method is called just before `node` is detached from the DOM. The return value of this
 * function will be passed to #restorePreInfuseState after the newly created widget's #$element
 * is inserted into DOM to replace `node`.
 *
 * @protected
 * @param {HTMLElement} node
 * @param {Object} config
 * @return {Object}
 */
OO.ui.Element.static.gatherPreInfuseState = function () {
	return {};
};

/**
 * Get a jQuery function within a specific document.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} context Context to bind the function to
 * @param {jQuery} [$iframe] HTML iframe element that contains the document, omit if document is
 *   not in an iframe
 * @return {Function} Bound jQuery function
 */
OO.ui.Element.static.getJQuery = function ( context, $iframe ) {
	function wrapper( selector ) {
		return $( selector, wrapper.context );
	}

	wrapper.context = this.getDocument( context );

	if ( $iframe ) {
		wrapper.$iframe = $iframe;
	}

	return wrapper;
};

/**
 * Get the document of an element.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Object to get the document for
 * @return {HTMLDocument|null} Document object
 */
OO.ui.Element.static.getDocument = function ( obj ) {
	// jQuery - selections created "offscreen" won't have a context, so .context isn't reliable
	return ( obj[ 0 ] && obj[ 0 ].ownerDocument ) ||
		// Empty jQuery selections might have a context
		obj.context ||
		// HTMLElement
		obj.ownerDocument ||
		// Window
		obj.document ||
		// HTMLDocument
		( obj.nodeType === Node.DOCUMENT_NODE && obj ) ||
		null;
};

/**
 * Get the window of an element or document.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Context to get the window for
 * @return {Window} Window object
 */
OO.ui.Element.static.getWindow = function ( obj ) {
	var doc = this.getDocument( obj );
	return doc.defaultView;
};

/**
 * Get the direction of an element or document.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Context to get the direction for
 * @return {string} Text direction, either 'ltr' or 'rtl'
 */
OO.ui.Element.static.getDir = function ( obj ) {
	var isDoc, isWin;

	if ( obj instanceof $ ) {
		obj = obj[ 0 ];
	}
	isDoc = obj.nodeType === Node.DOCUMENT_NODE;
	isWin = obj.document !== undefined;
	if ( isDoc || isWin ) {
		if ( isWin ) {
			obj = obj.document;
		}
		obj = obj.body;
	}
	return $( obj ).css( 'direction' );
};

/**
 * Get the offset between two frames.
 *
 * TODO: Make this function not use recursion.
 *
 * @static
 * @param {Window} from Window of the child frame
 * @param {Window} [to=window] Window of the parent frame
 * @param {Object} [offset] Offset to start with, used internally
 * @return {Object} Offset object, containing left and top properties
 */
OO.ui.Element.static.getFrameOffset = function ( from, to, offset ) {
	var i, len, frames, frame, rect;

	if ( !to ) {
		to = window;
	}
	if ( !offset ) {
		offset = { top: 0, left: 0 };
	}
	if ( from.parent === from ) {
		return offset;
	}

	// Get iframe element
	frames = from.parent.document.getElementsByTagName( 'iframe' );
	for ( i = 0, len = frames.length; i < len; i++ ) {
		if ( frames[ i ].contentWindow === from ) {
			frame = frames[ i ];
			break;
		}
	}

	// Recursively accumulate offset values
	if ( frame ) {
		rect = frame.getBoundingClientRect();
		offset.left += rect.left;
		offset.top += rect.top;
		if ( from !== to ) {
			this.getFrameOffset( from.parent, offset );
		}
	}
	return offset;
};

/**
 * Get the offset between two elements.
 *
 * The two elements may be in a different frame, but in that case the frame $element is in must
 * be contained in the frame $anchor is in.
 *
 * @static
 * @param {jQuery} $element Element whose position to get
 * @param {jQuery} $anchor Element to get $element's position relative to
 * @return {Object} Translated position coordinates, containing top and left properties
 */
OO.ui.Element.static.getRelativePosition = function ( $element, $anchor ) {
	var iframe, iframePos,
		pos = $element.offset(),
		anchorPos = $anchor.offset(),
		elementDocument = this.getDocument( $element ),
		anchorDocument = this.getDocument( $anchor );

	// If $element isn't in the same document as $anchor, traverse up
	while ( elementDocument !== anchorDocument ) {
		iframe = elementDocument.defaultView.frameElement;
		if ( !iframe ) {
			throw new Error( '$element frame is not contained in $anchor frame' );
		}
		iframePos = $( iframe ).offset();
		pos.left += iframePos.left;
		pos.top += iframePos.top;
		elementDocument = iframe.ownerDocument;
	}
	pos.left -= anchorPos.left;
	pos.top -= anchorPos.top;
	return pos;
};

/**
 * Get element border sizes.
 *
 * @static
 * @param {HTMLElement} el Element to measure
 * @return {Object} Dimensions object with `top`, `left`, `bottom` and `right` properties
 */
OO.ui.Element.static.getBorders = function ( el ) {
	var doc = el.ownerDocument,
		win = doc.defaultView,
		style = win.getComputedStyle( el, null ),
		$el = $( el ),
		top = parseFloat( style ? style.borderTopWidth : $el.css( 'borderTopWidth' ) ) || 0,
		left = parseFloat( style ? style.borderLeftWidth : $el.css( 'borderLeftWidth' ) ) || 0,
		bottom = parseFloat( style ? style.borderBottomWidth : $el.css( 'borderBottomWidth' ) ) || 0,
		right = parseFloat( style ? style.borderRightWidth : $el.css( 'borderRightWidth' ) ) || 0;

	return {
		top: top,
		left: left,
		bottom: bottom,
		right: right
	};
};

/**
 * Get dimensions of an element or window.
 *
 * @static
 * @param {HTMLElement|Window} el Element to measure
 * @return {Object} Dimensions object with `borders`, `scroll`, `scrollbar` and `rect` properties
 */
OO.ui.Element.static.getDimensions = function ( el ) {
	var $el, $win,
		doc = el.ownerDocument || el.document,
		win = doc.defaultView;

	if ( win === el || el === doc.documentElement ) {
		$win = $( win );
		return {
			borders: { top: 0, left: 0, bottom: 0, right: 0 },
			scroll: {
				top: $win.scrollTop(),
				left: $win.scrollLeft()
			},
			scrollbar: { right: 0, bottom: 0 },
			rect: {
				top: 0,
				left: 0,
				bottom: $win.innerHeight(),
				right: $win.innerWidth()
			}
		};
	} else {
		$el = $( el );
		return {
			borders: this.getBorders( el ),
			scroll: {
				top: $el.scrollTop(),
				left: $el.scrollLeft()
			},
			scrollbar: {
				right: $el.innerWidth() - el.clientWidth,
				bottom: $el.innerHeight() - el.clientHeight
			},
			rect: el.getBoundingClientRect()
		};
	}
};

/**
 * Get the number of pixels that an element's content is scrolled to the left.
 *
 * Adapted from <https://github.com/othree/jquery.rtl-scroll-type>.
 * Original code copyright 2012 Wei-Ko Kao, licensed under the MIT License.
 *
 * This function smooths out browser inconsistencies (nicely described in the README at
 * <https://github.com/othree/jquery.rtl-scroll-type>) and produces a result consistent
 * with Firefox's 'scrollLeft', which seems the sanest.
 *
 * @static
 * @method
 * @param {HTMLElement|Window} el Element to measure
 * @return {number} Scroll position from the left.
 *  If the element's direction is LTR, this is a positive number between `0` (initial scroll position)
 *  and `el.scrollWidth - el.clientWidth` (furthest possible scroll position).
 *  If the element's direction is RTL, this is a negative number between `0` (initial scroll position)
 *  and `-el.scrollWidth + el.clientWidth` (furthest possible scroll position).
 */
OO.ui.Element.static.getScrollLeft = ( function () {
	var rtlScrollType = null;

	function test() {
		var $definer = $( '<div>' ).attr( {
				dir: 'rtl',
				style: 'font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;'
			} ).text( 'A' ),
			definer = $definer[ 0 ];

		$definer.appendTo( 'body' );
		if ( definer.scrollLeft > 0 ) {
			// Safari, Chrome
			rtlScrollType = 'default';
		} else {
			definer.scrollLeft = 1;
			if ( definer.scrollLeft === 0 ) {
				// Firefox, old Opera
				rtlScrollType = 'negative';
			} else {
				// Internet Explorer, Edge
				rtlScrollType = 'reverse';
			}
		}
		$definer.remove();
	}

	return function getScrollLeft( el ) {
		var isRoot = el.window === el ||
				el === el.ownerDocument.body ||
				el === el.ownerDocument.documentElement,
			scrollLeft = isRoot ? $( window ).scrollLeft() : el.scrollLeft,
			// All browsers use the correct scroll type ('negative') on the root, so don't
			// do any fixups when looking at the root element
			direction = isRoot ? 'ltr' : $( el ).css( 'direction' );

		if ( direction === 'rtl' ) {
			if ( rtlScrollType === null ) {
				test();
			}
			if ( rtlScrollType === 'reverse' ) {
				scrollLeft = -scrollLeft;
			} else if ( rtlScrollType === 'default' ) {
				scrollLeft = scrollLeft - el.scrollWidth + el.clientWidth;
			}
		}

		return scrollLeft;
	};
}() );

/**
 * Get the root scrollable element of given element's document.
 *
 * On Blink-based browsers (Chrome etc.), `document.documentElement` can't be used to get or set
 * the scrollTop property; instead we have to use `document.body`. Changing and testing the value
 * lets us use 'body' or 'documentElement' based on what is working.
 *
 * https://code.google.com/p/chromium/issues/detail?id=303131
 *
 * @static
 * @param {HTMLElement} el Element to find root scrollable parent for
 * @return {HTMLElement} Scrollable parent, `document.body` or `document.documentElement`
 *     depending on browser
 */
OO.ui.Element.static.getRootScrollableElement = function ( el ) {
	var scrollTop, body;

	if ( OO.ui.scrollableElement === undefined ) {
		body = el.ownerDocument.body;
		scrollTop = body.scrollTop;
		body.scrollTop = 1;

		// In some browsers (observed in Chrome 56 on Linux Mint 18.1),
		// body.scrollTop doesn't become exactly 1, but a fractional value like 0.76
		if ( Math.round( body.scrollTop ) === 1 ) {
			body.scrollTop = scrollTop;
			OO.ui.scrollableElement = 'body';
		} else {
			OO.ui.scrollableElement = 'documentElement';
		}
	}

	return el.ownerDocument[ OO.ui.scrollableElement ];
};

/**
 * Get closest scrollable container.
 *
 * Traverses up until either a scrollable element or the root is reached, in which case the root
 * scrollable element will be returned (see #getRootScrollableElement).
 *
 * @static
 * @param {HTMLElement} el Element to find scrollable container for
 * @param {string} [dimension] Dimension of scrolling to look for; `x`, `y` or omit for either
 * @return {HTMLElement} Closest scrollable container
 */
OO.ui.Element.static.getClosestScrollableContainer = function ( el, dimension ) {
	var i, val,
		// Browsers do not correctly return the computed value of 'overflow' when 'overflow-x' and
		// 'overflow-y' have different values, so we need to check the separate properties.
		props = [ 'overflow-x', 'overflow-y' ],
		$parent = $( el ).parent();

	if ( dimension === 'x' || dimension === 'y' ) {
		props = [ 'overflow-' + dimension ];
	}

	// Special case for the document root (which doesn't really have any scrollable container, since
	// it is the ultimate scrollable container, but this is probably saner than null or exception)
	if ( $( el ).is( 'html, body' ) ) {
		return this.getRootScrollableElement( el );
	}

	while ( $parent.length ) {
		if ( $parent[ 0 ] === this.getRootScrollableElement( el ) ) {
			return $parent[ 0 ];
		}
		i = props.length;
		while ( i-- ) {
			val = $parent.css( props[ i ] );
			// We assume that elements with 'overflow' (in any direction) set to 'hidden' will never be
			// scrolled in that direction, but they can actually be scrolled programatically. The user can
			// unintentionally perform a scroll in such case even if the application doesn't scroll
			// programatically, e.g. when jumping to an anchor, or when using built-in find functionality.
			// This could cause funny issues...
			if ( val === 'auto' || val === 'scroll' ) {
				return $parent[ 0 ];
			}
		}
		$parent = $parent.parent();
	}
	// The element is unattached... return something mostly sane
	return this.getRootScrollableElement( el );
};

/**
 * Scroll element into view.
 *
 * @static
 * @param {HTMLElement} el Element to scroll into view
 * @param {Object} [config] Configuration options
 * @param {string} [config.duration='fast'] jQuery animation duration value
 * @param {string} [config.direction] Scroll in only one direction, e.g. 'x' or 'y', omit
 *  to scroll in both directions
 * @return {jQuery.Promise} Promise which resolves when the scroll is complete
 */
OO.ui.Element.static.scrollIntoView = function ( el, config ) {
	var position, animations, container, $container, elementDimensions, containerDimensions, $window,
		deferred = $.Deferred();

	// Configuration initialization
	config = config || {};

	animations = {};
	container = this.getClosestScrollableContainer( el, config.direction );
	$container = $( container );
	elementDimensions = this.getDimensions( el );
	containerDimensions = this.getDimensions( container );
	$window = $( this.getWindow( el ) );

	// Compute the element's position relative to the container
	if ( $container.is( 'html, body' ) ) {
		// If the scrollable container is the root, this is easy
		position = {
			top: elementDimensions.rect.top,
			bottom: $window.innerHeight() - elementDimensions.rect.bottom,
			left: elementDimensions.rect.left,
			right: $window.innerWidth() - elementDimensions.rect.right
		};
	} else {
		// Otherwise, we have to subtract el's coordinates from container's coordinates
		position = {
			top: elementDimensions.rect.top - ( containerDimensions.rect.top + containerDimensions.borders.top ),
			bottom: containerDimensions.rect.bottom - containerDimensions.borders.bottom - containerDimensions.scrollbar.bottom - elementDimensions.rect.bottom,
			left: elementDimensions.rect.left - ( containerDimensions.rect.left + containerDimensions.borders.left ),
			right: containerDimensions.rect.right - containerDimensions.borders.right - containerDimensions.scrollbar.right - elementDimensions.rect.right
		};
	}

	if ( !config.direction || config.direction === 'y' ) {
		if ( position.top < 0 ) {
			animations.scrollTop = containerDimensions.scroll.top + position.top;
		} else if ( position.top > 0 && position.bottom < 0 ) {
			animations.scrollTop = containerDimensions.scroll.top + Math.min( position.top, -position.bottom );
		}
	}
	if ( !config.direction || config.direction === 'x' ) {
		if ( position.left < 0 ) {
			animations.scrollLeft = containerDimensions.scroll.left + position.left;
		} else if ( position.left > 0 && position.right < 0 ) {
			animations.scrollLeft = containerDimensions.scroll.left + Math.min( position.left, -position.right );
		}
	}
	if ( !$.isEmptyObject( animations ) ) {
		// eslint-disable-next-line jquery/no-animate
		$container.stop( true ).animate( animations, config.duration === undefined ? 'fast' : config.duration );
		$container.queue( function ( next ) {
			deferred.resolve();
			next();
		} );
	} else {
		deferred.resolve();
	}
	return deferred.promise();
};

/**
 * Force the browser to reconsider whether it really needs to render scrollbars inside the element
 * and reserve space for them, because it probably doesn't.
 *
 * Workaround primarily for <https://code.google.com/p/chromium/issues/detail?id=387290>, but also
 * similar bugs in other browsers. "Just" forcing a reflow is not sufficient in all cases, we need
 * to first actually detach (or hide, but detaching is simpler) all children, *then* force a reflow,
 * and then reattach (or show) them back.
 *
 * @static
 * @param {HTMLElement} el Element to reconsider the scrollbars on
 */
OO.ui.Element.static.reconsiderScrollbars = function ( el ) {
	var i, len, scrollLeft, scrollTop, nodes = [];
	// Save scroll position
	scrollLeft = el.scrollLeft;
	scrollTop = el.scrollTop;
	// Detach all children
	while ( el.firstChild ) {
		nodes.push( el.firstChild );
		el.removeChild( el.firstChild );
	}
	// Force reflow
	// eslint-disable-next-line no-void
	void el.offsetHeight;
	// Reattach all children
	for ( i = 0, len = nodes.length; i < len; i++ ) {
		el.appendChild( nodes[ i ] );
	}
	// Restore scroll position (no-op if scrollbars disappeared)
	el.scrollLeft = scrollLeft;
	el.scrollTop = scrollTop;
};

/* Methods */

/**
 * Toggle visibility of an element.
 *
 * @param {boolean} [show] Make element visible, omit to toggle visibility
 * @fires visible
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.toggle = function ( show ) {
	show = show === undefined ? !this.visible : !!show;

	if ( show !== this.isVisible() ) {
		this.visible = show;
		this.$element.toggleClass( 'oo-ui-element-hidden', !this.visible );
		this.emit( 'toggle', show );
	}

	return this;
};

/**
 * Check if element is visible.
 *
 * @return {boolean} element is visible
 */
OO.ui.Element.prototype.isVisible = function () {
	return this.visible;
};

/**
 * Get element data.
 *
 * @return {Mixed} Element data
 */
OO.ui.Element.prototype.getData = function () {
	return this.data;
};

/**
 * Set element data.
 *
 * @param {Mixed} data Element data
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setData = function ( data ) {
	this.data = data;
	return this;
};

/**
 * Set the element has an 'id' attribute.
 *
 * @param {string} id
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setElementId = function ( id ) {
	this.elementId = id;
	this.$element.attr( 'id', id );
	return this;
};

/**
 * Ensure that the element has an 'id' attribute, setting it to an unique value if it's missing,
 * and return its value.
 *
 * @return {string}
 */
OO.ui.Element.prototype.getElementId = function () {
	if ( this.elementId === null ) {
		this.setElementId( OO.ui.generateElementId() );
	}
	return this.elementId;
};

/**
 * Check if element supports one or more methods.
 *
 * @param {string|string[]} methods Method or list of methods to check
 * @return {boolean} All methods are supported
 */
OO.ui.Element.prototype.supports = function ( methods ) {
	var i, len,
		support = 0;

	methods = Array.isArray( methods ) ? methods : [ methods ];
	for ( i = 0, len = methods.length; i < len; i++ ) {
		if ( typeof this[ methods[ i ] ] === 'function' ) {
			support++;
		}
	}

	return methods.length === support;
};

/**
 * Update the theme-provided classes.
 *
 * @localdoc This is called in element mixins and widget classes any time state changes.
 *   Updating is debounced, minimizing overhead of changing multiple attributes and
 *   guaranteeing that theme updates do not occur within an element's constructor
 */
OO.ui.Element.prototype.updateThemeClasses = function () {
	OO.ui.theme.queueUpdateElementClasses( this );
};

/**
 * Get the HTML tag name.
 *
 * Override this method to base the result on instance information.
 *
 * @return {string} HTML tag name
 */
OO.ui.Element.prototype.getTagName = function () {
	return this.constructor.static.tagName;
};

/**
 * Check if the element is attached to the DOM
 *
 * @return {boolean} The element is attached to the DOM
 */
OO.ui.Element.prototype.isElementAttached = function () {
	return $.contains( this.getElementDocument(), this.$element[ 0 ] );
};

/**
 * Get the DOM document.
 *
 * @return {HTMLDocument} Document object
 */
OO.ui.Element.prototype.getElementDocument = function () {
	// Don't cache this in other ways either because subclasses could can change this.$element
	return OO.ui.Element.static.getDocument( this.$element );
};

/**
 * Get the DOM window.
 *
 * @return {Window} Window object
 */
OO.ui.Element.prototype.getElementWindow = function () {
	return OO.ui.Element.static.getWindow( this.$element );
};

/**
 * Get closest scrollable container.
 *
 * @return {HTMLElement} Closest scrollable container
 */
OO.ui.Element.prototype.getClosestScrollableElementContainer = function () {
	return OO.ui.Element.static.getClosestScrollableContainer( this.$element[ 0 ] );
};

/**
 * Get group element is in.
 *
 * @return {OO.ui.mixin.GroupElement|null} Group element, null if none
 */
OO.ui.Element.prototype.getElementGroup = function () {
	return this.elementGroup;
};

/**
 * Set group element is in.
 *
 * @param {OO.ui.mixin.GroupElement|null} group Group element, null if none
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setElementGroup = function ( group ) {
	this.elementGroup = group;
	return this;
};

/**
 * Scroll element into view.
 *
 * @param {Object} [config] Configuration options
 * @return {jQuery.Promise} Promise which resolves when the scroll is complete
 */
OO.ui.Element.prototype.scrollElementIntoView = function ( config ) {
	if (
		!this.isElementAttached() ||
		!this.isVisible() ||
		( this.getElementGroup() && !this.getElementGroup().isVisible() )
	) {
		return $.Deferred().resolve();
	}
	return OO.ui.Element.static.scrollIntoView( this.$element[ 0 ], config );
};

/**
 * Restore the pre-infusion dynamic state for this widget.
 *
 * This method is called after #$element has been inserted into DOM. The parameter is the return
 * value of #gatherPreInfuseState.
 *
 * @protected
 * @param {Object} state
 */
OO.ui.Element.prototype.restorePreInfuseState = function () {
};

/**
 * Wraps an HTML snippet for use with configuration values which default
 * to strings.  This bypasses the default html-escaping done to string
 * values.
 *
 * @class
 *
 * @constructor
 * @param {string} [content] HTML content
 */
OO.ui.HtmlSnippet = function OoUiHtmlSnippet( content ) {
	// Properties
	this.content = content;
};

/* Setup */

OO.initClass( OO.ui.HtmlSnippet );

/* Methods */

/**
 * Render into HTML.
 *
 * @return {string} Unchanged HTML snippet.
 */
OO.ui.HtmlSnippet.prototype.toString = function () {
	return this.content;
};

/**
 * Layouts are containers for elements and are used to arrange other widgets of arbitrary type in a way
 * that is centrally controlled and can be updated dynamically. Layouts can be, and usually are, combined.
 * See {@link OO.ui.FieldsetLayout FieldsetLayout}, {@link OO.ui.FieldLayout FieldLayout}, {@link OO.ui.FormLayout FormLayout},
 * {@link OO.ui.PanelLayout PanelLayout}, {@link OO.ui.StackLayout StackLayout}, {@link OO.ui.PageLayout PageLayout},
 * {@link OO.ui.HorizontalLayout HorizontalLayout}, and {@link OO.ui.BookletLayout BookletLayout} for more information and examples.
 *
 * @abstract
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.Layout = function OoUiLayout( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.Layout.parent.call( this, config );

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Initialization
	this.$element.addClass( 'oo-ui-layout' );
};

/* Setup */

OO.inheritClass( OO.ui.Layout, OO.ui.Element );
OO.mixinClass( OO.ui.Layout, OO.EventEmitter );

/* Methods */

/**
 * Reset scroll offsets
 *
 * @chainable
 * @return {OO.ui.Layout} The layout, for chaining
 */
OO.ui.Layout.prototype.resetScroll = function () {
	this.$element[ 0 ].scrollTop = 0;
	// TODO: Reset scrollLeft in an RTL-aware manner, see OO.ui.Element.static.getScrollLeft.

	return this;
};

/**
 * Widgets are compositions of one or more OOUI elements that users can both view
 * and interact with. All widgets can be configured and modified via a standard API,
 * and their state can change dynamically according to a model.
 *
 * @abstract
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [disabled=false] Disable the widget. Disabled widgets cannot be used and their
 *  appearance reflects this state.
 */
OO.ui.Widget = function OoUiWidget( config ) {
	// Initialize config
	config = $.extend( { disabled: false }, config );

	// Parent constructor
	OO.ui.Widget.parent.call( this, config );

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Properties
	this.disabled = null;
	this.wasDisabled = null;

	// Initialization
	this.$element.addClass( 'oo-ui-widget' );
	this.setDisabled( !!config.disabled );
};

/* Setup */

OO.inheritClass( OO.ui.Widget, OO.ui.Element );
OO.mixinClass( OO.ui.Widget, OO.EventEmitter );

/* Events */

/**
 * @event disable
 *
 * A 'disable' event is emitted when the disabled state of the widget changes
 * (i.e. on disable **and** enable).
 *
 * @param {boolean} disabled Widget is disabled
 */

/**
 * @event toggle
 *
 * A 'toggle' event is emitted when the visibility of the widget changes.
 *
 * @param {boolean} visible Widget is visible
 */

/* Methods */

/**
 * Check if the widget is disabled.
 *
 * @return {boolean} Widget is disabled
 */
OO.ui.Widget.prototype.isDisabled = function () {
	return this.disabled;
};

/**
 * Set the 'disabled' state of the widget.
 *
 * When a widget is disabled, it cannot be used and its appearance is updated to reflect this state.
 *
 * @param {boolean} disabled Disable widget
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.Widget.prototype.setDisabled = function ( disabled ) {
	var isDisabled;

	this.disabled = !!disabled;
	isDisabled = this.isDisabled();
	if ( isDisabled !== this.wasDisabled ) {
		this.$element.toggleClass( 'oo-ui-widget-disabled', isDisabled );
		this.$element.toggleClass( 'oo-ui-widget-enabled', !isDisabled );
		this.$element.attr( 'aria-disabled', isDisabled.toString() );
		this.emit( 'disable', isDisabled );
		this.updateThemeClasses();
	}
	this.wasDisabled = isDisabled;

	return this;
};

/**
 * Update the disabled state, in case of changes in parent widget.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.Widget.prototype.updateDisabled = function () {
	this.setDisabled( this.disabled );
	return this;
};

/**
 * Get an ID of a labelable node which is part of this widget, if any, to be used for `<label for>`
 * value.
 *
 * If this function returns null, the widget should have a meaningful #simulateLabelClick method
 * instead.
 *
 * @return {string|null} The ID of the labelable element
 */
OO.ui.Widget.prototype.getInputId = function () {
	return null;
};

/**
 * Simulate the behavior of clicking on a label (a HTML `<label>` element) bound to this input.
 * HTML only allows `<label>` to act on specific "labelable" elements; complex widgets might need to
 * override this method to provide intuitive, accessible behavior.
 *
 * By default, this does nothing. OO.ui.mixin.TabIndexedElement overrides it for focusable widgets.
 * Individual widgets may override it too.
 *
 * This method is called by OO.ui.LabelWidget and OO.ui.FieldLayout. It should not be called
 * directly.
 */
OO.ui.Widget.prototype.simulateLabelClick = function () {
};

/**
 * Theme logic.
 *
 * @abstract
 * @class
 *
 * @constructor
 */
OO.ui.Theme = function OoUiTheme() {
	this.elementClassesQueue = [];
	this.debouncedUpdateQueuedElementClasses = OO.ui.debounce( this.updateQueuedElementClasses );
};

/* Setup */

OO.initClass( OO.ui.Theme );

/* Methods */

/**
 * Get a list of classes to be applied to a widget.
 *
 * The 'on' and 'off' lists combined MUST contain keys for all classes the theme adds or removes,
 * otherwise state transitions will not work properly.
 *
 * @param {OO.ui.Element} element Element for which to get classes
 * @return {Object.<string,string[]>} Categorized class names with `on` and `off` lists
 */
OO.ui.Theme.prototype.getElementClasses = function () {
	return { on: [], off: [] };
};

/**
 * Update CSS classes provided by the theme.
 *
 * For elements with theme logic hooks, this should be called any time there's a state change.
 *
 * @param {OO.ui.Element} element Element for which to update classes
 */
OO.ui.Theme.prototype.updateElementClasses = function ( element ) {
	var $elements = $( [] ),
		classes = this.getElementClasses( element );

	if ( element.$icon ) {
		$elements = $elements.add( element.$icon );
	}
	if ( element.$indicator ) {
		$elements = $elements.add( element.$indicator );
	}

	$elements
		.removeClass( classes.off )
		.addClass( classes.on );
};

/**
 * @private
 */
OO.ui.Theme.prototype.updateQueuedElementClasses = function () {
	var i;
	for ( i = 0; i < this.elementClassesQueue.length; i++ ) {
		this.updateElementClasses( this.elementClassesQueue[ i ] );
	}
	// Clear the queue
	this.elementClassesQueue = [];
};

/**
 * Queue #updateElementClasses to be called for this element.
 *
 * @localdoc QUnit tests override this method to directly call #queueUpdateElementClasses,
 *   to make them synchronous.
 *
 * @param {OO.ui.Element} element Element for which to update classes
 */
OO.ui.Theme.prototype.queueUpdateElementClasses = function ( element ) {
	// Keep items in the queue unique. Use lastIndexOf to start checking from the end because that's
	// the most common case (this method is often called repeatedly for the same element).
	if ( this.elementClassesQueue.lastIndexOf( element ) !== -1 ) {
		return;
	}
	this.elementClassesQueue.push( element );
	this.debouncedUpdateQueuedElementClasses();
};

/**
 * Get the transition duration in milliseconds for dialogs opening/closing
 *
 * The dialog should be fully rendered this many milliseconds after the
 * ready process has executed.
 *
 * @return {number} Transition duration in milliseconds
 */
OO.ui.Theme.prototype.getDialogTransitionDuration = function () {
	return 0;
};

/**
 * The TabIndexedElement class is an attribute mixin used to add additional functionality to an
 * element created by another class. The mixin provides a ‘tabIndex’ property, which specifies the
 * order in which users will navigate through the focusable elements via the “tab” key.
 *
 *     @example
 *     // TabIndexedElement is mixed into the ButtonWidget class
 *     // to provide a tabIndex property.
 *     var button1 = new OO.ui.ButtonWidget( {
 *             label: 'fourth',
 *             tabIndex: 4
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'second',
 *             tabIndex: 2
 *         } ),
 *         button3 = new OO.ui.ButtonWidget( {
 *             label: 'third',
 *             tabIndex: 3
 *         } ),
 *         button4 = new OO.ui.ButtonWidget( {
 *             label: 'first',
 *             tabIndex: 1
 *         } );
 *     $( document.body ).append( button1.$element, button2.$element, button3.$element, button4.$element );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$tabIndexed] The element that should use the tabindex functionality. By default,
 *  the functionality is applied to the element created by the class ($element). If a different element is specified, the tabindex
 *  functionality will be applied to it instead.
 * @cfg {string|number|null} [tabIndex=0] Number that specifies the element’s position in the tab-navigation
 *  order (e.g., 1 for the first focusable element). Use 0 to use the default navigation order; use -1
 *  to remove the element from the tab-navigation flow.
 */
OO.ui.mixin.TabIndexedElement = function OoUiMixinTabIndexedElement( config ) {
	// Configuration initialization
	config = $.extend( { tabIndex: 0 }, config );

	// Properties
	this.$tabIndexed = null;
	this.tabIndex = null;

	// Events
	this.connect( this, { disable: 'onTabIndexedElementDisable' } );

	// Initialization
	this.setTabIndex( config.tabIndex );
	this.setTabIndexedElement( config.$tabIndexed || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Set the element that should use the tabindex functionality.
 *
 * This method is used to retarget a tabindex mixin so that its functionality applies
 * to the specified element. If an element is currently using the functionality, the mixin’s
 * effect on that element is removed before the new element is set up.
 *
 * @param {jQuery} $tabIndexed Element that should use the tabindex functionality
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.setTabIndexedElement = function ( $tabIndexed ) {
	var tabIndex = this.tabIndex;
	// Remove attributes from old $tabIndexed
	this.setTabIndex( null );
	// Force update of new $tabIndexed
	this.$tabIndexed = $tabIndexed;
	this.tabIndex = tabIndex;
	return this.updateTabIndex();
};

/**
 * Set the value of the tabindex.
 *
 * @param {string|number|null} tabIndex Tabindex value, or `null` for no tabindex
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.setTabIndex = function ( tabIndex ) {
	tabIndex = /^-?\d+$/.test( tabIndex ) ? Number( tabIndex ) : null;

	if ( this.tabIndex !== tabIndex ) {
		this.tabIndex = tabIndex;
		this.updateTabIndex();
	}

	return this;
};

/**
 * Update the `tabindex` attribute, in case of changes to tab index or
 * disabled state.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.updateTabIndex = function () {
	if ( this.$tabIndexed ) {
		if ( this.tabIndex !== null ) {
			// Do not index over disabled elements
			this.$tabIndexed.attr( {
				tabindex: this.isDisabled() ? -1 : this.tabIndex,
				// Support: ChromeVox and NVDA
				// These do not seem to inherit aria-disabled from parent elements
				'aria-disabled': this.isDisabled().toString()
			} );
		} else {
			this.$tabIndexed.removeAttr( 'tabindex aria-disabled' );
		}
	}
	return this;
};

/**
 * Handle disable events.
 *
 * @private
 * @param {boolean} disabled Element is disabled
 */
OO.ui.mixin.TabIndexedElement.prototype.onTabIndexedElementDisable = function () {
	this.updateTabIndex();
};

/**
 * Get the value of the tabindex.
 *
 * @return {number|null} Tabindex value
 */
OO.ui.mixin.TabIndexedElement.prototype.getTabIndex = function () {
	return this.tabIndex;
};

/**
 * Get an ID of a focusable element of this widget, if any, to be used for `<label for>` value.
 *
 * If the element already has an ID then that is returned, otherwise unique ID is
 * generated, set on the element, and returned.
 *
 * @return {string|null} The ID of the focusable element
 */
OO.ui.mixin.TabIndexedElement.prototype.getInputId = function () {
	var id;

	if ( !this.$tabIndexed ) {
		return null;
	}
	if ( !this.isLabelableNode( this.$tabIndexed ) ) {
		return null;
	}

	id = this.$tabIndexed.attr( 'id' );
	if ( id === undefined ) {
		id = OO.ui.generateElementId();
		this.$tabIndexed.attr( 'id', id );
	}

	return id;
};

/**
 * Whether the node is 'labelable' according to the HTML spec
 * (i.e., whether it can be interacted with through a `<label for="…">`).
 * See: <https://html.spec.whatwg.org/multipage/forms.html#category-label>.
 *
 * @private
 * @param {jQuery} $node
 * @return {boolean}
 */
OO.ui.mixin.TabIndexedElement.prototype.isLabelableNode = function ( $node ) {
	var
		labelableTags = [ 'button', 'meter', 'output', 'progress', 'select', 'textarea' ],
		tagName = $node.prop( 'tagName' ).toLowerCase();

	if ( tagName === 'input' && $node.attr( 'type' ) !== 'hidden' ) {
		return true;
	}
	if ( labelableTags.indexOf( tagName ) !== -1 ) {
		return true;
	}
	return false;
};

/**
 * Focus this element.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.focus = function () {
	if ( !this.isDisabled() ) {
		this.$tabIndexed.focus();
	}
	return this;
};

/**
 * Blur this element.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.blur = function () {
	this.$tabIndexed.blur();
	return this;
};

/**
 * @inheritdoc OO.ui.Widget
 */
OO.ui.mixin.TabIndexedElement.prototype.simulateLabelClick = function () {
	this.focus();
};

/**
 * ButtonElement is often mixed into other classes to generate a button, which is a clickable
 * interface element that can be configured with access keys for keyboard interaction.
 * See the [OOUI documentation on MediaWiki] [1] for examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#Buttons
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$button] The button element created by the class.
 *  If this configuration is omitted, the button element will use a generated `<a>`.
 * @cfg {boolean} [framed=true] Render the button with a frame
 */
OO.ui.mixin.ButtonElement = function OoUiMixinButtonElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$button = null;
	this.framed = null;
	this.active = config.active !== undefined && config.active;
	this.onDocumentMouseUpHandler = this.onDocumentMouseUp.bind( this );
	this.onMouseDownHandler = this.onMouseDown.bind( this );
	this.onDocumentKeyUpHandler = this.onDocumentKeyUp.bind( this );
	this.onKeyDownHandler = this.onKeyDown.bind( this );
	this.onClickHandler = this.onClick.bind( this );
	this.onKeyPressHandler = this.onKeyPress.bind( this );

	// Initialization
	this.$element.addClass( 'oo-ui-buttonElement' );
	this.toggleFramed( config.framed === undefined || config.framed );
	this.setButtonElement( config.$button || $( '<a>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.ButtonElement );

/* Static Properties */

/**
 * Cancel mouse down events.
 *
 * This property is usually set to `true` to prevent the focus from changing when the button is clicked.
 * Classes such as {@link OO.ui.mixin.DraggableElement DraggableElement} and {@link OO.ui.ButtonOptionWidget ButtonOptionWidget}
 * use a value of `false` so that dragging behavior is possible and mousedown events can be handled by a
 * parent widget.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.mixin.ButtonElement.static.cancelButtonMouseDownEvents = true;

/* Events */

/**
 * A 'click' event is emitted when the button element is clicked.
 *
 * @event click
 */

/* Methods */

/**
 * Set the button element.
 *
 * This method is used to retarget a button mixin so that its functionality applies to
 * the specified button element instead of the one created by the class. If a button element
 * is already set, the method will remove the mixin’s effect on that element.
 *
 * @param {jQuery} $button Element to use as button
 */
OO.ui.mixin.ButtonElement.prototype.setButtonElement = function ( $button ) {
	if ( this.$button ) {
		this.$button
			.removeClass( 'oo-ui-buttonElement-button' )
			.removeAttr( 'role accesskey' )
			.off( {
				mousedown: this.onMouseDownHandler,
				keydown: this.onKeyDownHandler,
				click: this.onClickHandler,
				keypress: this.onKeyPressHandler
			} );
	}

	this.$button = $button
		.addClass( 'oo-ui-buttonElement-button' )
		.on( {
			mousedown: this.onMouseDownHandler,
			keydown: this.onKeyDownHandler,
			click: this.onClickHandler,
			keypress: this.onKeyPressHandler
		} );

	// Add `role="button"` on `<a>` elements, where it's needed
	// `toUpperCase()` is added for XHTML documents
	if ( this.$button.prop( 'tagName' ).toUpperCase() === 'A' ) {
		this.$button.attr( 'role', 'button' );
	}
};

/**
 * Handles mouse down events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onMouseDown = function ( e ) {
	if ( this.isDisabled() || e.which !== OO.ui.MouseButtons.LEFT ) {
		return;
	}
	this.$element.addClass( 'oo-ui-buttonElement-pressed' );
	// Run the mouseup handler no matter where the mouse is when the button is let go, so we can
	// reliably remove the pressed class
	this.getElementDocument().addEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
	// Prevent change of focus unless specifically configured otherwise
	if ( this.constructor.static.cancelButtonMouseDownEvents ) {
		return false;
	}
};

/**
 * Handles document mouse up events.
 *
 * @protected
 * @param {MouseEvent} e Mouse up event
 */
OO.ui.mixin.ButtonElement.prototype.onDocumentMouseUp = function ( e ) {
	if ( this.isDisabled() || e.which !== OO.ui.MouseButtons.LEFT ) {
		return;
	}
	this.$element.removeClass( 'oo-ui-buttonElement-pressed' );
	// Stop listening for mouseup, since we only needed this once
	this.getElementDocument().removeEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.mixin.ButtonElement.prototype.onMouseUp = function () {
	OO.ui.warnDeprecation( 'onMouseUp is deprecated, use onDocumentMouseUp instead' );
	this.onDocumentMouseUp.apply( this, arguments );
};

/**
 * Handles mouse click events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse click event
 * @fires click
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onClick = function ( e ) {
	if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
		if ( this.emit( 'click' ) ) {
			return false;
		}
	}
};

/**
 * Handles key down events.
 *
 * @protected
 * @param {jQuery.Event} e Key down event
 */
OO.ui.mixin.ButtonElement.prototype.onKeyDown = function ( e ) {
	if ( this.isDisabled() || ( e.which !== OO.ui.Keys.SPACE && e.which !== OO.ui.Keys.ENTER ) ) {
		return;
	}
	this.$element.addClass( 'oo-ui-buttonElement-pressed' );
	// Run the keyup handler no matter where the key is when the button is let go, so we can
	// reliably remove the pressed class
	this.getElementDocument().addEventListener( 'keyup', this.onDocumentKeyUpHandler, true );
};

/**
 * Handles document key up events.
 *
 * @protected
 * @param {KeyboardEvent} e Key up event
 */
OO.ui.mixin.ButtonElement.prototype.onDocumentKeyUp = function ( e ) {
	if ( this.isDisabled() || ( e.which !== OO.ui.Keys.SPACE && e.which !== OO.ui.Keys.ENTER ) ) {
		return;
	}
	this.$element.removeClass( 'oo-ui-buttonElement-pressed' );
	// Stop listening for keyup, since we only needed this once
	this.getElementDocument().removeEventListener( 'keyup', this.onDocumentKeyUpHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.mixin.ButtonElement.prototype.onKeyUp = function () {
	OO.ui.warnDeprecation( 'onKeyUp is deprecated, use onDocumentKeyUp instead' );
	this.onDocumentKeyUp.apply( this, arguments );
};

/**
 * Handles key press events.
 *
 * @protected
 * @param {jQuery.Event} e Key press event
 * @fires click
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onKeyPress = function ( e ) {
	if ( !this.isDisabled() && ( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER ) ) {
		if ( this.emit( 'click' ) ) {
			return false;
		}
	}
};

/**
 * Check if button has a frame.
 *
 * @return {boolean} Button is framed
 */
OO.ui.mixin.ButtonElement.prototype.isFramed = function () {
	return this.framed;
};

/**
 * Render the button with or without a frame. Omit the `framed` parameter to toggle the button frame on and off.
 *
 * @param {boolean} [framed] Make button framed, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ButtonElement.prototype.toggleFramed = function ( framed ) {
	framed = framed === undefined ? !this.framed : !!framed;
	if ( framed !== this.framed ) {
		this.framed = framed;
		this.$element
			.toggleClass( 'oo-ui-buttonElement-frameless', !framed )
			.toggleClass( 'oo-ui-buttonElement-framed', framed );
		this.updateThemeClasses();
	}

	return this;
};

/**
 * Set the button's active state.
 *
 * The active state can be set on:
 *
 *  - {@link OO.ui.ButtonOptionWidget ButtonOptionWidget} when it is selected
 *  - {@link OO.ui.ToggleButtonWidget ToggleButtonWidget} when it is toggle on
 *  - {@link OO.ui.ButtonWidget ButtonWidget} when clicking the button would only refresh the page
 *
 * @protected
 * @param {boolean} value Make button active
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ButtonElement.prototype.setActive = function ( value ) {
	this.active = !!value;
	this.$element.toggleClass( 'oo-ui-buttonElement-active', this.active );
	this.updateThemeClasses();
	return this;
};

/**
 * Check if the button is active
 *
 * @protected
 * @return {boolean} The button is active
 */
OO.ui.mixin.ButtonElement.prototype.isActive = function () {
	return this.active;
};

/**
 * Any OOUI widget that contains other widgets (such as {@link OO.ui.ButtonWidget buttons} or
 * {@link OO.ui.OptionWidget options}) mixes in GroupElement. Adding, removing, and clearing
 * items from the group is done through the interface the class provides.
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Elements/Groups
 *
 * @abstract
 * @mixins OO.EmitterList
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$group] The container element created by the class. If this configuration
 *  is omitted, the group element will use a generated `<div>`.
 */
OO.ui.mixin.GroupElement = function OoUiMixinGroupElement( config ) {
	// Configuration initialization
	config = config || {};

	// Mixin constructors
	OO.EmitterList.call( this, config );

	// Properties
	this.$group = null;

	// Initialization
	this.setGroupElement( config.$group || $( '<div>' ) );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.GroupElement, OO.EmitterList );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the set of selected items changes.
 *
 * @param {OO.ui.Element[]} items Items currently in the group
 */

/* Methods */

/**
 * Set the group element.
 *
 * If an element is already set, items will be moved to the new element.
 *
 * @param {jQuery} $group Element to use as group
 */
OO.ui.mixin.GroupElement.prototype.setGroupElement = function ( $group ) {
	var i, len;

	this.$group = $group;
	for ( i = 0, len = this.items.length; i < len; i++ ) {
		this.$group.append( this.items[ i ].$element );
	}
};

/**
 * Find an item by its data.
 *
 * Only the first item with matching data will be returned. To return all matching items,
 * use the #findItemsFromData method.
 *
 * @param {Object} data Item data to search for
 * @return {OO.ui.Element|null} Item with equivalent data, `null` if none exists
 */
OO.ui.mixin.GroupElement.prototype.findItemFromData = function ( data ) {
	var i, len, item,
		hash = OO.getHash( data );

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		item = this.items[ i ];
		if ( hash === OO.getHash( item.getData() ) ) {
			return item;
		}
	}

	return null;
};

/**
 * Find items by their data.
 *
 * All items with matching data will be returned. To return only the first match, use the #findItemFromData method instead.
 *
 * @param {Object} data Item data to search for
 * @return {OO.ui.Element[]} Items with equivalent data
 */
OO.ui.mixin.GroupElement.prototype.findItemsFromData = function ( data ) {
	var i, len, item,
		hash = OO.getHash( data ),
		items = [];

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		item = this.items[ i ];
		if ( hash === OO.getHash( item.getData() ) ) {
			items.push( item );
		}
	}

	return items;
};

/**
 * Add items to the group.
 *
 * Items will be added to the end of the group array unless the optional `index` parameter specifies
 * a different insertion point. Adding an existing item will move it to the end of the array or the point specified by the `index`.
 *
 * @param {OO.ui.Element[]} items An array of items to add to the group
 * @param {number} [index] Index of the insertion point
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.addItems = function ( items, index ) {

	if ( items.length === 0 ) {
		return this;
	}

	// Mixin method
	OO.EmitterList.prototype.addItems.call( this, items, index );

	this.emit( 'change', this.getItems() );
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.mixin.GroupElement.prototype.moveItem = function ( items, newIndex ) {
	// insertItemElements expects this.items to not have been modified yet, so call before the mixin
	this.insertItemElements( items, newIndex );

	// Mixin method
	newIndex = OO.EmitterList.prototype.moveItem.call( this, items, newIndex );

	return newIndex;
};

/**
 * @inheritdoc
 */
OO.ui.mixin.GroupElement.prototype.insertItem = function ( item, index ) {
	item.setElementGroup( this );
	this.insertItemElements( item, index );

	// Mixin method
	index = OO.EmitterList.prototype.insertItem.call( this, item, index );

	return index;
};

/**
 * Insert elements into the group
 *
 * @private
 * @param {OO.ui.Element} itemWidget Item to insert
 * @param {number} index Insertion index
 */
OO.ui.mixin.GroupElement.prototype.insertItemElements = function ( itemWidget, index ) {
	if ( index === undefined || index < 0 || index >= this.items.length ) {
		this.$group.append( itemWidget.$element );
	} else if ( index === 0 ) {
		this.$group.prepend( itemWidget.$element );
	} else {
		this.items[ index ].$element.before( itemWidget.$element );
	}
};

/**
 * Remove the specified items from a group.
 *
 * Removed items are detached (not removed) from the DOM so that they may be reused.
 * To remove all items from a group, you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.Element[]} items An array of items to remove
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.removeItems = function ( items ) {
	var i, len, item, index;

	if ( items.length === 0 ) {
		return this;
	}

	// Remove specific items elements
	for ( i = 0, len = items.length; i < len; i++ ) {
		item = items[ i ];
		index = this.items.indexOf( item );
		if ( index !== -1 ) {
			item.setElementGroup( null );
			item.$element.detach();
		}
	}

	// Mixin method
	OO.EmitterList.prototype.removeItems.call( this, items );

	this.emit( 'change', this.getItems() );
	return this;
};

/**
 * Clear all items from the group.
 *
 * Cleared items are detached from the DOM, not removed, so that they may be reused.
 * To remove only a subset of items from a group, use the #removeItems method.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.clearItems = function () {
	var i, len;

	// Remove all item elements
	for ( i = 0, len = this.items.length; i < len; i++ ) {
		this.items[ i ].setElementGroup( null );
		this.items[ i ].$element.detach();
	}

	// Mixin method
	OO.EmitterList.prototype.clearItems.call( this );

	this.emit( 'change', this.getItems() );
	return this;
};

/**
 * LabelElement is often mixed into other classes to generate a label, which
 * helps identify the function of an interface element.
 * See the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Labels
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$label] The label element created by the class. If this
 *  configuration is omitted, the label element will use a generated `<span>`.
 * @cfg {jQuery|string|Function|OO.ui.HtmlSnippet} [label] The label text. The label can be specified
 *  as a plaintext string, a jQuery selection of elements, or a function that will produce a string
 *  in the future. See the [OOUI documentation on MediaWiki] [2] for examples.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Labels
 * @cfg {boolean} [invisibleLabel] Whether the label should be visually hidden (but still accessible
 *  to screen-readers).
 */
OO.ui.mixin.LabelElement = function OoUiMixinLabelElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$label = null;
	this.label = null;
	this.invisibleLabel = null;

	// Initialization
	this.setLabel( config.label || this.constructor.static.label );
	this.setLabelElement( config.$label || $( '<span>' ) );
	this.setInvisibleLabel( config.invisibleLabel );
};

/* Setup */

OO.initClass( OO.ui.mixin.LabelElement );

/* Events */

/**
 * @event labelChange
 * @param {string} value
 */

/* Static Properties */

/**
 * The label text. The label can be specified as a plaintext string, a function that will
 * produce a string in the future, or `null` for no label. The static value will
 * be overridden if a label is specified with the #label config option.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.LabelElement.static.label = null;

/* Static methods */

/**
 * Highlight the first occurrence of the query in the given text
 *
 * @param {string} text Text
 * @param {string} query Query to find
 * @param {Function} [compare] Optional string comparator, e.g. Intl.Collator().compare
 * @return {jQuery} Text with the first match of the query
 *  sub-string wrapped in highlighted span
 */
OO.ui.mixin.LabelElement.static.highlightQuery = function ( text, query, compare ) {
	var i, tLen, qLen,
		offset = -1,
		$result = $( '<span>' );

	if ( compare ) {
		tLen = text.length;
		qLen = query.length;
		for ( i = 0; offset === -1 && i <= tLen - qLen; i++ ) {
			if ( compare( query, text.slice( i, i + qLen ) ) === 0 ) {
				offset = i;
			}
		}
	} else {
		offset = text.toLowerCase().indexOf( query.toLowerCase() );
	}

	if ( !query.length || offset === -1 ) {
		$result.text( text );
	} else {
		$result.append(
			document.createTextNode( text.slice( 0, offset ) ),
			$( '<span>' )
				.addClass( 'oo-ui-labelElement-label-highlight' )
				.text( text.slice( offset, offset + query.length ) ),
			document.createTextNode( text.slice( offset + query.length ) )
		);
	}
	return $result.contents();
};

/* Methods */

/**
 * Set the label element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $label Element to use as label
 */
OO.ui.mixin.LabelElement.prototype.setLabelElement = function ( $label ) {
	if ( this.$label ) {
		this.$label.removeClass( 'oo-ui-labelElement-label' ).empty();
	}

	this.$label = $label.addClass( 'oo-ui-labelElement-label' );
	this.setLabelContent( this.label );
};

/**
 * Set the label.
 *
 * An empty string will result in the label being hidden. A string containing only whitespace will
 * be converted to a single `&nbsp;`.
 *
 * @param {jQuery|string|OO.ui.HtmlSnippet|Function|null} label Label nodes; text; a function that returns nodes or
 *  text; or null for no label
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setLabel = function ( label ) {
	label = typeof label === 'function' ? OO.ui.resolveMsg( label ) : label;
	label = ( ( typeof label === 'string' || label instanceof $ ) && label.length ) || ( label instanceof OO.ui.HtmlSnippet && label.toString().length ) ? label : null;

	if ( this.label !== label ) {
		if ( this.$label ) {
			this.setLabelContent( label );
		}
		this.label = label;
		this.emit( 'labelChange' );
	}

	this.$element.toggleClass( 'oo-ui-labelElement', !!this.label && !this.invisibleLabel );

	return this;
};

/**
 * Set whether the label should be visually hidden (but still accessible to screen-readers).
 *
 * @param {boolean} invisibleLabel
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setInvisibleLabel = function ( invisibleLabel ) {
	invisibleLabel = !!invisibleLabel;

	if ( this.invisibleLabel !== invisibleLabel ) {
		this.invisibleLabel = invisibleLabel;
		this.emit( 'labelChange' );
	}

	this.$label.toggleClass( 'oo-ui-labelElement-invisible', this.invisibleLabel );
	// Pretend that there is no label, a lot of CSS has been written with this assumption
	this.$element.toggleClass( 'oo-ui-labelElement', !!this.label && !this.invisibleLabel );

	return this;
};

/**
 * Set the label as plain text with a highlighted query
 *
 * @param {string} text Text label to set
 * @param {string} query Substring of text to highlight
 * @param {Function} [compare] Optional string comparator, e.g. Intl.Collator().compare
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setHighlightedQuery = function ( text, query, compare ) {
	return this.setLabel( this.constructor.static.highlightQuery( text, query, compare ) );
};

/**
 * Get the label.
 *
 * @return {jQuery|string|Function|null} Label nodes; text; a function that returns nodes or
 *  text; or null for no label
 */
OO.ui.mixin.LabelElement.prototype.getLabel = function () {
	return this.label;
};

/**
 * Set the content of the label.
 *
 * Do not call this method until after the label element has been set by #setLabelElement.
 *
 * @private
 * @param {jQuery|string|Function|null} label Label nodes; text; a function that returns nodes or
 *  text; or null for no label
 */
OO.ui.mixin.LabelElement.prototype.setLabelContent = function ( label ) {
	if ( typeof label === 'string' ) {
		if ( label.match( /^\s*$/ ) ) {
			// Convert whitespace only string to a single non-breaking space
			this.$label.html( '&nbsp;' );
		} else {
			this.$label.text( label );
		}
	} else if ( label instanceof OO.ui.HtmlSnippet ) {
		this.$label.html( label.toString() );
	} else if ( label instanceof $ ) {
		this.$label.empty().append( label );
	} else {
		this.$label.empty();
	}
};

/**
 * IconElement is often mixed into other classes to generate an icon.
 * Icons are graphics, about the size of normal text. They are used to aid the user
 * in locating a control or to convey information in a space-efficient way. See the
 * [OOUI documentation on MediaWiki] [1] for a list of icons
 * included in the library.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$icon] The icon element created by the class. If this configuration is omitted,
 *  the icon element will use a generated `<span>`. To use a different HTML tag, or to specify that
 *  the icon element be set to an existing icon instead of the one generated by this class, set a
 *  value using a jQuery selection. For example:
 *
 *      // Use a <div> tag instead of a <span>
 *     $icon: $( '<div>' )
 *     // Use an existing icon element instead of the one generated by the class
 *     $icon: this.$element
 *     // Use an icon element from a child widget
 *     $icon: this.childwidget.$element
 * @cfg {Object|string} [icon=''] The symbolic name of the icon (e.g., ‘remove’ or ‘menu’), or a map of
 *  symbolic names.  A map is used for i18n purposes and contains a `default` icon
 *  name and additional names keyed by language code. The `default` name is used when no icon is keyed
 *  by the user's language.
 *
 *  Example of an i18n map:
 *
 *     { default: 'bold-a', en: 'bold-b', de: 'bold-f' }
 *  See the [OOUI documentation on MediaWiki] [2] for a list of icons included in the library.
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 * @cfg {string|Function} [iconTitle] A text string used as the icon title, or a function that returns title
 *  text. The icon title is displayed when users move the mouse over the icon.
 */
OO.ui.mixin.IconElement = function OoUiMixinIconElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$icon = null;
	this.icon = null;
	this.iconTitle = null;

	// `iconTitle`s are deprecated since 0.30.0
	if ( config.iconTitle !== undefined ) {
		OO.ui.warnDeprecation( 'IconElement: Widgets with iconTitle set are deprecated, use title instead. See T76638 for details.' );
	}

	// Initialization
	this.setIcon( config.icon || this.constructor.static.icon );
	this.setIconTitle( config.iconTitle || this.constructor.static.iconTitle );
	this.setIconElement( config.$icon || $( '<span>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.IconElement );

/* Static Properties */

/**
 * The symbolic name of the icon (e.g., ‘remove’ or ‘menu’), or a map of symbolic names. A map is used
 * for i18n purposes and contains a `default` icon name and additional names keyed by
 * language code. The `default` name is used when no icon is keyed by the user's language.
 *
 * Example of an i18n map:
 *
 *     { default: 'bold-a', en: 'bold-b', de: 'bold-f' }
 *
 * Note: the static property will be overridden if the #icon configuration is used.
 *
 * @static
 * @inheritable
 * @property {Object|string}
 */
OO.ui.mixin.IconElement.static.icon = null;

/**
 * The icon title, displayed when users move the mouse over the icon. The value can be text, a
 * function that returns title text, or `null` for no title.
 *
 * The static property will be overridden if the #iconTitle configuration is used.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.IconElement.static.iconTitle = null;

/* Methods */

/**
 * Set the icon element. This method is used to retarget an icon mixin so that its functionality
 * applies to the specified icon element instead of the one created by the class. If an icon
 * element is already set, the mixin’s effect on that element is removed. Generated CSS classes
 * and mixin methods will no longer affect the element.
 *
 * @param {jQuery} $icon Element to use as icon
 */
OO.ui.mixin.IconElement.prototype.setIconElement = function ( $icon ) {
	if ( this.$icon ) {
		this.$icon
			.removeClass( 'oo-ui-iconElement-icon oo-ui-icon-' + this.icon )
			.removeAttr( 'title' );
	}

	this.$icon = $icon
		.addClass( 'oo-ui-iconElement-icon' )
		.toggleClass( 'oo-ui-iconElement-noIcon', !this.icon )
		.toggleClass( 'oo-ui-icon-' + this.icon, !!this.icon );
	if ( this.iconTitle !== null ) {
		this.$icon.attr( 'title', this.iconTitle );
	}

	this.updateThemeClasses();
};

/**
 * Set icon by symbolic name (e.g., ‘remove’ or ‘menu’). Use `null` to remove an icon.
 * The icon parameter can also be set to a map of icon names. See the #icon config setting
 * for an example.
 *
 * @param {Object|string|null} icon A symbolic icon name, a {@link #icon map of icon names} keyed
 *  by language code, or `null` to remove the icon.
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.IconElement.prototype.setIcon = function ( icon ) {
	icon = OO.isPlainObject( icon ) ? OO.ui.getLocalValue( icon, null, 'default' ) : icon;
	icon = typeof icon === 'string' && icon.trim().length ? icon.trim() : null;

	if ( this.icon !== icon ) {
		if ( this.$icon ) {
			if ( this.icon !== null ) {
				this.$icon.removeClass( 'oo-ui-icon-' + this.icon );
			}
			if ( icon !== null ) {
				this.$icon.addClass( 'oo-ui-icon-' + icon );
			}
		}
		this.icon = icon;
	}

	this.$element.toggleClass( 'oo-ui-iconElement', !!this.icon );
	if ( this.$icon ) {
		this.$icon.toggleClass( 'oo-ui-iconElement-noIcon', !this.icon );
	}
	this.updateThemeClasses();

	return this;
};

/**
 * Set the icon title. Use `null` to remove the title.
 *
 * @param {string|Function|null} iconTitle A text string used as the icon title,
 *  a function that returns title text, or `null` for no title.
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @deprecated
 */
OO.ui.mixin.IconElement.prototype.setIconTitle = function ( iconTitle ) {
	iconTitle =
		( typeof iconTitle === 'function' || ( typeof iconTitle === 'string' && iconTitle.length ) ) ?
			OO.ui.resolveMsg( iconTitle ) : null;

	if ( this.iconTitle !== iconTitle ) {
		this.iconTitle = iconTitle;
		if ( this.$icon ) {
			if ( this.iconTitle !== null ) {
				this.$icon.attr( 'title', iconTitle );
			} else {
				this.$icon.removeAttr( 'title' );
			}
		}
	}

	// `setIconTitle is deprecated since 0.30.0
	if ( iconTitle !== null ) {
		// Avoid a warning when this is called from the constructor with no iconTitle set
		OO.ui.warnDeprecation( 'IconElement: setIconTitle is deprecated, use setTitle of TitledElement instead. See T76638 for details.' );
	}

	return this;
};

/**
 * Get the symbolic name of the icon.
 *
 * @return {string} Icon name
 */
OO.ui.mixin.IconElement.prototype.getIcon = function () {
	return this.icon;
};

/**
 * Get the icon title. The title text is displayed when a user moves the mouse over the icon.
 *
 * @return {string} Icon title text
 */
OO.ui.mixin.IconElement.prototype.getIconTitle = function () {
	return this.iconTitle;
};

/**
 * IndicatorElement is often mixed into other classes to generate an indicator.
 * Indicators are small graphics that are generally used in two ways:
 *
 * - To draw attention to the status of an item. For example, an indicator might be
 *   used to show that an item in a list has errors that need to be resolved.
 * - To clarify the function of a control that acts in an exceptional way (a button
 *   that opens a menu instead of performing an action directly, for example).
 *
 * For a list of indicators included in the library, please see the
 * [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$indicator] The indicator element created by the class. If this
 *  configuration is omitted, the indicator element will use a generated `<span>`.
 * @cfg {string} [indicator] Symbolic name of the indicator (e.g., ‘clear’ or ‘down’).
 *  See the [OOUI documentation on MediaWiki][2] for a list of indicators included
 *  in the library.
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 * @cfg {string|Function} [indicatorTitle] A text string used as the indicator title,
 *  or a function that returns title text. The indicator title is displayed when users move
 *  the mouse over the indicator.
 */
OO.ui.mixin.IndicatorElement = function OoUiMixinIndicatorElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$indicator = null;
	this.indicator = null;
	this.indicatorTitle = null;

	// `indicatorTitle`s are deprecated since 0.30.0
	if ( config.indicatorTitle !== undefined ) {
		OO.ui.warnDeprecation( 'IndicatorElement: Widgets with indicatorTitle set are deprecated, use title instead. See T76638 for details.' );
	}

	// Initialization
	this.setIndicator( config.indicator || this.constructor.static.indicator );
	this.setIndicatorTitle( config.indicatorTitle || this.constructor.static.indicatorTitle );
	this.setIndicatorElement( config.$indicator || $( '<span>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.IndicatorElement );

/* Static Properties */

/**
 * Symbolic name of the indicator (e.g., ‘clear’ or  ‘down’).
 * The static property will be overridden if the #indicator configuration is used.
 *
 * @static
 * @inheritable
 * @property {string|null}
 */
OO.ui.mixin.IndicatorElement.static.indicator = null;

/**
 * A text string used as the indicator title, a function that returns title text, or `null`
 * for no title. The static property will be overridden if the #indicatorTitle configuration is used.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.IndicatorElement.static.indicatorTitle = null;

/* Methods */

/**
 * Set the indicator element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $indicator Element to use as indicator
 */
OO.ui.mixin.IndicatorElement.prototype.setIndicatorElement = function ( $indicator ) {
	if ( this.$indicator ) {
		this.$indicator
			.removeClass( 'oo-ui-indicatorElement-indicator oo-ui-indicator-' + this.indicator )
			.removeAttr( 'title' );
	}

	this.$indicator = $indicator
		.addClass( 'oo-ui-indicatorElement-indicator' )
		.toggleClass( 'oo-ui-indicatorElement-noIndicator', !this.indicator )
		.toggleClass( 'oo-ui-indicator-' + this.indicator, !!this.indicator );
	if ( this.indicatorTitle !== null ) {
		this.$indicator.attr( 'title', this.indicatorTitle );
	}

	this.updateThemeClasses();
};

/**
 * Set the indicator by its symbolic name: ‘clear’, ‘down’, ‘required’, ‘search’, ‘up’. Use `null` to remove the indicator.
 *
 * @param {string|null} indicator Symbolic name of indicator, or `null` for no indicator
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.IndicatorElement.prototype.setIndicator = function ( indicator ) {
	indicator = typeof indicator === 'string' && indicator.length ? indicator.trim() : null;

	if ( this.indicator !== indicator ) {
		if ( this.$indicator ) {
			if ( this.indicator !== null ) {
				this.$indicator.removeClass( 'oo-ui-indicator-' + this.indicator );
			}
			if ( indicator !== null ) {
				this.$indicator.addClass( 'oo-ui-indicator-' + indicator );
			}
		}
		this.indicator = indicator;
	}

	this.$element.toggleClass( 'oo-ui-indicatorElement', !!this.indicator );
	if ( this.$indicator ) {
		this.$indicator.toggleClass( 'oo-ui-indicatorElement-noIndicator', !this.indicator );
	}
	this.updateThemeClasses();

	return this;
};

/**
 * Set the indicator title.
 *
 * The title is displayed when a user moves the mouse over the indicator.
 *
 * @param {string|Function|null} indicatorTitle Indicator title text, a function that returns text, or
 *   `null` for no indicator title
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @deprecated
 */
OO.ui.mixin.IndicatorElement.prototype.setIndicatorTitle = function ( indicatorTitle ) {
	indicatorTitle =
		( typeof indicatorTitle === 'function' || ( typeof indicatorTitle === 'string' && indicatorTitle.length ) ) ?
			OO.ui.resolveMsg( indicatorTitle ) : null;

	if ( this.indicatorTitle !== indicatorTitle ) {
		this.indicatorTitle = indicatorTitle;
		if ( this.$indicator ) {
			if ( this.indicatorTitle !== null ) {
				this.$indicator.attr( 'title', indicatorTitle );
			} else {
				this.$indicator.removeAttr( 'title' );
			}
		}
	}

	// `setIndicatorTitle is deprecated since 0.30.0
	if ( indicatorTitle !== null ) {
		// Avoid a warning when this is called from the constructor with no indicatorTitle set
		OO.ui.warnDeprecation( 'IndicatorElement: setIndicatorTitle is deprecated, use setTitle of TitledElement instead. See T76638 for details.' );
	}

	return this;
};

/**
 * Get the symbolic name of the indicator (e.g., ‘clear’ or  ‘down’).
 *
 * @return {string} Symbolic name of indicator
 */
OO.ui.mixin.IndicatorElement.prototype.getIndicator = function () {
	return this.indicator;
};

/**
 * Get the indicator title.
 *
 * The title is displayed when a user moves the mouse over the indicator.
 *
 * @return {string} Indicator title text
 */
OO.ui.mixin.IndicatorElement.prototype.getIndicatorTitle = function () {
	return this.indicatorTitle;
};

/**
 * The FlaggedElement class is an attribute mixin, meaning that it is used to add
 * additional functionality to an element created by another class. The class provides
 * a ‘flags’ property assigned the name (or an array of names) of styling flags,
 * which are used to customize the look and feel of a widget to better describe its
 * importance and functionality.
 *
 * The library currently contains the following styling flags for general use:
 *
 * - **progressive**: Progressive styling is applied to convey that the widget will move the user forward in a process.
 * - **destructive**: Destructive styling is applied to convey that the widget will remove something.
 *
 * The flags affect the appearance of the buttons:
 *
 *     @example
 *     // FlaggedElement is mixed into ButtonWidget to provide styling flags
 *     var button1 = new OO.ui.ButtonWidget( {
 *             label: 'Progressive',
 *             flags: 'progressive'
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'Destructive',
 *             flags: 'destructive'
 *         } );
 *     $( document.body ).append( button1.$element, button2.$element );
 *
 * {@link OO.ui.ActionWidget ActionWidgets}, which are a special kind of button that execute an action, use these flags: **primary** and **safe**.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Elements/Flagged
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string|string[]} [flags] The name or names of the flags (e.g., 'progressive' or 'primary') to apply.
 *  Please see the [OOUI documentation on MediaWiki] [2] for more information about available flags.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Elements/Flagged
 * @cfg {jQuery} [$flagged] The flagged element. By default,
 *  the flagged functionality is applied to the element created by the class ($element).
 *  If a different element is specified, the flagged functionality will be applied to it instead.
 */
OO.ui.mixin.FlaggedElement = function OoUiMixinFlaggedElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.flags = {};
	this.$flagged = null;

	// Initialization
	this.setFlags( config.flags );
	this.setFlaggedElement( config.$flagged || this.$element );
};

/* Events */

/**
 * @event flag
 * A flag event is emitted when the #clearFlags or #setFlags methods are used. The `changes`
 * parameter contains the name of each modified flag and indicates whether it was
 * added or removed.
 *
 * @param {Object.<string,boolean>} changes Object keyed by flag name. A Boolean `true` indicates
 * that the flag was added, `false` that the flag was removed.
 */

/* Methods */

/**
 * Set the flagged element.
 *
 * This method is used to retarget a flagged mixin so that its functionality applies to the specified element.
 * If an element is already set, the method will remove the mixin’s effect on that element.
 *
 * @param {jQuery} $flagged Element that should be flagged
 */
OO.ui.mixin.FlaggedElement.prototype.setFlaggedElement = function ( $flagged ) {
	var classNames = Object.keys( this.flags ).map( function ( flag ) {
		return 'oo-ui-flaggedElement-' + flag;
	} );

	if ( this.$flagged ) {
		this.$flagged.removeClass( classNames );
	}

	this.$flagged = $flagged.addClass( classNames );
};

/**
 * Check if the specified flag is set.
 *
 * @param {string} flag Name of flag
 * @return {boolean} The flag is set
 */
OO.ui.mixin.FlaggedElement.prototype.hasFlag = function ( flag ) {
	// This may be called before the constructor, thus before this.flags is set
	return this.flags && ( flag in this.flags );
};

/**
 * Get the names of all flags set.
 *
 * @return {string[]} Flag names
 */
OO.ui.mixin.FlaggedElement.prototype.getFlags = function () {
	// This may be called before the constructor, thus before this.flags is set
	return Object.keys( this.flags || {} );
};

/**
 * Clear all flags.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @fires flag
 */
OO.ui.mixin.FlaggedElement.prototype.clearFlags = function () {
	var flag, className,
		changes = {},
		remove = [],
		classPrefix = 'oo-ui-flaggedElement-';

	for ( flag in this.flags ) {
		className = classPrefix + flag;
		changes[ flag ] = false;
		delete this.flags[ flag ];
		remove.push( className );
	}

	if ( this.$flagged ) {
		this.$flagged.removeClass( remove );
	}

	this.updateThemeClasses();
	this.emit( 'flag', changes );

	return this;
};

/**
 * Add one or more flags.
 *
 * @param {string|string[]|Object.<string, boolean>} flags A flag name, an array of flag names,
 *  or an object keyed by flag name with a boolean value that indicates whether the flag should
 *  be added (`true`) or removed (`false`).
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @fires flag
 */
OO.ui.mixin.FlaggedElement.prototype.setFlags = function ( flags ) {
	var i, len, flag, className,
		changes = {},
		add = [],
		remove = [],
		classPrefix = 'oo-ui-flaggedElement-';

	if ( typeof flags === 'string' ) {
		className = classPrefix + flags;
		// Set
		if ( !this.flags[ flags ] ) {
			this.flags[ flags ] = true;
			add.push( className );
		}
	} else if ( Array.isArray( flags ) ) {
		for ( i = 0, len = flags.length; i < len; i++ ) {
			flag = flags[ i ];
			className = classPrefix + flag;
			// Set
			if ( !this.flags[ flag ] ) {
				changes[ flag ] = true;
				this.flags[ flag ] = true;
				add.push( className );
			}
		}
	} else if ( OO.isPlainObject( flags ) ) {
		for ( flag in flags ) {
			className = classPrefix + flag;
			if ( flags[ flag ] ) {
				// Set
				if ( !this.flags[ flag ] ) {
					changes[ flag ] = true;
					this.flags[ flag ] = true;
					add.push( className );
				}
			} else {
				// Remove
				if ( this.flags[ flag ] ) {
					changes[ flag ] = false;
					delete this.flags[ flag ];
					remove.push( className );
				}
			}
		}
	}

	if ( this.$flagged ) {
		this.$flagged
			.addClass( add )
			.removeClass( remove );
	}

	this.updateThemeClasses();
	this.emit( 'flag', changes );

	return this;
};

/**
 * TitledElement is mixed into other classes to provide a `title` attribute.
 * Titles are rendered by the browser and are made visible when the user moves
 * the mouse over the element. Titles are not visible on touch devices.
 *
 *     @example
 *     // TitledElement provides a `title` attribute to the
 *     // ButtonWidget class.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with Title',
 *         title: 'I am a button'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$titled] The element to which the `title` attribute is applied.
 *  If this config is omitted, the title functionality is applied to $element, the
 *  element created by the class.
 * @cfg {string|Function} [title] The title text or a function that returns text. If
 *  this config is omitted, the value of the {@link #static-title static title} property is used.
 */
OO.ui.mixin.TitledElement = function OoUiMixinTitledElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$titled = null;
	this.title = null;

	// Initialization
	this.setTitle( config.title !== undefined ? config.title : this.constructor.static.title );
	this.setTitledElement( config.$titled || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * The title text, a function that returns text, or `null` for no title. The value of the static property
 * is overridden if the #title config option is used.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.TitledElement.static.title = null;

/* Methods */

/**
 * Set the titled element.
 *
 * This method is used to retarget a TitledElement mixin so that its functionality applies to the specified element.
 * If an element is already set, the mixin’s effect on that element is removed before the new element is set up.
 *
 * @param {jQuery} $titled Element that should use the 'titled' functionality
 */
OO.ui.mixin.TitledElement.prototype.setTitledElement = function ( $titled ) {
	if ( this.$titled ) {
		this.$titled.removeAttr( 'title' );
	}

	this.$titled = $titled;
	if ( this.title ) {
		this.updateTitle();
	}
};

/**
 * Set title.
 *
 * @param {string|Function|null} title Title text, a function that returns text, or `null` for no title
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TitledElement.prototype.setTitle = function ( title ) {
	title = typeof title === 'function' ? OO.ui.resolveMsg( title ) : title;
	title = ( typeof title === 'string' && title.length ) ? title : null;

	if ( this.title !== title ) {
		this.title = title;
		this.updateTitle();
	}

	return this;
};

/**
 * Update the title attribute, in case of changes to title or accessKey.
 *
 * @protected
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TitledElement.prototype.updateTitle = function () {
	var title = this.getTitle();
	if ( this.$titled ) {
		if ( title !== null ) {
			// Only if this is an AccessKeyedElement
			if ( this.formatTitleWithAccessKey ) {
				title = this.formatTitleWithAccessKey( title );
			}
			this.$titled.attr( 'title', title );
		} else {
			this.$titled.removeAttr( 'title' );
		}
	}
	return this;
};

/**
 * Get title.
 *
 * @return {string} Title string
 */
OO.ui.mixin.TitledElement.prototype.getTitle = function () {
	return this.title;
};

/**
 * AccessKeyedElement is mixed into other classes to provide an `accesskey` HTML attribute.
 * Accesskeys allow an user to go to a specific element by using
 * a shortcut combination of a browser specific keys + the key
 * set to the field.
 *
 *     @example
 *     // AccessKeyedElement provides an `accesskey` attribute to the
 *     // ButtonWidget class.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with Accesskey',
 *         accessKey: 'k'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$accessKeyed] The element to which the `accesskey` attribute is applied.
 *  If this config is omitted, the accesskey functionality is applied to $element, the
 *  element created by the class.
 * @cfg {string|Function} [accessKey] The key or a function that returns the key. If
 *  this config is omitted, no accesskey will be added.
 */
OO.ui.mixin.AccessKeyedElement = function OoUiMixinAccessKeyedElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$accessKeyed = null;
	this.accessKey = null;

	// Initialization
	this.setAccessKey( config.accessKey || null );
	this.setAccessKeyedElement( config.$accessKeyed || this.$element );

	// If this is also a TitledElement and it initialized before we did, we may have
	// to update the title with the access key
	if ( this.updateTitle ) {
		this.updateTitle();
	}
};

/* Setup */

OO.initClass( OO.ui.mixin.AccessKeyedElement );

/* Static Properties */

/**
 * The access key, a function that returns a key, or `null` for no accesskey.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.AccessKeyedElement.static.accessKey = null;

/* Methods */

/**
 * Set the accesskeyed element.
 *
 * This method is used to retarget a AccessKeyedElement mixin so that its functionality applies to the specified element.
 * If an element is already set, the mixin's effect on that element is removed before the new element is set up.
 *
 * @param {jQuery} $accessKeyed Element that should use the 'accesskeyed' functionality
 */
OO.ui.mixin.AccessKeyedElement.prototype.setAccessKeyedElement = function ( $accessKeyed ) {
	if ( this.$accessKeyed ) {
		this.$accessKeyed.removeAttr( 'accesskey' );
	}

	this.$accessKeyed = $accessKeyed;
	if ( this.accessKey ) {
		this.$accessKeyed.attr( 'accesskey', this.accessKey );
	}
};

/**
 * Set accesskey.
 *
 * @param {string|Function|null} accessKey Key, a function that returns a key, or `null` for no accesskey
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.AccessKeyedElement.prototype.setAccessKey = function ( accessKey ) {
	accessKey = typeof accessKey === 'string' ? OO.ui.resolveMsg( accessKey ) : null;

	if ( this.accessKey !== accessKey ) {
		if ( this.$accessKeyed ) {
			if ( accessKey !== null ) {
				this.$accessKeyed.attr( 'accesskey', accessKey );
			} else {
				this.$accessKeyed.removeAttr( 'accesskey' );
			}
		}
		this.accessKey = accessKey;

		// Only if this is a TitledElement
		if ( this.updateTitle ) {
			this.updateTitle();
		}
	}

	return this;
};

/**
 * Get accesskey.
 *
 * @return {string} accessKey string
 */
OO.ui.mixin.AccessKeyedElement.prototype.getAccessKey = function () {
	return this.accessKey;
};

/**
 * Add information about the access key to the element's tooltip label.
 * (This is only public for hacky usage in FieldLayout.)
 *
 * @param {string} title Tooltip label for `title` attribute
 * @return {string}
 */
OO.ui.mixin.AccessKeyedElement.prototype.formatTitleWithAccessKey = function ( title ) {
	var accessKey;

	if ( !this.$accessKeyed ) {
		// Not initialized yet; the constructor will call updateTitle() which will rerun this function
		return title;
	}
	// Use jquery.accessKeyLabel if available to show modifiers, otherwise just display the single key
	if ( $.fn.updateTooltipAccessKeys && $.fn.updateTooltipAccessKeys.getAccessKeyLabel ) {
		accessKey = $.fn.updateTooltipAccessKeys.getAccessKeyLabel( this.$accessKeyed[ 0 ] );
	} else {
		accessKey = this.getAccessKey();
	}
	if ( accessKey ) {
		title += ' [' + accessKey + ']';
	}
	return title;
};

/**
 * ButtonWidget is a generic widget for buttons. A wide variety of looks,
 * feels, and functionality can be customized via the class’s configuration options
 * and methods. Please see the [OOUI documentation on MediaWiki] [1] for more information
 * and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches
 *
 *     @example
 *     // A button widget.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with Icon',
 *         icon: 'trash',
 *         title: 'Remove'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * NOTE: HTML form buttons should use the OO.ui.ButtonInputWidget class.
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [active=false] Whether button should be shown as active
 * @cfg {string} [href] Hyperlink to visit when the button is clicked.
 * @cfg {string} [target] The frame or window in which to open the hyperlink.
 * @cfg {boolean} [noFollow] Search engine traversal hint (default: true)
 */
OO.ui.ButtonWidget = function OoUiButtonWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ButtonWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ButtonElement.call( this, config );
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$button } ) );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$button } ) );
	OO.ui.mixin.AccessKeyedElement.call( this, $.extend( {}, config, { $accessKeyed: this.$button } ) );

	// Properties
	this.href = null;
	this.target = null;
	this.noFollow = false;

	// Events
	this.connect( this, { disable: 'onDisable' } );

	// Initialization
	this.$button.append( this.$icon, this.$label, this.$indicator );
	this.$element
		.addClass( 'oo-ui-buttonWidget' )
		.append( this.$button );
	this.setActive( config.active );
	this.setHref( config.href );
	this.setTarget( config.target );
	this.setNoFollow( config.noFollow );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.AccessKeyedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonWidget.static.cancelButtonMouseDownEvents = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonWidget.static.tagName = 'span';

/* Methods */

/**
 * Get hyperlink location.
 *
 * @return {string} Hyperlink location
 */
OO.ui.ButtonWidget.prototype.getHref = function () {
	return this.href;
};

/**
 * Get hyperlink target.
 *
 * @return {string} Hyperlink target
 */
OO.ui.ButtonWidget.prototype.getTarget = function () {
	return this.target;
};

/**
 * Get search engine traversal hint.
 *
 * @return {boolean} Whether search engines should avoid traversing this hyperlink
 */
OO.ui.ButtonWidget.prototype.getNoFollow = function () {
	return this.noFollow;
};

/**
 * Set hyperlink location.
 *
 * @param {string|null} href Hyperlink location, null to remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setHref = function ( href ) {
	href = typeof href === 'string' ? href : null;
	if ( href !== null && !OO.ui.isSafeUrl( href ) ) {
		href = './' + href;
	}

	if ( href !== this.href ) {
		this.href = href;
		this.updateHref();
	}

	return this;
};

/**
 * Update the `href` attribute, in case of changes to href or
 * disabled state.
 *
 * @private
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.updateHref = function () {
	if ( this.href !== null && !this.isDisabled() ) {
		this.$button.attr( 'href', this.href );
	} else {
		this.$button.removeAttr( 'href' );
	}

	return this;
};

/**
 * Handle disable events.
 *
 * @private
 * @param {boolean} disabled Element is disabled
 */
OO.ui.ButtonWidget.prototype.onDisable = function () {
	this.updateHref();
};

/**
 * Set hyperlink target.
 *
 * @param {string|null} target Hyperlink target, null to remove
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setTarget = function ( target ) {
	target = typeof target === 'string' ? target : null;

	if ( target !== this.target ) {
		this.target = target;
		if ( target !== null ) {
			this.$button.attr( 'target', target );
		} else {
			this.$button.removeAttr( 'target' );
		}
	}

	return this;
};

/**
 * Set search engine traversal hint.
 *
 * @param {boolean} noFollow True if search engines should avoid traversing this hyperlink
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setNoFollow = function ( noFollow ) {
	noFollow = typeof noFollow === 'boolean' ? noFollow : true;

	if ( noFollow !== this.noFollow ) {
		this.noFollow = noFollow;
		if ( noFollow ) {
			this.$button.attr( 'rel', 'nofollow' );
		} else {
			this.$button.removeAttr( 'rel' );
		}
	}

	return this;
};

// Override method visibility hints from ButtonElement
/**
 * @method setActive
 * @inheritdoc
 */
/**
 * @method isActive
 * @inheritdoc
 */

/**
 * A ButtonGroupWidget groups related buttons and is used together with OO.ui.ButtonWidget and
 * its subclasses. Each button in a group is addressed by a unique reference. Buttons can be added,
 * removed, and cleared from the group.
 *
 *     @example
 *     // A ButtonGroupWidget with two buttons.
 *     var button1 = new OO.ui.PopupButtonWidget( {
 *             label: 'Select a category',
 *             icon: 'menu',
 *             popup: {
 *                 $content: $( '<p>List of categories…</p>' ),
 *                 padded: true,
 *                 align: 'left'
 *             }
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'Add item'
 *         } ),
 *         buttonGroup = new OO.ui.ButtonGroupWidget( {
 *             items: [ button1, button2 ]
 *         } );
 *     $( document.body ).append( buttonGroup.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.ButtonWidget[]} [items] Buttons to add
 */
OO.ui.ButtonGroupWidget = function OoUiButtonGroupWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ButtonGroupWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, $.extend( {}, config, { $group: this.$element } ) );
	OO.ui.mixin.TitledElement.call( this, config );

	// Initialization
	this.$element.addClass( 'oo-ui-buttonGroupWidget' );
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.ButtonGroupWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ButtonGroupWidget, OO.ui.mixin.GroupElement );
OO.mixinClass( OO.ui.ButtonGroupWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonGroupWidget.static.tagName = 'span';

/* Methods */

/**
 * Focus the widget
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonGroupWidget.prototype.focus = function () {
	if ( !this.isDisabled() ) {
		if ( this.items[ 0 ] ) {
			this.items[ 0 ].focus();
		}
	}
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.ButtonGroupWidget.prototype.simulateLabelClick = function () {
	this.focus();
};

/**
 * IconWidget is a generic widget for {@link OO.ui.mixin.IconElement icons}. In general, IconWidgets should be used with OO.ui.LabelWidget,
 * which creates a label that identifies the icon’s function. See the [OOUI documentation on MediaWiki] [1]
 * for a list of icons included in the library.
 *
 *     @example
 *     // An IconWidget with a label via LabelWidget.
 *     var myIcon = new OO.ui.IconWidget( {
 *             icon: 'help',
 *             title: 'Help'
 *          } ),
 *          // Create a label.
 *          iconLabel = new OO.ui.LabelWidget( {
 *              label: 'Help'
 *          } );
 *      $( document.body ).append( myIcon.$element, iconLabel.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.IconWidget = function OoUiIconWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.IconWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, $.extend( {}, config, { $icon: this.$element } ) );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$element } ) );
	OO.ui.mixin.LabelElement.call( this, $.extend( {}, config, { $label: this.$element, invisibleLabel: true } ) );
	OO.ui.mixin.FlaggedElement.call( this, $.extend( {}, config, { $flagged: this.$element } ) );

	// Initialization
	this.$element.addClass( 'oo-ui-iconWidget' );
	// Remove class added by LabelElement initialization. It causes unexpected CSS to apply when
	// nested in other widgets, because this widget used to not mix in LabelElement.
	this.$element.removeClass( 'oo-ui-labelElement-label' );
};

/* Setup */

OO.inheritClass( OO.ui.IconWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.FlaggedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.IconWidget.static.tagName = 'span';

/**
 * IndicatorWidgets create indicators, which are small graphics that are generally used to draw
 * attention to the status of an item or to clarify the function within a control. For a list of
 * indicators included in the library, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // An indicator widget.
 *     var indicator1 = new OO.ui.IndicatorWidget( {
 *             indicator: 'required'
 *         } ),
 *         // Create a fieldset layout to add a label.
 *         fieldset = new OO.ui.FieldsetLayout();
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( indicator1, {
 *             label: 'A required indicator:'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.LabelElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.IndicatorWidget = function OoUiIndicatorWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.IndicatorWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IndicatorElement.call( this, $.extend( {}, config, { $indicator: this.$element } ) );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$element } ) );
	OO.ui.mixin.LabelElement.call( this, $.extend( {}, config, { $label: this.$element, invisibleLabel: true } ) );

	// Initialization
	this.$element.addClass( 'oo-ui-indicatorWidget' );
	// Remove class added by LabelElement initialization. It causes unexpected CSS to apply when
	// nested in other widgets, because this widget used to not mix in LabelElement.
	this.$element.removeClass( 'oo-ui-labelElement-label' );
};

/* Setup */

OO.inheritClass( OO.ui.IndicatorWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.LabelElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.IndicatorWidget.static.tagName = 'span';

/**
 * LabelWidgets help identify the function of interface elements. Each LabelWidget can
 * be configured with a `label` option that is set to a string, a label node, or a function:
 *
 * - String: a plaintext string
 * - jQuery selection: a jQuery selection, used for anything other than a plaintext label, e.g., a
 *   label that includes a link or special styling, such as a gray color or additional graphical elements.
 * - Function: a function that will produce a string in the future. Functions are used
 *   in cases where the value of the label is not currently defined.
 *
 * In addition, the LabelWidget can be associated with an {@link OO.ui.InputWidget input widget}, which
 * will come into focus when the label is clicked.
 *
 *     @example
 *     // Two LabelWidgets.
 *     var label1 = new OO.ui.LabelWidget( {
 *             label: 'plaintext label'
 *         } ),
 *         label2 = new OO.ui.LabelWidget( {
 *             label: $( '<a>' ).attr( 'href', 'default.html' ).text( 'jQuery label' )
 *         } ),
 *         // Create a fieldset layout with fields for each example.
 *         fieldset = new OO.ui.FieldsetLayout();
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( label1 ),
 *         new OO.ui.FieldLayout( label2 )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.InputWidget} [input] {@link OO.ui.InputWidget Input widget} that uses the label.
 *  Clicking the label will focus the specified input field.
 */
OO.ui.LabelWidget = function OoUiLabelWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.LabelWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.LabelElement.call( this, $.extend( {}, config, { $label: this.$element } ) );
	OO.ui.mixin.TitledElement.call( this, config );

	// Properties
	this.input = config.input;

	// Initialization
	if ( this.input ) {
		if ( this.input.getInputId() ) {
			this.$element.attr( 'for', this.input.getInputId() );
		} else {
			this.$label.on( 'click', function () {
				this.input.simulateLabelClick();
			}.bind( this ) );
		}
	}
	this.$element.addClass( 'oo-ui-labelWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.LabelWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.LabelWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.LabelWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.LabelWidget.static.tagName = 'label';

/**
 * PendingElement is a mixin that is used to create elements that notify users that something is happening
 * and that they should wait before proceeding. The pending state is visually represented with a pending
 * texture that appears in the head of a pending {@link OO.ui.ProcessDialog process dialog} or in the input
 * field of a {@link OO.ui.TextInputWidget text input widget}.
 *
 * Currently, {@link OO.ui.ActionWidget Action widgets}, which mix in this class, can also be marked as pending, but only when
 * used in {@link OO.ui.MessageDialog message dialogs}. The behavior is not currently supported for action widgets used
 * in process dialogs.
 *
 *     @example
 *     function MessageDialog( config ) {
 *         MessageDialog.parent.call( this, config );
 *     }
 *     OO.inheritClass( MessageDialog, OO.ui.MessageDialog );
 *
 *     MessageDialog.static.name = 'myMessageDialog';
 *     MessageDialog.static.actions = [
 *         { action: 'save', label: 'Done', flags: 'primary' },
 *         { label: 'Cancel', flags: 'safe' }
 *     ];
 *
 *     MessageDialog.prototype.initialize = function () {
 *         MessageDialog.parent.prototype.initialize.apply( this, arguments );
 *         this.content = new OO.ui.PanelLayout( { padded: true } );
 *         this.content.$element.append( '<p>Click the \'Done\' action widget to see its pending state. Note that action widgets can be marked pending in message dialogs but not process dialogs.</p>' );
 *         this.$body.append( this.content.$element );
 *     };
 *     MessageDialog.prototype.getBodyHeight = function () {
 *         return 100;
 *     }
 *     MessageDialog.prototype.getActionProcess = function ( action ) {
 *         var dialog = this;
 *         if ( action === 'save' ) {
 *             dialog.getActions().get({actions: 'save'})[0].pushPending();
 *             return new OO.ui.Process()
 *             .next( 1000 )
 *             .next( function () {
 *                 dialog.getActions().get({actions: 'save'})[0].popPending();
 *             } );
 *         }
 *         return MessageDialog.parent.prototype.getActionProcess.call( this, action );
 *     };
 *
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *
 *     var dialog = new MessageDialog();
 *     windowManager.addWindows( [ dialog ] );
 *     windowManager.openWindow( dialog );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$pending] Element to mark as pending, defaults to this.$element
 */
OO.ui.mixin.PendingElement = function OoUiMixinPendingElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.pending = 0;
	this.$pending = null;

	// Initialisation
	this.setPendingElement( config.$pending || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.PendingElement );

/* Methods */

/**
 * Set the pending element (and clean up any existing one).
 *
 * @param {jQuery} $pending The element to set to pending.
 */
OO.ui.mixin.PendingElement.prototype.setPendingElement = function ( $pending ) {
	if ( this.$pending ) {
		this.$pending.removeClass( 'oo-ui-pendingElement-pending' );
	}

	this.$pending = $pending;
	if ( this.pending > 0 ) {
		this.$pending.addClass( 'oo-ui-pendingElement-pending' );
	}
};

/**
 * Check if an element is pending.
 *
 * @return {boolean} Element is pending
 */
OO.ui.mixin.PendingElement.prototype.isPending = function () {
	return !!this.pending;
};

/**
 * Increase the pending counter. The pending state will remain active until the counter is zero
 * (i.e., the number of calls to #pushPending and #popPending is the same).
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.PendingElement.prototype.pushPending = function () {
	if ( this.pending === 0 ) {
		this.$pending.addClass( 'oo-ui-pendingElement-pending' );
		this.updateThemeClasses();
	}
	this.pending++;

	return this;
};

/**
 * Decrease the pending counter. The pending state will remain active until the counter is zero
 * (i.e., the number of calls to #pushPending and #popPending is the same).
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.PendingElement.prototype.popPending = function () {
	if ( this.pending === 1 ) {
		this.$pending.removeClass( 'oo-ui-pendingElement-pending' );
		this.updateThemeClasses();
	}
	this.pending = Math.max( 0, this.pending - 1 );

	return this;
};

/**
 * Element that will stick adjacent to a specified container, even when it is inserted elsewhere
 * in the document (for example, in an OO.ui.Window's $overlay).
 *
 * The elements's position is automatically calculated and maintained when window is resized or the
 * page is scrolled. If you reposition the container manually, you have to call #position to make
 * sure the element is still placed correctly.
 *
 * As positioning is only possible when both the element and the container are attached to the DOM
 * and visible, it's only done after you call #togglePositioning. You might want to do this inside
 * the #toggle method to display a floating popup, for example.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$floatable] Node to position, assigned to #$floatable, omit to use #$element
 * @cfg {jQuery} [$floatableContainer] Node to position adjacent to
 * @cfg {string} [verticalPosition='below'] Where to position $floatable vertically:
 *  'below': Directly below $floatableContainer, aligning f's top edge with fC's bottom edge
 *  'above': Directly above $floatableContainer, aligning f's bottom edge with fC's top edge
 *  'top': Align the top edge with $floatableContainer's top edge
 *  'bottom': Align the bottom edge with $floatableContainer's bottom edge
 *  'center': Vertically align the center with $floatableContainer's center
 * @cfg {string} [horizontalPosition='start'] Where to position $floatable horizontally:
 *  'before': Directly before $floatableContainer, aligning f's end edge with fC's start edge
 *  'after': Directly after $floatableContainer, aligning f's start edge with fC's end edge
 *  'start': Align the start (left in LTR, right in RTL) edge with $floatableContainer's start edge
 *  'end': Align the end (right in LTR, left in RTL) edge with $floatableContainer's end edge
 *  'center': Horizontally align the center with $floatableContainer's center
 * @cfg {boolean} [hideWhenOutOfView=true] Whether to hide the floatable element if the container
 *  is out of view
 */
OO.ui.mixin.FloatableElement = function OoUiMixinFloatableElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$floatable = null;
	this.$floatableContainer = null;
	this.$floatableWindow = null;
	this.$floatableClosestScrollable = null;
	this.floatableOutOfView = false;
	this.onFloatableScrollHandler = this.position.bind( this );
	this.onFloatableWindowResizeHandler = this.position.bind( this );

	// Initialization
	this.setFloatableContainer( config.$floatableContainer );
	this.setFloatableElement( config.$floatable || this.$element );
	this.setVerticalPosition( config.verticalPosition || 'below' );
	this.setHorizontalPosition( config.horizontalPosition || 'start' );
	this.hideWhenOutOfView = config.hideWhenOutOfView === undefined ? true : !!config.hideWhenOutOfView;
};

/* Methods */

/**
 * Set floatable element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $floatable Element to make floatable
 */
OO.ui.mixin.FloatableElement.prototype.setFloatableElement = function ( $floatable ) {
	if ( this.$floatable ) {
		this.$floatable.removeClass( 'oo-ui-floatableElement-floatable' );
		this.$floatable.css( { left: '', top: '' } );
	}

	this.$floatable = $floatable.addClass( 'oo-ui-floatableElement-floatable' );
	this.position();
};

/**
 * Set floatable container.
 *
 * The element will be positioned relative to the specified container.
 *
 * @param {jQuery|null} $floatableContainer Container to keep visible, or null to unset
 */
OO.ui.mixin.FloatableElement.prototype.setFloatableContainer = function ( $floatableContainer ) {
	this.$floatableContainer = $floatableContainer;
	if ( this.$floatable ) {
		this.position();
	}
};

/**
 * Change how the element is positioned vertically.
 *
 * @param {string} position 'below', 'above', 'top', 'bottom' or 'center'
 */
OO.ui.mixin.FloatableElement.prototype.setVerticalPosition = function ( position ) {
	if ( [ 'below', 'above', 'top', 'bottom', 'center' ].indexOf( position ) === -1 ) {
		throw new Error( 'Invalid value for vertical position: ' + position );
	}
	if ( this.verticalPosition !== position ) {
		this.verticalPosition = position;
		if ( this.$floatable ) {
			this.position();
		}
	}
};

/**
 * Change how the element is positioned horizontally.
 *
 * @param {string} position 'before', 'after', 'start', 'end' or 'center'
 */
OO.ui.mixin.FloatableElement.prototype.setHorizontalPosition = function ( position ) {
	if ( [ 'before', 'after', 'start', 'end', 'center' ].indexOf( position ) === -1 ) {
		throw new Error( 'Invalid value for horizontal position: ' + position );
	}
	if ( this.horizontalPosition !== position ) {
		this.horizontalPosition = position;
		if ( this.$floatable ) {
			this.position();
		}
	}
};

/**
 * Toggle positioning.
 *
 * Do not turn positioning on until after the element is attached to the DOM and visible.
 *
 * @param {boolean} [positioning] Enable positioning, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.FloatableElement.prototype.togglePositioning = function ( positioning ) {
	var closestScrollableOfContainer;

	if ( !this.$floatable || !this.$floatableContainer ) {
		return this;
	}

	positioning = positioning === undefined ? !this.positioning : !!positioning;

	if ( positioning && !this.warnedUnattached && !this.isElementAttached() ) {
		OO.ui.warnDeprecation( 'FloatableElement#togglePositioning: Before calling this method, the element must be attached to the DOM.' );
		this.warnedUnattached = true;
	}

	if ( this.positioning !== positioning ) {
		this.positioning = positioning;

		closestScrollableOfContainer = OO.ui.Element.static.getClosestScrollableContainer( this.$floatableContainer[ 0 ] );
		// If the scrollable is the root, we have to listen to scroll events
		// on the window because of browser inconsistencies.
		if ( $( closestScrollableOfContainer ).is( 'html, body' ) ) {
			closestScrollableOfContainer = OO.ui.Element.static.getWindow( closestScrollableOfContainer );
		}

		if ( positioning ) {
			this.$floatableWindow = $( this.getElementWindow() );
			this.$floatableWindow.on( 'resize', this.onFloatableWindowResizeHandler );

			this.$floatableClosestScrollable = $( closestScrollableOfContainer );
			this.$floatableClosestScrollable.on( 'scroll', this.onFloatableScrollHandler );

			// Initial position after visible
			this.position();
		} else {
			if ( this.$floatableWindow ) {
				this.$floatableWindow.off( 'resize', this.onFloatableWindowResizeHandler );
				this.$floatableWindow = null;
			}

			if ( this.$floatableClosestScrollable ) {
				this.$floatableClosestScrollable.off( 'scroll', this.onFloatableScrollHandler );
				this.$floatableClosestScrollable = null;
			}

			this.$floatable.css( { left: '', right: '', top: '' } );
		}
	}

	return this;
};

/**
 * Check whether the bottom edge of the given element is within the viewport of the given container.
 *
 * @private
 * @param {jQuery} $element
 * @param {jQuery} $container
 * @return {boolean}
 */
OO.ui.mixin.FloatableElement.prototype.isElementInViewport = function ( $element, $container ) {
	var elemRect, contRect, topEdgeInBounds, bottomEdgeInBounds, leftEdgeInBounds, rightEdgeInBounds,
		startEdgeInBounds, endEdgeInBounds, viewportSpacing,
		direction = $element.css( 'direction' );

	elemRect = $element[ 0 ].getBoundingClientRect();
	if ( $container[ 0 ] === window ) {
		viewportSpacing = OO.ui.getViewportSpacing();
		contRect = {
			top: 0,
			left: 0,
			right: document.documentElement.clientWidth,
			bottom: document.documentElement.clientHeight
		};
		contRect.top += viewportSpacing.top;
		contRect.left += viewportSpacing.left;
		contRect.right -= viewportSpacing.right;
		contRect.bottom -= viewportSpacing.bottom;
	} else {
		contRect = $container[ 0 ].getBoundingClientRect();
	}

	topEdgeInBounds = elemRect.top >= contRect.top && elemRect.top <= contRect.bottom;
	bottomEdgeInBounds = elemRect.bottom >= contRect.top && elemRect.bottom <= contRect.bottom;
	leftEdgeInBounds = elemRect.left >= contRect.left && elemRect.left <= contRect.right;
	rightEdgeInBounds = elemRect.right >= contRect.left && elemRect.right <= contRect.right;
	if ( direction === 'rtl' ) {
		startEdgeInBounds = rightEdgeInBounds;
		endEdgeInBounds = leftEdgeInBounds;
	} else {
		startEdgeInBounds = leftEdgeInBounds;
		endEdgeInBounds = rightEdgeInBounds;
	}

	if ( this.verticalPosition === 'below' && !bottomEdgeInBounds ) {
		return false;
	}
	if ( this.verticalPosition === 'above' && !topEdgeInBounds ) {
		return false;
	}
	if ( this.horizontalPosition === 'before' && !startEdgeInBounds ) {
		return false;
	}
	if ( this.horizontalPosition === 'after' && !endEdgeInBounds ) {
		return false;
	}

	// The other positioning values are all about being inside the container,
	// so in those cases all we care about is that any part of the container is visible.
	return elemRect.top <= contRect.bottom && elemRect.bottom >= contRect.top &&
		elemRect.left <= contRect.right && elemRect.right >= contRect.left;
};

/**
 * Check if the floatable is hidden to the user because it was offscreen.
 *
 * @return {boolean} Floatable is out of view
 */
OO.ui.mixin.FloatableElement.prototype.isFloatableOutOfView = function () {
	return this.floatableOutOfView;
};

/**
 * Position the floatable below its container.
 *
 * This should only be done when both of them are attached to the DOM and visible.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.FloatableElement.prototype.position = function () {
	if ( !this.positioning ) {
		return this;
	}

	if ( !(
		// To continue, some things need to be true:
		// The element must actually be in the DOM
		this.isElementAttached() && (
			// The closest scrollable is the current window
			this.$floatableClosestScrollable[ 0 ] === this.getElementWindow() ||
			// OR is an element in the element's DOM
			$.contains( this.getElementDocument(), this.$floatableClosestScrollable[ 0 ] )
		)
	) ) {
		// Abort early if important parts of the widget are no longer attached to the DOM
		return this;
	}

	this.floatableOutOfView = this.hideWhenOutOfView && !this.isElementInViewport( this.$floatableContainer, this.$floatableClosestScrollable );
	if ( this.floatableOutOfView ) {
		this.$floatable.addClass( 'oo-ui-element-hidden' );
		return this;
	} else {
		this.$floatable.removeClass( 'oo-ui-element-hidden' );
	}

	this.$floatable.css( this.computePosition() );

	// We updated the position, so re-evaluate the clipping state.
	// (ClippableElement does not listen to 'scroll' events on $floatableContainer's parent, and so
	// will not notice the need to update itself.)
	// TODO: This is terrible, we shouldn't need to know about ClippableElement at all here. Why does
	// it not listen to the right events in the right places?
	if ( this.clip ) {
		this.clip();
	}

	return this;
};

/**
 * Compute how #$floatable should be positioned based on the position of #$floatableContainer
 * and the positioning settings. This is a helper for #position that shouldn't be called directly,
 * but may be overridden by subclasses if they want to change or add to the positioning logic.
 *
 * @return {Object} New position to apply with .css(). Keys are 'top', 'left', 'bottom' and 'right'.
 */
OO.ui.mixin.FloatableElement.prototype.computePosition = function () {
	var isBody, scrollableX, scrollableY, containerPos,
		horizScrollbarHeight, vertScrollbarWidth, scrollTop, scrollLeft,
		newPos = { top: '', left: '', bottom: '', right: '' },
		direction = this.$floatableContainer.css( 'direction' ),
		$offsetParent = this.$floatable.offsetParent();

	if ( $offsetParent.is( 'html' ) ) {
		// The innerHeight/Width and clientHeight/Width calculations don't work well on the
		// <html> element, but they do work on the <body>
		$offsetParent = $( $offsetParent[ 0 ].ownerDocument.body );
	}
	isBody = $offsetParent.is( 'body' );
	scrollableX = $offsetParent.css( 'overflow-x' ) === 'scroll' || $offsetParent.css( 'overflow-x' ) === 'auto';
	scrollableY = $offsetParent.css( 'overflow-y' ) === 'scroll' || $offsetParent.css( 'overflow-y' ) === 'auto';

	vertScrollbarWidth = $offsetParent.innerWidth() - $offsetParent.prop( 'clientWidth' );
	horizScrollbarHeight = $offsetParent.innerHeight() - $offsetParent.prop( 'clientHeight' );
	// We don't need to compute and add scrollTop and scrollLeft if the scrollable container is the body,
	// or if it isn't scrollable
	scrollTop = scrollableY && !isBody ? $offsetParent.scrollTop() : 0;
	scrollLeft = scrollableX && !isBody ? OO.ui.Element.static.getScrollLeft( $offsetParent[ 0 ] ) : 0;

	// Avoid passing the <body> to getRelativePosition(), because it won't return what we expect
	// if the <body> has a margin
	containerPos = isBody ?
		this.$floatableContainer.offset() :
		OO.ui.Element.static.getRelativePosition( this.$floatableContainer, $offsetParent );
	containerPos.bottom = containerPos.top + this.$floatableContainer.outerHeight();
	containerPos.right = containerPos.left + this.$floatableContainer.outerWidth();
	containerPos.start = direction === 'rtl' ? containerPos.right : containerPos.left;
	containerPos.end = direction === 'rtl' ? containerPos.left : containerPos.right;

	if ( this.verticalPosition === 'below' ) {
		newPos.top = containerPos.bottom;
	} else if ( this.verticalPosition === 'above' ) {
		newPos.bottom = $offsetParent.outerHeight() - containerPos.top;
	} else if ( this.verticalPosition === 'top' ) {
		newPos.top = containerPos.top;
	} else if ( this.verticalPosition === 'bottom' ) {
		newPos.bottom = $offsetParent.outerHeight() - containerPos.bottom;
	} else if ( this.verticalPosition === 'center' ) {
		newPos.top = containerPos.top +
			( this.$floatableContainer.height() - this.$floatable.height() ) / 2;
	}

	if ( this.horizontalPosition === 'before' ) {
		newPos.end = containerPos.start;
	} else if ( this.horizontalPosition === 'after' ) {
		newPos.start = containerPos.end;
	} else if ( this.horizontalPosition === 'start' ) {
		newPos.start = containerPos.start;
	} else if ( this.horizontalPosition === 'end' ) {
		newPos.end = containerPos.end;
	} else if ( this.horizontalPosition === 'center' ) {
		newPos.left = containerPos.left +
			( this.$floatableContainer.width() - this.$floatable.width() ) / 2;
	}

	if ( newPos.start !== undefined ) {
		if ( direction === 'rtl' ) {
			newPos.right = ( isBody ? $( $offsetParent[ 0 ].ownerDocument.documentElement ) : $offsetParent ).outerWidth() - newPos.start;
		} else {
			newPos.left = newPos.start;
		}
		delete newPos.start;
	}
	if ( newPos.end !== undefined ) {
		if ( direction === 'rtl' ) {
			newPos.left = newPos.end;
		} else {
			newPos.right = ( isBody ? $( $offsetParent[ 0 ].ownerDocument.documentElement ) : $offsetParent ).outerWidth() - newPos.end;
		}
		delete newPos.end;
	}

	// Account for scroll position
	if ( newPos.top !== '' ) {
		newPos.top += scrollTop;
	}
	if ( newPos.bottom !== '' ) {
		newPos.bottom -= scrollTop;
	}
	if ( newPos.left !== '' ) {
		newPos.left += scrollLeft;
	}
	if ( newPos.right !== '' ) {
		newPos.right -= scrollLeft;
	}

	// Account for scrollbar gutter
	if ( newPos.bottom !== '' ) {
		newPos.bottom -= horizScrollbarHeight;
	}
	if ( direction === 'rtl' ) {
		if ( newPos.left !== '' ) {
			newPos.left -= vertScrollbarWidth;
		}
	} else {
		if ( newPos.right !== '' ) {
			newPos.right -= vertScrollbarWidth;
		}
	}

	return newPos;
};

/**
 * Element that can be automatically clipped to visible boundaries.
 *
 * Whenever the element's natural height changes, you have to call
 * {@link OO.ui.mixin.ClippableElement#clip} to make sure it's still
 * clipping correctly.
 *
 * The dimensions of #$clippableContainer will be compared to the boundaries of the
 * nearest scrollable container. If #$clippableContainer is too tall and/or too wide,
 * then #$clippable will be given a fixed reduced height and/or width and will be made
 * scrollable. By default, #$clippable and #$clippableContainer are the same element,
 * but you can build a static footer by setting #$clippableContainer to an element that contains
 * #$clippable and the footer.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$clippable] Node to clip, assigned to #$clippable, omit to use #$element
 * @cfg {jQuery} [$clippableContainer] Node to keep visible, assigned to #$clippableContainer,
 *   omit to use #$clippable
 */
OO.ui.mixin.ClippableElement = function OoUiMixinClippableElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.$clippable = null;
	this.$clippableContainer = null;
	this.clipping = false;
	this.clippedHorizontally = false;
	this.clippedVertically = false;
	this.$clippableScrollableContainer = null;
	this.$clippableScroller = null;
	this.$clippableWindow = null;
	this.idealWidth = null;
	this.idealHeight = null;
	this.onClippableScrollHandler = this.clip.bind( this );
	this.onClippableWindowResizeHandler = this.clip.bind( this );

	// Initialization
	if ( config.$clippableContainer ) {
		this.setClippableContainer( config.$clippableContainer );
	}
	this.setClippableElement( config.$clippable || this.$element );
};

/* Methods */

/**
 * Set clippable element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $clippable Element to make clippable
 */
OO.ui.mixin.ClippableElement.prototype.setClippableElement = function ( $clippable ) {
	if ( this.$clippable ) {
		this.$clippable.removeClass( 'oo-ui-clippableElement-clippable' );
		this.$clippable.css( { width: '', height: '', overflowX: '', overflowY: '' } );
		OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );
	}

	this.$clippable = $clippable.addClass( 'oo-ui-clippableElement-clippable' );
	this.clip();
};

/**
 * Set clippable container.
 *
 * This is the container that will be measured when deciding whether to clip. When clipping,
 * #$clippable will be resized in order to keep the clippable container fully visible.
 *
 * If the clippable container is unset, #$clippable will be used.
 *
 * @param {jQuery|null} $clippableContainer Container to keep visible, or null to unset
 */
OO.ui.mixin.ClippableElement.prototype.setClippableContainer = function ( $clippableContainer ) {
	this.$clippableContainer = $clippableContainer;
	if ( this.$clippable ) {
		this.clip();
	}
};

/**
 * Toggle clipping.
 *
 * Do not turn clipping on until after the element is attached to the DOM and visible.
 *
 * @param {boolean} [clipping] Enable clipping, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ClippableElement.prototype.toggleClipping = function ( clipping ) {
	clipping = clipping === undefined ? !this.clipping : !!clipping;

	if ( clipping && !this.warnedUnattached && !this.isElementAttached() ) {
		OO.ui.warnDeprecation( 'ClippableElement#toggleClipping: Before calling this method, the element must be attached to the DOM.' );
		this.warnedUnattached = true;
	}

	if ( this.clipping !== clipping ) {
		this.clipping = clipping;
		if ( clipping ) {
			this.$clippableScrollableContainer = $( this.getClosestScrollableElementContainer() );
			// If the clippable container is the root, we have to listen to scroll events and check
			// jQuery.scrollTop on the window because of browser inconsistencies
			this.$clippableScroller = this.$clippableScrollableContainer.is( 'html, body' ) ?
				$( OO.ui.Element.static.getWindow( this.$clippableScrollableContainer ) ) :
				this.$clippableScrollableContainer;
			this.$clippableScroller.on( 'scroll', this.onClippableScrollHandler );
			this.$clippableWindow = $( this.getElementWindow() )
				.on( 'resize', this.onClippableWindowResizeHandler );
			// Initial clip after visible
			this.clip();
		} else {
			this.$clippable.css( {
				width: '',
				height: '',
				maxWidth: '',
				maxHeight: '',
				overflowX: '',
				overflowY: ''
			} );
			OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );

			this.$clippableScrollableContainer = null;
			this.$clippableScroller.off( 'scroll', this.onClippableScrollHandler );
			this.$clippableScroller = null;
			this.$clippableWindow.off( 'resize', this.onClippableWindowResizeHandler );
			this.$clippableWindow = null;
		}
	}

	return this;
};

/**
 * Check if the element will be clipped to fit the visible area of the nearest scrollable container.
 *
 * @return {boolean} Element will be clipped to the visible area
 */
OO.ui.mixin.ClippableElement.prototype.isClipping = function () {
	return this.clipping;
};

/**
 * Check if the bottom or right of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClipped = function () {
	return this.clippedHorizontally || this.clippedVertically;
};

/**
 * Check if the right of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClippedHorizontally = function () {
	return this.clippedHorizontally;
};

/**
 * Check if the bottom of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClippedVertically = function () {
	return this.clippedVertically;
};

/**
 * Set the ideal size. These are the dimensions #$clippable will have when it's not being clipped.
 *
 * @param {number|string} [width] Width as a number of pixels or CSS string with unit suffix
 * @param {number|string} [height] Height as a number of pixels or CSS string with unit suffix
 */
OO.ui.mixin.ClippableElement.prototype.setIdealSize = function ( width, height ) {
	this.idealWidth = width;
	this.idealHeight = height;

	if ( !this.clipping ) {
		// Update dimensions
		this.$clippable.css( { width: width, height: height } );
	}
	// While clipping, idealWidth and idealHeight are not considered
};

/**
 * Return the side of the clippable on which it is "anchored" (aligned to something else).
 * ClippableElement will clip the opposite side when reducing element's width.
 *
 * Classes that mix in ClippableElement should override this to return 'right' if their
 * clippable is absolutely positioned and using 'right: Npx' (and not using 'left').
 * If your class also mixes in FloatableElement, this is handled automatically.
 *
 * (This can't be guessed from the actual CSS because the computed values for 'left'/'right' are
 * always in pixels, even if they were unset or set to 'auto'.)
 *
 * When in doubt, 'left' (or 'right' in RTL) is a sane fallback.
 *
 * @return {string} 'left' or 'right'
 */
OO.ui.mixin.ClippableElement.prototype.getHorizontalAnchorEdge = function () {
	if ( this.computePosition && this.positioning && this.computePosition().right !== '' ) {
		return 'right';
	}
	return 'left';
};

/**
 * Return the side of the clippable on which it is "anchored" (aligned to something else).
 * ClippableElement will clip the opposite side when reducing element's width.
 *
 * Classes that mix in ClippableElement should override this to return 'bottom' if their
 * clippable is absolutely positioned and using 'bottom: Npx' (and not using 'top').
 * If your class also mixes in FloatableElement, this is handled automatically.
 *
 * (This can't be guessed from the actual CSS because the computed values for 'left'/'right' are
 * always in pixels, even if they were unset or set to 'auto'.)
 *
 * When in doubt, 'top' is a sane fallback.
 *
 * @return {string} 'top' or 'bottom'
 */
OO.ui.mixin.ClippableElement.prototype.getVerticalAnchorEdge = function () {
	if ( this.computePosition && this.positioning && this.computePosition().bottom !== '' ) {
		return 'bottom';
	}
	return 'top';
};

/**
 * Clip element to visible boundaries and allow scrolling when needed. You should call this method
 * when the element's natural height changes.
 *
 * Element will be clipped the bottom or right of the element is within 10px of the edge of, or
 * overlapped by, the visible area of the nearest scrollable container.
 *
 * Because calling clip() when the natural height changes isn't always possible, we also set
 * max-height when the element isn't being clipped. This means that if the element tries to grow
 * beyond the edge, something reasonable will happen before clip() is called.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ClippableElement.prototype.clip = function () {
	var extraHeight, extraWidth, viewportSpacing,
		desiredWidth, desiredHeight, allotedWidth, allotedHeight,
		naturalWidth, naturalHeight, clipWidth, clipHeight,
		$item, itemRect, $viewport, viewportRect, availableRect,
		direction, vertScrollbarWidth, horizScrollbarHeight,
		// Extra tolerance so that the sloppy code below doesn't result in results that are off
		// by one or two pixels. (And also so that we have space to display drop shadows.)
		// Chosen by fair dice roll.
		buffer = 7;

	if ( !this.clipping ) {
		// this.$clippableScrollableContainer and this.$clippableWindow are null, so the below will fail
		return this;
	}

	function rectIntersection( a, b ) {
		var out = {};
		out.top = Math.max( a.top, b.top );
		out.left = Math.max( a.left, b.left );
		out.bottom = Math.min( a.bottom, b.bottom );
		out.right = Math.min( a.right, b.right );
		return out;
	}

	viewportSpacing = OO.ui.getViewportSpacing();

	if ( this.$clippableScrollableContainer.is( 'html, body' ) ) {
		$viewport = $( this.$clippableScrollableContainer[ 0 ].ownerDocument.body );
		// Dimensions of the browser window, rather than the element!
		viewportRect = {
			top: 0,
			left: 0,
			right: document.documentElement.clientWidth,
			bottom: document.documentElement.clientHeight
		};
		viewportRect.top += viewportSpacing.top;
		viewportRect.left += viewportSpacing.left;
		viewportRect.right -= viewportSpacing.right;
		viewportRect.bottom -= viewportSpacing.bottom;
	} else {
		$viewport = this.$clippableScrollableContainer;
		viewportRect = $viewport[ 0 ].getBoundingClientRect();
		// Convert into a plain object
		viewportRect = $.extend( {}, viewportRect );
	}

	// Account for scrollbar gutter
	direction = $viewport.css( 'direction' );
	vertScrollbarWidth = $viewport.innerWidth() - $viewport.prop( 'clientWidth' );
	horizScrollbarHeight = $viewport.innerHeight() - $viewport.prop( 'clientHeight' );
	viewportRect.bottom -= horizScrollbarHeight;
	if ( direction === 'rtl' ) {
		viewportRect.left += vertScrollbarWidth;
	} else {
		viewportRect.right -= vertScrollbarWidth;
	}

	// Add arbitrary tolerance
	viewportRect.top += buffer;
	viewportRect.left += buffer;
	viewportRect.right -= buffer;
	viewportRect.bottom -= buffer;

	$item = this.$clippableContainer || this.$clippable;

	extraHeight = $item.outerHeight() - this.$clippable.outerHeight();
	extraWidth = $item.outerWidth() - this.$clippable.outerWidth();

	itemRect = $item[ 0 ].getBoundingClientRect();
	// Convert into a plain object
	itemRect = $.extend( {}, itemRect );

	// Item might already be clipped, so we can't just use its dimensions (in case we might need to
	// make it larger than before). Extend the rectangle to the maximum size we are allowed to take.
	if ( this.getHorizontalAnchorEdge() === 'right' ) {
		itemRect.left = viewportRect.left;
	} else {
		itemRect.right = viewportRect.right;
	}
	if ( this.getVerticalAnchorEdge() === 'bottom' ) {
		itemRect.top = viewportRect.top;
	} else {
		itemRect.bottom = viewportRect.bottom;
	}

	availableRect = rectIntersection( viewportRect, itemRect );

	desiredWidth = Math.max( 0, availableRect.right - availableRect.left );
	desiredHeight = Math.max( 0, availableRect.bottom - availableRect.top );
	// It should never be desirable to exceed the dimensions of the browser viewport... right?
	desiredWidth = Math.min( desiredWidth,
		document.documentElement.clientWidth - viewportSpacing.left - viewportSpacing.right );
	desiredHeight = Math.min( desiredHeight,
		document.documentElement.clientHeight - viewportSpacing.top - viewportSpacing.right );
	allotedWidth = Math.ceil( desiredWidth - extraWidth );
	allotedHeight = Math.ceil( desiredHeight - extraHeight );
	naturalWidth = this.$clippable.prop( 'scrollWidth' );
	naturalHeight = this.$clippable.prop( 'scrollHeight' );
	clipWidth = allotedWidth < naturalWidth;
	clipHeight = allotedHeight < naturalHeight;

	if ( clipWidth ) {
		// The order matters here. If overflow is not set first, Chrome displays bogus scrollbars. See T157672.
		// Forcing a reflow is a smaller workaround than calling reconsiderScrollbars() for this case.
		this.$clippable.css( 'overflowX', 'scroll' );
		// eslint-disable-next-line no-void
		void this.$clippable[ 0 ].offsetHeight; // Force reflow
		this.$clippable.css( {
			width: Math.max( 0, allotedWidth ),
			maxWidth: ''
		} );
	} else {
		this.$clippable.css( {
			overflowX: '',
			width: this.idealWidth || '',
			maxWidth: Math.max( 0, allotedWidth )
		} );
	}
	if ( clipHeight ) {
		// The order matters here. If overflow is not set first, Chrome displays bogus scrollbars. See T157672.
		// Forcing a reflow is a smaller workaround than calling reconsiderScrollbars() for this case.
		this.$clippable.css( 'overflowY', 'scroll' );
		// eslint-disable-next-line no-void
		void this.$clippable[ 0 ].offsetHeight; // Force reflow
		this.$clippable.css( {
			height: Math.max( 0, allotedHeight ),
			maxHeight: ''
		} );
	} else {
		this.$clippable.css( {
			overflowY: '',
			height: this.idealHeight || '',
			maxHeight: Math.max( 0, allotedHeight )
		} );
	}

	// If we stopped clipping in at least one of the dimensions
	if ( ( this.clippedHorizontally && !clipWidth ) || ( this.clippedVertically && !clipHeight ) ) {
		OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );
	}

	this.clippedHorizontally = clipWidth;
	this.clippedVertically = clipHeight;

	return this;
};

/**
 * PopupWidget is a container for content. The popup is overlaid and positioned absolutely.
 * By default, each popup has an anchor that points toward its origin.
 * Please see the [OOUI documentation on MediaWiki.org] [1] for more information and examples.
 *
 * Unlike most widgets, PopupWidget is initially hidden and must be shown by calling #toggle.
 *
 *     @example
 *     // A PopupWidget.
 *     var popup = new OO.ui.PopupWidget( {
 *         $content: $( '<p>Hi there!</p>' ),
 *         padded: true,
 *         width: 300
 *     } );
 *
 *     $( document.body ).append( popup.$element );
 *     // To display the popup, toggle the visibility to 'true'.
 *     popup.toggle( true );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.ClippableElement
 * @mixins OO.ui.mixin.FloatableElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number|null} [width=320] Width of popup in pixels. Pass `null` to use automatic width.
 * @cfg {number|null} [height=null] Height of popup in pixels. Pass `null` to use automatic height.
 * @cfg {boolean} [anchor=true] Show anchor pointing to origin of popup
 * @cfg {string} [position='below'] Where to position the popup relative to $floatableContainer
 *  'above': Put popup above $floatableContainer; anchor points down to the horizontal center
 *           of $floatableContainer
 *  'below': Put popup below $floatableContainer; anchor points up to the horizontal center
 *           of $floatableContainer
 *  'before': Put popup to the left (LTR) / right (RTL) of $floatableContainer; anchor points
 *            endwards (right/left) to the vertical center of $floatableContainer
 *  'after': Put popup to the right (LTR) / left (RTL) of $floatableContainer; anchor points
 *            startwards (left/right) to the vertical center of $floatableContainer
 * @cfg {string} [align='center'] How to align the popup to $floatableContainer
 *  'forwards': If position is above/below, move the popup as far endwards (right in LTR, left in RTL)
 *              as possible while still keeping the anchor within the popup;
 *              if position is before/after, move the popup as far downwards as possible.
 *  'backwards': If position is above/below, move the popup as far startwards (left in LTR, right in RTL)
 *               as possible while still keeping the anchor within the popup;
 *               if position in before/after, move the popup as far upwards as possible.
 *  'center': Horizontally (if position is above/below) or vertically (before/after) align the center
 *            of the popup with the center of $floatableContainer.
 * 'force-left': Alias for 'forwards' in LTR and 'backwards' in RTL
 * 'force-right': Alias for 'backwards' in RTL and 'forwards' in LTR
 * @cfg {boolean} [autoFlip=true] Whether to automatically switch the popup's position between
 *  'above' and 'below', or between 'before' and 'after', if there is not enough space in the
 *  desired direction to display the popup without clipping
 * @cfg {jQuery} [$container] Constrain the popup to the boundaries of the specified container.
 *  See the [OOUI docs on MediaWiki][3] for an example.
 *  [3]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups#containerExample
 * @cfg {number} [containerPadding=10] Padding between the popup and its container, specified as a number of pixels.
 * @cfg {jQuery} [$content] Content to append to the popup's body
 * @cfg {jQuery} [$footer] Content to append to the popup's footer
 * @cfg {boolean} [autoClose=false] Automatically close the popup when it loses focus.
 * @cfg {jQuery} [$autoCloseIgnore] Elements that will not close the popup when clicked.
 *  This config option is only relevant if #autoClose is set to `true`. See the [OOUI documentation on MediaWiki][2]
 *  for an example.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups#autocloseExample
 * @cfg {boolean} [head=false] Show a popup header that contains a #label (if specified) and close
 *  button.
 * @cfg {boolean} [padded=false] Add padding to the popup's body
 */
OO.ui.PopupWidget = function OoUiPopupWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.PopupWidget.parent.call( this, config );

	// Properties (must be set before ClippableElement constructor call)
	this.$body = $( '<div>' );
	this.$popup = $( '<div>' );

	// Mixin constructors
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.ClippableElement.call( this, $.extend( {}, config, {
		$clippable: this.$body,
		$clippableContainer: this.$popup
	} ) );
	OO.ui.mixin.FloatableElement.call( this, config );

	// Properties
	this.$anchor = $( '<div>' );
	// If undefined, will be computed lazily in computePosition()
	this.$container = config.$container;
	this.containerPadding = config.containerPadding !== undefined ? config.containerPadding : 10;
	this.autoClose = !!config.autoClose;
	this.transitionTimeout = null;
	this.anchored = false;
	this.onDocumentMouseDownHandler = this.onDocumentMouseDown.bind( this );
	this.onDocumentKeyDownHandler = this.onDocumentKeyDown.bind( this );

	// Initialization
	this.setSize( config.width, config.height );
	this.toggleAnchor( config.anchor === undefined || config.anchor );
	this.setAlignment( config.align || 'center' );
	this.setPosition( config.position || 'below' );
	this.setAutoFlip( config.autoFlip === undefined || config.autoFlip );
	this.setAutoCloseIgnore( config.$autoCloseIgnore );
	this.$body.addClass( 'oo-ui-popupWidget-body' );
	this.$anchor.addClass( 'oo-ui-popupWidget-anchor' );
	this.$popup
		.addClass( 'oo-ui-popupWidget-popup' )
		.append( this.$body );
	this.$element
		.addClass( 'oo-ui-popupWidget' )
		.append( this.$popup, this.$anchor );
	// Move content, which was added to #$element by OO.ui.Widget, to the body
	// FIXME This is gross, we should use '$body' or something for the config
	if ( config.$content instanceof $ ) {
		this.$body.append( config.$content );
	}

	if ( config.padded ) {
		this.$body.addClass( 'oo-ui-popupWidget-body-padded' );
	}

	if ( config.head ) {
		this.closeButton = new OO.ui.ButtonWidget( { framed: false, icon: 'close' } );
		this.closeButton.connect( this, { click: 'onCloseButtonClick' } );
		this.$head = $( '<div>' )
			.addClass( 'oo-ui-popupWidget-head' )
			.append( this.$label, this.closeButton.$element );
		this.$popup.prepend( this.$head );
	}

	if ( config.$footer ) {
		this.$footer = $( '<div>' )
			.addClass( 'oo-ui-popupWidget-footer' )
			.append( config.$footer );
		this.$popup.append( this.$footer );
	}

	// Initially hidden - using #toggle may cause errors if subclasses override toggle with methods
	// that reference properties not initialized at that time of parent class construction
	// TODO: Find a better way to handle post-constructor setup
	this.visible = false;
	this.$element.addClass( 'oo-ui-element-hidden' );
};

/* Setup */

OO.inheritClass( OO.ui.PopupWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.ClippableElement );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.FloatableElement );

/* Events */

/**
 * @event ready
 *
 * The popup is ready: it is visible and has been positioned and clipped.
 */

/* Methods */

/**
 * Handles document mouse down events.
 *
 * @private
 * @param {MouseEvent} e Mouse down event
 */
OO.ui.PopupWidget.prototype.onDocumentMouseDown = function ( e ) {
	if (
		this.isVisible() &&
		!OO.ui.contains( this.$element.add( this.$autoCloseIgnore ).get(), e.target, true )
	) {
		this.toggle( false );
	}
};

// Deprecated alias since 0.28.3
OO.ui.PopupWidget.prototype.onMouseDown = function () {
	OO.ui.warnDeprecation( 'onMouseDown is deprecated, use onDocumentMouseDown instead' );
	this.onDocumentMouseDown.apply( this, arguments );
};

/**
 * Bind document mouse down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.bindDocumentMouseDownListener = function () {
	// Capture clicks outside popup
	this.getElementDocument().addEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
	// We add 'click' event because iOS safari needs to respond to this event.
	// We can't use 'touchstart' (as is usually the equivalent to 'mousedown') because
	// then it will trigger when scrolling. While iOS Safari has some reported behavior
	// of occasionally not emitting 'click' properly, that event seems to be the standard
	// that it should be emitting, so we add it to this and will operate the event handler
	// on whichever of these events was triggered first
	this.getElementDocument().addEventListener( 'click', this.onDocumentMouseDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.PopupWidget.prototype.bindMouseDownListener = function () {
	OO.ui.warnDeprecation( 'bindMouseDownListener is deprecated, use bindDocumentMouseDownListener instead' );
	this.bindDocumentMouseDownListener.apply( this, arguments );
};

/**
 * Handles close button click events.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.onCloseButtonClick = function () {
	if ( this.isVisible() ) {
		this.toggle( false );
	}
};

/**
 * Unbind document mouse down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.unbindDocumentMouseDownListener = function () {
	this.getElementDocument().removeEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
	this.getElementDocument().removeEventListener( 'click', this.onDocumentMouseDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.PopupWidget.prototype.unbindMouseDownListener = function () {
	OO.ui.warnDeprecation( 'unbindMouseDownListener is deprecated, use unbindDocumentMouseDownListener instead' );
	this.unbindDocumentMouseDownListener.apply( this, arguments );
};

/**
 * Handles document key down events.
 *
 * @private
 * @param {KeyboardEvent} e Key down event
 */
OO.ui.PopupWidget.prototype.onDocumentKeyDown = function ( e ) {
	if (
		e.which === OO.ui.Keys.ESCAPE &&
		this.isVisible()
	) {
		this.toggle( false );
		e.preventDefault();
		e.stopPropagation();
	}
};

/**
 * Bind document key down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.bindDocumentKeyDownListener = function () {
	this.getElementDocument().addEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.PopupWidget.prototype.bindKeyDownListener = function () {
	OO.ui.warnDeprecation( 'bindKeyDownListener is deprecated, use bindDocumentKeyDownListener instead' );
	this.bindDocumentKeyDownListener.apply( this, arguments );
};

/**
 * Unbind document key down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.unbindDocumentKeyDownListener = function () {
	this.getElementDocument().removeEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.PopupWidget.prototype.unbindKeyDownListener = function () {
	OO.ui.warnDeprecation( 'unbindKeyDownListener is deprecated, use unbindDocumentKeyDownListener instead' );
	this.unbindDocumentKeyDownListener.apply( this, arguments );
};

/**
 * Show, hide, or toggle the visibility of the anchor.
 *
 * @param {boolean} [show] Show anchor, omit to toggle
 */
OO.ui.PopupWidget.prototype.toggleAnchor = function ( show ) {
	show = show === undefined ? !this.anchored : !!show;

	if ( this.anchored !== show ) {
		if ( show ) {
			this.$element.addClass( 'oo-ui-popupWidget-anchored' );
			this.$element.addClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
		} else {
			this.$element.removeClass( 'oo-ui-popupWidget-anchored' );
			this.$element.removeClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
		}
		this.anchored = show;
	}
};

/**
 * Change which edge the anchor appears on.
 *
 * @param {string} edge 'top', 'bottom', 'start' or 'end'
 */
OO.ui.PopupWidget.prototype.setAnchorEdge = function ( edge ) {
	if ( [ 'top', 'bottom', 'start', 'end' ].indexOf( edge ) === -1 ) {
		throw new Error( 'Invalid value for edge: ' + edge );
	}
	if ( this.anchorEdge !== null ) {
		this.$element.removeClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
	}
	this.anchorEdge = edge;
	if ( this.anchored ) {
		this.$element.addClass( 'oo-ui-popupWidget-anchored-' + edge );
	}
};

/**
 * Check if the anchor is visible.
 *
 * @return {boolean} Anchor is visible
 */
OO.ui.PopupWidget.prototype.hasAnchor = function () {
	return this.anchored;
};

/**
 * Toggle visibility of the popup. The popup is initially hidden and must be shown by calling
 * `.toggle( true )` after its #$element is attached to the DOM.
 *
 * Do not show the popup while it is not attached to the DOM. The calculations required to display
 * it in the right place and with the right dimensions only work correctly while it is attached.
 * Side-effects may include broken interface and exceptions being thrown. This wasn't always
 * strictly enforced, so currently it only generates a warning in the browser console.
 *
 * @fires ready
 * @inheritdoc
 */
OO.ui.PopupWidget.prototype.toggle = function ( show ) {
	var change, normalHeight, oppositeHeight, normalWidth, oppositeWidth;
	show = show === undefined ? !this.isVisible() : !!show;

	change = show !== this.isVisible();

	if ( show && !this.warnedUnattached && !this.isElementAttached() ) {
		OO.ui.warnDeprecation( 'PopupWidget#toggle: Before calling this method, the popup must be attached to the DOM.' );
		this.warnedUnattached = true;
	}
	if ( show && !this.$floatableContainer && this.isElementAttached() ) {
		// Fall back to the parent node if the floatableContainer is not set
		this.setFloatableContainer( this.$element.parent() );
	}

	if ( change && show && this.autoFlip ) {
		// Reset auto-flipping before showing the popup again. It's possible we no longer need to flip
		// (e.g. if the user scrolled).
		this.isAutoFlipped = false;
	}

	// Parent method
	OO.ui.PopupWidget.parent.prototype.toggle.call( this, show );

	if ( change ) {
		this.togglePositioning( show && !!this.$floatableContainer );

		if ( show ) {
			if ( this.autoClose ) {
				this.bindDocumentMouseDownListener();
				this.bindDocumentKeyDownListener();
			}
			this.updateDimensions();
			this.toggleClipping( true );

			if ( this.autoFlip ) {
				if ( this.popupPosition === 'above' || this.popupPosition === 'below' ) {
					if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
						// If opening the popup in the normal direction causes it to be clipped, open
						// in the opposite one instead
						normalHeight = this.$element.height();
						this.isAutoFlipped = !this.isAutoFlipped;
						this.position();
						if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
							// If that also causes it to be clipped, open in whichever direction
							// we have more space
							oppositeHeight = this.$element.height();
							if ( oppositeHeight < normalHeight ) {
								this.isAutoFlipped = !this.isAutoFlipped;
								this.position();
							}
						}
					}
				}
				if ( this.popupPosition === 'before' || this.popupPosition === 'after' ) {
					if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
						// If opening the popup in the normal direction causes it to be clipped, open
						// in the opposite one instead
						normalWidth = this.$element.width();
						this.isAutoFlipped = !this.isAutoFlipped;
						// Due to T180173 horizontally clipped PopupWidgets have messed up dimensions,
						// which causes positioning to be off. Toggle clipping back and fort to work around.
						this.toggleClipping( false );
						this.position();
						this.toggleClipping( true );
						if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
							// If that also causes it to be clipped, open in whichever direction
							// we have more space
							oppositeWidth = this.$element.width();
							if ( oppositeWidth < normalWidth ) {
								this.isAutoFlipped = !this.isAutoFlipped;
								// Due to T180173 horizontally clipped PopupWidgets have messed up dimensions,
								// which causes positioning to be off. Toggle clipping back and fort to work around.
								this.toggleClipping( false );
								this.position();
								this.toggleClipping( true );
							}
						}
					}
				}
			}

			this.emit( 'ready' );
		} else {
			this.toggleClipping( false );
			if ( this.autoClose ) {
				this.unbindDocumentMouseDownListener();
				this.unbindDocumentKeyDownListener();
			}
		}
	}

	return this;
};

/**
 * Set the size of the popup.
 *
 * Changing the size may also change the popup's position depending on the alignment.
 *
 * @param {number|null} [width=320] Width in pixels. Pass `null` to use automatic width.
 * @param {number|null} [height=null] Height in pixels. Pass `null` to use automatic height.
 * @param {boolean} [transition=false] Use a smooth transition
 * @chainable
 */
OO.ui.PopupWidget.prototype.setSize = function ( width, height, transition ) {
	this.width = width !== undefined ? width : 320;
	this.height = height !== undefined ? height : null;
	if ( this.isVisible() ) {
		this.updateDimensions( transition );
	}
};

/**
 * Update the size and position.
 *
 * Only use this to keep the popup properly anchored. Use #setSize to change the size, and this will
 * be called automatically.
 *
 * @param {boolean} [transition=false] Use a smooth transition
 * @chainable
 */
OO.ui.PopupWidget.prototype.updateDimensions = function ( transition ) {
	var widget = this;

	// Prevent transition from being interrupted
	clearTimeout( this.transitionTimeout );
	if ( transition ) {
		// Enable transition
		this.$element.addClass( 'oo-ui-popupWidget-transitioning' );
	}

	this.position();

	if ( transition ) {
		// Prevent transitioning after transition is complete
		this.transitionTimeout = setTimeout( function () {
			widget.$element.removeClass( 'oo-ui-popupWidget-transitioning' );
		}, 200 );
	} else {
		// Prevent transitioning immediately
		this.$element.removeClass( 'oo-ui-popupWidget-transitioning' );
	}
};

/**
 * @inheritdoc
 */
OO.ui.PopupWidget.prototype.computePosition = function () {
	var direction, align, vertical, start, end, near, far, sizeProp, popupSize, anchorSize, anchorPos,
		anchorOffset, anchorMargin, parentPosition, positionProp, positionAdjustment, floatablePos,
		offsetParentPos, containerPos, popupPosition, viewportSpacing,
		popupPos = {},
		anchorCss = { left: '', right: '', top: '', bottom: '' },
		popupPositionOppositeMap = {
			above: 'below',
			below: 'above',
			before: 'after',
			after: 'before'
		},
		alignMap = {
			ltr: {
				'force-left': 'backwards',
				'force-right': 'forwards'
			},
			rtl: {
				'force-left': 'forwards',
				'force-right': 'backwards'
			}
		},
		anchorEdgeMap = {
			above: 'bottom',
			below: 'top',
			before: 'end',
			after: 'start'
		},
		hPosMap = {
			forwards: 'start',
			center: 'center',
			backwards: this.anchored ? 'before' : 'end'
		},
		vPosMap = {
			forwards: 'top',
			center: 'center',
			backwards: 'bottom'
		};

	if ( !this.$container ) {
		// Lazy-initialize $container if not specified in constructor
		this.$container = $( this.getClosestScrollableElementContainer() );
	}
	direction = this.$container.css( 'direction' );

	// Set height and width before we do anything else, since it might cause our measurements
	// to change (e.g. due to scrollbars appearing or disappearing), and it also affects centering
	this.$popup.css( {
		width: this.width !== null ? this.width : 'auto',
		height: this.height !== null ? this.height : 'auto'
	} );

	align = alignMap[ direction ][ this.align ] || this.align;
	popupPosition = this.popupPosition;
	if ( this.isAutoFlipped ) {
		popupPosition = popupPositionOppositeMap[ popupPosition ];
	}

	// If the popup is positioned before or after, then the anchor positioning is vertical, otherwise horizontal
	vertical = popupPosition === 'before' || popupPosition === 'after';
	start = vertical ? 'top' : ( direction === 'rtl' ? 'right' : 'left' );
	end = vertical ? 'bottom' : ( direction === 'rtl' ? 'left' : 'right' );
	near = vertical ? 'top' : 'left';
	far = vertical ? 'bottom' : 'right';
	sizeProp = vertical ? 'Height' : 'Width';
	popupSize = vertical ? ( this.height || this.$popup.height() ) : ( this.width || this.$popup.width() );

	this.setAnchorEdge( anchorEdgeMap[ popupPosition ] );
	this.horizontalPosition = vertical ? popupPosition : hPosMap[ align ];
	this.verticalPosition = vertical ? vPosMap[ align ] : popupPosition;

	// Parent method
	parentPosition = OO.ui.mixin.FloatableElement.prototype.computePosition.call( this );
	// Find out which property FloatableElement used for positioning, and adjust that value
	positionProp = vertical ?
		( parentPosition.top !== '' ? 'top' : 'bottom' ) :
		( parentPosition.left !== '' ? 'left' : 'right' );

	// Figure out where the near and far edges of the popup and $floatableContainer are
	floatablePos = this.$floatableContainer.offset();
	floatablePos[ far ] = floatablePos[ near ] + this.$floatableContainer[ 'outer' + sizeProp ]();
	// Measure where the offsetParent is and compute our position based on that and parentPosition
	offsetParentPos = this.$element.offsetParent()[ 0 ] === document.documentElement ?
		{ top: 0, left: 0 } :
		this.$element.offsetParent().offset();

	if ( positionProp === near ) {
		popupPos[ near ] = offsetParentPos[ near ] + parentPosition[ near ];
		popupPos[ far ] = popupPos[ near ] + popupSize;
	} else {
		popupPos[ far ] = offsetParentPos[ near ] +
			this.$element.offsetParent()[ 'inner' + sizeProp ]() - parentPosition[ far ];
		popupPos[ near ] = popupPos[ far ] - popupSize;
	}

	if ( this.anchored ) {
		// Position the anchor (which is positioned relative to the popup) to point to $floatableContainer
		anchorPos = ( floatablePos[ start ] + floatablePos[ end ] ) / 2;
		anchorOffset = ( start === far ? -1 : 1 ) * ( anchorPos - popupPos[ start ] );

		// If the anchor is less than 2*anchorSize from either edge, move the popup to make more space
		// this.$anchor.width()/height() returns 0 because of the CSS trickery we use, so use scrollWidth/Height
		anchorSize = this.$anchor[ 0 ][ 'scroll' + sizeProp ];
		anchorMargin = parseFloat( this.$anchor.css( 'margin-' + start ) );
		if ( anchorOffset + anchorMargin < 2 * anchorSize ) {
			// Not enough space for the anchor on the start side; pull the popup startwards
			positionAdjustment = ( positionProp === start ? -1 : 1 ) *
				( 2 * anchorSize - ( anchorOffset + anchorMargin ) );
		} else if ( anchorOffset + anchorMargin > popupSize - 2 * anchorSize ) {
			// Not enough space for the anchor on the end side; pull the popup endwards
			positionAdjustment = ( positionProp === end ? -1 : 1 ) *
				( anchorOffset + anchorMargin - ( popupSize - 2 * anchorSize ) );
		} else {
			positionAdjustment = 0;
		}
	} else {
		positionAdjustment = 0;
	}

	// Check if the popup will go beyond the edge of this.$container
	containerPos = this.$container[ 0 ] === document.documentElement ?
		{ top: 0, left: 0 } :
		this.$container.offset();
	containerPos[ far ] = containerPos[ near ] + this.$container[ 'inner' + sizeProp ]();
	if ( this.$container[ 0 ] === document.documentElement ) {
		viewportSpacing = OO.ui.getViewportSpacing();
		containerPos[ near ] += viewportSpacing[ near ];
		containerPos[ far ] -= viewportSpacing[ far ];
	}
	// Take into account how much the popup will move because of the adjustments we're going to make
	popupPos[ near ] += ( positionProp === near ? 1 : -1 ) * positionAdjustment;
	popupPos[ far ] += ( positionProp === near ? 1 : -1 ) * positionAdjustment;
	if ( containerPos[ near ] + this.containerPadding > popupPos[ near ] ) {
		// Popup goes beyond the near (left/top) edge, move it to the right/bottom
		positionAdjustment += ( positionProp === near ? 1 : -1 ) *
			( containerPos[ near ] + this.containerPadding - popupPos[ near ] );
	} else if ( containerPos[ far ] - this.containerPadding < popupPos[ far ] ) {
		// Popup goes beyond the far (right/bottom) edge, move it to the left/top
		positionAdjustment += ( positionProp === far ? 1 : -1 ) *
			( popupPos[ far ] - ( containerPos[ far ] - this.containerPadding ) );
	}

	if ( this.anchored ) {
		// Adjust anchorOffset for positionAdjustment
		anchorOffset += ( positionProp === start ? -1 : 1 ) * positionAdjustment;

		// Position the anchor
		anchorCss[ start ] = anchorOffset;
		this.$anchor.css( anchorCss );
	}

	// Move the popup if needed
	parentPosition[ positionProp ] += positionAdjustment;

	return parentPosition;
};

/**
 * Set popup alignment
 *
 * @param {string} [align=center] Alignment of the popup, `center`, `force-left`, `force-right`,
 *  `backwards` or `forwards`.
 */
OO.ui.PopupWidget.prototype.setAlignment = function ( align ) {
	// Validate alignment
	if ( [ 'force-left', 'force-right', 'backwards', 'forwards', 'center' ].indexOf( align ) > -1 ) {
		this.align = align;
	} else {
		this.align = 'center';
	}
	this.position();
};

/**
 * Get popup alignment
 *
 * @return {string} Alignment of the popup, `center`, `force-left`, `force-right`,
 *  `backwards` or `forwards`.
 */
OO.ui.PopupWidget.prototype.getAlignment = function () {
	return this.align;
};

/**
 * Change the positioning of the popup.
 *
 * @param {string} position 'above', 'below', 'before' or 'after'
 */
OO.ui.PopupWidget.prototype.setPosition = function ( position ) {
	if ( [ 'above', 'below', 'before', 'after' ].indexOf( position ) === -1 ) {
		position = 'below';
	}
	this.popupPosition = position;
	this.position();
};

/**
 * Get popup positioning.
 *
 * @return {string} 'above', 'below', 'before' or 'after'
 */
OO.ui.PopupWidget.prototype.getPosition = function () {
	return this.popupPosition;
};

/**
 * Set popup auto-flipping.
 *
 * @param {boolean} autoFlip Whether to automatically switch the popup's position between
 *  'above' and 'below', or between 'before' and 'after', if there is not enough space in the
 *  desired direction to display the popup without clipping
 */
OO.ui.PopupWidget.prototype.setAutoFlip = function ( autoFlip ) {
	autoFlip = !!autoFlip;

	if ( this.autoFlip !== autoFlip ) {
		this.autoFlip = autoFlip;
	}
};

/**
 * Set which elements will not close the popup when clicked.
 *
 * For auto-closing popups, clicks on these elements will not cause the popup to auto-close.
 *
 * @param {jQuery} $autoCloseIgnore Elements to ignore for auto-closing
 */
OO.ui.PopupWidget.prototype.setAutoCloseIgnore = function ( $autoCloseIgnore ) {
	this.$autoCloseIgnore = $autoCloseIgnore;
};

/**
 * Get an ID of the body element, this can be used as the
 * `aria-describedby` attribute for an input field.
 *
 * @return {string} The ID of the body element
 */
OO.ui.PopupWidget.prototype.getBodyId = function () {
	var id = this.$body.attr( 'id' );
	if ( id === undefined ) {
		id = OO.ui.generateElementId();
		this.$body.attr( 'id', id );
	}
	return id;
};

/**
 * PopupElement is mixed into other classes to generate a {@link OO.ui.PopupWidget popup widget}.
 * A popup is a container for content. It is overlaid and positioned absolutely. By default, each
 * popup has an anchor, which is an arrow-like protrusion that points toward the popup’s origin.
 * See {@link OO.ui.PopupWidget PopupWidget} for an example.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [popup] Configuration to pass to popup
 * @cfg {boolean} [popup.autoClose=true] Popup auto-closes when it loses focus
 */
OO.ui.mixin.PopupElement = function OoUiMixinPopupElement( config ) {
	// Configuration initialization
	config = config || {};

	// Properties
	this.popup = new OO.ui.PopupWidget( $.extend(
		{
			autoClose: true,
			$floatableContainer: this.$element
		},
		config.popup,
		{
			$autoCloseIgnore: this.$element.add( config.popup && config.popup.$autoCloseIgnore )
		}
	) );
};

/* Methods */

/**
 * Get popup.
 *
 * @return {OO.ui.PopupWidget} Popup widget
 */
OO.ui.mixin.PopupElement.prototype.getPopup = function () {
	return this.popup;
};

/**
 * PopupButtonWidgets toggle the visibility of a contained {@link OO.ui.PopupWidget PopupWidget},
 * which is used to display additional information or options.
 *
 *     @example
 *     // A PopupButtonWidget.
 *     var popupButton = new OO.ui.PopupButtonWidget( {
 *         label: 'Popup button with options',
 *         icon: 'menu',
 *         popup: {
 *             $content: $( '<p>Additional options here.</p>' ),
 *             padded: true,
 *             align: 'force-left'
 *         }
 *     } );
 *     // Append the button to the DOM.
 *     $( document.body ).append( popupButton.$element );
 *
 * @class
 * @extends OO.ui.ButtonWidget
 * @mixins OO.ui.mixin.PopupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$overlay] Render the popup into a separate layer. This configuration is useful in cases where
 *  the expanded popup is larger than its containing `<div>`. The specified overlay layer is usually on top of the
 *  containing `<div>` and has a larger area. By default, the popup uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.PopupButtonWidget = function OoUiPopupButtonWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.PopupButtonWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.PopupElement.call( this, config );

	// Properties
	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

	// Events
	this.connect( this, { click: 'onAction' } );

	// Initialization
	this.$element
		.addClass( 'oo-ui-popupButtonWidget' );
	this.popup.$element
		.addClass( 'oo-ui-popupButtonWidget-popup' )
		.toggleClass( 'oo-ui-popupButtonWidget-framed-popup', this.isFramed() )
		.toggleClass( 'oo-ui-popupButtonWidget-frameless-popup', !this.isFramed() );
	this.$overlay.append( this.popup.$element );
};

/* Setup */

OO.inheritClass( OO.ui.PopupButtonWidget, OO.ui.ButtonWidget );
OO.mixinClass( OO.ui.PopupButtonWidget, OO.ui.mixin.PopupElement );

/* Methods */

/**
 * Handle the button action being triggered.
 *
 * @private
 */
OO.ui.PopupButtonWidget.prototype.onAction = function () {
	this.popup.toggle();
};

/**
 * Mixin for OO.ui.Widget subclasses to provide OO.ui.mixin.GroupElement.
 *
 * Use together with OO.ui.mixin.ItemWidget to make disabled state inheritable.
 *
 * @private
 * @abstract
 * @class
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.mixin.GroupWidget = function OoUiMixinGroupWidget( config ) {
	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, config );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.GroupWidget, OO.ui.mixin.GroupElement );

/* Methods */

/**
 * Set the disabled state of the widget.
 *
 * This will also update the disabled state of child widgets.
 *
 * @param {boolean} disabled Disable widget
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.mixin.GroupWidget.prototype.setDisabled = function ( disabled ) {
	var i, len;

	// Parent method
	// Note: Calling #setDisabled this way assumes this is mixed into an OO.ui.Widget
	OO.ui.Widget.prototype.setDisabled.call( this, disabled );

	// During construction, #setDisabled is called before the OO.ui.mixin.GroupElement constructor
	if ( this.items ) {
		for ( i = 0, len = this.items.length; i < len; i++ ) {
			this.items[ i ].updateDisabled();
		}
	}

	return this;
};

/**
 * Mixin for widgets used as items in widgets that mix in OO.ui.mixin.GroupWidget.
 *
 * Item widgets have a reference to a OO.ui.mixin.GroupWidget while they are attached to the group. This
 * allows bidirectional communication.
 *
 * Use together with OO.ui.mixin.GroupWidget to make disabled state inheritable.
 *
 * @private
 * @abstract
 * @class
 *
 * @constructor
 */
OO.ui.mixin.ItemWidget = function OoUiMixinItemWidget() {
	//
};

/* Methods */

/**
 * Check if widget is disabled.
 *
 * Checks parent if present, making disabled state inheritable.
 *
 * @return {boolean} Widget is disabled
 */
OO.ui.mixin.ItemWidget.prototype.isDisabled = function () {
	return this.disabled ||
		( this.elementGroup instanceof OO.ui.Widget && this.elementGroup.isDisabled() );
};

/**
 * Set group element is in.
 *
 * @param {OO.ui.mixin.GroupElement|null} group Group element, null if none
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.mixin.ItemWidget.prototype.setElementGroup = function ( group ) {
	// Parent method
	// Note: Calling #setElementGroup this way assumes this is mixed into an OO.ui.Element
	OO.ui.Element.prototype.setElementGroup.call( this, group );

	// Initialize item disabled states
	this.updateDisabled();

	return this;
};

/**
 * OptionWidgets are special elements that can be selected and configured with data. The
 * data is often unique for each option, but it does not have to be. OptionWidgets are used
 * with OO.ui.SelectWidget to create a selection of mutually exclusive options. For more information
 * and examples, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.OptionWidget = function OoUiOptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.OptionWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ItemWidget.call( this );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.AccessKeyedElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );

	// Properties
	this.selected = false;
	this.highlighted = false;
	this.pressed = false;

	// Initialization
	this.$element
		.data( 'oo-ui-optionWidget', this )
		// Allow programmatic focussing (and by accesskey), but not tabbing
		.attr( 'tabindex', '-1' )
		.attr( 'role', 'option' )
		.attr( 'aria-selected', 'false' )
		.addClass( 'oo-ui-optionWidget' )
		.append( this.$label );
};

/* Setup */

OO.inheritClass( OO.ui.OptionWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.AccessKeyedElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * Whether this option can be selected. See #setSelected.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.selectable = true;

/**
 * Whether this option can be highlighted. See #setHighlighted.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.highlightable = true;

/**
 * Whether this option can be pressed. See #setPressed.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.pressable = true;

/**
 * Whether this option will be scrolled into view when it is selected.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.scrollIntoViewOnSelect = false;

/* Methods */

/**
 * Check if the option can be selected.
 *
 * @return {boolean} Item is selectable
 */
OO.ui.OptionWidget.prototype.isSelectable = function () {
	return this.constructor.static.selectable && !this.disabled && this.isVisible();
};

/**
 * Check if the option can be highlighted. A highlight indicates that the option
 * may be selected when a user presses enter or clicks. Disabled items cannot
 * be highlighted.
 *
 * @return {boolean} Item is highlightable
 */
OO.ui.OptionWidget.prototype.isHighlightable = function () {
	return this.constructor.static.highlightable && !this.disabled && this.isVisible();
};

/**
 * Check if the option can be pressed. The pressed state occurs when a user mouses
 * down on an item, but has not yet let go of the mouse.
 *
 * @return {boolean} Item is pressable
 */
OO.ui.OptionWidget.prototype.isPressable = function () {
	return this.constructor.static.pressable && !this.disabled && this.isVisible();
};

/**
 * Check if the option is selected.
 *
 * @return {boolean} Item is selected
 */
OO.ui.OptionWidget.prototype.isSelected = function () {
	return this.selected;
};

/**
 * Check if the option is highlighted. A highlight indicates that the
 * item may be selected when a user presses enter or clicks.
 *
 * @return {boolean} Item is highlighted
 */
OO.ui.OptionWidget.prototype.isHighlighted = function () {
	return this.highlighted;
};

/**
 * Check if the option is pressed. The pressed state occurs when a user mouses
 * down on an item, but has not yet let go of the mouse. The item may appear
 * selected, but it will not be selected until the user releases the mouse.
 *
 * @return {boolean} Item is pressed
 */
OO.ui.OptionWidget.prototype.isPressed = function () {
	return this.pressed;
};

/**
 * Set the option’s selected state. In general, all modifications to the selection
 * should be handled by the SelectWidget’s {@link OO.ui.SelectWidget#selectItem selectItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Select option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setSelected = function ( state ) {
	if ( this.constructor.static.selectable ) {
		this.selected = !!state;
		this.$element
			.toggleClass( 'oo-ui-optionWidget-selected', state )
			.attr( 'aria-selected', state.toString() );
		if ( state && this.constructor.static.scrollIntoViewOnSelect ) {
			this.scrollElementIntoView();
		}
		this.updateThemeClasses();
	}
	return this;
};

/**
 * Set the option’s highlighted state. In general, all programmatic
 * modifications to the highlight should be handled by the
 * SelectWidget’s {@link OO.ui.SelectWidget#highlightItem highlightItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Highlight option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setHighlighted = function ( state ) {
	if ( this.constructor.static.highlightable ) {
		this.highlighted = !!state;
		this.$element.toggleClass( 'oo-ui-optionWidget-highlighted', state );
		this.updateThemeClasses();
	}
	return this;
};

/**
 * Set the option’s pressed state. In general, all
 * programmatic modifications to the pressed state should be handled by the
 * SelectWidget’s {@link OO.ui.SelectWidget#pressItem pressItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Press option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setPressed = function ( state ) {
	if ( this.constructor.static.pressable ) {
		this.pressed = !!state;
		this.$element.toggleClass( 'oo-ui-optionWidget-pressed', state );
		this.updateThemeClasses();
	}
	return this;
};

/**
 * Get text to match search strings against.
 *
 * The default implementation returns the label text, but subclasses
 * can override this to provide more complex behavior.
 *
 * @return {string|boolean} String to match search string against
 */
OO.ui.OptionWidget.prototype.getMatchText = function () {
	var label = this.getLabel();
	return typeof label === 'string' ? label : this.$label.text();
};

/**
 * A SelectWidget is of a generic selection of options. The OOUI library contains several types of
 * select widgets, including {@link OO.ui.ButtonSelectWidget button selects},
 * {@link OO.ui.RadioSelectWidget radio selects}, and {@link OO.ui.MenuSelectWidget
 * menu selects}.
 *
 * This class should be used together with OO.ui.OptionWidget or OO.ui.DecoratedOptionWidget. For more
 * information, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // A select widget with three options.
 *     var select = new OO.ui.SelectWidget( {
 *         items: [
 *             new OO.ui.OptionWidget( {
 *                 data: 'a',
 *                 label: 'Option One',
 *             } ),
 *             new OO.ui.OptionWidget( {
 *                 data: 'b',
 *                 label: 'Option Two',
 *             } ),
 *             new OO.ui.OptionWidget( {
 *                 data: 'c',
 *                 label: 'Option Three',
 *             } )
 *         ]
 *     } );
 *     $( document.body ).append( select.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.OptionWidget[]} [items] An array of options to add to the select.
 *  Options are created with {@link OO.ui.OptionWidget OptionWidget} classes. See
 *  the [OOUI documentation on MediaWiki] [2] for examples.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 */
OO.ui.SelectWidget = function OoUiSelectWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.SelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupWidget.call( this, $.extend( {}, config, { $group: this.$element } ) );

	// Properties
	this.pressed = false;
	this.selecting = null;
	this.onDocumentMouseUpHandler = this.onDocumentMouseUp.bind( this );
	this.onDocumentMouseMoveHandler = this.onDocumentMouseMove.bind( this );
	this.onDocumentKeyDownHandler = this.onDocumentKeyDown.bind( this );
	this.onDocumentKeyPressHandler = this.onDocumentKeyPress.bind( this );
	this.keyPressBuffer = '';
	this.keyPressBufferTimer = null;
	this.blockMouseOverEvents = 0;

	// Events
	this.connect( this, {
		toggle: 'onToggle'
	} );
	this.$element.on( {
		focusin: this.onFocus.bind( this ),
		mousedown: this.onMouseDown.bind( this ),
		mouseover: this.onMouseOver.bind( this ),
		mouseleave: this.onMouseLeave.bind( this )
	} );

	// Initialization
	this.$element
		.addClass( 'oo-ui-selectWidget oo-ui-selectWidget-depressed' )
		.attr( 'role', 'listbox' );
	this.setFocusOwner( this.$element );
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.SelectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.SelectWidget, OO.ui.mixin.GroupWidget );

/* Events */

/**
 * @event highlight
 *
 * A `highlight` event is emitted when the highlight is changed with the #highlightItem method.
 *
 * @param {OO.ui.OptionWidget|null} item Highlighted item
 */

/**
 * @event press
 *
 * A `press` event is emitted when the #pressItem method is used to programmatically modify the
 * pressed state of an option.
 *
 * @param {OO.ui.OptionWidget|null} item Pressed item
 */

/**
 * @event select
 *
 * A `select` event is emitted when the selection is modified programmatically with the #selectItem method.
 *
 * @param {OO.ui.OptionWidget|null} item Selected item
 */

/**
 * @event choose
 * A `choose` event is emitted when an item is chosen with the #chooseItem method.
 * @param {OO.ui.OptionWidget} item Chosen item
 */

/**
 * @event add
 *
 * An `add` event is emitted when options are added to the select with the #addItems method.
 *
 * @param {OO.ui.OptionWidget[]} items Added items
 * @param {number} index Index of insertion point
 */

/**
 * @event remove
 *
 * A `remove` event is emitted when options are removed from the select with the #clearItems
 * or #removeItems methods.
 *
 * @param {OO.ui.OptionWidget[]} items Removed items
 */

/* Methods */

/**
 * Handle focus events
 *
 * @private
 * @param {jQuery.Event} event
 */
OO.ui.SelectWidget.prototype.onFocus = function ( event ) {
	var item;
	if ( event.target === this.$element[ 0 ] ) {
		// This widget was focussed, e.g. by the user tabbing to it.
		// The styles for focus state depend on one of the items being selected.
		if ( !this.findSelectedItem() ) {
			item = this.findFirstSelectableItem();
		}
	} else {
		if ( event.target.tabIndex === -1 ) {
			// One of the options got focussed (and the event bubbled up here).
			// They can't be tabbed to, but they can be activated using accesskeys.
			// OptionWidgets and focusable UI elements inside them have tabindex="-1" set.
			item = this.findTargetItem( event );
		} else {
			// There is something actually user-focusable in one of the labels of the options, and the
			// user focussed it (e.g. by tabbing to it). Do nothing (especially, don't change the focus).
			return;
		}
	}

	if ( item ) {
		if ( item.constructor.static.highlightable ) {
			this.highlightItem( item );
		} else {
			this.selectItem( item );
		}
	}

	if ( event.target !== this.$element[ 0 ] ) {
		this.$focusOwner.focus();
	}
};

/**
 * Handle mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseDown = function ( e ) {
	var item;

	if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
		this.togglePressed( true );
		item = this.findTargetItem( e );
		if ( item && item.isSelectable() ) {
			this.pressItem( item );
			this.selecting = item;
			this.getElementDocument().addEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
			this.getElementDocument().addEventListener( 'mousemove', this.onDocumentMouseMoveHandler, true );
		}
	}
	return false;
};

/**
 * Handle document mouse up events.
 *
 * @private
 * @param {MouseEvent} e Mouse up event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onDocumentMouseUp = function ( e ) {
	var item;

	this.togglePressed( false );
	if ( !this.selecting ) {
		item = this.findTargetItem( e );
		if ( item && item.isSelectable() ) {
			this.selecting = item;
		}
	}
	if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT && this.selecting ) {
		this.pressItem( null );
		this.chooseItem( this.selecting );
		this.selecting = null;
	}

	this.getElementDocument().removeEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
	this.getElementDocument().removeEventListener( 'mousemove', this.onDocumentMouseMoveHandler, true );

	return false;
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.onMouseUp = function () {
	OO.ui.warnDeprecation( 'onMouseUp is deprecated, use onDocumentMouseUp instead' );
	this.onDocumentMouseUp.apply( this, arguments );
};

/**
 * Handle document mouse move events.
 *
 * @private
 * @param {MouseEvent} e Mouse move event
 */
OO.ui.SelectWidget.prototype.onDocumentMouseMove = function ( e ) {
	var item;

	if ( !this.isDisabled() && this.pressed ) {
		item = this.findTargetItem( e );
		if ( item && item !== this.selecting && item.isSelectable() ) {
			this.pressItem( item );
			this.selecting = item;
		}
	}
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.onMouseMove = function () {
	OO.ui.warnDeprecation( 'onMouseMove is deprecated, use onDocumentMouseMove instead' );
	this.onDocumentMouseMove.apply( this, arguments );
};

/**
 * Handle mouse over events.
 *
 * @private
 * @param {jQuery.Event} e Mouse over event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseOver = function ( e ) {
	var item;
	if ( this.blockMouseOverEvents ) {
		return;
	}
	if ( !this.isDisabled() ) {
		item = this.findTargetItem( e );
		this.highlightItem( item && item.isHighlightable() ? item : null );
	}
	return false;
};

/**
 * Handle mouse leave events.
 *
 * @private
 * @param {jQuery.Event} e Mouse over event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseLeave = function () {
	if ( !this.isDisabled() ) {
		this.highlightItem( null );
	}
	return false;
};

/**
 * Handle document key down events.
 *
 * @protected
 * @param {KeyboardEvent} e Key down event
 */
OO.ui.SelectWidget.prototype.onDocumentKeyDown = function ( e ) {
	var nextItem,
		handled = false,
		currentItem = this.findHighlightedItem() || this.findSelectedItem();

	if ( !this.isDisabled() && this.isVisible() ) {
		switch ( e.keyCode ) {
			case OO.ui.Keys.ENTER:
				if ( currentItem && currentItem.constructor.static.highlightable ) {
					// Was only highlighted, now let's select it. No-op if already selected.
					this.chooseItem( currentItem );
					handled = true;
				}
				break;
			case OO.ui.Keys.UP:
			case OO.ui.Keys.LEFT:
				this.clearKeyPressBuffer();
				nextItem = this.findRelativeSelectableItem( currentItem, -1 );
				handled = true;
				break;
			case OO.ui.Keys.DOWN:
			case OO.ui.Keys.RIGHT:
				this.clearKeyPressBuffer();
				nextItem = this.findRelativeSelectableItem( currentItem, 1 );
				handled = true;
				break;
			case OO.ui.Keys.ESCAPE:
			case OO.ui.Keys.TAB:
				if ( currentItem && currentItem.constructor.static.highlightable ) {
					currentItem.setHighlighted( false );
				}
				this.unbindDocumentKeyDownListener();
				this.unbindDocumentKeyPressListener();
				// Don't prevent tabbing away / defocusing
				handled = false;
				break;
		}

		if ( nextItem ) {
			if ( nextItem.constructor.static.highlightable ) {
				this.highlightItem( nextItem );
			} else {
				this.chooseItem( nextItem );
			}
			this.scrollItemIntoView( nextItem );
		}

		if ( handled ) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.onKeyDown = function () {
	OO.ui.warnDeprecation( 'onKeyDown is deprecated, use onDocumentKeyDown instead' );
	this.onDocumentKeyDown.apply( this, arguments );
};

/**
 * Bind document key down listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.bindDocumentKeyDownListener = function () {
	this.getElementDocument().addEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.bindKeyDownListener = function () {
	OO.ui.warnDeprecation( 'bindKeyDownListener is deprecated, use bindDocumentKeyDownListener instead' );
	this.bindDocumentKeyDownListener.apply( this, arguments );
};

/**
 * Unbind document key down listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.unbindDocumentKeyDownListener = function () {
	this.getElementDocument().removeEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.unbindKeyDownListener = function () {
	OO.ui.warnDeprecation( 'unbindKeyDownListener is deprecated, use unbindDocumentKeyDownListener instead' );
	this.unbindDocumentKeyDownListener.apply( this, arguments );
};

/**
 * Scroll item into view, preventing spurious mouse highlight actions from happening.
 *
 * @param {OO.ui.OptionWidget} item Item to scroll into view
 */
OO.ui.SelectWidget.prototype.scrollItemIntoView = function ( item ) {
	var widget = this;
	// Chromium's Blink engine will generate spurious 'mouseover' events during programmatic scrolling
	// and around 100-150 ms after it is finished.
	this.blockMouseOverEvents++;
	item.scrollElementIntoView().done( function () {
		setTimeout( function () {
			widget.blockMouseOverEvents--;
		}, 200 );
	} );
};

/**
 * Clear the key-press buffer
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.clearKeyPressBuffer = function () {
	if ( this.keyPressBufferTimer ) {
		clearTimeout( this.keyPressBufferTimer );
		this.keyPressBufferTimer = null;
	}
	this.keyPressBuffer = '';
};

/**
 * Handle key press events.
 *
 * @protected
 * @param {KeyboardEvent} e Key press event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onDocumentKeyPress = function ( e ) {
	var c, filter, item;

	if ( !e.charCode ) {
		if ( e.keyCode === OO.ui.Keys.BACKSPACE && this.keyPressBuffer !== '' ) {
			this.keyPressBuffer = this.keyPressBuffer.substr( 0, this.keyPressBuffer.length - 1 );
			return false;
		}
		return;
	}
	// eslint-disable-next-line no-restricted-properties
	if ( String.fromCodePoint ) {
		// eslint-disable-next-line no-restricted-properties
		c = String.fromCodePoint( e.charCode );
	} else {
		c = String.fromCharCode( e.charCode );
	}

	if ( this.keyPressBufferTimer ) {
		clearTimeout( this.keyPressBufferTimer );
	}
	this.keyPressBufferTimer = setTimeout( this.clearKeyPressBuffer.bind( this ), 1500 );

	item = this.findHighlightedItem() || this.findSelectedItem();

	if ( this.keyPressBuffer === c ) {
		// Common (if weird) special case: typing "xxxx" will cycle through all
		// the items beginning with "x".
		if ( item ) {
			item = this.findRelativeSelectableItem( item, 1 );
		}
	} else {
		this.keyPressBuffer += c;
	}

	filter = this.getItemMatcher( this.keyPressBuffer, false );
	if ( !item || !filter( item ) ) {
		item = this.findRelativeSelectableItem( item, 1, filter );
	}
	if ( item ) {
		if ( this.isVisible() && item.constructor.static.highlightable ) {
			this.highlightItem( item );
		} else {
			this.chooseItem( item );
		}
		this.scrollItemIntoView( item );
	}

	e.preventDefault();
	e.stopPropagation();
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.onKeyPress = function () {
	OO.ui.warnDeprecation( 'onKeyPress is deprecated, use onDocumentKeyPress instead' );
	this.onDocumentKeyPress.apply( this, arguments );
};

/**
 * Get a matcher for the specific string
 *
 * @protected
 * @param {string} s String to match against items
 * @param {boolean} [exact=false] Only accept exact matches
 * @return {Function} function ( OO.ui.OptionWidget ) => boolean
 */
OO.ui.SelectWidget.prototype.getItemMatcher = function ( s, exact ) {
	var re;

	// eslint-disable-next-line no-restricted-properties
	if ( s.normalize ) {
		// eslint-disable-next-line no-restricted-properties
		s = s.normalize();
	}
	s = exact ? s.trim() : s.replace( /^\s+/, '' );
	re = '^\\s*' + s.replace( /([\\{}()|.?*+\-^$[\]])/g, '\\$1' ).replace( /\s+/g, '\\s+' );
	if ( exact ) {
		re += '\\s*$';
	}
	re = new RegExp( re, 'i' );
	return function ( item ) {
		var matchText = item.getMatchText();
		// eslint-disable-next-line no-restricted-properties
		if ( matchText.normalize ) {
			// eslint-disable-next-line no-restricted-properties
			matchText = matchText.normalize();
		}
		return re.test( matchText );
	};
};

/**
 * Bind document key press listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.bindDocumentKeyPressListener = function () {
	this.getElementDocument().addEventListener( 'keypress', this.onDocumentKeyPressHandler, true );
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.bindKeyPressListener = function () {
	OO.ui.warnDeprecation( 'bindKeyPressListener is deprecated, use bindDocumentKeyPressListener instead' );
	this.bindDocumentKeyPressListener.apply( this, arguments );
};

/**
 * Unbind document key down listener.
 *
 * If you override this, be sure to call this.clearKeyPressBuffer() from your
 * implementation.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.unbindDocumentKeyPressListener = function () {
	this.getElementDocument().removeEventListener( 'keypress', this.onDocumentKeyPressHandler, true );
	this.clearKeyPressBuffer();
};

// Deprecated alias since 0.28.3
OO.ui.SelectWidget.prototype.unbindKeyPressListener = function () {
	OO.ui.warnDeprecation( 'unbindKeyPressListener is deprecated, use unbindDocumentKeyPressListener instead' );
	this.unbindDocumentKeyPressListener.apply( this, arguments );
};

/**
 * Visibility change handler
 *
 * @protected
 * @param {boolean} visible
 */
OO.ui.SelectWidget.prototype.onToggle = function ( visible ) {
	if ( !visible ) {
		this.clearKeyPressBuffer();
	}
};

/**
 * Get the closest item to a jQuery.Event.
 *
 * @private
 * @param {jQuery.Event} e
 * @return {OO.ui.OptionWidget|null} Outline item widget, `null` if none was found
 */
OO.ui.SelectWidget.prototype.findTargetItem = function ( e ) {
	var $option = $( e.target ).closest( '.oo-ui-optionWidget' );
	if ( !$option.closest( '.oo-ui-selectWidget' ).is( this.$element ) ) {
		return null;
	}
	return $option.data( 'oo-ui-optionWidget' ) || null;
};

/**
 * Find selected item.
 *
 * @return {OO.ui.OptionWidget|null} Selected item, `null` if no item is selected
 */
OO.ui.SelectWidget.prototype.findSelectedItem = function () {
	var i, len;

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		if ( this.items[ i ].isSelected() ) {
			return this.items[ i ];
		}
	}
	return null;
};

/**
 * Find highlighted item.
 *
 * @return {OO.ui.OptionWidget|null} Highlighted item, `null` if no item is highlighted
 */
OO.ui.SelectWidget.prototype.findHighlightedItem = function () {
	var i, len;

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		if ( this.items[ i ].isHighlighted() ) {
			return this.items[ i ];
		}
	}
	return null;
};

/**
 * Toggle pressed state.
 *
 * Press is a state that occurs when a user mouses down on an item, but
 * has not yet let go of the mouse. The item may appear selected, but it will not be selected
 * until the user releases the mouse.
 *
 * @param {boolean} pressed An option is being pressed
 */
OO.ui.SelectWidget.prototype.togglePressed = function ( pressed ) {
	if ( pressed === undefined ) {
		pressed = !this.pressed;
	}
	if ( pressed !== this.pressed ) {
		this.$element
			.toggleClass( 'oo-ui-selectWidget-pressed', pressed )
			.toggleClass( 'oo-ui-selectWidget-depressed', !pressed );
		this.pressed = pressed;
	}
};

/**
 * Highlight an option. If the `item` param is omitted, no options will be highlighted
 * and any existing highlight will be removed. The highlight is mutually exclusive.
 *
 * @param {OO.ui.OptionWidget} [item] Item to highlight, omit for no highlight
 * @fires highlight
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.highlightItem = function ( item ) {
	var i, len, highlighted,
		changed = false;

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		highlighted = this.items[ i ] === item;
		if ( this.items[ i ].isHighlighted() !== highlighted ) {
			this.items[ i ].setHighlighted( highlighted );
			changed = true;
		}
	}
	if ( changed ) {
		if ( item ) {
			this.$focusOwner.attr( 'aria-activedescendant', item.getElementId() );
		} else {
			this.$focusOwner.removeAttr( 'aria-activedescendant' );
		}
		this.emit( 'highlight', item );
	}

	return this;
};

/**
 * Fetch an item by its label.
 *
 * @param {string} label Label of the item to select.
 * @param {boolean} [prefix=false] Allow a prefix match, if only a single item matches
 * @return {OO.ui.Element|null} Item with equivalent label, `null` if none exists
 */
OO.ui.SelectWidget.prototype.getItemFromLabel = function ( label, prefix ) {
	var i, item, found,
		len = this.items.length,
		filter = this.getItemMatcher( label, true );

	for ( i = 0; i < len; i++ ) {
		item = this.items[ i ];
		if ( item instanceof OO.ui.OptionWidget && item.isSelectable() && filter( item ) ) {
			return item;
		}
	}

	if ( prefix ) {
		found = null;
		filter = this.getItemMatcher( label, false );
		for ( i = 0; i < len; i++ ) {
			item = this.items[ i ];
			if ( item instanceof OO.ui.OptionWidget && item.isSelectable() && filter( item ) ) {
				if ( found ) {
					return null;
				}
				found = item;
			}
		}
		if ( found ) {
			return found;
		}
	}

	return null;
};

/**
 * Programmatically select an option by its label. If the item does not exist,
 * all options will be deselected.
 *
 * @param {string} [label] Label of the item to select.
 * @param {boolean} [prefix=false] Allow a prefix match, if only a single item matches
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.selectItemByLabel = function ( label, prefix ) {
	var itemFromLabel = this.getItemFromLabel( label, !!prefix );
	if ( label === undefined || !itemFromLabel ) {
		return this.selectItem();
	}
	return this.selectItem( itemFromLabel );
};

/**
 * Programmatically select an option by its data. If the `data` parameter is omitted,
 * or if the item does not exist, all options will be deselected.
 *
 * @param {Object|string} [data] Value of the item to select, omit to deselect all
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.selectItemByData = function ( data ) {
	var itemFromData = this.findItemFromData( data );
	if ( data === undefined || !itemFromData ) {
		return this.selectItem();
	}
	return this.selectItem( itemFromData );
};

/**
 * Programmatically select an option by its reference. If the `item` parameter is omitted,
 * all options will be deselected.
 *
 * @param {OO.ui.OptionWidget} [item] Item to select, omit to deselect all
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
*/
OO.ui.SelectWidget.prototype.selectItem = function ( item ) {
	var i, len, selected,
		changed = false;

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		selected = this.items[ i ] === item;
		if ( this.items[ i ].isSelected() !== selected ) {
			this.items[ i ].setSelected( selected );
			changed = true;
		}
	}
	if ( changed ) {
		if ( item && !item.constructor.static.highlightable ) {
			if ( item ) {
				this.$focusOwner.attr( 'aria-activedescendant', item.getElementId() );
			} else {
				this.$focusOwner.removeAttr( 'aria-activedescendant' );
			}
		}
		this.emit( 'select', item );
	}

	return this;
};

/**
 * Press an item.
 *
 * Press is a state that occurs when a user mouses down on an item, but has not
 * yet let go of the mouse. The item may appear selected, but it will not be selected until the user
 * releases the mouse.
 *
 * @param {OO.ui.OptionWidget} [item] Item to press, omit to depress all
 * @fires press
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.pressItem = function ( item ) {
	var i, len, pressed,
		changed = false;

	for ( i = 0, len = this.items.length; i < len; i++ ) {
		pressed = this.items[ i ] === item;
		if ( this.items[ i ].isPressed() !== pressed ) {
			this.items[ i ].setPressed( pressed );
			changed = true;
		}
	}
	if ( changed ) {
		this.emit( 'press', item );
	}

	return this;
};

/**
 * Choose an item.
 *
 * Note that ‘choose’ should never be modified programmatically. A user can choose
 * an option with the keyboard or mouse and it becomes selected. To select an item programmatically,
 * use the #selectItem method.
 *
 * This method is identical to #selectItem, but may vary in subclasses that take additional action
 * when users choose an item with the keyboard or mouse.
 *
 * @param {OO.ui.OptionWidget} item Item to choose
 * @fires choose
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.chooseItem = function ( item ) {
	if ( item ) {
		this.selectItem( item );
		this.emit( 'choose', item );
	}

	return this;
};

/**
 * Find an option by its position relative to the specified item (or to the start of the option array,
 * if item is `null`). The direction in which to search through the option array is specified with a
 * number: -1 for reverse (the default) or 1 for forward. The method will return an option, or
 * `null` if there are no options in the array.
 *
 * @param {OO.ui.OptionWidget|null} item Item to describe the start position, or `null` to start at the beginning of the array.
 * @param {number} direction Direction to move in: -1 to move backward, 1 to move forward
 * @param {Function} [filter] Only consider items for which this function returns
 *  true. Function takes an OO.ui.OptionWidget and returns a boolean.
 * @return {OO.ui.OptionWidget|null} Item at position, `null` if there are no items in the select
 */
OO.ui.SelectWidget.prototype.findRelativeSelectableItem = function ( item, direction, filter ) {
	var currentIndex, nextIndex, i,
		increase = direction > 0 ? 1 : -1,
		len = this.items.length;

	if ( item instanceof OO.ui.OptionWidget ) {
		currentIndex = this.items.indexOf( item );
		nextIndex = ( currentIndex + increase + len ) % len;
	} else {
		// If no item is selected and moving forward, start at the beginning.
		// If moving backward, start at the end.
		nextIndex = direction > 0 ? 0 : len - 1;
	}

	for ( i = 0; i < len; i++ ) {
		item = this.items[ nextIndex ];
		if (
			item instanceof OO.ui.OptionWidget && item.isSelectable() &&
			( !filter || filter( item ) )
		) {
			return item;
		}
		nextIndex = ( nextIndex + increase + len ) % len;
	}
	return null;
};

/**
 * Find the next selectable item or `null` if there are no selectable items.
 * Disabled options and menu-section markers and breaks are not selectable.
 *
 * @return {OO.ui.OptionWidget|null} Item, `null` if there aren't any selectable items
 */
OO.ui.SelectWidget.prototype.findFirstSelectableItem = function () {
	return this.findRelativeSelectableItem( null, 1 );
};

/**
 * Add an array of options to the select. Optionally, an index number can be used to
 * specify an insertion point.
 *
 * @param {OO.ui.OptionWidget[]} items Items to add
 * @param {number} [index] Index to insert items after
 * @fires add
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.addItems = function ( items, index ) {
	// Mixin method
	OO.ui.mixin.GroupWidget.prototype.addItems.call( this, items, index );

	// Always provide an index, even if it was omitted
	this.emit( 'add', items, index === undefined ? this.items.length - items.length - 1 : index );

	return this;
};

/**
 * Remove the specified array of options from the select. Options will be detached
 * from the DOM, not removed, so they can be reused later. To remove all options from
 * the select, you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.OptionWidget[]} items Items to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.removeItems = function ( items ) {
	var i, len, item;

	// Deselect items being removed
	for ( i = 0, len = items.length; i < len; i++ ) {
		item = items[ i ];
		if ( item.isSelected() ) {
			this.selectItem( null );
		}
	}

	// Mixin method
	OO.ui.mixin.GroupWidget.prototype.removeItems.call( this, items );

	this.emit( 'remove', items );

	return this;
};

/**
 * Clear all options from the select. Options will be detached from the DOM, not removed,
 * so that they can be reused later. To remove a subset of options from the select, use
 * the #removeItems method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.clearItems = function () {
	var items = this.items.slice();

	// Mixin method
	OO.ui.mixin.GroupWidget.prototype.clearItems.call( this );

	// Clear selection
	this.selectItem( null );

	this.emit( 'remove', items );

	return this;
};

/**
 * Set the DOM element which has focus while the user is interacting with this SelectWidget.
 *
 * This is used to set `aria-activedescendant` and `aria-expanded` on it.
 *
 * @protected
 * @param {jQuery} $focusOwner
 */
OO.ui.SelectWidget.prototype.setFocusOwner = function ( $focusOwner ) {
	this.$focusOwner = $focusOwner;
};

/**
 * DecoratedOptionWidgets are {@link OO.ui.OptionWidget options} that can be configured
 * with an {@link OO.ui.mixin.IconElement icon} and/or {@link OO.ui.mixin.IndicatorElement indicator}.
 * This class is used with OO.ui.SelectWidget to create a selection of mutually exclusive
 * options. For more information about options and selects, please see the
 * [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // Decorated options in a select widget.
 *     var select = new OO.ui.SelectWidget( {
 *         items: [
 *             new OO.ui.DecoratedOptionWidget( {
 *                 data: 'a',
 *                 label: 'Option with icon',
 *                 icon: 'help'
 *             } ),
 *             new OO.ui.DecoratedOptionWidget( {
 *                 data: 'b',
 *                 label: 'Option with indicator',
 *                 indicator: 'next'
 *             } )
 *         ]
 *     } );
 *     $( document.body ).append( select.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.OptionWidget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.DecoratedOptionWidget = function OoUiDecoratedOptionWidget( config ) {
	// Parent constructor
	OO.ui.DecoratedOptionWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );

	// Initialization
	this.$element
		.addClass( 'oo-ui-decoratedOptionWidget' )
		.prepend( this.$icon )
		.append( this.$indicator );
};

/* Setup */

OO.inheritClass( OO.ui.DecoratedOptionWidget, OO.ui.OptionWidget );
OO.mixinClass( OO.ui.DecoratedOptionWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.DecoratedOptionWidget, OO.ui.mixin.IndicatorElement );

/**
 * MenuOptionWidget is an option widget that looks like a menu item. The class is used with
 * OO.ui.MenuSelectWidget to create a menu of mutually exclusive options. Please see
 * the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.MenuOptionWidget = function OoUiMenuOptionWidget( config ) {
	// Parent constructor
	OO.ui.MenuOptionWidget.parent.call( this, config );

	// Properties
	this.checkIcon = new OO.ui.IconWidget( {
		icon: 'check',
		classes: [ 'oo-ui-menuOptionWidget-checkIcon' ]
	} );

	// Initialization
	this.$element
		.prepend( this.checkIcon.$element )
		.addClass( 'oo-ui-menuOptionWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * MenuSectionOptionWidgets are used inside {@link OO.ui.MenuSelectWidget menu select widgets} to group one or more related
 * {@link OO.ui.MenuOptionWidget menu options}. MenuSectionOptionWidgets cannot be highlighted or selected.
 *
 *     @example
 *     var dropdown = new OO.ui.DropdownWidget( {
 *         menu: {
 *             items: [
 *                 new OO.ui.MenuSectionOptionWidget( {
 *                     label: 'Dogs'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'corgi',
 *                     label: 'Welsh Corgi'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'poodle',
 *                     label: 'Standard Poodle'
 *                 } ),
 *                 new OO.ui.MenuSectionOptionWidget( {
 *                     label: 'Cats'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'lion',
 *                     label: 'Lion'
 *                 } )
 *             ]
 *         }
 *     } );
 *     $( document.body ).append( dropdown.$element );
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.MenuSectionOptionWidget = function OoUiMenuSectionOptionWidget( config ) {
	// Parent constructor
	OO.ui.MenuSectionOptionWidget.parent.call( this, config );

	// Initialization
	this.$element.addClass( 'oo-ui-menuSectionOptionWidget' )
		.removeAttr( 'role aria-selected' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuSectionOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuSectionOptionWidget.static.selectable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuSectionOptionWidget.static.highlightable = false;

/**
 * MenuSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains options and
 * is used together with OO.ui.MenuOptionWidget. It is designed be used as part of another widget.
 * See {@link OO.ui.DropdownWidget DropdownWidget}, {@link OO.ui.ComboBoxInputWidget ComboBoxInputWidget},
 * and {@link OO.ui.mixin.LookupElement LookupElement} for examples of widgets that contain menus.
 * MenuSelectWidgets themselves are not instantiated directly, rather subclassed
 * and customized to be opened, closed, and displayed as needed.
 *
 * By default, menus are clipped to the visible viewport and are not visible when a user presses the
 * mouse outside the menu.
 *
 * Menus also have support for keyboard interaction:
 *
 * - Enter/Return key: choose and select a menu option
 * - Up-arrow key: highlight the previous menu option
 * - Down-arrow key: highlight the next menu option
 * - Esc key: hide the menu
 *
 * Unlike most widgets, MenuSelectWidget is initially hidden and must be shown by calling #toggle.
 *
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.ClippableElement
 * @mixins OO.ui.mixin.FloatableElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.TextInputWidget} [input] Text input used to implement option highlighting for menu items that match
 *  the text the user types. This config is used by {@link OO.ui.ComboBoxInputWidget ComboBoxInputWidget}
 *  and {@link OO.ui.mixin.LookupElement LookupElement}
 * @cfg {jQuery} [$input] Text input used to implement option highlighting for menu items that match
 *  the text the user types. This config is used by {@link OO.ui.TagMultiselectWidget TagMultiselectWidget}
 * @cfg {OO.ui.Widget} [widget] Widget associated with the menu's active state. If the user clicks the mouse
 *  anywhere on the page outside of this widget, the menu is hidden. For example, if there is a button
 *  that toggles the menu's visibility on click, the menu will be hidden then re-shown when the user clicks
 *  that button, unless the button (or its parent widget) is passed in here.
 * @cfg {boolean} [autoHide=true] Hide the menu when the mouse is pressed outside the menu.
 * @cfg {jQuery} [$autoCloseIgnore] If these elements are clicked, don't auto-hide the menu.
 * @cfg {boolean} [hideOnChoose=true] Hide the menu when the user chooses an option.
 * @cfg {boolean} [filterFromInput=false] Filter the displayed options from the input
 * @cfg {boolean} [highlightOnFilter] Highlight the first result when filtering
 * @cfg {number} [width] Width of the menu
 */
OO.ui.MenuSelectWidget = function OoUiMenuSelectWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.MenuSelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ClippableElement.call( this, $.extend( {}, config, { $clippable: this.$group } ) );
	OO.ui.mixin.FloatableElement.call( this, config );

	// Initial vertical positions other than 'center' will result in
	// the menu being flipped if there is not enough space in the container.
	// Store the original position so we know what to reset to.
	this.originalVerticalPosition = this.verticalPosition;

	// Properties
	this.autoHide = config.autoHide === undefined || !!config.autoHide;
	this.hideOnChoose = config.hideOnChoose === undefined || !!config.hideOnChoose;
	this.filterFromInput = !!config.filterFromInput;
	this.$input = config.$input ? config.$input : config.input ? config.input.$input : null;
	this.$widget = config.widget ? config.widget.$element : null;
	this.$autoCloseIgnore = config.$autoCloseIgnore || $( [] );
	this.onDocumentMouseDownHandler = this.onDocumentMouseDown.bind( this );
	this.onInputEditHandler = OO.ui.debounce( this.updateItemVisibility.bind( this ), 100 );
	this.highlightOnFilter = !!config.highlightOnFilter;
	this.width = config.width;

	// Initialization
	this.$element.addClass( 'oo-ui-menuSelectWidget' );
	if ( config.widget ) {
		this.setFocusOwner( config.widget.$tabIndexed );
	}

	// Initially hidden - using #toggle may cause errors if subclasses override toggle with methods
	// that reference properties not initialized at that time of parent class construction
	// TODO: Find a better way to handle post-constructor setup
	this.visible = false;
	this.$element.addClass( 'oo-ui-element-hidden' );
	this.$focusOwner.attr( 'aria-expanded', 'false' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.MenuSelectWidget, OO.ui.mixin.ClippableElement );
OO.mixinClass( OO.ui.MenuSelectWidget, OO.ui.mixin.FloatableElement );

/* Events */

/**
 * @event ready
 *
 * The menu is ready: it is visible and has been positioned and clipped.
 */

/* Static properties */

/**
 * Positions to flip to if there isn't room in the container for the
 * menu in a specific direction.
 *
 * @property {Object.<string,string>}
 */
OO.ui.MenuSelectWidget.static.flippedPositions = {
	below: 'above',
	above: 'below',
	top: 'bottom',
	bottom: 'top'
};

/* Methods */

/**
 * Handles document mouse down events.
 *
 * @protected
 * @param {MouseEvent} e Mouse down event
 */
OO.ui.MenuSelectWidget.prototype.onDocumentMouseDown = function ( e ) {
	if (
		this.isVisible() &&
		!OO.ui.contains(
			this.$element.add( this.$widget ).add( this.$autoCloseIgnore ).get(),
			e.target,
			true
		)
	) {
		this.toggle( false );
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.onDocumentKeyDown = function ( e ) {
	var currentItem = this.findHighlightedItem() || this.findSelectedItem();

	if ( !this.isDisabled() && this.isVisible() ) {
		switch ( e.keyCode ) {
			case OO.ui.Keys.LEFT:
			case OO.ui.Keys.RIGHT:
				// Do nothing if a text field is associated, arrow keys will be handled natively
				if ( !this.$input ) {
					OO.ui.MenuSelectWidget.parent.prototype.onDocumentKeyDown.call( this, e );
				}
				break;
			case OO.ui.Keys.ESCAPE:
			case OO.ui.Keys.TAB:
				if ( currentItem ) {
					currentItem.setHighlighted( false );
				}
				this.toggle( false );
				// Don't prevent tabbing away, prevent defocusing
				if ( e.keyCode === OO.ui.Keys.ESCAPE ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
			default:
				OO.ui.MenuSelectWidget.parent.prototype.onDocumentKeyDown.call( this, e );
				return;
		}
	}
};

/**
 * Update menu item visibility and clipping after input changes (if filterFromInput is enabled)
 * or after items were added/removed (always).
 *
 * @protected
 */
OO.ui.MenuSelectWidget.prototype.updateItemVisibility = function () {
	var i, item, items, visible, section, sectionEmpty, filter, exactFilter,
		anyVisible = false,
		len = this.items.length,
		showAll = !this.isVisible(),
		exactMatch = false;

	if ( this.$input && this.filterFromInput ) {
		filter = showAll ? null : this.getItemMatcher( this.$input.val() );
		exactFilter = this.getItemMatcher( this.$input.val(), true );
		// Hide non-matching options, and also hide section headers if all options
		// in their section are hidden.
		for ( i = 0; i < len; i++ ) {
			item = this.items[ i ];
			if ( item instanceof OO.ui.MenuSectionOptionWidget ) {
				if ( section ) {
					// If the previous section was empty, hide its header
					section.toggle( showAll || !sectionEmpty );
				}
				section = item;
				sectionEmpty = true;
			} else if ( item instanceof OO.ui.OptionWidget ) {
				visible = showAll || filter( item );
				exactMatch = exactMatch || exactFilter( item );
				anyVisible = anyVisible || visible;
				sectionEmpty = sectionEmpty && !visible;
				item.toggle( visible );
			}
		}
		// Process the final section
		if ( section ) {
			section.toggle( showAll || !sectionEmpty );
		}

		if ( anyVisible && this.items.length && !exactMatch ) {
			this.scrollItemIntoView( this.items[ 0 ] );
		}

		if ( !anyVisible ) {
			this.highlightItem( null );
		}

		this.$element.toggleClass( 'oo-ui-menuSelectWidget-invisible', !anyVisible );

		if ( this.highlightOnFilter ) {
			// Highlight the first item on the list
			item = null;
			items = this.getItems();
			for ( i = 0; i < items.length; i++ ) {
				if ( items[ i ].isVisible() ) {
					item = items[ i ];
					break;
				}
			}
			this.highlightItem( item );
		}

	}

	// Reevaluate clipping
	this.clip();
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.bindDocumentKeyDownListener = function () {
	if ( this.$input ) {
		this.$input.on( 'keydown', this.onDocumentKeyDownHandler );
	} else {
		OO.ui.MenuSelectWidget.parent.prototype.bindDocumentKeyDownListener.call( this );
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.unbindDocumentKeyDownListener = function () {
	if ( this.$input ) {
		this.$input.off( 'keydown', this.onDocumentKeyDownHandler );
	} else {
		OO.ui.MenuSelectWidget.parent.prototype.unbindDocumentKeyDownListener.call( this );
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.bindDocumentKeyPressListener = function () {
	if ( this.$input ) {
		if ( this.filterFromInput ) {
			this.$input.on( 'keydown mouseup cut paste change input select', this.onInputEditHandler );
			this.updateItemVisibility();
		}
	} else {
		OO.ui.MenuSelectWidget.parent.prototype.bindDocumentKeyPressListener.call( this );
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.unbindDocumentKeyPressListener = function () {
	if ( this.$input ) {
		if ( this.filterFromInput ) {
			this.$input.off( 'keydown mouseup cut paste change input select', this.onInputEditHandler );
			this.updateItemVisibility();
		}
	} else {
		OO.ui.MenuSelectWidget.parent.prototype.unbindDocumentKeyPressListener.call( this );
	}
};

/**
 * Choose an item.
 *
 * When a user chooses an item, the menu is closed, unless the hideOnChoose config option is set to false.
 *
 * Note that ‘choose’ should never be modified programmatically. A user can choose an option with the keyboard
 * or mouse and it becomes selected. To select an item programmatically, use the #selectItem method.
 *
 * @param {OO.ui.OptionWidget} item Item to choose
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MenuSelectWidget.prototype.chooseItem = function ( item ) {
	OO.ui.MenuSelectWidget.parent.prototype.chooseItem.call( this, item );
	if ( this.hideOnChoose ) {
		this.toggle( false );
	}
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.addItems = function ( items, index ) {
	// Parent method
	OO.ui.MenuSelectWidget.parent.prototype.addItems.call( this, items, index );

	this.updateItemVisibility();

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.removeItems = function ( items ) {
	// Parent method
	OO.ui.MenuSelectWidget.parent.prototype.removeItems.call( this, items );

	this.updateItemVisibility();

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.clearItems = function () {
	// Parent method
	OO.ui.MenuSelectWidget.parent.prototype.clearItems.call( this );

	this.updateItemVisibility();

	return this;
};

/**
 * Toggle visibility of the menu. The menu is initially hidden and must be shown by calling
 * `.toggle( true )` after its #$element is attached to the DOM.
 *
 * Do not show the menu while it is not attached to the DOM. The calculations required to display
 * it in the right place and with the right dimensions only work correctly while it is attached.
 * Side-effects may include broken interface and exceptions being thrown. This wasn't always
 * strictly enforced, so currently it only generates a warning in the browser console.
 *
 * @fires ready
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.toggle = function ( visible ) {
	var change, originalHeight, flippedHeight;

	visible = ( visible === undefined ? !this.visible : !!visible ) && !!this.items.length;
	change = visible !== this.isVisible();

	if ( visible && !this.warnedUnattached && !this.isElementAttached() ) {
		OO.ui.warnDeprecation( 'MenuSelectWidget#toggle: Before calling this method, the menu must be attached to the DOM.' );
		this.warnedUnattached = true;
	}

	if ( change && visible ) {
		// Reset position before showing the popup again. It's possible we no longer need to flip
		// (e.g. if the user scrolled).
		this.setVerticalPosition( this.originalVerticalPosition );
	}

	// Parent method
	OO.ui.MenuSelectWidget.parent.prototype.toggle.call( this, visible );

	if ( change ) {
		if ( visible ) {

			if ( this.width ) {
				this.setIdealSize( this.width );
			} else if ( this.$floatableContainer ) {
				this.$clippable.css( 'width', 'auto' );
				this.setIdealSize(
					this.$floatableContainer[ 0 ].offsetWidth > this.$clippable[ 0 ].offsetWidth ?
						// Dropdown is smaller than handle so expand to width
						this.$floatableContainer[ 0 ].offsetWidth :
						// Dropdown is larger than handle so auto size
						'auto'
				);
				this.$clippable.css( 'width', '' );
			}

			this.togglePositioning( !!this.$floatableContainer );
			this.toggleClipping( true );

			this.bindDocumentKeyDownListener();
			this.bindDocumentKeyPressListener();

			if (
				( this.isClippedVertically() || this.isFloatableOutOfView() ) &&
				this.originalVerticalPosition !== 'center'
			) {
				// If opening the menu in one direction causes it to be clipped, flip it
				originalHeight = this.$element.height();
				this.setVerticalPosition(
					this.constructor.static.flippedPositions[ this.originalVerticalPosition ]
				);
				if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
					// If flipping also causes it to be clipped, open in whichever direction
					// we have more space
					flippedHeight = this.$element.height();
					if ( originalHeight > flippedHeight ) {
						this.setVerticalPosition( this.originalVerticalPosition );
					}
				}
			}
			// Note that we do not flip the menu's opening direction if the clipping changes
			// later (e.g. after the user scrolls), that seems like it would be annoying

			this.$focusOwner.attr( 'aria-expanded', 'true' );

			if ( this.findSelectedItem() ) {
				this.$focusOwner.attr( 'aria-activedescendant', this.findSelectedItem().getElementId() );
				this.findSelectedItem().scrollElementIntoView( { duration: 0 } );
			}

			// Auto-hide
			if ( this.autoHide ) {
				this.getElementDocument().addEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
			}

			this.emit( 'ready' );
		} else {
			this.$focusOwner.removeAttr( 'aria-activedescendant' );
			this.unbindDocumentKeyDownListener();
			this.unbindDocumentKeyPressListener();
			this.$focusOwner.attr( 'aria-expanded', 'false' );
			this.getElementDocument().removeEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
			this.togglePositioning( false );
			this.toggleClipping( false );
		}
	}

	return this;
};

/**
 * DropdownWidgets are not menus themselves, rather they contain a menu of options created with
 * OO.ui.MenuOptionWidget. The DropdownWidget takes care of opening and displaying the menu so that
 * users can interact with it.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.DropdownInputWidget instead.
 *
 *     @example
 *     // A DropdownWidget with a menu that contains three options.
 *     var dropDown = new OO.ui.DropdownWidget( {
 *         label: 'Dropdown menu: Select a menu option',
 *         menu: {
 *             items: [
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'a',
 *                     label: 'First'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'b',
 *                     label: 'Second'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'c',
 *                     label: 'Third'
 *                 } )
 *             ]
 *         }
 *     } );
 *
 *     $( document.body ).append( dropDown.$element );
 *
 *     dropDown.getMenu().selectItemByData( 'b' );
 *
 *     dropDown.getMenu().findSelectedItem().getData(); // Returns 'b'.
 *
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [menu] Configuration options to pass to {@link OO.ui.MenuSelectWidget menu select widget}
 * @cfg {jQuery} [$overlay] Render the menu into a separate layer. This configuration is useful in cases where
 *  the expanded menu is larger than its containing `<div>`. The specified overlay layer is usually on top of the
 *  containing `<div>` and has a larger area. By default, the menu uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.DropdownWidget = function OoUiDropdownWidget( config ) {
	// Configuration initialization
	config = $.extend( { indicator: 'down' }, config );

	// Parent constructor
	OO.ui.DropdownWidget.parent.call( this, config );

	// Properties (must be set before TabIndexedElement constructor call)
	this.$handle = $( '<button>' );
	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$label } ) );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$handle } ) );

	// Properties
	this.menu = new OO.ui.MenuSelectWidget( $.extend( {
		widget: this,
		$floatableContainer: this.$element
	}, config.menu ) );

	// Events
	this.$handle.on( {
		click: this.onClick.bind( this ),
		keydown: this.onKeyDown.bind( this ),
		// Hack? Handle type-to-search when menu is not expanded and not handling its own events
		keypress: this.menu.onDocumentKeyPressHandler,
		blur: this.menu.clearKeyPressBuffer.bind( this.menu )
	} );
	this.menu.connect( this, {
		select: 'onMenuSelect',
		toggle: 'onMenuToggle'
	} );

	// Initialization
	this.$handle
		.addClass( 'oo-ui-dropdownWidget-handle' )
		.attr( {
			type: 'button',
			'aria-owns': this.menu.getElementId(),
			'aria-haspopup': 'listbox'
		} )
		.append( this.$icon, this.$label, this.$indicator );
	this.$element
		.addClass( 'oo-ui-dropdownWidget' )
		.append( this.$handle );
	this.$overlay.append( this.menu.$element );
};

/* Setup */

OO.inheritClass( OO.ui.DropdownWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Get the menu.
 *
 * @return {OO.ui.MenuSelectWidget} Menu of widget
 */
OO.ui.DropdownWidget.prototype.getMenu = function () {
	return this.menu;
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.MenuOptionWidget} item Selected menu item
 */
OO.ui.DropdownWidget.prototype.onMenuSelect = function ( item ) {
	var selectedLabel;

	if ( !item ) {
		this.setLabel( null );
		return;
	}

	selectedLabel = item.getLabel();

	// If the label is a DOM element, clone it, because setLabel will append() it
	if ( selectedLabel instanceof $ ) {
		selectedLabel = selectedLabel.clone();
	}

	this.setLabel( selectedLabel );
};

/**
 * Handle menu toggle events.
 *
 * @private
 * @param {boolean} isVisible Open state of the menu
 */
OO.ui.DropdownWidget.prototype.onMenuToggle = function ( isVisible ) {
	this.$element.toggleClass( 'oo-ui-dropdownWidget-open', isVisible );
};

/**
 * Handle mouse click events.
 *
 * @private
 * @param {jQuery.Event} e Mouse click event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.DropdownWidget.prototype.onClick = function ( e ) {
	if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
		this.menu.toggle();
	}
	return false;
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.DropdownWidget.prototype.onKeyDown = function ( e ) {
	if (
		!this.isDisabled() &&
		(
			e.which === OO.ui.Keys.ENTER ||
			(
				e.which === OO.ui.Keys.SPACE &&
				// Avoid conflicts with type-to-search, see SelectWidget#onKeyPress.
				// Space only closes the menu is the user is not typing to search.
				this.menu.keyPressBuffer === ''
			) ||
			(
				!this.menu.isVisible() &&
				(
					e.which === OO.ui.Keys.UP ||
					e.which === OO.ui.Keys.DOWN
				)
			)
		)
	) {
		this.menu.toggle();
		return false;
	}
};

/**
 * RadioOptionWidget is an option widget that looks like a radio button.
 * The class is used with OO.ui.RadioSelectWidget to create a selection of radio options.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_option
 *
 * @class
 * @extends OO.ui.OptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.RadioOptionWidget = function OoUiRadioOptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Properties (must be done before parent constructor which calls #setDisabled)
	this.radio = new OO.ui.RadioInputWidget( { value: config.data, tabIndex: -1 } );

	// Parent constructor
	OO.ui.RadioOptionWidget.parent.call( this, config );

	// Initialization
	// Remove implicit role, we're handling it ourselves
	this.radio.$input.attr( 'role', 'presentation' );
	this.$element
		.addClass( 'oo-ui-radioOptionWidget' )
		.attr( 'role', 'radio' )
		.attr( 'aria-checked', 'false' )
		.removeAttr( 'aria-selected' )
		.prepend( this.radio.$element );
};

/* Setup */

OO.inheritClass( OO.ui.RadioOptionWidget, OO.ui.OptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.highlightable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.pressable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.tagName = 'label';

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.prototype.setSelected = function ( state ) {
	OO.ui.RadioOptionWidget.parent.prototype.setSelected.call( this, state );

	this.radio.setSelected( state );
	this.$element
		.attr( 'aria-checked', state.toString() )
		.removeAttr( 'aria-selected' );

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.prototype.setDisabled = function ( disabled ) {
	OO.ui.RadioOptionWidget.parent.prototype.setDisabled.call( this, disabled );

	this.radio.setDisabled( this.isDisabled() );

	return this;
};

/**
 * RadioSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains radio
 * options and is used together with OO.ui.RadioOptionWidget. The RadioSelectWidget provides
 * an interface for adding, removing and selecting options.
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.RadioSelectInputWidget instead.
 *
 *     @example
 *     // A RadioSelectWidget with RadioOptions.
 *     var option1 = new OO.ui.RadioOptionWidget( {
 *             data: 'a',
 *             label: 'Selected radio option'
 *         } ),
 *         option2 = new OO.ui.RadioOptionWidget( {
 *             data: 'b',
 *             label: 'Unselected radio option'
 *         } );
 *         radioSelect = new OO.ui.RadioSelectWidget( {
 *             items: [ option1, option2 ]
 *         } );
 *
 *     // Select 'option 1' using the RadioSelectWidget's selectItem() method.
 *     radioSelect.selectItem( option1 );
 *
 *     $( document.body ).append( radioSelect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options

 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.RadioSelectWidget = function OoUiRadioSelectWidget( config ) {
	// Parent constructor
	OO.ui.RadioSelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.TabIndexedElement.call( this, config );

	// Events
	this.$element.on( {
		focus: this.bindDocumentKeyDownListener.bind( this ),
		blur: this.unbindDocumentKeyDownListener.bind( this )
	} );

	// Initialization
	this.$element
		.addClass( 'oo-ui-radioSelectWidget' )
		.attr( 'role', 'radiogroup' );
};

/* Setup */

OO.inheritClass( OO.ui.RadioSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.RadioSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * MultioptionWidgets are special elements that can be selected and configured with data. The
 * data is often unique for each option, but it does not have to be. MultioptionWidgets are used
 * with OO.ui.SelectWidget to create a selection of mutually exclusive options. For more information
 * and examples, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Multioptions
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Whether the option is initially selected
 */
OO.ui.MultioptionWidget = function OoUiMultioptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.MultioptionWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ItemWidget.call( this );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );

	// Properties
	this.selected = null;

	// Initialization
	this.$element
		.addClass( 'oo-ui-multioptionWidget' )
		.append( this.$label );
	this.setSelected( config.selected );
};

/* Setup */

OO.inheritClass( OO.ui.MultioptionWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the selected state of the option changes.
 *
 * @param {boolean} selected Whether the option is now selected
 */

/* Methods */

/**
 * Check if the option is selected.
 *
 * @return {boolean} Item is selected
 */
OO.ui.MultioptionWidget.prototype.isSelected = function () {
	return this.selected;
};

/**
 * Set the option’s selected state. In general, all modifications to the selection
 * should be handled by the SelectWidget’s {@link OO.ui.SelectWidget#selectItem selectItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Select option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultioptionWidget.prototype.setSelected = function ( state ) {
	state = !!state;
	if ( this.selected !== state ) {
		this.selected = state;
		this.emit( 'change', state );
		this.$element.toggleClass( 'oo-ui-multioptionWidget-selected', state );
	}
	return this;
};

/**
 * MultiselectWidget allows selecting multiple options from a list.
 *
 * For more information about menus and options, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @abstract
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.MultioptionWidget[]} [items] An array of options to add to the multiselect.
 */
OO.ui.MultiselectWidget = function OoUiMultiselectWidget( config ) {
	// Parent constructor
	OO.ui.MultiselectWidget.parent.call( this, config );

	// Configuration initialization
	config = config || {};

	// Mixin constructors
	OO.ui.mixin.GroupWidget.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );

	// Events
	this.aggregate( { change: 'select' } );
	// This is mostly for compatibility with TagMultiselectWidget... normally, 'change' is emitted
	// by GroupElement only when items are added/removed
	this.connect( this, { select: [ 'emit', 'change' ] } );

	// Initialization
	if ( config.items ) {
		this.addItems( config.items );
	}
	this.$group.addClass( 'oo-ui-multiselectWidget-group' );
	this.$element.addClass( 'oo-ui-multiselectWidget' )
		.append( this.$group );
};

/* Setup */

OO.inheritClass( OO.ui.MultiselectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.MultiselectWidget, OO.ui.mixin.GroupWidget );
OO.mixinClass( OO.ui.MultiselectWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the set of items changes, or an item is selected or deselected.
 */

/**
 * @event select
 *
 * A select event is emitted when an item is selected or deselected.
 */

/* Methods */

/**
 * Find options that are selected.
 *
 * @return {OO.ui.MultioptionWidget[]} Selected options
 */
OO.ui.MultiselectWidget.prototype.findSelectedItems = function () {
	return this.items.filter( function ( item ) {
		return item.isSelected();
	} );
};

/**
 * Find the data of options that are selected.
 *
 * @return {Object[]|string[]} Values of selected options
 */
OO.ui.MultiselectWidget.prototype.findSelectedItemsData = function () {
	return this.findSelectedItems().map( function ( item ) {
		return item.data;
	} );
};

/**
 * Select options by reference. Options not mentioned in the `items` array will be deselected.
 *
 * @param {OO.ui.MultioptionWidget[]} items Items to select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultiselectWidget.prototype.selectItems = function ( items ) {
	this.items.forEach( function ( item ) {
		var selected = items.indexOf( item ) !== -1;
		item.setSelected( selected );
	} );
	return this;
};

/**
 * Select items by their data. Options not mentioned in the `datas` array will be deselected.
 *
 * @param {Object[]|string[]} datas Values of items to select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultiselectWidget.prototype.selectItemsByData = function ( datas ) {
	var items,
		widget = this;
	items = datas.map( function ( data ) {
		return widget.findItemFromData( data );
	} );
	this.selectItems( items );
	return this;
};

/**
 * CheckboxMultioptionWidget is an option widget that looks like a checkbox.
 * The class is used with OO.ui.CheckboxMultiselectWidget to create a selection of checkbox options.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_option
 *
 * @class
 * @extends OO.ui.MultioptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.CheckboxMultioptionWidget = function OoUiCheckboxMultioptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Properties (must be done before parent constructor which calls #setDisabled)
	this.checkbox = new OO.ui.CheckboxInputWidget();

	// Parent constructor
	OO.ui.CheckboxMultioptionWidget.parent.call( this, config );

	// Events
	this.checkbox.on( 'change', this.onCheckboxChange.bind( this ) );
	this.$element.on( 'keydown', this.onKeyDown.bind( this ) );

	// Initialization
	this.$element
		.addClass( 'oo-ui-checkboxMultioptionWidget' )
		.prepend( this.checkbox.$element );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultioptionWidget, OO.ui.MultioptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.static.tagName = 'label';

/* Methods */

/**
 * Handle checkbox selected state change.
 *
 * @private
 */
OO.ui.CheckboxMultioptionWidget.prototype.onCheckboxChange = function () {
	this.setSelected( this.checkbox.isSelected() );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.prototype.setSelected = function ( state ) {
	OO.ui.CheckboxMultioptionWidget.parent.prototype.setSelected.call( this, state );
	this.checkbox.setSelected( state );
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.prototype.setDisabled = function ( disabled ) {
	OO.ui.CheckboxMultioptionWidget.parent.prototype.setDisabled.call( this, disabled );
	this.checkbox.setDisabled( this.isDisabled() );
	return this;
};

/**
 * Focus the widget.
 */
OO.ui.CheckboxMultioptionWidget.prototype.focus = function () {
	this.checkbox.focus();
};

/**
 * Handle key down events.
 *
 * @protected
 * @param {jQuery.Event} e
 */
OO.ui.CheckboxMultioptionWidget.prototype.onKeyDown = function ( e ) {
	var
		element = this.getElementGroup(),
		nextItem;

	if ( e.keyCode === OO.ui.Keys.LEFT || e.keyCode === OO.ui.Keys.UP ) {
		nextItem = element.getRelativeFocusableItem( this, -1 );
	} else if ( e.keyCode === OO.ui.Keys.RIGHT || e.keyCode === OO.ui.Keys.DOWN ) {
		nextItem = element.getRelativeFocusableItem( this, 1 );
	}

	if ( nextItem ) {
		e.preventDefault();
		nextItem.focus();
	}
};

/**
 * CheckboxMultiselectWidget is a {@link OO.ui.MultiselectWidget multiselect widget} that contains
 * checkboxes and is used together with OO.ui.CheckboxMultioptionWidget. The
 * CheckboxMultiselectWidget provides an interface for adding, removing and selecting options.
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.CheckboxMultiselectInputWidget instead.
 *
 *     @example
 *     // A CheckboxMultiselectWidget with CheckboxMultioptions.
 *     var option1 = new OO.ui.CheckboxMultioptionWidget( {
 *             data: 'a',
 *             selected: true,
 *             label: 'Selected checkbox'
 *         } ),
 *         option2 = new OO.ui.CheckboxMultioptionWidget( {
 *             data: 'b',
 *             label: 'Unselected checkbox'
 *         } ),
 *         multiselect = new OO.ui.CheckboxMultiselectWidget( {
 *             items: [ option1, option2 ]
 *         } );
 *     $( document.body ).append( multiselect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.MultiselectWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.CheckboxMultiselectWidget = function OoUiCheckboxMultiselectWidget( config ) {
	// Parent constructor
	OO.ui.CheckboxMultiselectWidget.parent.call( this, config );

	// Properties
	this.$lastClicked = null;

	// Events
	this.$group.on( 'click', this.onClick.bind( this ) );

	// Initialization
	this.$element
		.addClass( 'oo-ui-checkboxMultiselectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultiselectWidget, OO.ui.MultiselectWidget );

/* Methods */

/**
 * Get an option by its position relative to the specified item (or to the start of the option array,
 * if item is `null`). The direction in which to search through the option array is specified with a
 * number: -1 for reverse (the default) or 1 for forward. The method will return an option, or
 * `null` if there are no options in the array.
 *
 * @param {OO.ui.CheckboxMultioptionWidget|null} item Item to describe the start position, or `null` to start at the beginning of the array.
 * @param {number} direction Direction to move in: -1 to move backward, 1 to move forward
 * @return {OO.ui.CheckboxMultioptionWidget|null} Item at position, `null` if there are no items in the select
 */
OO.ui.CheckboxMultiselectWidget.prototype.getRelativeFocusableItem = function ( item, direction ) {
	var currentIndex, nextIndex, i,
		increase = direction > 0 ? 1 : -1,
		len = this.items.length;

	if ( item ) {
		currentIndex = this.items.indexOf( item );
		nextIndex = ( currentIndex + increase + len ) % len;
	} else {
		// If no item is selected and moving forward, start at the beginning.
		// If moving backward, start at the end.
		nextIndex = direction > 0 ? 0 : len - 1;
	}

	for ( i = 0; i < len; i++ ) {
		item = this.items[ nextIndex ];
		if ( item && !item.isDisabled() ) {
			return item;
		}
		nextIndex = ( nextIndex + increase + len ) % len;
	}
	return null;
};

/**
 * Handle click events on checkboxes.
 *
 * @param {jQuery.Event} e
 */
OO.ui.CheckboxMultiselectWidget.prototype.onClick = function ( e ) {
	var $options, lastClickedIndex, nowClickedIndex, i, direction, wasSelected, items,
		$lastClicked = this.$lastClicked,
		$nowClicked = $( e.target ).closest( '.oo-ui-checkboxMultioptionWidget' )
			.not( '.oo-ui-widget-disabled' );

	// Allow selecting multiple options at once by Shift-clicking them
	if ( $lastClicked && $nowClicked.length && e.shiftKey ) {
		$options = this.$group.find( '.oo-ui-checkboxMultioptionWidget' );
		lastClickedIndex = $options.index( $lastClicked );
		nowClickedIndex = $options.index( $nowClicked );
		// If it's the same item, either the user is being silly, or it's a fake event generated by the
		// browser. In either case we don't need custom handling.
		if ( nowClickedIndex !== lastClickedIndex ) {
			items = this.items;
			wasSelected = items[ nowClickedIndex ].isSelected();
			direction = nowClickedIndex > lastClickedIndex ? 1 : -1;

			// This depends on the DOM order of the items and the order of the .items array being the same.
			for ( i = lastClickedIndex; i !== nowClickedIndex; i += direction ) {
				if ( !items[ i ].isDisabled() ) {
					items[ i ].setSelected( !wasSelected );
				}
			}
			// For the now-clicked element, use immediate timeout to allow the browser to do its own
			// handling first, then set our value. The order in which events happen is different for
			// clicks on the <input> and on the <label> and there are additional fake clicks fired for
			// non-click actions that change the checkboxes.
			e.preventDefault();
			setTimeout( function () {
				if ( !items[ nowClickedIndex ].isDisabled() ) {
					items[ nowClickedIndex ].setSelected( !wasSelected );
				}
			} );
		}
	}

	if ( $nowClicked.length ) {
		this.$lastClicked = $nowClicked;
	}
};

/**
 * Focus the widget
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.CheckboxMultiselectWidget.prototype.focus = function () {
	var item;
	if ( !this.isDisabled() ) {
		item = this.getRelativeFocusableItem( null, 1 );
		if ( item ) {
			item.focus();
		}
	}
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectWidget.prototype.simulateLabelClick = function () {
	this.focus();
};

/**
 * Progress bars visually display the status of an operation, such as a download,
 * and can be either determinate or indeterminate:
 *
 * - **determinate** process bars show the percent of an operation that is complete.
 *
 * - **indeterminate** process bars use a visual display of motion to indicate that an operation
 *   is taking place. Because the extent of an indeterminate operation is unknown, the bar does
 *   not use percentages.
 *
 * The value of the `progress` configuration determines whether the bar is determinate or indeterminate.
 *
 *     @example
 *     // Examples of determinate and indeterminate progress bars.
 *     var progressBar1 = new OO.ui.ProgressBarWidget( {
 *         progress: 33
 *     } );
 *     var progressBar2 = new OO.ui.ProgressBarWidget();
 *
 *     // Create a FieldsetLayout to layout progress bars.
 *     var fieldset = new OO.ui.FieldsetLayout;
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( progressBar1, {
 *             label: 'Determinate',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( progressBar2, {
 *             label: 'Indeterminate',
 *             align: 'top'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number|boolean} [progress=false] The type of progress bar (determinate or indeterminate).
 *  To create a determinate progress bar, specify a number that reflects the initial percent complete.
 *  By default, the progress bar is indeterminate.
 */
OO.ui.ProgressBarWidget = function OoUiProgressBarWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ProgressBarWidget.parent.call( this, config );

	// Properties
	this.$bar = $( '<div>' );
	this.progress = null;

	// Initialization
	this.setProgress( config.progress !== undefined ? config.progress : false );
	this.$bar.addClass( 'oo-ui-progressBarWidget-bar' );
	this.$element
		.attr( {
			role: 'progressbar',
			'aria-valuemin': 0,
			'aria-valuemax': 100
		} )
		.addClass( 'oo-ui-progressBarWidget' )
		.append( this.$bar );
};

/* Setup */

OO.inheritClass( OO.ui.ProgressBarWidget, OO.ui.Widget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ProgressBarWidget.static.tagName = 'div';

/* Methods */

/**
 * Get the percent of the progress that has been completed. Indeterminate progresses will return `false`.
 *
 * @return {number|boolean} Progress percent
 */
OO.ui.ProgressBarWidget.prototype.getProgress = function () {
	return this.progress;
};

/**
 * Set the percent of the process completed or `false` for an indeterminate process.
 *
 * @param {number|boolean} progress Progress percent or `false` for indeterminate
 */
OO.ui.ProgressBarWidget.prototype.setProgress = function ( progress ) {
	this.progress = progress;

	if ( progress !== false ) {
		this.$bar.css( 'width', this.progress + '%' );
		this.$element.attr( 'aria-valuenow', this.progress );
	} else {
		this.$bar.css( 'width', '' );
		this.$element.removeAttr( 'aria-valuenow' );
	}
	this.$element.toggleClass( 'oo-ui-progressBarWidget-indeterminate', progress === false );
};

/**
 * InputWidget is the base class for all input widgets, which
 * include {@link OO.ui.TextInputWidget text inputs}, {@link OO.ui.CheckboxInputWidget checkbox inputs},
 * {@link OO.ui.RadioInputWidget radio inputs}, and {@link OO.ui.ButtonInputWidget button inputs}.
 * See the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [name=''] The value of the input’s HTML `name` attribute.
 * @cfg {string} [value=''] The value of the input.
 * @cfg {string} [dir] The directionality of the input (ltr/rtl).
 * @cfg {string} [inputId] The value of the input’s HTML `id` attribute.
 * @cfg {Function} [inputFilter] The name of an input filter function. Input filters modify the value of an input
 *  before it is accepted.
 */
OO.ui.InputWidget = function OoUiInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.InputWidget.parent.call( this, config );

	// Properties
	// See #reusePreInfuseDOM about config.$input
	this.$input = config.$input || this.getInputElement( config );
	this.value = '';
	this.inputFilter = config.inputFilter;

	// Mixin constructors
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$input } ) );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$input } ) );
	OO.ui.mixin.AccessKeyedElement.call( this, $.extend( {}, config, { $accessKeyed: this.$input } ) );

	// Events
	this.$input.on( 'keydown mouseup cut paste change input select', this.onEdit.bind( this ) );

	// Initialization
	this.$input
		.addClass( 'oo-ui-inputWidget-input' )
		.attr( 'name', config.name )
		.prop( 'disabled', this.isDisabled() );
	this.$element
		.addClass( 'oo-ui-inputWidget' )
		.append( this.$input );
	this.setValue( config.value );
	if ( config.dir ) {
		this.setDir( config.dir );
	}
	if ( config.inputId !== undefined ) {
		this.setInputId( config.inputId );
	}
};

/* Setup */

OO.inheritClass( OO.ui.InputWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.AccessKeyedElement );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.InputWidget.static.reusePreInfuseDOM = function ( node, config ) {
	config = OO.ui.InputWidget.parent.static.reusePreInfuseDOM( node, config );
	// Reusing `$input` lets browsers preserve inputted values across page reloads, see T114134.
	config.$input = $( node ).find( '.oo-ui-inputWidget-input' );
	return config;
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.InputWidget.parent.static.gatherPreInfuseState( node, config );
	if ( config.$input && config.$input.length ) {
		state.value = config.$input.val();
		// Might be better in TabIndexedElement, but it's awkward to do there because mixins are awkward
		state.focus = config.$input.is( ':focus' );
	}
	return state;
};

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the value of the input changes.
 *
 * @param {string} value
 */

/* Methods */

/**
 * Get input element.
 *
 * Subclasses of OO.ui.InputWidget use the `config` parameter to produce different elements in
 * different circumstances. The element must have a `value` property (like form elements).
 *
 * @protected
 * @param {Object} config Configuration options
 * @return {jQuery} Input element
 */
OO.ui.InputWidget.prototype.getInputElement = function () {
	return $( '<input>' );
};

/**
 * Handle potentially value-changing events.
 *
 * @private
 * @param {jQuery.Event} e Key down, mouse up, cut, paste, change, input, or select event
 */
OO.ui.InputWidget.prototype.onEdit = function () {
	var widget = this;
	if ( !this.isDisabled() ) {
		// Allow the stack to clear so the value will be updated
		setTimeout( function () {
			widget.setValue( widget.$input.val() );
		} );
	}
};

/**
 * Get the value of the input.
 *
 * @return {string} Input value
 */
OO.ui.InputWidget.prototype.getValue = function () {
	// Resynchronize our internal data with DOM data. Other scripts executing on the page can modify
	// it, and we won't know unless they're kind enough to trigger a 'change' event.
	var value = this.$input.val();
	if ( this.value !== value ) {
		this.setValue( value );
	}
	return this.value;
};

/**
 * Set the directionality of the input.
 *
 * @param {string} dir Text directionality: 'ltr', 'rtl' or 'auto'
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setDir = function ( dir ) {
	this.$input.prop( 'dir', dir );
	return this;
};

/**
 * Set the value of the input.
 *
 * @param {string} value New value
 * @fires change
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setValue = function ( value ) {
	value = this.cleanUpValue( value );
	// Update the DOM if it has changed. Note that with cleanUpValue, it
	// is possible for the DOM value to change without this.value changing.
	if ( this.$input.val() !== value ) {
		this.$input.val( value );
	}
	if ( this.value !== value ) {
		this.value = value;
		this.emit( 'change', this.value );
	}
	// The first time that the value is set (probably while constructing the widget),
	// remember it in defaultValue. This property can be later used to check whether
	// the value of the input has been changed since it was created.
	if ( this.defaultValue === undefined ) {
		this.defaultValue = this.value;
		this.$input[ 0 ].defaultValue = this.defaultValue;
	}
	return this;
};

/**
 * Clean up incoming value.
 *
 * Ensures value is a string, and converts undefined and null to empty string.
 *
 * @private
 * @param {string} value Original value
 * @return {string} Cleaned up value
 */
OO.ui.InputWidget.prototype.cleanUpValue = function ( value ) {
	if ( value === undefined || value === null ) {
		return '';
	} else if ( this.inputFilter ) {
		return this.inputFilter( String( value ) );
	} else {
		return String( value );
	}
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.prototype.setDisabled = function ( state ) {
	OO.ui.InputWidget.parent.prototype.setDisabled.call( this, state );
	if ( this.$input ) {
		this.$input.prop( 'disabled', this.isDisabled() );
	}
	return this;
};

/**
 * Set the 'id' attribute of the `<input>` element.
 *
 * @param {string} id
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setInputId = function ( id ) {
	this.$input.attr( 'id', id );
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.prototype.restorePreInfuseState = function ( state ) {
	OO.ui.InputWidget.parent.prototype.restorePreInfuseState.call( this, state );
	if ( state.value !== undefined && state.value !== this.getValue() ) {
		this.setValue( state.value );
	}
	if ( state.focus ) {
		this.focus();
	}
};

/**
 * Data widget intended for creating `<input type="hidden">` inputs.
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [value=''] The value of the input.
 * @cfg {string} [name=''] The value of the input’s HTML `name` attribute.
 */
OO.ui.HiddenInputWidget = function OoUiHiddenInputWidget( config ) {
	// Configuration initialization
	config = $.extend( { value: '', name: '' }, config );

	// Parent constructor
	OO.ui.HiddenInputWidget.parent.call( this, config );

	// Initialization
	this.$element.attr( {
		type: 'hidden',
		value: config.value,
		name: config.name
	} );
	this.$element.removeAttr( 'aria-disabled' );
};

/* Setup */

OO.inheritClass( OO.ui.HiddenInputWidget, OO.ui.Widget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.HiddenInputWidget.static.tagName = 'input';

/**
 * ButtonInputWidget is used to submit HTML forms and is intended to be used within
 * a OO.ui.FormLayout. If you do not need the button to work with HTML forms, you probably
 * want to use OO.ui.ButtonWidget instead. Button input widgets can be rendered as either an
 * HTML `<button>` (the default) or an HTML `<input>` tags. See the
 * [OOUI documentation on MediaWiki] [1] for more information.
 *
 *     @example
 *     // A ButtonInputWidget rendered as an HTML button, the default.
 *     var button = new OO.ui.ButtonInputWidget( {
 *         label: 'Input button',
 *         icon: 'check',
 *         value: 'check'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#Button_inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [type='button'] The value of the HTML `'type'` attribute: 'button', 'submit' or 'reset'.
 * @cfg {boolean} [useInputTag=false] Use an `<input>` tag instead of a `<button>` tag, the default.
 *  Widgets configured to be an `<input>` do not support {@link #icon icons} and {@link #indicator indicators},
 *  non-plaintext {@link #label labels}, or {@link #value values}. In general, useInputTag should only
 *  be set to `true` when there’s need to support IE 6 in a form with multiple buttons.
 */
OO.ui.ButtonInputWidget = function OoUiButtonInputWidget( config ) {
	// Configuration initialization
	config = $.extend( { type: 'button', useInputTag: false }, config );

	// See InputWidget#reusePreInfuseDOM about config.$input
	if ( config.$input ) {
		config.$input.empty();
	}

	// Properties (must be set before parent constructor, which calls #setValue)
	this.useInputTag = config.useInputTag;

	// Parent constructor
	OO.ui.ButtonInputWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ButtonElement.call( this, $.extend( {}, config, { $button: this.$input } ) );
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );

	// Initialization
	if ( !config.useInputTag ) {
		this.$input.append( this.$icon, this.$label, this.$indicator );
	}
	this.$element.addClass( 'oo-ui-buttonInputWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonInputWidget, OO.ui.InputWidget );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.LabelElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonInputWidget.static.tagName = 'span';

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.ButtonInputWidget.prototype.getInputElement = function ( config ) {
	var type;
	type = [ 'button', 'submit', 'reset' ].indexOf( config.type ) !== -1 ? config.type : 'button';
	return $( '<' + ( config.useInputTag ? 'input' : 'button' ) + ' type="' + type + '">' );
};

/**
 * Set label value.
 *
 * If #useInputTag is `true`, the label is set as the `value` of the `<input>` tag.
 *
 * @param {jQuery|string|Function|null} label Label nodes, text, a function that returns nodes or
 *  text, or `null` for no label
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonInputWidget.prototype.setLabel = function ( label ) {
	if ( typeof label === 'function' ) {
		label = OO.ui.resolveMsg( label );
	}

	if ( this.useInputTag ) {
		// Discard non-plaintext labels
		if ( typeof label !== 'string' ) {
			label = '';
		}

		this.$input.val( label );
	}

	return OO.ui.mixin.LabelElement.prototype.setLabel.call( this, label );
};

/**
 * Set the value of the input.
 *
 * This method is disabled for button inputs configured as {@link #useInputTag <input> tags}, as
 * they do not support {@link #value values}.
 *
 * @param {string} value New value
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonInputWidget.prototype.setValue = function ( value ) {
	if ( !this.useInputTag ) {
		OO.ui.ButtonInputWidget.parent.prototype.setValue.call( this, value );
	}
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.ButtonInputWidget.prototype.getInputId = function () {
	// Disable generating `<label>` elements for buttons. One would very rarely need additional label
	// for a button, and it's already a big clickable target, and it causes unexpected rendering.
	return null;
};

/**
 * CheckboxInputWidgets, like HTML checkboxes, can be selected and/or configured with a value.
 * Note that these {@link OO.ui.InputWidget input widgets} are best laid out
 * in {@link OO.ui.FieldLayout field layouts} that use the {@link OO.ui.FieldLayout#align inline}
 * alignment. For more information, please see the [OOUI documentation on MediaWiki][1].
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // An example of selected, unselected, and disabled checkbox inputs.
 *     var checkbox1 = new OO.ui.CheckboxInputWidget( {
 *             value: 'a',
 *              selected: true
 *         } ),
 *         checkbox2 = new OO.ui.CheckboxInputWidget( {
 *             value: 'b'
 *         } ),
 *         checkbox3 = new OO.ui.CheckboxInputWidget( {
 *             value:'c',
 *             disabled: true
 *         } ),
 *         // Create a fieldset layout with fields for each checkbox.
 *         fieldset = new OO.ui.FieldsetLayout( {
 *             label: 'Checkboxes'
 *         } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( checkbox1, { label: 'Selected checkbox', align: 'inline' } ),
 *         new OO.ui.FieldLayout( checkbox2, { label: 'Unselected checkbox', align: 'inline' } ),
 *         new OO.ui.FieldLayout( checkbox3, { label: 'Disabled checkbox', align: 'inline' } ),
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Select the checkbox initially. By default, the checkbox is not selected.
 */
OO.ui.CheckboxInputWidget = function OoUiCheckboxInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.CheckboxInputWidget.parent.call( this, config );

	// Properties
	this.checkIcon = new OO.ui.IconWidget( {
		icon: 'check',
		classes: [ 'oo-ui-checkboxInputWidget-checkIcon' ]
	} );

	// Initialization
	this.$element
		.addClass( 'oo-ui-checkboxInputWidget' )
		// Required for pretty styling in WikimediaUI theme
		.append( this.checkIcon.$element );
	this.setSelected( config.selected !== undefined ? config.selected : false );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxInputWidget, OO.ui.InputWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.static.tagName = 'span';

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.CheckboxInputWidget.parent.static.gatherPreInfuseState( node, config );
	state.checked = config.$input.prop( 'checked' );
	return state;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.CheckboxInputWidget.prototype.getInputElement = function () {
	return $( '<input>' ).attr( 'type', 'checkbox' );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.onEdit = function () {
	var widget = this;
	if ( !this.isDisabled() ) {
		// Allow the stack to clear so the value will be updated
		setTimeout( function () {
			widget.setSelected( widget.$input.prop( 'checked' ) );
		} );
	}
};

/**
 * Set selection state of this checkbox.
 *
 * @param {boolean} state `true` for selected
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.CheckboxInputWidget.prototype.setSelected = function ( state ) {
	state = !!state;
	if ( this.selected !== state ) {
		this.selected = state;
		this.$input.prop( 'checked', this.selected );
		this.emit( 'change', this.selected );
	}
	// The first time that the selection state is set (probably while constructing the widget),
	// remember it in defaultSelected. This property can be later used to check whether
	// the selection state of the input has been changed since it was created.
	if ( this.defaultSelected === undefined ) {
		this.defaultSelected = this.selected;
		this.$input[ 0 ].defaultChecked = this.defaultSelected;
	}
	return this;
};

/**
 * Check if this checkbox is selected.
 *
 * @return {boolean} Checkbox is selected
 */
OO.ui.CheckboxInputWidget.prototype.isSelected = function () {
	// Resynchronize our internal data with DOM data. Other scripts executing on the page can modify
	// it, and we won't know unless they're kind enough to trigger a 'change' event.
	var selected = this.$input.prop( 'checked' );
	if ( this.selected !== selected ) {
		this.setSelected( selected );
	}
	return this.selected;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.simulateLabelClick = function () {
	if ( !this.isDisabled() ) {
		this.$input.click();
	}
	this.focus();
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.restorePreInfuseState = function ( state ) {
	OO.ui.CheckboxInputWidget.parent.prototype.restorePreInfuseState.call( this, state );
	if ( state.checked !== undefined && state.checked !== this.isSelected() ) {
		this.setSelected( state.checked );
	}
};

/**
 * DropdownInputWidget is a {@link OO.ui.DropdownWidget DropdownWidget} intended to be used
 * within an HTML form, such as a OO.ui.FormLayout. The selected value is synchronized with the value
 * of a hidden HTML `input` tag. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 * A DropdownInputWidget always has a value (one of the options is always selected), unless there
 * are no options. If no `value` configuration option is provided, the first option is selected.
 * If you need a state representing no value (no option being selected), use a DropdownWidget.
 *
 * This and OO.ui.RadioSelectInputWidget support similar configuration options.
 *
 *     @example
 *     // A DropdownInputWidget with three options.
 *     var dropdownInput = new OO.ui.DropdownInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second', disabled: true },
 *             { optgroup: 'Group label' },
 *             { data: 'c', label: 'First sub-item)' }
 *         ]
 *     } );
 *     $( document.body ).append( dropdownInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format described above.
 * @cfg {Object} [dropdown] Configuration options for {@link OO.ui.DropdownWidget DropdownWidget}
 * @cfg {jQuery} [$overlay] Render the menu into a separate layer. This configuration is useful in cases where
 *  the expanded menu is larger than its containing `<div>`. The specified overlay layer is usually on top of the
 *  containing `<div>` and has a larger area. By default, the menu uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.DropdownInputWidget = function OoUiDropdownInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Properties (must be done before parent constructor which calls #setDisabled)
	this.dropdownWidget = new OO.ui.DropdownWidget( $.extend(
		{
			$overlay: config.$overlay
		},
		config.dropdown
	) );
	// Set up the options before parent constructor, which uses them to validate config.value.
	// Use this instead of setOptions() because this.$input is not set up yet.
	this.setOptionsData( config.options || [] );

	// Parent constructor
	OO.ui.DropdownInputWidget.parent.call( this, config );

	// Events
	this.dropdownWidget.getMenu().connect( this, { select: 'onMenuSelect' } );

	// Initialization
	this.$element
		.addClass( 'oo-ui-dropdownInputWidget' )
		.append( this.dropdownWidget.$element );
	this.setTabIndexedElement( this.dropdownWidget.$tabIndexed );
	this.setTitledElement( this.dropdownWidget.$handle );
};

/* Setup */

OO.inheritClass( OO.ui.DropdownInputWidget, OO.ui.InputWidget );

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.DropdownInputWidget.prototype.getInputElement = function () {
	return $( '<select>' );
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.MenuOptionWidget|null} item Selected menu item
 */
OO.ui.DropdownInputWidget.prototype.onMenuSelect = function ( item ) {
	this.setValue( item ? item.getData() : '' );
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.setValue = function ( value ) {
	var selected;
	value = this.cleanUpValue( value );
	// Only allow setting values that are actually present in the dropdown
	selected = this.dropdownWidget.getMenu().findItemFromData( value ) ||
		this.dropdownWidget.getMenu().findFirstSelectableItem();
	this.dropdownWidget.getMenu().selectItem( selected );
	value = selected ? selected.getData() : '';
	OO.ui.DropdownInputWidget.parent.prototype.setValue.call( this, value );
	if ( this.optionsDirty ) {
		// We reached this from the constructor or from #setOptions.
		// We have to update the <select> element.
		this.updateOptionsInterface();
	}
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.setDisabled = function ( state ) {
	this.dropdownWidget.setDisabled( state );
	OO.ui.DropdownInputWidget.parent.prototype.setDisabled.call( this, state );
	return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.DropdownInputWidget.prototype.setOptions = function ( options ) {
	var value = this.getValue();

	this.setOptionsData( options );

	// Re-set the value to update the visible interface (DropdownWidget and <select>).
	// In case the previous value is no longer an available option, select the first valid one.
	this.setValue( value );

	return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * initialized yet.
 *
 * @param {Object[]} options Array of menu options (see #constructor for details).
 * @private
 */
OO.ui.DropdownInputWidget.prototype.setOptionsData = function ( options ) {
	var optionWidgets, optIndex, opt, previousOptgroup, optionWidget, optValue,
		widget = this;

	this.optionsDirty = true;

	// Go through all the supplied option configs and create either
	// MenuSectionOption or MenuOption widgets from each.
	optionWidgets = [];
	for ( optIndex = 0; optIndex < options.length; optIndex++ ) {
		opt = options[ optIndex ];

		if ( opt.optgroup !== undefined ) {
			// Create a <optgroup> menu item.
			optionWidget = widget.createMenuSectionOptionWidget( opt.optgroup );
			previousOptgroup = optionWidget;

		} else {
			// Create a normal <option> menu item.
			optValue = widget.cleanUpValue( opt.data );
			optionWidget = widget.createMenuOptionWidget(
				optValue,
				opt.label !== undefined ? opt.label : optValue
			);
		}

		// Disable the menu option if it is itself disabled or if its parent optgroup is disabled.
		if ( opt.disabled !== undefined ||
			previousOptgroup instanceof OO.ui.MenuSectionOptionWidget && previousOptgroup.isDisabled() ) {
			optionWidget.setDisabled( true );
		}

		optionWidgets.push( optionWidget );
	}

	this.dropdownWidget.getMenu().clearItems().addItems( optionWidgets );
};

/**
 * Create a menu option widget.
 *
 * @protected
 * @param {string} data Item data
 * @param {string} label Item label
 * @return {OO.ui.MenuOptionWidget} Option widget
 */
OO.ui.DropdownInputWidget.prototype.createMenuOptionWidget = function ( data, label ) {
	return new OO.ui.MenuOptionWidget( {
		data: data,
		label: label
	} );
};

/**
 * Create a menu section option widget.
 *
 * @protected
 * @param {string} label Section item label
 * @return {OO.ui.MenuSectionOptionWidget} Menu section option widget
 */
OO.ui.DropdownInputWidget.prototype.createMenuSectionOptionWidget = function ( label ) {
	return new OO.ui.MenuSectionOptionWidget( {
		label: label
	} );
};

/**
 * Update the user-visible interface to match the internal list of options and value.
 *
 * This method must only be called after the parent constructor.
 *
 * @private
 */
OO.ui.DropdownInputWidget.prototype.updateOptionsInterface = function () {
	var
		$optionsContainer = this.$input,
		defaultValue = this.defaultValue,
		widget = this;

	this.$input.empty();

	this.dropdownWidget.getMenu().getItems().forEach( function ( optionWidget ) {
		var $optionNode;

		if ( !( optionWidget instanceof OO.ui.MenuSectionOptionWidget ) ) {
			$optionNode = $( '<option>' )
				.attr( 'value', optionWidget.getData() )
				.text( optionWidget.getLabel() );

			// Remember original selection state. This property can be later used to check whether
			// the selection state of the input has been changed since it was created.
			$optionNode[ 0 ].defaultSelected = ( optionWidget.getData() === defaultValue );

			$optionsContainer.append( $optionNode );
		} else {
			$optionNode = $( '<optgroup>' )
				.attr( 'label', optionWidget.getLabel() );
			widget.$input.append( $optionNode );
			$optionsContainer = $optionNode;
		}

		// Disable the option or optgroup if required.
		if ( optionWidget.isDisabled() ) {
			$optionNode.prop( 'disabled', true );
		}
	} );

	this.optionsDirty = false;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.focus = function () {
	this.dropdownWidget.focus();
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.blur = function () {
	this.dropdownWidget.blur();
	return this;
};

/**
 * RadioInputWidget creates a single radio button. Because radio buttons are usually used as a set,
 * in most cases you will want to use a {@link OO.ui.RadioSelectWidget radio select}
 * with {@link OO.ui.RadioOptionWidget radio options} instead of this class. For more information,
 * please see the [OOUI documentation on MediaWiki][1].
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // An example of selected, unselected, and disabled radio inputs
 *     var radio1 = new OO.ui.RadioInputWidget( {
 *         value: 'a',
 *         selected: true
 *     } );
 *     var radio2 = new OO.ui.RadioInputWidget( {
 *         value: 'b'
 *     } );
 *     var radio3 = new OO.ui.RadioInputWidget( {
 *         value: 'c',
 *         disabled: true
 *     } );
 *     // Create a fieldset layout with fields for each radio button.
 *     var fieldset = new OO.ui.FieldsetLayout( {
 *         label: 'Radio inputs'
 *     } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( radio1, { label: 'Selected', align: 'inline' } ),
 *         new OO.ui.FieldLayout( radio2, { label: 'Unselected', align: 'inline' } ),
 *         new OO.ui.FieldLayout( radio3, { label: 'Disabled', align: 'inline' } ),
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Select the radio button initially. By default, the radio button is not selected.
 */
OO.ui.RadioInputWidget = function OoUiRadioInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.RadioInputWidget.parent.call( this, config );

	// Initialization
	this.$element
		.addClass( 'oo-ui-radioInputWidget' )
		// Required for pretty styling in WikimediaUI theme
		.append( $( '<span>' ) );
	this.setSelected( config.selected !== undefined ? config.selected : false );
};

/* Setup */

OO.inheritClass( OO.ui.RadioInputWidget, OO.ui.InputWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioInputWidget.static.tagName = 'span';

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.RadioInputWidget.parent.static.gatherPreInfuseState( node, config );
	state.checked = config.$input.prop( 'checked' );
	return state;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.RadioInputWidget.prototype.getInputElement = function () {
	return $( '<input>' ).attr( 'type', 'radio' );
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.onEdit = function () {
	// RadioInputWidget doesn't track its state.
};

/**
 * Set selection state of this radio button.
 *
 * @param {boolean} state `true` for selected
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.RadioInputWidget.prototype.setSelected = function ( state ) {
	// RadioInputWidget doesn't track its state.
	this.$input.prop( 'checked', state );
	// The first time that the selection state is set (probably while constructing the widget),
	// remember it in defaultSelected. This property can be later used to check whether
	// the selection state of the input has been changed since it was created.
	if ( this.defaultSelected === undefined ) {
		this.defaultSelected = state;
		this.$input[ 0 ].defaultChecked = this.defaultSelected;
	}
	return this;
};

/**
 * Check if this radio button is selected.
 *
 * @return {boolean} Radio is selected
 */
OO.ui.RadioInputWidget.prototype.isSelected = function () {
	return this.$input.prop( 'checked' );
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.simulateLabelClick = function () {
	if ( !this.isDisabled() ) {
		this.$input.click();
	}
	this.focus();
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.restorePreInfuseState = function ( state ) {
	OO.ui.RadioInputWidget.parent.prototype.restorePreInfuseState.call( this, state );
	if ( state.checked !== undefined && state.checked !== this.isSelected() ) {
		this.setSelected( state.checked );
	}
};

/**
 * RadioSelectInputWidget is a {@link OO.ui.RadioSelectWidget RadioSelectWidget} intended to be used
 * within an HTML form, such as a OO.ui.FormLayout. The selected value is synchronized with the value
 * of a hidden HTML `input` tag. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 * This and OO.ui.DropdownInputWidget support similar configuration options.
 *
 *     @example
 *     // A RadioSelectInputWidget with three options
 *     var radioSelectInput = new OO.ui.RadioSelectInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second'},
 *             { data: 'c', label: 'Third' }
 *         ]
 *     } );
 *     $( document.body ).append( radioSelectInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 */
OO.ui.RadioSelectInputWidget = function OoUiRadioSelectInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Properties (must be done before parent constructor which calls #setDisabled)
	this.radioSelectWidget = new OO.ui.RadioSelectWidget();
	// Set up the options before parent constructor, which uses them to validate config.value.
	// Use this instead of setOptions() because this.$input is not set up yet
	this.setOptionsData( config.options || [] );

	// Parent constructor
	OO.ui.RadioSelectInputWidget.parent.call( this, config );

	// Events
	this.radioSelectWidget.connect( this, { select: 'onMenuSelect' } );

	// Initialization
	this.$element
		.addClass( 'oo-ui-radioSelectInputWidget' )
		.append( this.radioSelectWidget.$element );
	this.setTabIndexedElement( this.radioSelectWidget.$tabIndexed );
};

/* Setup */

OO.inheritClass( OO.ui.RadioSelectInputWidget, OO.ui.InputWidget );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.RadioSelectInputWidget.parent.static.gatherPreInfuseState( node, config );
	state.value = $( node ).find( '.oo-ui-radioInputWidget .oo-ui-inputWidget-input:checked' ).val();
	return state;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.static.reusePreInfuseDOM = function ( node, config ) {
	config = OO.ui.RadioSelectInputWidget.parent.static.reusePreInfuseDOM( node, config );
	// Cannot reuse the `<input type=radio>` set
	delete config.$input;
	return config;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.RadioSelectInputWidget.prototype.getInputElement = function () {
	// Use this instead of <input type="hidden">, because hidden inputs do not have separate
	// 'value' and 'defaultValue' properties, and InputWidget wants to handle 'defaultValue'.
	return $( '<input>' ).addClass( 'oo-ui-element-hidden' );
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.RadioOptionWidget} item Selected menu item
 */
OO.ui.RadioSelectInputWidget.prototype.onMenuSelect = function ( item ) {
	this.setValue( item.getData() );
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.setValue = function ( value ) {
	var selected;
	value = this.cleanUpValue( value );
	// Only allow setting values that are actually present in the dropdown
	selected = this.radioSelectWidget.findItemFromData( value ) ||
		this.radioSelectWidget.findFirstSelectableItem();
	this.radioSelectWidget.selectItem( selected );
	value = selected ? selected.getData() : '';
	OO.ui.RadioSelectInputWidget.parent.prototype.setValue.call( this, value );
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.setDisabled = function ( state ) {
	this.radioSelectWidget.setDisabled( state );
	OO.ui.RadioSelectInputWidget.parent.prototype.setDisabled.call( this, state );
	return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.RadioSelectInputWidget.prototype.setOptions = function ( options ) {
	var value = this.getValue();

	this.setOptionsData( options );

	// Re-set the value to update the visible interface (RadioSelectWidget).
	// In case the previous value is no longer an available option, select the first valid one.
	this.setValue( value );

	return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * intialized yet.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @private
 */
OO.ui.RadioSelectInputWidget.prototype.setOptionsData = function ( options ) {
	var widget = this;

	this.radioSelectWidget
		.clearItems()
		.addItems( options.map( function ( opt ) {
			var optValue = widget.cleanUpValue( opt.data );
			return new OO.ui.RadioOptionWidget( {
				data: optValue,
				label: opt.label !== undefined ? opt.label : optValue
			} );
		} ) );
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.focus = function () {
	this.radioSelectWidget.focus();
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.blur = function () {
	this.radioSelectWidget.blur();
	return this;
};

/**
 * CheckboxMultiselectInputWidget is a
 * {@link OO.ui.CheckboxMultiselectWidget CheckboxMultiselectWidget} intended to be used within a
 * HTML form, such as a OO.ui.FormLayout. The selected values are synchronized with the value of
 * HTML `<input type=checkbox>` tags. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 *     @example
 *     // A CheckboxMultiselectInputWidget with three options.
 *     var multiselectInput = new OO.ui.CheckboxMultiselectInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second' },
 *             { data: 'c', label: 'Third' }
 *         ]
 *     } );
 *     $( document.body ).append( multiselectInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: …, disabled: … }`
 */
OO.ui.CheckboxMultiselectInputWidget = function OoUiCheckboxMultiselectInputWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Properties (must be done before parent constructor which calls #setDisabled)
	this.checkboxMultiselectWidget = new OO.ui.CheckboxMultiselectWidget();
	// Must be set before the #setOptionsData call below
	this.inputName = config.name;
	// Set up the options before parent constructor, which uses them to validate config.value.
	// Use this instead of setOptions() because this.$input is not set up yet
	this.setOptionsData( config.options || [] );

	// Parent constructor
	OO.ui.CheckboxMultiselectInputWidget.parent.call( this, config );

	// Events
	this.checkboxMultiselectWidget.connect( this, { select: 'onCheckboxesSelect' } );

	// Initialization
	this.$element
		.addClass( 'oo-ui-checkboxMultiselectInputWidget' )
		.append( this.checkboxMultiselectWidget.$element );
	// We don't use this.$input, but rather the CheckboxInputWidgets inside each option
	this.$input.detach();
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultiselectInputWidget, OO.ui.InputWidget );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.CheckboxMultiselectInputWidget.parent.static.gatherPreInfuseState( node, config );
	state.value = $( node ).find( '.oo-ui-checkboxInputWidget .oo-ui-inputWidget-input:checked' )
		.toArray().map( function ( el ) { return el.value; } );
	return state;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.static.reusePreInfuseDOM = function ( node, config ) {
	config = OO.ui.CheckboxMultiselectInputWidget.parent.static.reusePreInfuseDOM( node, config );
	// Cannot reuse the `<input type=checkbox>` set
	delete config.$input;
	return config;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.getInputElement = function () {
	// Actually unused
	return $( '<unused>' );
};

/**
 * Handles CheckboxMultiselectWidget select events.
 *
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.onCheckboxesSelect = function () {
	this.setValue( this.checkboxMultiselectWidget.findSelectedItemsData() );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.getValue = function () {
	var value = this.$element.find( '.oo-ui-checkboxInputWidget .oo-ui-inputWidget-input:checked' )
		.toArray().map( function ( el ) { return el.value; } );
	if ( this.value !== value ) {
		this.setValue( value );
	}
	return this.value;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setValue = function ( value ) {
	value = this.cleanUpValue( value );
	this.checkboxMultiselectWidget.selectItemsByData( value );
	OO.ui.CheckboxMultiselectInputWidget.parent.prototype.setValue.call( this, value );
	if ( this.optionsDirty ) {
		// We reached this from the constructor or from #setOptions.
		// We have to update the <select> element.
		this.updateOptionsInterface();
	}
	return this;
};

/**
 * Clean up incoming value.
 *
 * @param {string[]} value Original value
 * @return {string[]} Cleaned up value
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.cleanUpValue = function ( value ) {
	var i, singleValue,
		cleanValue = [];
	if ( !Array.isArray( value ) ) {
		return cleanValue;
	}
	for ( i = 0; i < value.length; i++ ) {
		singleValue =
			OO.ui.CheckboxMultiselectInputWidget.parent.prototype.cleanUpValue.call( this, value[ i ] );
		// Remove options that we don't have here
		if ( !this.checkboxMultiselectWidget.findItemFromData( singleValue ) ) {
			continue;
		}
		cleanValue.push( singleValue );
	}
	return cleanValue;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setDisabled = function ( state ) {
	this.checkboxMultiselectWidget.setDisabled( state );
	OO.ui.CheckboxMultiselectInputWidget.parent.prototype.setDisabled.call( this, state );
	return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: …, disabled: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setOptions = function ( options ) {
	var value = this.getValue();

	this.setOptionsData( options );

	// Re-set the value to update the visible interface (CheckboxMultiselectWidget).
	// This will also get rid of any stale options that we just removed.
	this.setValue( value );

	return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * intialized yet.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setOptionsData = function ( options ) {
	var widget = this;

	this.optionsDirty = true;

	this.checkboxMultiselectWidget
		.clearItems()
		.addItems( options.map( function ( opt ) {
			var optValue, item, optDisabled;
			optValue =
				OO.ui.CheckboxMultiselectInputWidget.parent.prototype.cleanUpValue.call( widget, opt.data );
			optDisabled = opt.disabled !== undefined ? opt.disabled : false;
			item = new OO.ui.CheckboxMultioptionWidget( {
				data: optValue,
				label: opt.label !== undefined ? opt.label : optValue,
				disabled: optDisabled
			} );
			// Set the 'name' and 'value' for form submission
			item.checkbox.$input.attr( 'name', widget.inputName );
			item.checkbox.setValue( optValue );
			return item;
		} ) );
};

/**
 * Update the user-visible interface to match the internal list of options and value.
 *
 * This method must only be called after the parent constructor.
 *
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.updateOptionsInterface = function () {
	var defaultValue = this.defaultValue;

	this.checkboxMultiselectWidget.getItems().forEach( function ( item ) {
		// Remember original selection state. This property can be later used to check whether
		// the selection state of the input has been changed since it was created.
		var isDefault = defaultValue.indexOf( item.getData() ) !== -1;
		item.checkbox.defaultSelected = isDefault;
		item.checkbox.$input[ 0 ].defaultChecked = isDefault;
	} );

	this.optionsDirty = false;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.focus = function () {
	this.checkboxMultiselectWidget.focus();
	return this;
};

/**
 * TextInputWidgets, like HTML text inputs, can be configured with options that customize the
 * size of the field as well as its presentation. In addition, these widgets can be configured
 * with {@link OO.ui.mixin.IconElement icons}, {@link OO.ui.mixin.IndicatorElement indicators}, an optional
 * validation-pattern (used to determine if an input value is valid or not) and an input filter,
 * which modifies incoming values rather than validating them.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // A TextInputWidget.
 *     var textInput = new OO.ui.TextInputWidget( {
 *         value: 'Text input'
 *     } )
 *     $( document.body ).append( textInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.PendingElement
 * @mixins OO.ui.mixin.LabelElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [type='text'] The value of the HTML `type` attribute: 'text', 'password'
 *  'email', 'url' or 'number'.
 * @cfg {string} [placeholder] Placeholder text
 * @cfg {boolean} [autofocus=false] Use an HTML `autofocus` attribute to
 *  instruct the browser to focus this widget.
 * @cfg {boolean} [readOnly=false] Prevent changes to the value of the text input.
 * @cfg {number} [maxLength] Maximum number of characters allowed in the input.
 *
 *  For unfortunate historical reasons, this counts the number of UTF-16 code units rather than
 *  Unicode codepoints, which means that codepoints outside the Basic Multilingual Plane (e.g.
 *  many emojis) count as 2 characters each.
 * @cfg {string} [labelPosition='after'] The position of the inline label relative to that of
 *  the value or placeholder text: `'before'` or `'after'`
 * @cfg {boolean} [required=false] Mark the field as required with `true`. Implies `indicator: 'required'`.
 *  Note that `false` & setting `indicator: 'required' will result in no indicator shown.
 * @cfg {boolean} [autocomplete=true] Should the browser support autocomplete for this field
 * @cfg {boolean} [spellcheck] Should the browser support spellcheck for this field (`undefined` means
 *  leaving it up to the browser).
 * @cfg {RegExp|Function|string} [validate] Validation pattern: when string, a symbolic name of a
 *  pattern defined by the class: 'non-empty' (the value cannot be an empty string) or 'integer'
 *  (the value must contain only numbers); when RegExp, a regular expression that must match the
 *  value for it to be considered valid; when Function, a function receiving the value as parameter
 *  that must return true, or promise resolving to true, for it to be considered valid.
 */
OO.ui.TextInputWidget = function OoUiTextInputWidget( config ) {
	// Configuration initialization
	config = $.extend( {
		type: 'text',
		labelPosition: 'after'
	}, config );

	// Parent constructor
	OO.ui.TextInputWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.PendingElement.call( this, $.extend( {}, config, { $pending: this.$input } ) );
	OO.ui.mixin.LabelElement.call( this, config );

	// Properties
	this.type = this.getSaneType( config );
	this.readOnly = false;
	this.required = false;
	this.validate = null;
	this.scrollWidth = null;

	this.setValidation( config.validate );
	this.setLabelPosition( config.labelPosition );

	// Events
	this.$input.on( {
		keypress: this.onKeyPress.bind( this ),
		blur: this.onBlur.bind( this ),
		focus: this.onFocus.bind( this )
	} );
	this.$icon.on( 'mousedown', this.onIconMouseDown.bind( this ) );
	this.$indicator.on( 'mousedown', this.onIndicatorMouseDown.bind( this ) );
	this.on( 'labelChange', this.updatePosition.bind( this ) );
	this.on( 'change', OO.ui.debounce( this.onDebouncedChange.bind( this ), 250 ) );

	// Initialization
	this.$element
		.addClass( 'oo-ui-textInputWidget oo-ui-textInputWidget-type-' + this.type )
		.append( this.$icon, this.$indicator );
	this.setReadOnly( !!config.readOnly );
	this.setRequired( !!config.required );
	if ( config.placeholder !== undefined ) {
		this.$input.attr( 'placeholder', config.placeholder );
	}
	if ( config.maxLength !== undefined ) {
		this.$input.attr( 'maxlength', config.maxLength );
	}
	if ( config.autofocus ) {
		this.$input.attr( 'autofocus', 'autofocus' );
	}
	if ( config.autocomplete === false ) {
		this.$input.attr( 'autocomplete', 'off' );
		// Turning off autocompletion also disables "form caching" when the user navigates to a
		// different page and then clicks "Back". Re-enable it when leaving. Borrowed from jQuery UI.
		$( window ).on( {
			beforeunload: function () {
				this.$input.removeAttr( 'autocomplete' );
			}.bind( this ),
			pageshow: function () {
				// Browsers don't seem to actually fire this event on "Back", they instead just reload the
				// whole page... it shouldn't hurt, though.
				this.$input.attr( 'autocomplete', 'off' );
			}.bind( this )
		} );
	}
	if ( config.spellcheck !== undefined ) {
		this.$input.attr( 'spellcheck', config.spellcheck ? 'true' : 'false' );
	}
	if ( this.label ) {
		this.isWaitingToBeAttached = true;
		this.installParentChangeDetector();
	}
};

/* Setup */

OO.inheritClass( OO.ui.TextInputWidget, OO.ui.InputWidget );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.PendingElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.LabelElement );

/* Static Properties */

OO.ui.TextInputWidget.static.validationPatterns = {
	'non-empty': /.+/,
	integer: /^\d+$/
};

/* Events */

/**
 * An `enter` event is emitted when the user presses 'enter' inside the text box.
 *
 * @event enter
 */

/* Methods */

/**
 * Handle icon mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.TextInputWidget.prototype.onIconMouseDown = function ( e ) {
	if ( e.which === OO.ui.MouseButtons.LEFT ) {
		this.focus();
		return false;
	}
};

/**
 * Handle indicator mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.TextInputWidget.prototype.onIndicatorMouseDown = function ( e ) {
	if ( e.which === OO.ui.MouseButtons.LEFT ) {
		this.focus();
		return false;
	}
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @fires enter If enter key is pressed
 */
OO.ui.TextInputWidget.prototype.onKeyPress = function ( e ) {
	if ( e.which === OO.ui.Keys.ENTER ) {
		this.emit( 'enter', e );
	}
};

/**
 * Handle blur events.
 *
 * @private
 * @param {jQuery.Event} e Blur event
 */
OO.ui.TextInputWidget.prototype.onBlur = function () {
	this.setValidityFlag();
};

/**
 * Handle focus events.
 *
 * @private
 * @param {jQuery.Event} e Focus event
 */
OO.ui.TextInputWidget.prototype.onFocus = function () {
	if ( this.isWaitingToBeAttached ) {
		// If we've received focus, then we must be attached to the document, and if
		// isWaitingToBeAttached is still true, that means the handler never fired. Fire it now.
		this.onElementAttach();
	}
	this.setValidityFlag( true );
};

/**
 * Handle element attach events.
 *
 * @private
 * @param {jQuery.Event} e Element attach event
 */
OO.ui.TextInputWidget.prototype.onElementAttach = function () {
	this.isWaitingToBeAttached = false;
	// Any previously calculated size is now probably invalid if we reattached elsewhere
	this.valCache = null;
	this.positionLabel();
};

/**
 * Handle debounced change events.
 *
 * @param {string} value
 * @private
 */
OO.ui.TextInputWidget.prototype.onDebouncedChange = function () {
	this.setValidityFlag();
};

/**
 * Check if the input is {@link #readOnly read-only}.
 *
 * @return {boolean}
 */
OO.ui.TextInputWidget.prototype.isReadOnly = function () {
	return this.readOnly;
};

/**
 * Set the {@link #readOnly read-only} state of the input.
 *
 * @param {boolean} state Make input read-only
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setReadOnly = function ( state ) {
	this.readOnly = !!state;
	this.$input.prop( 'readOnly', this.readOnly );
	return this;
};

/**
 * Check if the input is {@link #required required}.
 *
 * @return {boolean}
 */
OO.ui.TextInputWidget.prototype.isRequired = function () {
	return this.required;
};

/**
 * Set the {@link #required required} state of the input.
 *
 * @param {boolean} state Make input required
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setRequired = function ( state ) {
	this.required = !!state;
	if ( this.required ) {
		this.$input
			.prop( 'required', true )
			.attr( 'aria-required', 'true' );
		if ( this.getIndicator() === null ) {
			this.setIndicator( 'required' );
		}
	} else {
		this.$input
			.prop( 'required', false )
			.removeAttr( 'aria-required' );
		if ( this.getIndicator() === 'required' ) {
			this.setIndicator( null );
		}
	}
	return this;
};

/**
 * Support function for making #onElementAttach work across browsers.
 *
 * This whole function could be replaced with one line of code using the DOMNodeInsertedIntoDocument
 * event, but it's not supported by Firefox and allegedly deprecated, so we only use it as fallback.
 *
 * Due to MutationObserver performance woes, #onElementAttach is only somewhat reliably called the
 * first time that the element gets attached to the documented.
 */
OO.ui.TextInputWidget.prototype.installParentChangeDetector = function () {
	var mutationObserver, onRemove, topmostNode, fakeParentNode,
		MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
		widget = this;

	if ( MutationObserver ) {
		// The new way. If only it wasn't so ugly.

		if ( this.isElementAttached() ) {
			// Widget is attached already, do nothing. This breaks the functionality of this function when
			// the widget is detached and reattached. Alas, doing this correctly with MutationObserver
			// would require observation of the whole document, which would hurt performance of other,
			// more important code.
			return;
		}

		// Find topmost node in the tree
		topmostNode = this.$element[ 0 ];
		while ( topmostNode.parentNode ) {
			topmostNode = topmostNode.parentNode;
		}

		// We have no way to detect the $element being attached somewhere without observing the entire
		// DOM with subtree modifications, which would hurt performance. So we cheat: we hook to the
		// parent node of $element, and instead detect when $element is removed from it (and thus
		// probably attached somewhere else). If there is no parent, we create a "fake" one. If it
		// doesn't get attached, we end up back here and create the parent.

		mutationObserver = new MutationObserver( function ( mutations ) {
			var i, j, removedNodes;
			for ( i = 0; i < mutations.length; i++ ) {
				removedNodes = mutations[ i ].removedNodes;
				for ( j = 0; j < removedNodes.length; j++ ) {
					if ( removedNodes[ j ] === topmostNode ) {
						setTimeout( onRemove, 0 );
						return;
					}
				}
			}
		} );

		onRemove = function () {
			// If the node was attached somewhere else, report it
			if ( widget.isElementAttached() ) {
				widget.onElementAttach();
			}
			mutationObserver.disconnect();
			widget.installParentChangeDetector();
		};

		// Create a fake parent and observe it
		fakeParentNode = $( '<div>' ).append( topmostNode )[ 0 ];
		mutationObserver.observe( fakeParentNode, { childList: true } );
	} else {
		// Using the DOMNodeInsertedIntoDocument event is much nicer and less magical, and works for
		// detachment and reattachment, but it's not supported by Firefox and allegedly deprecated.
		this.$element.on( 'DOMNodeInsertedIntoDocument', this.onElementAttach.bind( this ) );
	}
};

/**
 * @inheritdoc
 * @protected
 */
OO.ui.TextInputWidget.prototype.getInputElement = function ( config ) {
	if ( this.getSaneType( config ) === 'number' ) {
		return $( '<input>' )
			.attr( 'step', 'any' )
			.attr( 'type', 'number' );
	} else {
		return $( '<input>' ).attr( 'type', this.getSaneType( config ) );
	}
};

/**
 * Get sanitized value for 'type' for given config.
 *
 * @param {Object} config Configuration options
 * @return {string|null}
 * @protected
 */
OO.ui.TextInputWidget.prototype.getSaneType = function ( config ) {
	var allowedTypes = [
		'text',
		'password',
		'email',
		'url',
		'number'
	];
	return allowedTypes.indexOf( config.type ) !== -1 ? config.type : 'text';
};

/**
 * Focus the input and select a specified range within the text.
 *
 * @param {number} from Select from offset
 * @param {number} [to] Select to offset, defaults to from
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.selectRange = function ( from, to ) {
	var isBackwards, start, end,
		input = this.$input[ 0 ];

	to = to || from;

	isBackwards = to < from;
	start = isBackwards ? to : from;
	end = isBackwards ? from : to;

	this.focus();

	try {
		input.setSelectionRange( start, end, isBackwards ? 'backward' : 'forward' );
	} catch ( e ) {
		// IE throws an exception if you call setSelectionRange on a unattached DOM node.
		// Rather than expensively check if the input is attached every time, just check
		// if it was the cause of an error being thrown. If not, rethrow the error.
		if ( this.getElementDocument().body.contains( input ) ) {
			throw e;
		}
	}
	return this;
};

/**
 * Get an object describing the current selection range in a directional manner
 *
 * @return {Object} Object containing 'from' and 'to' offsets
 */
OO.ui.TextInputWidget.prototype.getRange = function () {
	var input = this.$input[ 0 ],
		start = input.selectionStart,
		end = input.selectionEnd,
		isBackwards = input.selectionDirection === 'backward';

	return {
		from: isBackwards ? end : start,
		to: isBackwards ? start : end
	};
};

/**
 * Get the length of the text input value.
 *
 * This could differ from the length of #getValue if the
 * value gets filtered
 *
 * @return {number} Input length
 */
OO.ui.TextInputWidget.prototype.getInputLength = function () {
	return this.$input[ 0 ].value.length;
};

/**
 * Focus the input and select the entire text.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.select = function () {
	return this.selectRange( 0, this.getInputLength() );
};

/**
 * Focus the input and move the cursor to the start.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.moveCursorToStart = function () {
	return this.selectRange( 0 );
};

/**
 * Focus the input and move the cursor to the end.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.moveCursorToEnd = function () {
	return this.selectRange( this.getInputLength() );
};

/**
 * Insert new content into the input.
 *
 * @param {string} content Content to be inserted
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.insertContent = function ( content ) {
	var start, end,
		range = this.getRange(),
		value = this.getValue();

	start = Math.min( range.from, range.to );
	end = Math.max( range.from, range.to );

	this.setValue( value.slice( 0, start ) + content + value.slice( end ) );
	this.selectRange( start + content.length );
	return this;
};

/**
 * Insert new content either side of a selection.
 *
 * @param {string} pre Content to be inserted before the selection
 * @param {string} post Content to be inserted after the selection
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.encapsulateContent = function ( pre, post ) {
	var start, end,
		range = this.getRange(),
		offset = pre.length;

	start = Math.min( range.from, range.to );
	end = Math.max( range.from, range.to );

	this.selectRange( start ).insertContent( pre );
	this.selectRange( offset + end ).insertContent( post );

	this.selectRange( offset + start, offset + end );
	return this;
};

/**
 * Set the validation pattern.
 *
 * The validation pattern is either a regular expression, a function, or the symbolic name of a
 * pattern defined by the class: 'non-empty' (the value cannot be an empty string) or 'integer' (the
 * value must contain only numbers).
 *
 * @param {RegExp|Function|string|null} validate Regular expression, function, or the symbolic name
 *  of a pattern (either ‘integer’ or ‘non-empty’) defined by the class.
 */
OO.ui.TextInputWidget.prototype.setValidation = function ( validate ) {
	if ( validate instanceof RegExp || validate instanceof Function ) {
		this.validate = validate;
	} else {
		this.validate = this.constructor.static.validationPatterns[ validate ] || /.*/;
	}
};

/**
 * Sets the 'invalid' flag appropriately.
 *
 * @param {boolean} [isValid] Optionally override validation result
 */
OO.ui.TextInputWidget.prototype.setValidityFlag = function ( isValid ) {
	var widget = this,
		setFlag = function ( valid ) {
			if ( !valid ) {
				widget.$input.attr( 'aria-invalid', 'true' );
			} else {
				widget.$input.removeAttr( 'aria-invalid' );
			}
			widget.setFlags( { invalid: !valid } );
		};

	if ( isValid !== undefined ) {
		setFlag( isValid );
	} else {
		this.getValidity().then( function () {
			setFlag( true );
		}, function () {
			setFlag( false );
		} );
	}
};

/**
 * Get the validity of current value.
 *
 * This method returns a promise that resolves if the value is valid and rejects if
 * it isn't. Uses the {@link #validate validation pattern}  to check for validity.
 *
 * @return {jQuery.Promise} A promise that resolves if the value is valid, rejects if not.
 */
OO.ui.TextInputWidget.prototype.getValidity = function () {
	var result;

	function rejectOrResolve( valid ) {
		if ( valid ) {
			return $.Deferred().resolve().promise();
		} else {
			return $.Deferred().reject().promise();
		}
	}

	// Check browser validity and reject if it is invalid
	if (
		this.$input[ 0 ].checkValidity !== undefined &&
		this.$input[ 0 ].checkValidity() === false
	) {
		return rejectOrResolve( false );
	}

	// Run our checks if the browser thinks the field is valid
	if ( this.validate instanceof Function ) {
		result = this.validate( this.getValue() );
		if ( result && typeof result.promise === 'function' ) {
			return result.promise().then( function ( valid ) {
				return rejectOrResolve( valid );
			} );
		} else {
			return rejectOrResolve( result );
		}
	} else {
		return rejectOrResolve( this.getValue().match( this.validate ) );
	}
};

/**
 * Set the position of the inline label relative to that of the value: `‘before’` or `‘after’`.
 *
 * @param {string} labelPosition Label position, 'before' or 'after'
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setLabelPosition = function ( labelPosition ) {
	this.labelPosition = labelPosition;
	if ( this.label ) {
		// If there is no label and we only change the position, #updatePosition is a no-op,
		// but it takes really a lot of work to do nothing.
		this.updatePosition();
	}
	return this;
};

/**
 * Update the position of the inline label.
 *
 * This method is called by #setLabelPosition, and can also be called on its own if
 * something causes the label to be mispositioned.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.updatePosition = function () {
	var after = this.labelPosition === 'after';

	this.$element
		.toggleClass( 'oo-ui-textInputWidget-labelPosition-after', !!this.label && after )
		.toggleClass( 'oo-ui-textInputWidget-labelPosition-before', !!this.label && !after );

	this.valCache = null;
	this.scrollWidth = null;
	this.positionLabel();

	return this;
};

/**
 * Position the label by setting the correct padding on the input.
 *
 * @private
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.positionLabel = function () {
	var after, rtl, property, newCss;

	if ( this.isWaitingToBeAttached ) {
		// #onElementAttach will be called soon, which calls this method
		return this;
	}

	newCss = {
		'padding-right': '',
		'padding-left': ''
	};

	if ( this.label ) {
		this.$element.append( this.$label );
	} else {
		this.$label.detach();
		// Clear old values if present
		this.$input.css( newCss );
		return;
	}

	after = this.labelPosition === 'after';
	rtl = this.$element.css( 'direction' ) === 'rtl';
	property = after === rtl ? 'padding-left' : 'padding-right';

	newCss[ property ] = this.$label.outerWidth( true ) + ( after ? this.scrollWidth : 0 );
	// We have to clear the padding on the other side, in case the element direction changed
	this.$input.css( newCss );

	return this;
};

/**
 * SearchInputWidgets are TextInputWidgets with `type="search"` assigned and feature a
 * {@link OO.ui.mixin.IconElement search icon} by default.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#SearchInputWidget
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.SearchInputWidget = function OoUiSearchInputWidget( config ) {
	config = $.extend( {
		icon: 'search'
	}, config );

	// Parent constructor
	OO.ui.SearchInputWidget.parent.call( this, config );

	// Events
	this.connect( this, {
		change: 'onChange'
	} );

	// Initialization
	this.updateSearchIndicator();
	this.connect( this, {
		disable: 'onDisable'
	} );
};

/* Setup */

OO.inheritClass( OO.ui.SearchInputWidget, OO.ui.TextInputWidget );

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.SearchInputWidget.prototype.getSaneType = function () {
	return 'search';
};

/**
 * @inheritdoc
 */
OO.ui.SearchInputWidget.prototype.onIndicatorMouseDown = function ( e ) {
	if ( e.which === OO.ui.MouseButtons.LEFT ) {
		// Clear the text field
		this.setValue( '' );
		this.focus();
		return false;
	}
};

/**
 * Update the 'clear' indicator displayed on type: 'search' text
 * fields, hiding it when the field is already empty or when it's not
 * editable.
 */
OO.ui.SearchInputWidget.prototype.updateSearchIndicator = function () {
	if ( this.getValue() === '' || this.isDisabled() || this.isReadOnly() ) {
		this.setIndicator( null );
	} else {
		this.setIndicator( 'clear' );
	}
};

/**
 * Handle change events.
 *
 * @private
 */
OO.ui.SearchInputWidget.prototype.onChange = function () {
	this.updateSearchIndicator();
};

/**
 * Handle disable events.
 *
 * @param {boolean} disabled Element is disabled
 * @private
 */
OO.ui.SearchInputWidget.prototype.onDisable = function () {
	this.updateSearchIndicator();
};

/**
 * @inheritdoc
 */
OO.ui.SearchInputWidget.prototype.setReadOnly = function ( state ) {
	OO.ui.SearchInputWidget.parent.prototype.setReadOnly.call( this, state );
	this.updateSearchIndicator();
	return this;
};

/**
 * MultilineTextInputWidgets, like HTML textareas, are featuring customization options to
 * configure number of rows visible. In addition, these widgets can be autosized to fit user
 * inputs and can show {@link OO.ui.mixin.IconElement icons} and
 * {@link OO.ui.mixin.IndicatorElement indicators}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // A MultilineTextInputWidget.
 *     var multilineTextInput = new OO.ui.MultilineTextInputWidget( {
 *         value: 'Text input on multiple lines'
 *     } )
 *     $( 'body' ).append( multilineTextInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#MultilineTextInputWidget
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number} [rows] Number of visible lines in textarea. If used with `autosize`,
 *  specifies minimum number of rows to display.
 * @cfg {boolean} [autosize=false] Automatically resize the text input to fit its content.
 *  Use the #maxRows config to specify a maximum number of displayed rows.
 * @cfg {number} [maxRows] Maximum number of rows to display when #autosize is set to true.
 *  Defaults to the maximum of `10` and `2 * rows`, or `10` if `rows` isn't provided.
 */
OO.ui.MultilineTextInputWidget = function OoUiMultilineTextInputWidget( config ) {
	config = $.extend( {
		type: 'text'
	}, config );
	// Parent constructor
	OO.ui.MultilineTextInputWidget.parent.call( this, config );

	// Properties
	this.autosize = !!config.autosize;
	this.styleHeight = null;
	this.minRows = config.rows !== undefined ? config.rows : '';
	this.maxRows = config.maxRows || Math.max( 2 * ( this.minRows || 0 ), 10 );

	// Clone for resizing
	if ( this.autosize ) {
		this.$clone = this.$input
			.clone()
			.removeAttr( 'id' )
			.removeAttr( 'name' )
			.insertAfter( this.$input )
			.attr( 'aria-hidden', 'true' )
			.addClass( 'oo-ui-element-hidden' );
	}

	// Events
	this.connect( this, {
		change: 'onChange'
	} );

	// Initialization
	if ( config.rows ) {
		this.$input.attr( 'rows', config.rows );
	}
	if ( this.autosize ) {
		this.$input.addClass( 'oo-ui-textInputWidget-autosized' );
		this.isWaitingToBeAttached = true;
		this.installParentChangeDetector();
	}
};

/* Setup */

OO.inheritClass( OO.ui.MultilineTextInputWidget, OO.ui.TextInputWidget );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.static.gatherPreInfuseState = function ( node, config ) {
	var state = OO.ui.MultilineTextInputWidget.parent.static.gatherPreInfuseState( node, config );
	state.scrollTop = config.$input.scrollTop();
	return state;
};

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.onElementAttach = function () {
	OO.ui.MultilineTextInputWidget.parent.prototype.onElementAttach.call( this );
	this.adjustSize();
};

/**
 * Handle change events.
 *
 * @private
 */
OO.ui.MultilineTextInputWidget.prototype.onChange = function () {
	this.adjustSize();
};

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.updatePosition = function () {
	OO.ui.MultilineTextInputWidget.parent.prototype.updatePosition.call( this );
	this.adjustSize();
};

/**
 * @inheritdoc
 *
 * Modify to emit 'enter' on Ctrl/Meta+Enter, instead of plain Enter
 */
OO.ui.MultilineTextInputWidget.prototype.onKeyPress = function ( e ) {
	if (
		( e.which === OO.ui.Keys.ENTER && ( e.ctrlKey || e.metaKey ) ) ||
		// Some platforms emit keycode 10 for ctrl+enter in a textarea
		e.which === 10
	) {
		this.emit( 'enter', e );
	}
};

/**
 * Automatically adjust the size of the text input.
 *
 * This only affects multiline inputs that are {@link #autosize autosized}.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 * @fires resize
 */
OO.ui.MultilineTextInputWidget.prototype.adjustSize = function () {
	var scrollHeight, innerHeight, outerHeight, maxInnerHeight, measurementError,
		idealHeight, newHeight, scrollWidth, property;

	if ( this.$input.val() !== this.valCache ) {
		if ( this.autosize ) {
			this.$clone
				.val( this.$input.val() )
				.attr( 'rows', this.minRows )
				// Set inline height property to 0 to measure scroll height
				.css( 'height', 0 );

			this.$clone.removeClass( 'oo-ui-element-hidden' );

			this.valCache = this.$input.val();

			scrollHeight = this.$clone[ 0 ].scrollHeight;

			// Remove inline height property to measure natural heights
			this.$clone.css( 'height', '' );
			innerHeight = this.$clone.innerHeight();
			outerHeight = this.$clone.outerHeight();

			// Measure max rows height
			this.$clone
				.attr( 'rows', this.maxRows )
				.css( 'height', 'auto' )
				.val( '' );
			maxInnerHeight = this.$clone.innerHeight();

			// Difference between reported innerHeight and scrollHeight with no scrollbars present.
			// This is sometimes non-zero on Blink-based browsers, depending on zoom level.
			measurementError = maxInnerHeight - this.$clone[ 0 ].scrollHeight;
			idealHeight = Math.min( maxInnerHeight, scrollHeight + measurementError );

			this.$clone.addClass( 'oo-ui-element-hidden' );

			// Only apply inline height when expansion beyond natural height is needed
			// Use the difference between the inner and outer height as a buffer
			newHeight = idealHeight > innerHeight ? idealHeight + ( outerHeight - innerHeight ) : '';
			if ( newHeight !== this.styleHeight ) {
				this.$input.css( 'height', newHeight );
				this.styleHeight = newHeight;
				this.emit( 'resize' );
			}
		}
		scrollWidth = this.$input[ 0 ].offsetWidth - this.$input[ 0 ].clientWidth;
		if ( scrollWidth !== this.scrollWidth ) {
			property = this.$element.css( 'direction' ) === 'rtl' ? 'left' : 'right';
			// Reset
			this.$label.css( { right: '', left: '' } );
			this.$indicator.css( { right: '', left: '' } );

			if ( scrollWidth ) {
				this.$indicator.css( property, scrollWidth );
				if ( this.labelPosition === 'after' ) {
					this.$label.css( property, scrollWidth );
				}
			}

			this.scrollWidth = scrollWidth;
			this.positionLabel();
		}
	}
	return this;
};

/**
 * @inheritdoc
 * @protected
 */
OO.ui.MultilineTextInputWidget.prototype.getInputElement = function () {
	return $( '<textarea>' );
};

/**
 * Check if the input automatically adjusts its size.
 *
 * @return {boolean}
 */
OO.ui.MultilineTextInputWidget.prototype.isAutosizing = function () {
	return !!this.autosize;
};

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.restorePreInfuseState = function ( state ) {
	OO.ui.MultilineTextInputWidget.parent.prototype.restorePreInfuseState.call( this, state );
	if ( state.scrollTop !== undefined ) {
		this.$input.scrollTop( state.scrollTop );
	}
};

/**
 * ComboBoxInputWidgets combine a {@link OO.ui.TextInputWidget text input} (where a value
 * can be entered manually) and a {@link OO.ui.MenuSelectWidget menu of options} (from which
 * a value can be chosen instead). Users can choose options from the combo box in one of two ways:
 *
 * - by typing a value in the text input field. If the value exactly matches the value of a menu
 *   option, that option will appear to be selected.
 * - by choosing a value from the menu. The value of the chosen option will then appear in the text
 *   input field.
 *
 * After the user chooses an option, its `data` will be used as a new value for the widget.
 * A `label` also can be specified for each option: if given, it will be shown instead of the
 * `data` in the dropdown menu.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 * For more information about menus and options, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // A ComboBoxInputWidget.
 *     var comboBox = new OO.ui.ComboBoxInputWidget( {
 *         value: 'Option 1',
 *         options: [
 *             { data: 'Option 1' },
 *             { data: 'Option 2' },
 *             { data: 'Option 3' }
 *         ]
 *     } );
 *     $( document.body ).append( comboBox.$element );
 *
 *     @example
 *     // Example: A ComboBoxInputWidget with additional option labels.
 *     var comboBox = new OO.ui.ComboBoxInputWidget( {
 *         value: 'Option 1',
 *         options: [
 *             {
 *                 data: 'Option 1',
 *                 label: 'Option One'
 *             },
 *             {
 *                 data: 'Option 2',
 *                 label: 'Option Two'
 *             },
 *             {
 *                 data: 'Option 3',
 *                 label: 'Option Three'
 *             }
 *         ]
 *     } );
 *     $( document.body ).append( comboBox.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 * @cfg {Object} [menu] Configuration options to pass to the {@link OO.ui.MenuSelectWidget menu select widget}.
 * @cfg {jQuery} [$overlay] Render the menu into a separate layer. This configuration is useful in cases where
 *  the expanded menu is larger than its containing `<div>`. The specified overlay layer is usually on top of the
 *  containing `<div>` and has a larger area. By default, the menu uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.ComboBoxInputWidget = function OoUiComboBoxInputWidget( config ) {
	// Configuration initialization
	config = $.extend( {
		autocomplete: false
	}, config );

	// ComboBoxInputWidget shouldn't support `multiline`
	config.multiline = false;

	// See InputWidget#reusePreInfuseDOM about `config.$input`
	if ( config.$input ) {
		config.$input.removeAttr( 'list' );
	}

	// Parent constructor
	OO.ui.ComboBoxInputWidget.parent.call( this, config );

	// Properties
	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
	this.dropdownButton = new OO.ui.ButtonWidget( {
		classes: [ 'oo-ui-comboBoxInputWidget-dropdownButton' ],
		label: OO.ui.msg( 'ooui-combobox-button-label' ),
		indicator: 'down',
		invisibleLabel: true,
		disabled: this.disabled
	} );
	this.menu = new OO.ui.MenuSelectWidget( $.extend(
		{
			widget: this,
			input: this,
			$floatableContainer: this.$element,
			disabled: this.isDisabled()
		},
		config.menu
	) );

	// Events
	this.connect( this, {
		change: 'onInputChange',
		enter: 'onInputEnter'
	} );
	this.dropdownButton.connect( this, {
		click: 'onDropdownButtonClick'
	} );
	this.menu.connect( this, {
		choose: 'onMenuChoose',
		add: 'onMenuItemsChange',
		remove: 'onMenuItemsChange',
		toggle: 'onMenuToggle'
	} );

	// Initialization
	this.$input.attr( {
		role: 'combobox',
		'aria-owns': this.menu.getElementId(),
		'aria-autocomplete': 'list'
	} );
	this.dropdownButton.$button.attr( {
		'aria-controls': this.menu.getElementId()
	} );
	// Do not override options set via config.menu.items
	if ( config.options !== undefined ) {
		this.setOptions( config.options );
	}
	this.$field = $( '<div>' )
		.addClass( 'oo-ui-comboBoxInputWidget-field' )
		.append( this.$input, this.dropdownButton.$element );
	this.$element
		.addClass( 'oo-ui-comboBoxInputWidget' )
		.append( this.$field );
	this.$overlay.append( this.menu.$element );
	this.onMenuItemsChange();
};

/* Setup */

OO.inheritClass( OO.ui.ComboBoxInputWidget, OO.ui.TextInputWidget );

/* Methods */

/**
 * Get the combobox's menu.
 *
 * @return {OO.ui.MenuSelectWidget} Menu widget
 */
OO.ui.ComboBoxInputWidget.prototype.getMenu = function () {
	return this.menu;
};

/**
 * Get the combobox's text input widget.
 *
 * @return {OO.ui.TextInputWidget} Text input widget
 */
OO.ui.ComboBoxInputWidget.prototype.getInput = function () {
	return this;
};

/**
 * Handle input change events.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.ComboBoxInputWidget.prototype.onInputChange = function ( value ) {
	var match = this.menu.findItemFromData( value );

	this.menu.selectItem( match );
	if ( this.menu.findHighlightedItem() ) {
		this.menu.highlightItem( match );
	}

	if ( !this.isDisabled() ) {
		this.menu.toggle( true );
	}
};

/**
 * Handle input enter events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onInputEnter = function () {
	if ( !this.isDisabled() ) {
		this.menu.toggle( false );
	}
};

/**
 * Handle button click events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onDropdownButtonClick = function () {
	this.menu.toggle();
	this.focus();
};

/**
 * Handle menu choose events.
 *
 * @private
 * @param {OO.ui.OptionWidget} item Chosen item
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuChoose = function ( item ) {
	this.setValue( item.getData() );
};

/**
 * Handle menu item change events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuItemsChange = function () {
	var match = this.menu.findItemFromData( this.getValue() );
	this.menu.selectItem( match );
	if ( this.menu.findHighlightedItem() ) {
		this.menu.highlightItem( match );
	}
	this.$element.toggleClass( 'oo-ui-comboBoxInputWidget-empty', this.menu.isEmpty() );
};

/**
 * Handle menu toggle events.
 *
 * @private
 * @param {boolean} isVisible Open state of the menu
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuToggle = function ( isVisible ) {
	this.$element.toggleClass( 'oo-ui-comboBoxInputWidget-open', isVisible );
};

/**
 * @inheritdoc
 */
OO.ui.ComboBoxInputWidget.prototype.setDisabled = function ( disabled ) {
	// Parent method
	OO.ui.ComboBoxInputWidget.parent.prototype.setDisabled.call( this, disabled );

	if ( this.dropdownButton ) {
		this.dropdownButton.setDisabled( this.isDisabled() );
	}
	if ( this.menu ) {
		this.menu.setDisabled( this.isDisabled() );
	}

	return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ComboBoxInputWidget.prototype.setOptions = function ( options ) {
	this.getMenu()
		.clearItems()
		.addItems( options.map( function ( opt ) {
			return new OO.ui.MenuOptionWidget( {
				data: opt.data,
				label: opt.label !== undefined ? opt.label : opt.data
			} );
		} ) );

	return this;
};

/**
 * FieldLayouts are used with OO.ui.FieldsetLayout. Each FieldLayout requires a field-widget,
 * which is a widget that is specified by reference before any optional configuration settings.
 *
 * Field layouts can be configured with help text and/or labels. Labels are aligned in one of four ways:
 *
 * - **left**: The label is placed before the field-widget and aligned with the left margin.
 *   A left-alignment is used for forms with many fields.
 * - **right**: The label is placed before the field-widget and aligned to the right margin.
 *   A right-alignment is used for long but familiar forms which users tab through,
 *   verifying the current field with a quick glance at the label.
 * - **top**: The label is placed above the field-widget. A top-alignment is used for brief forms
 *   that users fill out from top to bottom.
 * - **inline**: The label is placed after the field-widget and aligned to the left.
 *   An inline-alignment is best used with checkboxes or radio buttons.
 *
 * Help text can either be:
 *
 * - accessed via a help icon that appears in the upper right corner of the rendered field layout, or
 * - shown as a subtle explanation below the label.
 *
 * If the help text is brief, or is essential to always expose it, set `helpInline` to `true`. If it
 * is long or not essential, leave `helpInline` to its default, `false`.
 *
 * Please see the [OOUI documentation on MediaWiki] [1] for examples and more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Fields_and_Fieldsets
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {OO.ui.Widget} fieldWidget Field widget
 * @param {Object} [config] Configuration options
 * @cfg {string} [align='left'] Alignment of the label: 'left', 'right', 'top'
 *  or 'inline'
 * @cfg {Array} [errors] Error messages about the widget, which will be
 *  displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @cfg {Array} [notices] Notices about the widget, which will be displayed
 *  below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 *  These are more visible than `help` messages when `helpInline` is set, and so
 *  might be good for transient messages.
 * @cfg {string|OO.ui.HtmlSnippet} [help] Help text. When help text is specified
 *  and `helpInline` is `false`, a "help" icon will appear in the upper-right
 *  corner of the rendered field; clicking it will display the text in a popup.
 *  If `helpInline` is `true`, then a subtle description will be shown after the
 *  label.
 * @cfg {boolean} [helpInline=false] Whether or not the help should be inline,
 *  or shown when the "help" icon is clicked.
 * @cfg {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup, if
 * `help` is given.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 *
 * @throws {Error} An error is thrown if no widget is specified
 */
OO.ui.FieldLayout = function OoUiFieldLayout( fieldWidget, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( fieldWidget ) && config === undefined ) {
		config = fieldWidget;
		fieldWidget = config.fieldWidget;
	}

	// Make sure we have required constructor arguments
	if ( fieldWidget === undefined ) {
		throw new Error( 'Widget not found' );
	}

	// Configuration initialization
	config = $.extend( { align: 'left', helpInline: false }, config );

	// Parent constructor
	OO.ui.FieldLayout.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.LabelElement.call( this, $.extend( {}, config, {
		$label: $( '<label>' )
	} ) );
	OO.ui.mixin.TitledElement.call( this, $.extend( {}, config, { $titled: this.$label } ) );

	// Properties
	this.fieldWidget = fieldWidget;
	this.errors = [];
	this.notices = [];
	this.$field = this.isFieldInline() ? $( '<span>' ) : $( '<div>' );
	this.$messages = $( '<ul>' );
	this.$header = $( '<span>' );
	this.$body = $( '<div>' );
	this.align = null;
	this.helpInline = config.helpInline;

	// Events
	this.fieldWidget.connect( this, { disable: 'onFieldDisable' } );

	// Initialization
	this.$help = config.help ?
		this.createHelpElement( config.help, config.$overlay ) :
		$( [] );
	if ( this.fieldWidget.getInputId() ) {
		this.$label.attr( 'for', this.fieldWidget.getInputId() );
		if ( this.helpInline ) {
			this.$help.attr( 'for', this.fieldWidget.getInputId() );
		}
	} else {
		this.$label.on( 'click', function () {
			this.fieldWidget.simulateLabelClick();
		}.bind( this ) );
		if ( this.helpInline ) {
			this.$help.on( 'click', function () {
				this.fieldWidget.simulateLabelClick();
			}.bind( this ) );
		}
	}
	this.$element
		.addClass( 'oo-ui-fieldLayout' )
		.toggleClass( 'oo-ui-fieldLayout-disabled', this.fieldWidget.isDisabled() )
		.append( this.$body );
	this.$body.addClass( 'oo-ui-fieldLayout-body' );
	this.$header.addClass( 'oo-ui-fieldLayout-header' );
	this.$messages.addClass( 'oo-ui-fieldLayout-messages' );
	this.$field
		.addClass( 'oo-ui-fieldLayout-field' )
		.append( this.fieldWidget.$element );

	this.setErrors( config.errors || [] );
	this.setNotices( config.notices || [] );
	this.setAlignment( config.align );
	// Call this again to take into account the widget's accessKey
	this.updateTitle();
};

/* Setup */

OO.inheritClass( OO.ui.FieldLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FieldLayout, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.FieldLayout, OO.ui.mixin.TitledElement );

/* Methods */

/**
 * Handle field disable events.
 *
 * @private
 * @param {boolean} value Field is disabled
 */
OO.ui.FieldLayout.prototype.onFieldDisable = function ( value ) {
	this.$element.toggleClass( 'oo-ui-fieldLayout-disabled', value );
};

/**
 * Get the widget contained by the field.
 *
 * @return {OO.ui.Widget} Field widget
 */
OO.ui.FieldLayout.prototype.getField = function () {
	return this.fieldWidget;
};

/**
 * Return `true` if the given field widget can be used with `'inline'` alignment (see
 * #setAlignment). Return `false` if it can't or if this can't be determined.
 *
 * @return {boolean}
 */
OO.ui.FieldLayout.prototype.isFieldInline = function () {
	// This is very simplistic, but should be good enough.
	return this.getField().$element.prop( 'tagName' ).toLowerCase() === 'span';
};

/**
 * @protected
 * @param {string} kind 'error' or 'notice'
 * @param {string|OO.ui.HtmlSnippet} text
 * @return {jQuery}
 */
OO.ui.FieldLayout.prototype.makeMessage = function ( kind, text ) {
	var $listItem, $icon, message;
	$listItem = $( '<li>' );
	if ( kind === 'error' ) {
		$icon = new OO.ui.IconWidget( { icon: 'alert', flags: [ 'warning' ] } ).$element;
		$listItem.attr( 'role', 'alert' );
	} else if ( kind === 'notice' ) {
		$icon = new OO.ui.IconWidget( { icon: 'notice' } ).$element;
	} else {
		$icon = '';
	}
	message = new OO.ui.LabelWidget( { label: text } );
	$listItem
		.append( $icon, message.$element )
		.addClass( 'oo-ui-fieldLayout-messages-' + kind );
	return $listItem;
};

/**
 * Set the field alignment mode.
 *
 * @private
 * @param {string} value Alignment mode, either 'left', 'right', 'top' or 'inline'
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setAlignment = function ( value ) {
	if ( value !== this.align ) {
		// Default to 'left'
		if ( [ 'left', 'right', 'top', 'inline' ].indexOf( value ) === -1 ) {
			value = 'left';
		}
		// Validate
		if ( value === 'inline' && !this.isFieldInline() ) {
			value = 'top';
		}
		// Reorder elements

		if ( this.helpInline ) {
			if ( value === 'top' ) {
				this.$header.append( this.$label );
				this.$body.append( this.$header, this.$field, this.$help );
			} else if ( value === 'inline' ) {
				this.$header.append( this.$label, this.$help );
				this.$body.append( this.$field, this.$header );
			} else {
				this.$header.append( this.$label, this.$help );
				this.$body.append( this.$header, this.$field );
			}
		} else {
			if ( value === 'top' ) {
				this.$header.append( this.$help, this.$label );
				this.$body.append( this.$header, this.$field );
			} else if ( value === 'inline' ) {
				this.$header.append( this.$help, this.$label );
				this.$body.append( this.$field, this.$header );
			} else {
				this.$header.append( this.$label );
				this.$body.append( this.$header, this.$help, this.$field );
			}
		}
		// Set classes. The following classes can be used here:
		// * oo-ui-fieldLayout-align-left
		// * oo-ui-fieldLayout-align-right
		// * oo-ui-fieldLayout-align-top
		// * oo-ui-fieldLayout-align-inline
		if ( this.align ) {
			this.$element.removeClass( 'oo-ui-fieldLayout-align-' + this.align );
		}
		this.$element.addClass( 'oo-ui-fieldLayout-align-' + value );
		this.align = value;
	}

	return this;
};

/**
 * Set the list of error messages.
 *
 * @param {Array} errors Error messages about the widget, which will be displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setErrors = function ( errors ) {
	this.errors = errors.slice();
	this.updateMessages();
	return this;
};

/**
 * Set the list of notice messages.
 *
 * @param {Array} notices Notices about the widget, which will be displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setNotices = function ( notices ) {
	this.notices = notices.slice();
	this.updateMessages();
	return this;
};

/**
 * Update the rendering of error and notice messages.
 *
 * @private
 */
OO.ui.FieldLayout.prototype.updateMessages = function () {
	var i;
	this.$messages.empty();

	if ( this.errors.length || this.notices.length ) {
		this.$body.after( this.$messages );
	} else {
		this.$messages.remove();
		return;
	}

	for ( i = 0; i < this.notices.length; i++ ) {
		this.$messages.append( this.makeMessage( 'notice', this.notices[ i ] ) );
	}
	for ( i = 0; i < this.errors.length; i++ ) {
		this.$messages.append( this.makeMessage( 'error', this.errors[ i ] ) );
	}
};

/**
 * Include information about the widget's accessKey in our title. TitledElement calls this method.
 * (This is a bit of a hack.)
 *
 * @protected
 * @param {string} title Tooltip label for 'title' attribute
 * @return {string}
 */
OO.ui.FieldLayout.prototype.formatTitleWithAccessKey = function ( title ) {
	if ( this.fieldWidget && this.fieldWidget.formatTitleWithAccessKey ) {
		return this.fieldWidget.formatTitleWithAccessKey( title );
	}
	return title;
};

/**
 * Creates and returns the help element. Also sets the `aria-describedby`
 * attribute on the main element of the `fieldWidget`.
 *
 * @private
 * @param {string|OO.ui.HtmlSnippet} [help] Help text.
 * @param {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup.
 * @return {jQuery} The element that should become `this.$help`.
 */
OO.ui.FieldLayout.prototype.createHelpElement = function ( help, $overlay ) {
	var helpId, helpWidget;

	if ( this.helpInline ) {
		helpWidget = new OO.ui.LabelWidget( {
			label: help,
			classes: [ 'oo-ui-inline-help' ]
		} );

		helpId = helpWidget.getElementId();
	} else {
		helpWidget = new OO.ui.PopupButtonWidget( {
			$overlay: $overlay,
			popup: {
				padded: true
			},
			classes: [ 'oo-ui-fieldLayout-help' ],
			framed: false,
			icon: 'info',
			label: OO.ui.msg( 'ooui-field-help' ),
			invisibleLabel: true
		} );
		if ( help instanceof OO.ui.HtmlSnippet ) {
			helpWidget.getPopup().$body.html( help.toString() );
		} else {
			helpWidget.getPopup().$body.text( help );
		}

		helpId = helpWidget.getPopup().getBodyId();
	}

	// Set the 'aria-describedby' attribute on the fieldWidget
	// Preference given to an input or a button
	(
		this.fieldWidget.$input ||
		this.fieldWidget.$button ||
		this.fieldWidget.$element
	).attr( 'aria-describedby', helpId );

	return helpWidget.$element;
};

/**
 * ActionFieldLayouts are used with OO.ui.FieldsetLayout. The layout consists of a field-widget, a button,
 * and an optional label and/or help text. The field-widget (e.g., a {@link OO.ui.TextInputWidget TextInputWidget}),
 * is required and is specified before any optional configuration settings.
 *
 * Labels can be aligned in one of four ways:
 *
 * - **left**: The label is placed before the field-widget and aligned with the left margin.
 *   A left-alignment is used for forms with many fields.
 * - **right**: The label is placed before the field-widget and aligned to the right margin.
 *   A right-alignment is used for long but familiar forms which users tab through,
 *   verifying the current field with a quick glance at the label.
 * - **top**: The label is placed above the field-widget. A top-alignment is used for brief forms
 *   that users fill out from top to bottom.
 * - **inline**: The label is placed after the field-widget and aligned to the left.
 *   An inline-alignment is best used with checkboxes or radio buttons.
 *
 * Help text is accessed via a help icon that appears in the upper right corner of the rendered field layout when help
 * text is specified.
 *
 *     @example
 *     // Example of an ActionFieldLayout
 *     var actionFieldLayout = new OO.ui.ActionFieldLayout(
 *         new OO.ui.TextInputWidget( {
 *             placeholder: 'Field widget'
 *         } ),
 *         new OO.ui.ButtonWidget( {
 *             label: 'Button'
 *         } ),
 *         {
 *             label: 'An ActionFieldLayout. This label is aligned top',
 *             align: 'top',
 *             help: 'This is help text'
 *         }
 *     );
 *
 *     $( document.body ).append( actionFieldLayout.$element );
 *
 * @class
 * @extends OO.ui.FieldLayout
 *
 * @constructor
 * @param {OO.ui.Widget} fieldWidget Field widget
 * @param {OO.ui.ButtonWidget} buttonWidget Button widget
 * @param {Object} config
 */
OO.ui.ActionFieldLayout = function OoUiActionFieldLayout( fieldWidget, buttonWidget, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( fieldWidget ) && config === undefined ) {
		config = fieldWidget;
		fieldWidget = config.fieldWidget;
		buttonWidget = config.buttonWidget;
	}

	// Parent constructor
	OO.ui.ActionFieldLayout.parent.call( this, fieldWidget, config );

	// Properties
	this.buttonWidget = buttonWidget;
	this.$button = $( '<span>' );
	this.$input = this.isFieldInline() ? $( '<span>' ) : $( '<div>' );

	// Initialization
	this.$element
		.addClass( 'oo-ui-actionFieldLayout' );
	this.$button
		.addClass( 'oo-ui-actionFieldLayout-button' )
		.append( this.buttonWidget.$element );
	this.$input
		.addClass( 'oo-ui-actionFieldLayout-input' )
		.append( this.fieldWidget.$element );
	this.$field
		.append( this.$input, this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ActionFieldLayout, OO.ui.FieldLayout );

/**
 * FieldsetLayouts are composed of one or more {@link OO.ui.FieldLayout FieldLayouts},
 * which each contain an individual widget and, optionally, a label. Each Fieldset can be
 * configured with a label as well. For more information and examples,
 * please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // Example of a fieldset layout
 *     var input1 = new OO.ui.TextInputWidget( {
 *         placeholder: 'A text input field'
 *     } );
 *
 *     var input2 = new OO.ui.TextInputWidget( {
 *         placeholder: 'A text input field'
 *     } );
 *
 *     var fieldset = new OO.ui.FieldsetLayout( {
 *         label: 'Example of a fieldset layout'
 *     } );
 *
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( input1, {
 *             label: 'Field One'
 *         } ),
 *         new OO.ui.FieldLayout( input2, {
 *             label: 'Field Two'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Fields_and_Fieldsets
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.FieldLayout[]} [items] An array of fields to add to the fieldset. See OO.ui.FieldLayout for more information about fields.
 * @cfg {string|OO.ui.HtmlSnippet} [help] Help text. When help text is specified, a "help" icon will appear
 *  in the upper-right corner of the rendered field; clicking it will display the text in a popup.
 *  For important messages, you are advised to use `notices`, as they are always shown.
 * @cfg {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup, if `help` is given.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.FieldsetLayout = function OoUiFieldsetLayout( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.FieldsetLayout.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.GroupElement.call( this, config );

	// Properties
	this.$header = $( '<legend>' );
	if ( config.help ) {
		this.popupButtonWidget = new OO.ui.PopupButtonWidget( {
			$overlay: config.$overlay,
			popup: {
				padded: true
			},
			classes: [ 'oo-ui-fieldsetLayout-help' ],
			framed: false,
			icon: 'info',
			label: OO.ui.msg( 'ooui-field-help' ),
			invisibleLabel: true
		} );
		if ( config.help instanceof OO.ui.HtmlSnippet ) {
			this.popupButtonWidget.getPopup().$body.html( config.help.toString() );
		} else {
			this.popupButtonWidget.getPopup().$body.text( config.help );
		}
		this.$help = this.popupButtonWidget.$element;
	} else {
		this.$help = $( [] );
	}

	// Initialization
	this.$header
		.addClass( 'oo-ui-fieldsetLayout-header' )
		.append( this.$icon, this.$label, this.$help );
	this.$group.addClass( 'oo-ui-fieldsetLayout-group' );
	this.$element
		.addClass( 'oo-ui-fieldsetLayout' )
		.prepend( this.$header, this.$group );
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.FieldsetLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.GroupElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.FieldsetLayout.static.tagName = 'fieldset';

/**
 * FormLayouts are used to wrap {@link OO.ui.FieldsetLayout FieldsetLayouts} when you intend to use browser-based
 * form submission for the fields instead of handling them in JavaScript. Form layouts can be configured with an
 * HTML form action, an encoding type, and a method using the #action, #enctype, and #method configs, respectively.
 * See the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * Only widgets from the {@link OO.ui.InputWidget InputWidget} family support form submission. It
 * includes standard form elements like {@link OO.ui.CheckboxInputWidget checkboxes}, {@link
 * OO.ui.RadioInputWidget radio buttons} and {@link OO.ui.TextInputWidget text fields}, as well as
 * some fancier controls. Some controls have both regular and InputWidget variants, for example
 * OO.ui.DropdownWidget and OO.ui.DropdownInputWidget – only the latter support form submission and
 * often have simplified APIs to match the capabilities of HTML forms.
 * See the [OOUI documentation on MediaWiki] [2] for more information about InputWidgets.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Forms
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 *     @example
 *     // Example of a form layout that wraps a fieldset layout
 *     var input1 = new OO.ui.TextInputWidget( {
 *         placeholder: 'Username'
 *     } );
 *     var input2 = new OO.ui.TextInputWidget( {
 *         placeholder: 'Password',
 *         type: 'password'
 *     } );
 *     var submit = new OO.ui.ButtonInputWidget( {
 *         label: 'Submit'
 *     } );
 *
 *     var fieldset = new OO.ui.FieldsetLayout( {
 *         label: 'A form layout'
 *     } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( input1, {
 *             label: 'Username',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( input2, {
 *             label: 'Password',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( submit )
 *     ] );
 *     var form = new OO.ui.FormLayout( {
 *         items: [ fieldset ],
 *         action: '/api/formhandler',
 *         method: 'get'
 *     } )
 *     $( document.body ).append( form.$element );
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [method] HTML form `method` attribute
 * @cfg {string} [action] HTML form `action` attribute
 * @cfg {string} [enctype] HTML form `enctype` attribute
 * @cfg {OO.ui.FieldsetLayout[]} [items] Fieldset layouts to add to the form layout.
 */
OO.ui.FormLayout = function OoUiFormLayout( config ) {
	var action;

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.FormLayout.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, $.extend( {}, config, { $group: this.$element } ) );

	// Events
	this.$element.on( 'submit', this.onFormSubmit.bind( this ) );

	// Make sure the action is safe
	action = config.action;
	if ( action !== undefined && !OO.ui.isSafeUrl( action ) ) {
		action = './' + action;
	}

	// Initialization
	this.$element
		.addClass( 'oo-ui-formLayout' )
		.attr( {
			method: config.method,
			action: action,
			enctype: config.enctype
		} );
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.FormLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FormLayout, OO.ui.mixin.GroupElement );

/* Events */

/**
 * A 'submit' event is emitted when the form is submitted.
 *
 * @event submit
 */

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.FormLayout.static.tagName = 'form';

/* Methods */

/**
 * Handle form submit events.
 *
 * @private
 * @param {jQuery.Event} e Submit event
 * @fires submit
 * @return {OO.ui.FormLayout} The layout, for chaining
 */
OO.ui.FormLayout.prototype.onFormSubmit = function () {
	if ( this.emit( 'submit' ) ) {
		return false;
	}
};

/**
 * PanelLayouts expand to cover the entire area of their parent. They can be configured with scrolling, padding,
 * and a frame, and are often used together with {@link OO.ui.StackLayout StackLayouts}.
 *
 *     @example
 *     // Example of a panel layout
 *     var panel = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true,
 *         padded: true,
 *         $content: $( '<p>A panel layout with padding and a frame.</p>' )
 *     } );
 *     $( document.body ).append( panel.$element );
 *
 * @class
 * @extends OO.ui.Layout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [scrollable=false] Allow vertical scrolling
 * @cfg {boolean} [padded=false] Add padding between the content and the edges of the panel.
 * @cfg {boolean} [expanded=true] Expand the panel to fill the entire parent element.
 * @cfg {boolean} [framed=false] Render the panel with a frame to visually separate it from outside content.
 */
OO.ui.PanelLayout = function OoUiPanelLayout( config ) {
	// Configuration initialization
	config = $.extend( {
		scrollable: false,
		padded: false,
		expanded: true,
		framed: false
	}, config );

	// Parent constructor
	OO.ui.PanelLayout.parent.call( this, config );

	// Initialization
	this.$element.addClass( 'oo-ui-panelLayout' );
	if ( config.scrollable ) {
		this.$element.addClass( 'oo-ui-panelLayout-scrollable' );
	}
	if ( config.padded ) {
		this.$element.addClass( 'oo-ui-panelLayout-padded' );
	}
	if ( config.expanded ) {
		this.$element.addClass( 'oo-ui-panelLayout-expanded' );
	}
	if ( config.framed ) {
		this.$element.addClass( 'oo-ui-panelLayout-framed' );
	}
};

/* Setup */

OO.inheritClass( OO.ui.PanelLayout, OO.ui.Layout );

/* Methods */

/**
 * Focus the panel layout
 *
 * The default implementation just focuses the first focusable element in the panel
 */
OO.ui.PanelLayout.prototype.focus = function () {
	OO.ui.findFocusable( this.$element ).focus();
};

/**
 * HorizontalLayout arranges its contents in a single line (using `display: inline-block` for its
 * items), with small margins between them. Convenient when you need to put a number of block-level
 * widgets on a single line next to each other.
 *
 * Note that inline elements, such as OO.ui.ButtonWidgets, do not need this wrapper.
 *
 *     @example
 *     // HorizontalLayout with a text input and a label
 *     var layout = new OO.ui.HorizontalLayout( {
 *       items: [
 *         new OO.ui.LabelWidget( { label: 'Label' } ),
 *         new OO.ui.TextInputWidget( { value: 'Text' } )
 *       ]
 *     } );
 *     $( document.body ).append( layout.$element );
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.Widget[]|OO.ui.Layout[]} [items] Widgets or other layouts to add to the layout.
 */
OO.ui.HorizontalLayout = function OoUiHorizontalLayout( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.HorizontalLayout.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, $.extend( {}, config, { $group: this.$element } ) );

	// Initialization
	this.$element.addClass( 'oo-ui-horizontalLayout' );
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.HorizontalLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.HorizontalLayout, OO.ui.mixin.GroupElement );

/**
 * NumberInputWidgets combine a {@link OO.ui.TextInputWidget text input} (where a value
 * can be entered manually) and two {@link OO.ui.ButtonWidget button widgets}
 * (to adjust the value in increments) to allow the user to enter a number.
 *
 *     @example
 *     // A NumberInputWidget.
 *     var numberInput = new OO.ui.NumberInputWidget( {
 *         label: 'NumberInputWidget',
 *         input: { value: 5 },
 *         min: 1,
 *         max: 10
 *     } );
 *     $( document.body ).append( numberInput.$element );
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [minusButton] Configuration options to pass to the
 *  {@link OO.ui.ButtonWidget decrementing button widget}.
 * @cfg {Object} [plusButton] Configuration options to pass to the
 *  {@link OO.ui.ButtonWidget incrementing button widget}.
 * @cfg {number} [min=-Infinity] Minimum allowed value
 * @cfg {number} [max=Infinity] Maximum allowed value
 * @cfg {number|null} [step] If specified, the field only accepts values that are multiples of this.
 * @cfg {number} [buttonStep=step||1] Delta when using the buttons or up/down arrow keys.
 *  Defaults to `step` if specified, otherwise `1`.
 * @cfg {number} [pageStep=10*buttonStep] Delta when using the page-up/page-down keys.
 *  Defaults to 10 times `buttonStep`.
 * @cfg {boolean} [showButtons=true] Whether to show the plus and minus buttons.
 */
OO.ui.NumberInputWidget = function OoUiNumberInputWidget( config ) {
	var $field = $( '<div>' )
		.addClass( 'oo-ui-numberInputWidget-field' );

	// Configuration initialization
	config = $.extend( {
		min: -Infinity,
		max: Infinity,
		showButtons: true
	}, config );

	// For backward compatibility
	$.extend( config, config.input );
	this.input = this;

	// Parent constructor
	OO.ui.NumberInputWidget.parent.call( this, $.extend( config, {
		type: 'number'
	} ) );

	if ( config.showButtons ) {
		this.minusButton = new OO.ui.ButtonWidget( $.extend(
			{
				disabled: this.isDisabled(),
				tabIndex: -1,
				classes: [ 'oo-ui-numberInputWidget-minusButton' ],
				icon: 'subtract'
			},
			config.minusButton
		) );
		this.minusButton.$element.attr( 'aria-hidden', 'true' );
		this.plusButton = new OO.ui.ButtonWidget( $.extend(
			{
				disabled: this.isDisabled(),
				tabIndex: -1,
				classes: [ 'oo-ui-numberInputWidget-plusButton' ],
				icon: 'add'
			},
			config.plusButton
		) );
		this.plusButton.$element.attr( 'aria-hidden', 'true' );
	}

	// Events
	this.$input.on( {
		keydown: this.onKeyDown.bind( this ),
		'wheel mousewheel DOMMouseScroll': this.onWheel.bind( this )
	} );
	if ( config.showButtons ) {
		this.plusButton.connect( this, {
			click: [ 'onButtonClick', +1 ]
		} );
		this.minusButton.connect( this, {
			click: [ 'onButtonClick', -1 ]
		} );
	}

	// Build the field
	$field.append( this.$input );
	if ( config.showButtons ) {
		$field
			.prepend( this.minusButton.$element )
			.append( this.plusButton.$element );
	}

	// Initialization
	if ( config.allowInteger || config.isInteger ) {
		// Backward compatibility
		config.step = 1;
	}
	this.setRange( config.min, config.max );
	this.setStep( config.buttonStep, config.pageStep, config.step );
	// Set the validation method after we set step and range
	// so that it doesn't immediately call setValidityFlag
	this.setValidation( this.validateNumber.bind( this ) );

	this.$element
		.addClass( 'oo-ui-numberInputWidget' )
		.toggleClass( 'oo-ui-numberInputWidget-buttoned', config.showButtons )
		.append( $field );
};

/* Setup */

OO.inheritClass( OO.ui.NumberInputWidget, OO.ui.TextInputWidget );

/* Methods */

// Backward compatibility
OO.ui.NumberInputWidget.prototype.setAllowInteger = function ( flag ) {
	this.setStep( flag ? 1 : null );
};
// Backward compatibility
OO.ui.NumberInputWidget.prototype.setIsInteger = OO.ui.NumberInputWidget.prototype.setAllowInteger;

// Backward compatibility
OO.ui.NumberInputWidget.prototype.getAllowInteger = function () {
	return this.step === 1;
};
// Backward compatibility
OO.ui.NumberInputWidget.prototype.getIsInteger = OO.ui.NumberInputWidget.prototype.getAllowInteger;

/**
 * Set the range of allowed values
 *
 * @param {number} min Minimum allowed value
 * @param {number} max Maximum allowed value
 */
OO.ui.NumberInputWidget.prototype.setRange = function ( min, max ) {
	if ( min > max ) {
		throw new Error( 'Minimum (' + min + ') must not be greater than maximum (' + max + ')' );
	}
	this.min = min;
	this.max = max;
	this.$input.attr( 'min', this.min );
	this.$input.attr( 'max', this.max );
	this.setValidityFlag();
};

/**
 * Get the current range
 *
 * @return {number[]} Minimum and maximum values
 */
OO.ui.NumberInputWidget.prototype.getRange = function () {
	return [ this.min, this.max ];
};

/**
 * Set the stepping deltas
 *
 * @param {number} [buttonStep=step||1] Delta when using the buttons or up/down arrow keys.
 *  Defaults to `step` if specified, otherwise `1`.
 * @param {number} [pageStep=10*buttonStep] Delta when using the page-up/page-down keys.
 *  Defaults to 10 times `buttonStep`.
 * @param {number|null} [step] If specified, the field only accepts values that are multiples of this.
 */
OO.ui.NumberInputWidget.prototype.setStep = function ( buttonStep, pageStep, step ) {
	if ( buttonStep === undefined ) {
		buttonStep = step || 1;
	}
	if ( pageStep === undefined ) {
		pageStep = 10 * buttonStep;
	}
	if ( step !== null && step <= 0 ) {
		throw new Error( 'Step value, if given, must be positive' );
	}
	if ( buttonStep <= 0 ) {
		throw new Error( 'Button step value must be positive' );
	}
	if ( pageStep <= 0 ) {
		throw new Error( 'Page step value must be positive' );
	}
	this.step = step;
	this.buttonStep = buttonStep;
	this.pageStep = pageStep;
	this.$input.attr( 'step', this.step || 'any' );
	this.setValidityFlag();
};

/**
 * @inheritdoc
 */
OO.ui.NumberInputWidget.prototype.setValue = function ( value ) {
	if ( value === '' ) {
		// Some browsers allow a value in the input even if there isn't one reported by $input.val()
		// so here we make sure an 'empty' value is actually displayed as such.
		this.$input.val( '' );
	}
	return OO.ui.NumberInputWidget.parent.prototype.setValue.call( this, value );
};

/**
 * Get the current stepping values
 *
 * @return {number[]} Button step, page step, and validity step
 */
OO.ui.NumberInputWidget.prototype.getStep = function () {
	return [ this.buttonStep, this.pageStep, this.step ];
};

/**
 * Get the current value of the widget as a number
 *
 * @return {number} May be NaN, or an invalid number
 */
OO.ui.NumberInputWidget.prototype.getNumericValue = function () {
	return +this.getValue();
};

/**
 * Adjust the value of the widget
 *
 * @param {number} delta Adjustment amount
 */
OO.ui.NumberInputWidget.prototype.adjustValue = function ( delta ) {
	var n, v = this.getNumericValue();

	delta = +delta;
	if ( isNaN( delta ) || !isFinite( delta ) ) {
		throw new Error( 'Delta must be a finite number' );
	}

	if ( isNaN( v ) ) {
		n = 0;
	} else {
		n = v + delta;
		n = Math.max( Math.min( n, this.max ), this.min );
		if ( this.step ) {
			n = Math.round( n / this.step ) * this.step;
		}
	}

	if ( n !== v ) {
		this.setValue( n );
	}
};
/**
 * Validate input
 *
 * @private
 * @param {string} value Field value
 * @return {boolean}
 */
OO.ui.NumberInputWidget.prototype.validateNumber = function ( value ) {
	var n = +value;
	if ( value === '' ) {
		return !this.isRequired();
	}

	if ( isNaN( n ) || !isFinite( n ) ) {
		return false;
	}

	if ( this.step && Math.floor( n / this.step ) !== n / this.step ) {
		return false;
	}

	if ( n < this.min || n > this.max ) {
		return false;
	}

	return true;
};

/**
 * Handle mouse click events.
 *
 * @private
 * @param {number} dir +1 or -1
 */
OO.ui.NumberInputWidget.prototype.onButtonClick = function ( dir ) {
	this.adjustValue( dir * this.buttonStep );
};

/**
 * Handle mouse wheel events.
 *
 * @private
 * @param {jQuery.Event} event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.NumberInputWidget.prototype.onWheel = function ( event ) {
	var delta = 0;

	if ( !this.isDisabled() && this.$input.is( ':focus' ) ) {
		// Standard 'wheel' event
		if ( event.originalEvent.deltaMode !== undefined ) {
			this.sawWheelEvent = true;
		}
		if ( event.originalEvent.deltaY ) {
			delta = -event.originalEvent.deltaY;
		} else if ( event.originalEvent.deltaX ) {
			delta = event.originalEvent.deltaX;
		}

		// Non-standard events
		if ( !this.sawWheelEvent ) {
			if ( event.originalEvent.wheelDeltaX ) {
				delta = -event.originalEvent.wheelDeltaX;
			} else if ( event.originalEvent.wheelDeltaY ) {
				delta = event.originalEvent.wheelDeltaY;
			} else if ( event.originalEvent.wheelDelta ) {
				delta = event.originalEvent.wheelDelta;
			} else if ( event.originalEvent.detail ) {
				delta = -event.originalEvent.detail;
			}
		}

		if ( delta ) {
			delta = delta < 0 ? -1 : 1;
			this.adjustValue( delta * this.buttonStep );
		}

		return false;
	}
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.NumberInputWidget.prototype.onKeyDown = function ( e ) {
	if ( !this.isDisabled() ) {
		switch ( e.which ) {
			case OO.ui.Keys.UP:
				this.adjustValue( this.buttonStep );
				return false;
			case OO.ui.Keys.DOWN:
				this.adjustValue( -this.buttonStep );
				return false;
			case OO.ui.Keys.PAGEUP:
				this.adjustValue( this.pageStep );
				return false;
			case OO.ui.Keys.PAGEDOWN:
				this.adjustValue( -this.pageStep );
				return false;
		}
	}
};

/**
 * @inheritdoc
 */
OO.ui.NumberInputWidget.prototype.setDisabled = function ( disabled ) {
	// Parent method
	OO.ui.NumberInputWidget.parent.prototype.setDisabled.call( this, disabled );

	if ( this.minusButton ) {
		this.minusButton.setDisabled( this.isDisabled() );
	}
	if ( this.plusButton ) {
		this.plusButton.setDisabled( this.isDisabled() );
	}

	return this;
};

}( OO ) );

//# sourceMappingURL=oojs-ui-core.js.map.json
/*!
 * OOUI v0.30.2
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2019 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2019-01-23T01:14:20Z
 */
( function ( OO ) {

'use strict';

/**
 * DraggableElement is a mixin class used to create elements that can be clicked
 * and dragged by a mouse to a new position within a group. This class must be used
 * in conjunction with OO.ui.mixin.DraggableGroupElement, which provides a container for
 * the draggable elements.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$handle] The part of the element which can be used for dragging, defaults to the whole element
 * @cfg {boolean} [draggable] The items are draggable. This can change with #toggleDraggable
 *  but the draggable state should be called from the DraggableGroupElement, which updates
 *  the whole group
 */
OO.ui.mixin.DraggableElement = function OoUiMixinDraggableElement( config ) {
	config = config || {};

	// Properties
	this.index = null;
	this.$handle = config.$handle || this.$element;
	this.wasHandleUsed = null;

	// Initialize and events
	this.$element
		.addClass( 'oo-ui-draggableElement' )
		.on( {
			mousedown: this.onDragMouseDown.bind( this ),
			dragstart: this.onDragStart.bind( this ),
			dragover: this.onDragOver.bind( this ),
			dragend: this.onDragEnd.bind( this ),
			drop: this.onDrop.bind( this )
		} );
	this.$handle.addClass( 'oo-ui-draggableElement-handle' );
	this.toggleDraggable( config.draggable === undefined ? true : !!config.draggable );
};

OO.initClass( OO.ui.mixin.DraggableElement );

/* Events */

/**
 * @event dragstart
 *
 * A dragstart event is emitted when the user clicks and begins dragging an item.
 * @param {OO.ui.mixin.DraggableElement} item The item the user has clicked and is dragging with the mouse.
 */

/**
 * @event dragend
 * A dragend event is emitted when the user drags an item and releases the mouse,
 * thus terminating the drag operation.
 */

/**
 * @event drop
 * A drop event is emitted when the user drags an item and then releases the mouse button
 * over a valid target.
 */

/* Static Properties */

/**
 * @inheritdoc OO.ui.mixin.ButtonElement
 */
OO.ui.mixin.DraggableElement.static.cancelButtonMouseDownEvents = false;

/* Methods */

/**
 * Change the draggable state of this widget.
 * This allows users to temporarily halt the dragging operations.
 *
 * @param {boolean} isDraggable Widget supports draggable operations
 * @fires draggable
 */
OO.ui.mixin.DraggableElement.prototype.toggleDraggable = function ( isDraggable ) {
	isDraggable = isDraggable !== undefined ? !!isDraggable : !this.draggable;

	if ( this.draggable !== isDraggable ) {
		this.draggable = isDraggable;

		this.$handle.toggleClass( 'oo-ui-draggableElement-undraggable', !this.draggable );

		// We make the entire element draggable, not just the handle, so that
		// the whole element appears to move. wasHandleUsed prevents drags from
		// starting outside the handle
		this.$element.prop( 'draggable', this.draggable );
	}
};

/**
 * Check the draggable state of this widget
 *
 * @return {boolean} Widget supports draggable operations
 */
OO.ui.mixin.DraggableElement.prototype.isDraggable = function () {
	return this.draggable;
};

/**
 * Respond to mousedown event.
 *
 * @private
 * @param {jQuery.Event} e Drag event
 */
OO.ui.mixin.DraggableElement.prototype.onDragMouseDown = function ( e ) {
	if ( !this.isDraggable() ) {
		return;
	}

	this.wasHandleUsed =
		// Optimization: if the handle is the whole element this is always true
		this.$handle[ 0 ] === this.$element[ 0 ] ||
		// Check the mousedown occurred inside the handle
		OO.ui.contains( this.$handle[ 0 ], e.target, true );
};

/**
 * Respond to dragstart event.
 *
 * @private
 * @param {jQuery.Event} e Drag event
 * @return {boolean} False if the event is cancelled
 * @fires dragstart
 */
OO.ui.mixin.DraggableElement.prototype.onDragStart = function ( e ) {
	var element = this,
		dataTransfer = e.originalEvent.dataTransfer;

	if ( !this.wasHandleUsed || !this.isDraggable() ) {
		return false;
	}

	// Define drop effect
	dataTransfer.dropEffect = 'none';
	dataTransfer.effectAllowed = 'move';
	// Support: Firefox
	// We must set up a dataTransfer data property or Firefox seems to
	// ignore the fact the element is draggable.
	try {
		dataTransfer.setData( 'application-x/OOUI-draggable', this.getIndex() );
	} catch ( err ) {
		// The above is only for Firefox. Move on if it fails.
	}
	// Briefly add a 'clone' class to style the browser's native drag image
	this.$element.addClass( 'oo-ui-draggableElement-clone' );
	// Add placeholder class after the browser has rendered the clone
	setTimeout( function () {
		element.$element
			.removeClass( 'oo-ui-draggableElement-clone' )
			.addClass( 'oo-ui-draggableElement-placeholder' );
	} );
	// Emit event
	this.emit( 'dragstart', this );
	return true;
};

/**
 * Respond to dragend event.
 *
 * @private
 * @fires dragend
 */
OO.ui.mixin.DraggableElement.prototype.onDragEnd = function () {
	this.$element.removeClass( 'oo-ui-draggableElement-placeholder' );
	this.emit( 'dragend' );
};

/**
 * Handle drop event.
 *
 * @private
 * @param {jQuery.Event} e Drop event
 * @fires drop
 */
OO.ui.mixin.DraggableElement.prototype.onDrop = function ( e ) {
	e.preventDefault();
	this.emit( 'drop', e );
};

/**
 * In order for drag/drop to work, the dragover event must
 * return false and stop propogation.
 *
 * @param {jQuery.Event} e Drag event
 * @private
 */
OO.ui.mixin.DraggableElement.prototype.onDragOver = function ( e ) {
	e.preventDefault();
};

/**
 * Set item index.
 * Store it in the DOM so we can access from the widget drag event
 *
 * @private
 * @param {number} index Item index
 */
OO.ui.mixin.DraggableElement.prototype.setIndex = function ( index ) {
	if ( this.index !== index ) {
		this.index = index;
		this.$element.data( 'index', index );
	}
};

/**
 * Get item index
 *
 * @private
 * @return {number} Item index
 */
OO.ui.mixin.DraggableElement.prototype.getIndex = function () {
	return this.index;
};

/**
 * DraggableGroupElement is a mixin class used to create a group element to
 * contain draggable elements, which are items that can be clicked and dragged by a mouse.
 * The class is used with OO.ui.mixin.DraggableElement.
 *
 * @abstract
 * @class
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [orientation] Item orientation: 'horizontal' or 'vertical'. The orientation
 *  should match the layout of the items. Items displayed in a single row
 *  or in several rows should use horizontal orientation. The vertical orientation should only be
 *  used when the items are displayed in a single column. Defaults to 'vertical'
 * @cfg {boolean} [draggable] The items are draggable. This can change with #toggleDraggable
 */
OO.ui.mixin.DraggableGroupElement = function OoUiMixinDraggableGroupElement( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.mixin.GroupElement.call( this, config );

	// Properties
	this.orientation = config.orientation || 'vertical';
	this.dragItem = null;
	this.itemKeys = {};
	this.dir = null;
	this.itemsOrder = null;
	this.draggable = config.draggable === undefined ? true : !!config.draggable;

	// Events
	this.aggregate( {
		dragstart: 'itemDragStart',
		dragend: 'itemDragEnd',
		drop: 'itemDrop'
	} );
	this.connect( this, {
		itemDragStart: 'onItemDragStart',
		itemDrop: 'onItemDropOrDragEnd',
		itemDragEnd: 'onItemDropOrDragEnd'
	} );

	// Initialize
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
	this.$element
		.addClass( 'oo-ui-draggableGroupElement' )
		.toggleClass( 'oo-ui-draggableGroupElement-horizontal', this.orientation === 'horizontal' );
};

/* Setup */
OO.mixinClass( OO.ui.mixin.DraggableGroupElement, OO.ui.mixin.GroupElement );

/* Events */

/**
 * An item has been dragged to a new position, but not yet dropped.
 *
 * @event drag
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 * @param {number} [newIndex] New index for the item
 */

/**
 * An item has been dropped at a new position.
 *
 * @event reorder
 * @param {OO.ui.mixin.DraggableElement} item Reordered item
 * @param {number} [newIndex] New index for the item
 */

/**
 * Draggable state of this widget has changed.
 *
 * @event draggable
 * @param {boolean} [draggable] Widget is draggable
 */

/* Methods */

/**
 * Change the draggable state of this widget.
 * This allows users to temporarily halt the dragging operations.
 *
 * @param {boolean} isDraggable Widget supports draggable operations
 * @fires draggable
 */
OO.ui.mixin.DraggableGroupElement.prototype.toggleDraggable = function ( isDraggable ) {
	isDraggable = isDraggable !== undefined ? !!isDraggable : !this.draggable;

	if ( this.draggable !== isDraggable ) {
		this.draggable = isDraggable;

		// Tell the items their draggable state changed
		this.getItems().forEach( function ( item ) {
			item.toggleDraggable( this.draggable );
		}.bind( this ) );

		// Emit event
		this.emit( 'draggable', this.draggable );
	}
};

/**
 * Check the draggable state of this widget
 *
 * @return {boolean} Widget supports draggable operations
 */
OO.ui.mixin.DraggableGroupElement.prototype.isDraggable = function () {
	return this.draggable;
};

/**
 * Respond to item drag start event
 *
 * @private
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.onItemDragStart = function ( item ) {
	if ( !this.isDraggable() ) {
		return;
	}
	// Make a shallow copy of this.items so we can re-order it during previews
	// without affecting the original array.
	this.itemsOrder = this.items.slice();
	this.updateIndexes();
	if ( this.orientation === 'horizontal' ) {
		// Calculate and cache directionality on drag start - it's a little
		// expensive and it shouldn't change while dragging.
		this.dir = this.$element.css( 'direction' );
	}
	this.setDragItem( item );
};

/**
 * Update the index properties of the items
 */
OO.ui.mixin.DraggableGroupElement.prototype.updateIndexes = function () {
	var i, len;

	// Map the index of each object
	for ( i = 0, len = this.itemsOrder.length; i < len; i++ ) {
		this.itemsOrder[ i ].setIndex( i );
	}
};

/**
 * Handle drop or dragend event and switch the order of the items accordingly
 *
 * @private
 * @param {OO.ui.mixin.DraggableElement} item Dropped item
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.DraggableGroupElement.prototype.onItemDropOrDragEnd = function () {
	var targetIndex, originalIndex,
		item = this.getDragItem();

	// TODO: Figure out a way to configure a list of legally droppable
	// elements even if they are not yet in the list
	if ( item ) {
		originalIndex = this.items.indexOf( item );
		// If the item has moved forward, add one to the index to account for the left shift
		targetIndex = item.getIndex() + ( item.getIndex() > originalIndex ? 1 : 0 );
		if ( targetIndex !== originalIndex ) {
			this.reorder( this.getDragItem(), targetIndex );
			this.emit( 'reorder', this.getDragItem(), targetIndex );
		}
		this.updateIndexes();
	}
	this.unsetDragItem();
	// Return false to prevent propogation
	return false;
};

/**
 * Respond to dragover event
 *
 * @private
 * @param {jQuery.Event} e Dragover event
 * @fires reorder
 */
OO.ui.mixin.DraggableGroupElement.prototype.onDragOver = function ( e ) {
	var overIndex, targetIndex,
		item = this.getDragItem(),
		dragItemIndex = item.getIndex();

	// Get the OptionWidget item we are dragging over
	overIndex = $( e.target ).closest( '.oo-ui-draggableElement' ).data( 'index' );

	if ( overIndex !== undefined && overIndex !== dragItemIndex ) {
		targetIndex = overIndex + ( overIndex > dragItemIndex ? 1 : 0 );

		if ( targetIndex > 0 ) {
			this.$group.children().eq( targetIndex - 1 ).after( item.$element );
		} else {
			this.$group.prepend( item.$element );
		}
		// Move item in itemsOrder array
		this.itemsOrder.splice( overIndex, 0,
			this.itemsOrder.splice( dragItemIndex, 1 )[ 0 ]
		);
		this.updateIndexes();
		this.emit( 'drag', item, targetIndex );
	}
	// Prevent default
	e.preventDefault();
};

/**
 * Reorder the items in the group
 *
 * @param {OO.ui.mixin.DraggableElement} item Reordered item
 * @param {number} newIndex New index
 */
OO.ui.mixin.DraggableGroupElement.prototype.reorder = function ( item, newIndex ) {
	this.addItems( [ item ], newIndex );
};

/**
 * Set a dragged item
 *
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.setDragItem = function ( item ) {
	if ( this.dragItem !== item ) {
		this.dragItem = item;
		this.$element.on( 'dragover', this.onDragOver.bind( this ) );
		this.$element.addClass( 'oo-ui-draggableGroupElement-dragging' );
	}
};

/**
 * Unset the current dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.unsetDragItem = function () {
	if ( this.dragItem ) {
		this.dragItem = null;
		this.$element.off( 'dragover' );
		this.$element.removeClass( 'oo-ui-draggableGroupElement-dragging' );
	}
};

/**
 * Get the item that is currently being dragged.
 *
 * @return {OO.ui.mixin.DraggableElement|null} The currently dragged item, or `null` if no item is being dragged
 */
OO.ui.mixin.DraggableGroupElement.prototype.getDragItem = function () {
	return this.dragItem;
};

/**
 * RequestManager is a mixin that manages the lifecycle of a promise-backed request for a widget, such as
 * the {@link OO.ui.mixin.LookupElement}.
 *
 * @class
 * @abstract
 *
 * @constructor
 */
OO.ui.mixin.RequestManager = function OoUiMixinRequestManager() {
	this.requestCache = {};
	this.requestQuery = null;
	this.requestRequest = null;
};

/* Setup */

OO.initClass( OO.ui.mixin.RequestManager );

/**
 * Get request results for the current query.
 *
 * @return {jQuery.Promise} Promise object which will be passed response data as the first argument of
 *   the done event. If the request was aborted to make way for a subsequent request, this promise
 *   may not be rejected, depending on what jQuery feels like doing.
 */
OO.ui.mixin.RequestManager.prototype.getRequestData = function () {
	var widget = this,
		value = this.getRequestQuery(),
		deferred = $.Deferred(),
		ourRequest;

	this.abortRequest();
	if ( Object.prototype.hasOwnProperty.call( this.requestCache, value ) ) {
		deferred.resolve( this.requestCache[ value ] );
	} else {
		if ( this.pushPending ) {
			this.pushPending();
		}
		this.requestQuery = value;
		ourRequest = this.requestRequest = this.getRequest();
		ourRequest
			.always( function () {
				// We need to pop pending even if this is an old request, otherwise
				// the widget will remain pending forever.
				// TODO: this assumes that an aborted request will fail or succeed soon after
				// being aborted, or at least eventually. It would be nice if we could popPending()
				// at abort time, but only if we knew that we hadn't already called popPending()
				// for that request.
				if ( widget.popPending ) {
					widget.popPending();
				}
			} )
			.done( function ( response ) {
				// If this is an old request (and aborting it somehow caused it to still succeed),
				// ignore its success completely
				if ( ourRequest === widget.requestRequest ) {
					widget.requestQuery = null;
					widget.requestRequest = null;
					widget.requestCache[ value ] = widget.getRequestCacheDataFromResponse( response );
					deferred.resolve( widget.requestCache[ value ] );
				}
			} )
			.fail( function () {
				// If this is an old request (or a request failing because it's being aborted),
				// ignore its failure completely
				if ( ourRequest === widget.requestRequest ) {
					widget.requestQuery = null;
					widget.requestRequest = null;
					deferred.reject();
				}
			} );
	}
	return deferred.promise();
};

/**
 * Abort the currently pending request, if any.
 *
 * @private
 */
OO.ui.mixin.RequestManager.prototype.abortRequest = function () {
	var oldRequest = this.requestRequest;
	if ( oldRequest ) {
		// First unset this.requestRequest to the fail handler will notice
		// that the request is no longer current
		this.requestRequest = null;
		this.requestQuery = null;
		oldRequest.abort();
	}
};

/**
 * Get the query to be made.
 *
 * @protected
 * @method
 * @abstract
 * @return {string} query to be used
 */
OO.ui.mixin.RequestManager.prototype.getRequestQuery = null;

/**
 * Get a new request object of the current query value.
 *
 * @protected
 * @method
 * @abstract
 * @return {jQuery.Promise} jQuery AJAX object, or promise object with an .abort() method
 */
OO.ui.mixin.RequestManager.prototype.getRequest = null;

/**
 * Pre-process data returned by the request from #getRequest.
 *
 * The return value of this function will be cached, and any further queries for the given value
 * will use the cache rather than doing API requests.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} response Response from server
 * @return {Mixed} Cached result data
 */
OO.ui.mixin.RequestManager.prototype.getRequestCacheDataFromResponse = null;

/**
 * LookupElement is a mixin that creates a {@link OO.ui.MenuSelectWidget menu} of suggested values for
 * a {@link OO.ui.TextInputWidget text input widget}. Suggested values are based on the characters the user types
 * into the text input field and, in general, the menu is only displayed when the user types. If a suggested value is chosen
 * from the lookup menu, that value becomes the value of the input field.
 *
 * Note that a new menu of suggested items is displayed when a value is chosen from the lookup menu. If this is
 * not the desired behavior, disable lookup menus with the #setLookupsDisabled method, then set the value, then
 * re-enable lookups.
 *
 * See the [OOUI demos][1] for an example.
 *
 * [1]: https://doc.wikimedia.org/oojs-ui/master/demos/#LookupElement-try-inputting-an-integer
 *
 * @class
 * @abstract
 * @mixins OO.ui.mixin.RequestManager
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$overlay] Overlay for the lookup menu; defaults to relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {jQuery} [$container=this.$element] The container element. The lookup menu is rendered beneath the specified element.
 * @cfg {Object} [menu] Configuration options to pass to {@link OO.ui.MenuSelectWidget menu select widget}
 * @cfg {boolean} [allowSuggestionsWhenEmpty=false] Request and display a lookup menu when the text input is empty.
 *  By default, the lookup menu is not generated and displayed until the user begins to type.
 * @cfg {boolean} [highlightFirst=true] Whether the first lookup result should be highlighted (so, that the user can
 *  take it over into the input with simply pressing return) automatically or not.
 */
OO.ui.mixin.LookupElement = function OoUiMixinLookupElement( config ) {
	// Configuration initialization
	config = $.extend( { highlightFirst: true }, config );

	// Mixin constructors
	OO.ui.mixin.RequestManager.call( this, config );

	// Properties
	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
	this.lookupMenu = new OO.ui.MenuSelectWidget( $.extend( {
		widget: this,
		input: this,
		$floatableContainer: config.$container || this.$element
	}, config.menu ) );

	this.allowSuggestionsWhenEmpty = config.allowSuggestionsWhenEmpty || false;

	this.lookupsDisabled = false;
	this.lookupInputFocused = false;
	this.lookupHighlightFirstItem = config.highlightFirst;

	// Events
	this.$input.on( {
		focus: this.onLookupInputFocus.bind( this ),
		blur: this.onLookupInputBlur.bind( this ),
		mousedown: this.onLookupInputMouseDown.bind( this )
	} );
	this.connect( this, { change: 'onLookupInputChange' } );
	this.lookupMenu.connect( this, {
		toggle: 'onLookupMenuToggle',
		choose: 'onLookupMenuItemChoose'
	} );

	// Initialization
	this.$input.attr( {
		role: 'combobox',
		'aria-owns': this.lookupMenu.getElementId(),
		'aria-autocomplete': 'list'
	} );
	this.$element.addClass( 'oo-ui-lookupElement' );
	this.lookupMenu.$element.addClass( 'oo-ui-lookupElement-menu' );
	this.$overlay.append( this.lookupMenu.$element );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.LookupElement, OO.ui.mixin.RequestManager );

/* Methods */

/**
 * Handle input focus event.
 *
 * @protected
 * @param {jQuery.Event} e Input focus event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputFocus = function () {
	this.lookupInputFocused = true;
	this.populateLookupMenu();
};

/**
 * Handle input blur event.
 *
 * @protected
 * @param {jQuery.Event} e Input blur event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputBlur = function () {
	this.closeLookupMenu();
	this.lookupInputFocused = false;
};

/**
 * Handle input mouse down event.
 *
 * @protected
 * @param {jQuery.Event} e Input mouse down event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputMouseDown = function () {
	// Only open the menu if the input was already focused.
	// This way we allow the user to open the menu again after closing it with Esc
	// by clicking in the input. Opening (and populating) the menu when initially
	// clicking into the input is handled by the focus handler.
	if ( this.lookupInputFocused && !this.lookupMenu.isVisible() ) {
		this.populateLookupMenu();
	}
};

/**
 * Handle input change event.
 *
 * @protected
 * @param {string} value New input value
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputChange = function () {
	if ( this.lookupInputFocused ) {
		this.populateLookupMenu();
	}
};

/**
 * Handle the lookup menu being shown/hidden.
 *
 * @protected
 * @param {boolean} visible Whether the lookup menu is now visible.
 */
OO.ui.mixin.LookupElement.prototype.onLookupMenuToggle = function ( visible ) {
	if ( !visible ) {
		// When the menu is hidden, abort any active request and clear the menu.
		// This has to be done here in addition to closeLookupMenu(), because
		// MenuSelectWidget will close itself when the user presses Esc.
		this.abortLookupRequest();
		this.lookupMenu.clearItems();
	}
};

/**
 * Handle menu item 'choose' event, updating the text input value to the value of the clicked item.
 *
 * @protected
 * @param {OO.ui.MenuOptionWidget} item Selected item
 */
OO.ui.mixin.LookupElement.prototype.onLookupMenuItemChoose = function ( item ) {
	this.setValue( item.getData() );
};

/**
 * Get lookup menu.
 *
 * @private
 * @return {OO.ui.MenuSelectWidget}
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenu = function () {
	return this.lookupMenu;
};

/**
 * Disable or re-enable lookups.
 *
 * When lookups are disabled, calls to #populateLookupMenu will be ignored.
 *
 * @param {boolean} disabled Disable lookups
 */
OO.ui.mixin.LookupElement.prototype.setLookupsDisabled = function ( disabled ) {
	this.lookupsDisabled = !!disabled;
};

/**
 * Open the menu. If there are no entries in the menu, this does nothing.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.openLookupMenu = function () {
	if ( !this.lookupMenu.isEmpty() ) {
		this.lookupMenu.toggle( true );
	}
	return this;
};

/**
 * Close the menu, empty it, and abort any pending request.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.closeLookupMenu = function () {
	this.lookupMenu.toggle( false );
	this.abortLookupRequest();
	this.lookupMenu.clearItems();
	return this;
};

/**
 * Request menu items based on the input's current value, and when they arrive,
 * populate the menu with these items and show the menu.
 *
 * If lookups have been disabled with #setLookupsDisabled, this function does nothing.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.populateLookupMenu = function () {
	var widget = this,
		value = this.getValue();

	if ( this.lookupsDisabled || this.isReadOnly() ) {
		return;
	}

	// If the input is empty, clear the menu, unless suggestions when empty are allowed.
	if ( !this.allowSuggestionsWhenEmpty && value === '' ) {
		this.closeLookupMenu();
	// Skip population if there is already a request pending for the current value
	} else if ( value !== this.lookupQuery ) {
		this.getLookupMenuItems()
			.done( function ( items ) {
				widget.lookupMenu.clearItems();
				if ( items.length ) {
					widget.lookupMenu
						.addItems( items )
						.toggle( true );
					widget.initializeLookupMenuSelection();
				} else {
					widget.lookupMenu.toggle( false );
				}
			} )
			.fail( function () {
				widget.lookupMenu.clearItems();
				widget.lookupMenu.toggle( false );
			} );
	}

	return this;
};

/**
 * Highlight the first selectable item in the menu, if configured.
 *
 * @private
 * @chainable
 */
OO.ui.mixin.LookupElement.prototype.initializeLookupMenuSelection = function () {
	if ( this.lookupHighlightFirstItem && !this.lookupMenu.findSelectedItem() ) {
		this.lookupMenu.highlightItem( this.lookupMenu.findFirstSelectableItem() );
	}
};

/**
 * Get lookup menu items for the current query.
 *
 * @private
 * @return {jQuery.Promise} Promise object which will be passed menu items as the first argument of
 *   the done event. If the request was aborted to make way for a subsequent request, this promise
 *   will not be rejected: it will remain pending forever.
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenuItems = function () {
	return this.getRequestData().then( function ( data ) {
		return this.getLookupMenuOptionsFromData( data );
	}.bind( this ) );
};

/**
 * Abort the currently pending lookup request, if any.
 *
 * @private
 */
OO.ui.mixin.LookupElement.prototype.abortLookupRequest = function () {
	this.abortRequest();
};

/**
 * Get a new request object of the current lookup query value.
 *
 * @protected
 * @method
 * @abstract
 * @return {jQuery.Promise} jQuery AJAX object, or promise object with an .abort() method
 */
OO.ui.mixin.LookupElement.prototype.getLookupRequest = null;

/**
 * Pre-process data returned by the request from #getLookupRequest.
 *
 * The return value of this function will be cached, and any further queries for the given value
 * will use the cache rather than doing API requests.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} response Response from server
 * @return {Mixed} Cached result data
 */
OO.ui.mixin.LookupElement.prototype.getLookupCacheDataFromResponse = null;

/**
 * Get a list of menu option widgets from the (possibly cached) data returned by
 * #getLookupCacheDataFromResponse.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} data Cached result data, usually an array
 * @return {OO.ui.MenuOptionWidget[]} Menu items
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenuOptionsFromData = null;

/**
 * Set the read-only state of the widget.
 *
 * This will also disable/enable the lookups functionality.
 *
 * @param {boolean} readOnly Make input read-only
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.setReadOnly = function ( readOnly ) {
	// Parent method
	// Note: Calling #setReadOnly this way assumes this is mixed into an OO.ui.TextInputWidget
	OO.ui.TextInputWidget.prototype.setReadOnly.call( this, readOnly );

	// During construction, #setReadOnly is called before the OO.ui.mixin.LookupElement constructor
	if ( this.isReadOnly() && this.lookupMenu ) {
		this.closeLookupMenu();
	}

	return this;
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequestQuery = function () {
	return this.getValue();
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequest = function () {
	return this.getLookupRequest();
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequestCacheDataFromResponse = function ( response ) {
	return this.getLookupCacheDataFromResponse( response );
};

/**
 * TabPanelLayouts are used within {@link OO.ui.IndexLayout index layouts} to create tab panels that
 * users can select and display from the index's optional {@link OO.ui.TabSelectWidget tab}
 * navigation. TabPanels are usually not instantiated directly, rather extended to include the
 * required content and functionality.
 *
 * Each tab panel must have a unique symbolic name, which is passed to the constructor. In addition,
 * the tab panel's tab item is customized (with a label) using the #setupTabItem method. See
 * {@link OO.ui.IndexLayout IndexLayout} for an example.
 *
 * @class
 * @extends OO.ui.PanelLayout
 *
 * @constructor
 * @param {string} name Unique symbolic name of tab panel
 * @param {Object} [config] Configuration options
 * @cfg {jQuery|string|Function|OO.ui.HtmlSnippet} [label] Label for tab panel's tab
 */
OO.ui.TabPanelLayout = function OoUiTabPanelLayout( name, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( name ) && config === undefined ) {
		config = name;
		name = config.name;
	}

	// Configuration initialization
	config = $.extend( { scrollable: true }, config );

	// Parent constructor
	OO.ui.TabPanelLayout.parent.call( this, config );

	// Properties
	this.name = name;
	this.label = config.label;
	this.tabItem = null;
	this.active = false;

	// Initialization
	this.$element
		.addClass( 'oo-ui-tabPanelLayout' )
		.attr( 'role', 'tabpanel' );
};

/* Setup */

OO.inheritClass( OO.ui.TabPanelLayout, OO.ui.PanelLayout );

/* Events */

/**
 * An 'active' event is emitted when the tab panel becomes active. Tab panels become active when they are
 * shown in a index layout that is configured to display only one tab panel at a time.
 *
 * @event active
 * @param {boolean} active Tab panel is active
 */

/* Methods */

/**
 * Get the symbolic name of the tab panel.
 *
 * @return {string} Symbolic name of tab panel
 */
OO.ui.TabPanelLayout.prototype.getName = function () {
	return this.name;
};

/**
 * Check if tab panel is active.
 *
 * Tab panels become active when they are shown in a {@link OO.ui.IndexLayout index layout} that is configured to
 * display only one tab panel at a time. Additional CSS is applied to the tab panel's tab item to reflect the
 * active state.
 *
 * @return {boolean} Tab panel is active
 */
OO.ui.TabPanelLayout.prototype.isActive = function () {
	return this.active;
};

/**
 * Get tab item.
 *
 * The tab item allows users to access the tab panel from the index's tab
 * navigation. The tab item itself can be customized (with a label, level, etc.) using the #setupTabItem method.
 *
 * @return {OO.ui.TabOptionWidget|null} Tab option widget
 */
OO.ui.TabPanelLayout.prototype.getTabItem = function () {
	return this.tabItem;
};

/**
 * Set or unset the tab item.
 *
 * Specify a {@link OO.ui.TabOptionWidget tab option} to set it,
 * or `null` to clear the tab item. To customize the tab item itself (e.g., to set a label or tab
 * level), use #setupTabItem instead of this method.
 *
 * @param {OO.ui.TabOptionWidget|null} tabItem Tab option widget, null to clear
 * @chainable
 * @return {OO.ui.TabPanelLayout} The layout, for chaining
 */
OO.ui.TabPanelLayout.prototype.setTabItem = function ( tabItem ) {
	this.tabItem = tabItem || null;
	if ( tabItem ) {
		this.setupTabItem();
	}
	return this;
};

/**
 * Set up the tab item.
 *
 * Use this method to customize the tab item (e.g., to add a label or tab level). To set or unset
 * the tab item itself (with a {@link OO.ui.TabOptionWidget tab option} or `null`), use
 * the #setTabItem method instead.
 *
 * @param {OO.ui.TabOptionWidget} tabItem Tab option widget to set up
 * @chainable
 * @return {OO.ui.TabPanelLayout} The layout, for chaining
 */
OO.ui.TabPanelLayout.prototype.setupTabItem = function () {
	this.$element.attr( 'aria-labelledby', this.tabItem.getElementId() );

	this.tabItem.$element.attr( 'aria-controls', this.getElementId() );

	if ( this.label ) {
		this.tabItem.setLabel( this.label );
	}
	return this;
};

/**
 * Set the tab panel to its 'active' state.
 *
 * Tab panels become active when they are shown in a index layout that is configured to display only
 * one tab panel at a time. Additional CSS is applied to the tab item to reflect the tab panel's
 * active state. Outside of the index context, setting the active state on a tab panel does nothing.
 *
 * @param {boolean} active Tab panel is active
 * @fires active
 */
OO.ui.TabPanelLayout.prototype.setActive = function ( active ) {
	active = !!active;

	if ( active !== this.active ) {
		this.active = active;
		this.$element.toggleClass( 'oo-ui-tabPanelLayout-active', this.active );
		this.emit( 'active', this.active );
	}
};

/**
 * PageLayouts are used within {@link OO.ui.BookletLayout booklet layouts} to create pages that users can select and display
 * from the booklet's optional {@link OO.ui.OutlineSelectWidget outline} navigation. Pages are usually not instantiated directly,
 * rather extended to include the required content and functionality.
 *
 * Each page must have a unique symbolic name, which is passed to the constructor. In addition, the page's outline
 * item is customized (with a label, outline level, etc.) using the #setupOutlineItem method. See
 * {@link OO.ui.BookletLayout BookletLayout} for an example.
 *
 * @class
 * @extends OO.ui.PanelLayout
 *
 * @constructor
 * @param {string} name Unique symbolic name of page
 * @param {Object} [config] Configuration options
 */
OO.ui.PageLayout = function OoUiPageLayout( name, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( name ) && config === undefined ) {
		config = name;
		name = config.name;
	}

	// Configuration initialization
	config = $.extend( { scrollable: true }, config );

	// Parent constructor
	OO.ui.PageLayout.parent.call( this, config );

	// Properties
	this.name = name;
	this.outlineItem = null;
	this.active = false;

	// Initialization
	this.$element.addClass( 'oo-ui-pageLayout' );
};

/* Setup */

OO.inheritClass( OO.ui.PageLayout, OO.ui.PanelLayout );

/* Events */

/**
 * An 'active' event is emitted when the page becomes active. Pages become active when they are
 * shown in a booklet layout that is configured to display only one page at a time.
 *
 * @event active
 * @param {boolean} active Page is active
 */

/* Methods */

/**
 * Get the symbolic name of the page.
 *
 * @return {string} Symbolic name of page
 */
OO.ui.PageLayout.prototype.getName = function () {
	return this.name;
};

/**
 * Check if page is active.
 *
 * Pages become active when they are shown in a {@link OO.ui.BookletLayout booklet layout} that is configured to display
 * only one page at a time. Additional CSS is applied to the page's outline item to reflect the active state.
 *
 * @return {boolean} Page is active
 */
OO.ui.PageLayout.prototype.isActive = function () {
	return this.active;
};

/**
 * Get outline item.
 *
 * The outline item allows users to access the page from the booklet's outline
 * navigation. The outline item itself can be customized (with a label, level, etc.) using the #setupOutlineItem method.
 *
 * @return {OO.ui.OutlineOptionWidget|null} Outline option widget
 */
OO.ui.PageLayout.prototype.getOutlineItem = function () {
	return this.outlineItem;
};

/**
 * Set or unset the outline item.
 *
 * Specify an {@link OO.ui.OutlineOptionWidget outline option} to set it,
 * or `null` to clear the outline item. To customize the outline item itself (e.g., to set a label or outline
 * level), use #setupOutlineItem instead of this method.
 *
 * @param {OO.ui.OutlineOptionWidget|null} outlineItem Outline option widget, null to clear
 * @chainable
 * @return {OO.ui.PageLayout} The layout, for chaining
 */
OO.ui.PageLayout.prototype.setOutlineItem = function ( outlineItem ) {
	this.outlineItem = outlineItem || null;
	if ( outlineItem ) {
		this.setupOutlineItem();
	}
	return this;
};

/**
 * Set up the outline item.
 *
 * Use this method to customize the outline item (e.g., to add a label or outline level). To set or unset
 * the outline item itself (with an {@link OO.ui.OutlineOptionWidget outline option} or `null`), use
 * the #setOutlineItem method instead.
 *
 * @param {OO.ui.OutlineOptionWidget} outlineItem Outline option widget to set up
 * @chainable
 * @return {OO.ui.PageLayout} The layout, for chaining
 */
OO.ui.PageLayout.prototype.setupOutlineItem = function () {
	return this;
};

/**
 * Set the page to its 'active' state.
 *
 * Pages become active when they are shown in a booklet layout that is configured to display only one page at a time. Additional
 * CSS is applied to the outline item to reflect the page's active state. Outside of the booklet
 * context, setting the active state on a page does nothing.
 *
 * @param {boolean} active Page is active
 * @fires active
 */
OO.ui.PageLayout.prototype.setActive = function ( active ) {
	active = !!active;

	if ( active !== this.active ) {
		this.active = active;
		this.$element.toggleClass( 'oo-ui-pageLayout-active', active );
		this.emit( 'active', this.active );
	}
};

/**
 * StackLayouts contain a series of {@link OO.ui.PanelLayout panel layouts}. By default, only one panel is displayed
 * at a time, though the stack layout can also be configured to show all contained panels, one after another,
 * by setting the #continuous option to 'true'.
 *
 *     @example
 *     // A stack layout with two panels, configured to be displayed continuously
 *     var myStack = new OO.ui.StackLayout( {
 *         items: [
 *             new OO.ui.PanelLayout( {
 *                 $content: $( '<p>Panel One</p>' ),
 *                 padded: true,
 *                 framed: true
 *             } ),
 *             new OO.ui.PanelLayout( {
 *                 $content: $( '<p>Panel Two</p>' ),
 *                 padded: true,
 *                 framed: true
 *             } )
 *         ],
 *         continuous: true
 *     } );
 *     $( document.body ).append( myStack.$element );
 *
 * @class
 * @extends OO.ui.PanelLayout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [continuous=false] Show all panels, one after another. By default, only one panel is displayed at a time.
 * @cfg {OO.ui.Layout[]} [items] Panel layouts to add to the stack layout.
 */
OO.ui.StackLayout = function OoUiStackLayout( config ) {
	// Configuration initialization
	// Make the layout scrollable in continuous mode, otherwise each
	// panel is responsible for its own scrolling.
	config = $.extend( { scrollable: !!( config && config.continuous ) }, config );

	// Parent constructor
	OO.ui.StackLayout.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, $.extend( {}, config, { $group: this.$element } ) );

	// Properties
	this.currentItem = null;
	this.continuous = !!config.continuous;

	// Initialization
	this.$element.addClass( 'oo-ui-stackLayout' );
	if ( this.continuous ) {
		this.$element.addClass( 'oo-ui-stackLayout-continuous' );
		this.$element.on( 'scroll', OO.ui.debounce( this.onScroll.bind( this ), 250 ) );
	}
	if ( Array.isArray( config.items ) ) {
		this.addItems( config.items );
	}
};

/* Setup */

OO.inheritClass( OO.ui.StackLayout, OO.ui.PanelLayout );
OO.mixinClass( OO.ui.StackLayout, OO.ui.mixin.GroupElement );

/* Events */

/**
 * A 'set' event is emitted when panels are {@link #addItems added}, {@link #removeItems removed},
 * {@link #clearItems cleared} or {@link #setItem displayed}.
 *
 * @event set
 * @param {OO.ui.Layout|null} item Current panel or `null` if no panel is shown
 */

/**
 * When used in continuous mode, this event is emitted when the user scrolls down
 * far enough such that currentItem is no longer visible.
 *
 * @event visibleItemChange
 * @param {OO.ui.PanelLayout} panel The next visible item in the layout
 */

/* Methods */

/**
 * Handle scroll events from the layout element
 *
 * @param {jQuery.Event} e
 * @fires visibleItemChange
 */
OO.ui.StackLayout.prototype.onScroll = function () {
	var currentRect,
		len = this.items.length,
		currentIndex = this.items.indexOf( this.currentItem ),
		newIndex = currentIndex,
		containerRect = this.$element[ 0 ].getBoundingClientRect();

	if ( !containerRect || ( !containerRect.top && !containerRect.bottom ) ) {
		// Can't get bounding rect, possibly not attached.
		return;
	}

	function getRect( item ) {
		return item.$element[ 0 ].getBoundingClientRect();
	}

	function isVisible( item ) {
		var rect = getRect( item );
		return rect.bottom > containerRect.top && rect.top < containerRect.bottom;
	}

	currentRect = getRect( this.currentItem );

	if ( currentRect.bottom < containerRect.top ) {
		// Scrolled down past current item
		while ( ++newIndex < len ) {
			if ( isVisible( this.items[ newIndex ] ) ) {
				break;
			}
		}
	} else if ( currentRect.top > containerRect.bottom ) {
		// Scrolled up past current item
		while ( --newIndex >= 0 ) {
			if ( isVisible( this.items[ newIndex ] ) ) {
				break;
			}
		}
	}

	if ( newIndex !== currentIndex ) {
		this.emit( 'visibleItemChange', this.items[ newIndex ] );
	}
};

/**
 * Get the current panel.
 *
 * @return {OO.ui.Layout|null}
 */
OO.ui.StackLayout.prototype.getCurrentItem = function () {
	return this.currentItem;
};

/**
 * Unset the current item.
 *
 * @private
 * @param {OO.ui.StackLayout} layout
 * @fires set
 */
OO.ui.StackLayout.prototype.unsetCurrentItem = function () {
	var prevItem = this.currentItem;
	if ( prevItem === null ) {
		return;
	}

	this.currentItem = null;
	this.emit( 'set', null );
};

/**
 * Add panel layouts to the stack layout.
 *
 * Panels will be added to the end of the stack layout array unless the optional index parameter specifies a different
 * insertion point. Adding a panel that is already in the stack will move it to the end of the array or the point specified
 * by the index.
 *
 * @param {OO.ui.Layout[]} items Panels to add
 * @param {number} [index] Index of the insertion point
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 */
OO.ui.StackLayout.prototype.addItems = function ( items, index ) {
	// Update the visibility
	this.updateHiddenState( items, this.currentItem );

	// Mixin method
	OO.ui.mixin.GroupElement.prototype.addItems.call( this, items, index );

	if ( !this.currentItem && items.length ) {
		this.setItem( items[ 0 ] );
	}

	return this;
};

/**
 * Remove the specified panels from the stack layout.
 *
 * Removed panels are detached from the DOM, not removed, so that they may be reused. To remove all panels,
 * you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.Layout[]} items Panels to remove
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.removeItems = function ( items ) {
	// Mixin method
	OO.ui.mixin.GroupElement.prototype.removeItems.call( this, items );

	if ( items.indexOf( this.currentItem ) !== -1 ) {
		if ( this.items.length ) {
			this.setItem( this.items[ 0 ] );
		} else {
			this.unsetCurrentItem();
		}
	}

	return this;
};

/**
 * Clear all panels from the stack layout.
 *
 * Cleared panels are detached from the DOM, not removed, so that they may be reused. To remove only
 * a subset of panels, use the #removeItems method.
 *
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.clearItems = function () {
	this.unsetCurrentItem();
	OO.ui.mixin.GroupElement.prototype.clearItems.call( this );

	return this;
};

/**
 * Show the specified panel.
 *
 * If another panel is currently displayed, it will be hidden.
 *
 * @param {OO.ui.Layout} item Panel to show
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.setItem = function ( item ) {
	if ( item !== this.currentItem ) {
		this.updateHiddenState( this.items, item );

		if ( this.items.indexOf( item ) !== -1 ) {
			this.currentItem = item;
			this.emit( 'set', item );
		} else {
			this.unsetCurrentItem();
		}
	}

	return this;
};

/**
 * Reset the scroll offset of all panels, or the container if continuous
 *
 * @inheritdoc
 */
OO.ui.StackLayout.prototype.resetScroll = function () {
	if ( this.continuous ) {
		// Parent method
		return OO.ui.StackLayout.parent.prototype.resetScroll.call( this );
	}
	// Reset each panel
	this.getItems().forEach( function ( panel ) {
		var hidden = panel.$element.hasClass( 'oo-ui-element-hidden' );
		// Scroll can only be reset when panel is visible
		panel.$element.removeClass( 'oo-ui-element-hidden' );
		panel.resetScroll();
		if ( hidden ) {
			panel.$element.addClass( 'oo-ui-element-hidden' );
		}
	} );

	return this;
};

/**
 * Update the visibility of all items in case of non-continuous view.
 *
 * Ensure all items are hidden except for the selected one.
 * This method does nothing when the stack is continuous.
 *
 * @private
 * @param {OO.ui.Layout[]} items Item list iterate over
 * @param {OO.ui.Layout} [selectedItem] Selected item to show
 */
OO.ui.StackLayout.prototype.updateHiddenState = function ( items, selectedItem ) {
	var i, len;

	if ( !this.continuous ) {
		for ( i = 0, len = items.length; i < len; i++ ) {
			if ( !selectedItem || selectedItem !== items[ i ] ) {
				items[ i ].$element.addClass( 'oo-ui-element-hidden' );
				items[ i ].$element.attr( 'aria-hidden', 'true' );
			}
		}
		if ( selectedItem ) {
			selectedItem.$element.removeClass( 'oo-ui-element-hidden' );
			selectedItem.$element.removeAttr( 'aria-hidden' );
		}
	}
};

/**
 * MenuLayouts combine a menu and a content {@link OO.ui.PanelLayout panel}. The menu is positioned relative to the content (after, before, top, or bottom)
 * and its size is customized with the #menuSize config. The content area will fill all remaining space.
 *
 *     @example
 *     var menuLayout,
 *         menuPanel = new OO.ui.PanelLayout( { padded: true, expanded: true, scrollable: true } ),
 *         contentPanel = new OO.ui.PanelLayout( { padded: true, expanded: true, scrollable: true } ),
 *         select = new OO.ui.SelectWidget( {
 *             items: [
 *                 new OO.ui.OptionWidget( {
 *                     data: 'before',
 *                     label: 'Before'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'after',
 *                     label: 'After'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'top',
 *                     label: 'Top'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'bottom',
 *                     label: 'Bottom'
 *                 } )
 *              ]
 *         } ).on( 'select', function ( item ) {
 *            menuLayout.setMenuPosition( item.getData() );
 *         } );
 *
 *     menuLayout = new OO.ui.MenuLayout( {
 *         position: 'top',
 *         menuPanel: menuPanel,
 *         contentPanel: contentPanel
 *     } )
 *     menuLayout.$menu.append(
 *         menuPanel.$element.append( '<b>Menu panel</b>', select.$element )
 *     );
 *     menuLayout.$content.append(
 *         contentPanel.$element.append( '<b>Content panel</b>', '<p>Note that the menu is positioned relative to the content panel: top, bottom, after, before.</p>')
 *     );
 *     $( document.body ).append( menuLayout.$element );
 *
 * If menu size needs to be overridden, it can be accomplished using CSS similar to the snippet
 * below. MenuLayout's CSS will override the appropriate values with 'auto' or '0' to display the
 * menu correctly. If `menuPosition` is known beforehand, CSS rules corresponding to other positions
 * may be omitted.
 *
 *     .oo-ui-menuLayout-menu {
 *         width: 200px;
 *         height: 200px;
 *     }
 *
 *     .oo-ui-menuLayout-content {
 *         top: 200px;
 *         left: 200px;
 *         right: 200px;
 *         bottom: 200px;
 *     }
 *
 * @class
 * @extends OO.ui.Layout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.PanelLayout} [menuPanel] Menu panel
 * @cfg {OO.ui.PanelLayout} [contentPanel] Content panel
 * @cfg {boolean} [expanded=true] Expand the layout to fill the entire parent element.
 * @cfg {boolean} [showMenu=true] Show menu
 * @cfg {string} [menuPosition='before'] Position of menu: `top`, `after`, `bottom` or `before`
 */
OO.ui.MenuLayout = function OoUiMenuLayout( config ) {
	// Configuration initialization
	config = $.extend( {
		expanded: true,
		showMenu: true,
		menuPosition: 'before'
	}, config );

	// Parent constructor
	OO.ui.MenuLayout.parent.call( this, config );

	this.menuPanel = null;
	this.contentPanel = null;
	this.expanded = !!config.expanded;
	/**
	 * Menu DOM node
	 *
	 * @property {jQuery}
	 */
	this.$menu = $( '<div>' );
	/**
	 * Content DOM node
	 *
	 * @property {jQuery}
	 */
	this.$content = $( '<div>' );

	// Initialization
	this.$menu
		.addClass( 'oo-ui-menuLayout-menu' );
	this.$content.addClass( 'oo-ui-menuLayout-content' );
	this.$element
		.addClass( 'oo-ui-menuLayout' );
	if ( config.expanded ) {
		this.$element.addClass( 'oo-ui-menuLayout-expanded' );
	} else {
		this.$element.addClass( 'oo-ui-menuLayout-static' );
	}
	if ( config.menuPanel ) {
		this.setMenuPanel( config.menuPanel );
	}
	if ( config.contentPanel ) {
		this.setContentPanel( config.contentPanel );
	}
	this.setMenuPosition( config.menuPosition );
	this.toggleMenu( config.showMenu );
};

/* Setup */

OO.inheritClass( OO.ui.MenuLayout, OO.ui.Layout );

/* Methods */

/**
 * Toggle menu.
 *
 * @param {boolean} showMenu Show menu, omit to toggle
 * @chainable
 * @return {OO.ui.MenuLayout} The layout, for chaining
 */
OO.ui.MenuLayout.prototype.toggleMenu = function ( showMenu ) {
	showMenu = showMenu === undefined ? !this.showMenu : !!showMenu;

	if ( this.showMenu !== showMenu ) {
		this.showMenu = showMenu;
		this.$element
			.toggleClass( 'oo-ui-menuLayout-showMenu', this.showMenu )
			.toggleClass( 'oo-ui-menuLayout-hideMenu', !this.showMenu );
		this.$menu.attr( 'aria-hidden', this.showMenu ? 'false' : 'true' );
	}

	return this;
};

/**
 * Check if menu is visible
 *
 * @return {boolean} Menu is visible
 */
OO.ui.MenuLayout.prototype.isMenuVisible = function () {
	return this.showMenu;
};

/**
 * Set menu position.
 *
 * @param {string} position Position of menu, either `top`, `after`, `bottom` or `before`
 * @throws {Error} If position value is not supported
 * @chainable
 * @return {OO.ui.MenuLayout} The layout, for chaining
 */
OO.ui.MenuLayout.prototype.setMenuPosition = function ( position ) {
	this.$element.removeClass( 'oo-ui-menuLayout-' + this.menuPosition );
	this.menuPosition = position;
	if ( this.menuPosition === 'top' || this.menuPosition === 'before' ) {
		this.$element.append( this.$menu, this.$content );
	} else {
		this.$element.append( this.$content, this.$menu );
	}
	this.$element.addClass( 'oo-ui-menuLayout-' + position );

	return this;
};

/**
 * Get menu position.
 *
 * @return {string} Menu position
 */
OO.ui.MenuLayout.prototype.getMenuPosition = function () {
	return this.menuPosition;
};

/**
 * Set the menu panel.
 *
 * @param {OO.ui.PanelLayout} menuPanel Menu panel
 */
OO.ui.MenuLayout.prototype.setMenuPanel = function ( menuPanel ) {
	this.menuPanel = menuPanel;
	this.$menu.append( this.menuPanel.$element );
};

/**
 * Set the content panel.
 *
 * @param {OO.ui.PanelLayout} contentPanel Content panel
 */
OO.ui.MenuLayout.prototype.setContentPanel = function ( contentPanel ) {
	this.contentPanel = contentPanel;
	this.$content.append( this.contentPanel.$element );
};

/**
 * Clear the menu panel.
 */
OO.ui.MenuLayout.prototype.clearMenuPanel = function () {
	this.menuPanel = null;
	this.$menu.empty();
};

/**
 * Clear the content panel.
 */
OO.ui.MenuLayout.prototype.clearContentPanel = function () {
	this.contentPanel = null;
	this.$content.empty();
};

/**
 * Reset the scroll offset of all panels and the tab select widget
 *
 * @inheritdoc
 */
OO.ui.MenuLayout.prototype.resetScroll = function () {
	if ( this.menuPanel ) {
		this.menuPanel.resetScroll();
	}
	if ( this.contentPanel ) {
		this.contentPanel.resetScroll();
	}

	return this;
};

/**
 * BookletLayouts contain {@link OO.ui.PageLayout page layouts} as well as
 * an {@link OO.ui.OutlineSelectWidget outline} that allows users to easily navigate
 * through the pages and select which one to display. By default, only one page is
 * displayed at a time and the outline is hidden. When a user navigates to a new page,
 * the booklet layout automatically focuses on the first focusable element, unless the
 * default setting is changed. Optionally, booklets can be configured to show
 * {@link OO.ui.OutlineControlsWidget controls} for adding, moving, and removing items.
 *
 *     @example
 *     // Example of a BookletLayout that contains two PageLayouts.
 *
 *     function PageOneLayout( name, config ) {
 *         PageOneLayout.parent.call( this, name, config );
 *         this.$element.append( '<p>First page</p><p>(This booklet has an outline, displayed on the left)</p>' );
 *     }
 *     OO.inheritClass( PageOneLayout, OO.ui.PageLayout );
 *     PageOneLayout.prototype.setupOutlineItem = function () {
 *         this.outlineItem.setLabel( 'Page One' );
 *     };
 *
 *     function PageTwoLayout( name, config ) {
 *         PageTwoLayout.parent.call( this, name, config );
 *         this.$element.append( '<p>Second page</p>' );
 *     }
 *     OO.inheritClass( PageTwoLayout, OO.ui.PageLayout );
 *     PageTwoLayout.prototype.setupOutlineItem = function () {
 *         this.outlineItem.setLabel( 'Page Two' );
 *     };
 *
 *     var page1 = new PageOneLayout( 'one' ),
 *         page2 = new PageTwoLayout( 'two' );
 *
 *     var booklet = new OO.ui.BookletLayout( {
 *         outlined: true
 *     } );
 *
 *     booklet.addPages( [ page1, page2 ] );
 *     $( document.body ).append( booklet.$element );
 *
 * @class
 * @extends OO.ui.MenuLayout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [continuous=false] Show all pages, one after another
 * @cfg {boolean} [autoFocus=true] Focus on the first focusable element when a new page is displayed. Disabled on mobile.
 * @cfg {boolean} [outlined=false] Show the outline. The outline is used to navigate through the pages of the booklet.
 * @cfg {boolean} [editable=false] Show controls for adding, removing and reordering pages
 */
OO.ui.BookletLayout = function OoUiBookletLayout( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.BookletLayout.parent.call( this, config );

	// Properties
	this.currentPageName = null;
	this.pages = {};
	this.ignoreFocus = false;
	this.stackLayout = new OO.ui.StackLayout( {
		continuous: !!config.continuous,
		expanded: this.expanded
	} );
	this.setContentPanel( this.stackLayout );
	this.autoFocus = config.autoFocus === undefined || !!config.autoFocus;
	this.outlineVisible = false;
	this.outlined = !!config.outlined;
	if ( this.outlined ) {
		this.editable = !!config.editable;
		this.outlineControlsWidget = null;
		this.outlineSelectWidget = new OO.ui.OutlineSelectWidget();
		this.outlinePanel = new OO.ui.PanelLayout( {
			expanded: this.expanded,
			scrollable: true
		} );
		this.setMenuPanel( this.outlinePanel );
		this.outlineVisible = true;
		if ( this.editable ) {
			this.outlineControlsWidget = new OO.ui.OutlineControlsWidget(
				this.outlineSelectWidget
			);
		}
	}
	this.toggleMenu( this.outlined );

	// Events
	this.stackLayout.connect( this, { set: 'onStackLayoutSet' } );
	if ( this.outlined ) {
		this.outlineSelectWidget.connect( this, { select: 'onOutlineSelectWidgetSelect' } );
		this.scrolling = false;
		this.stackLayout.connect( this, { visibleItemChange: 'onStackLayoutVisibleItemChange' } );
	}
	if ( this.autoFocus ) {
		// Event 'focus' does not bubble, but 'focusin' does
		this.stackLayout.$element.on( 'focusin', this.onStackLayoutFocus.bind( this ) );
	}

	// Initialization
	this.$element.addClass( 'oo-ui-bookletLayout' );
	this.stackLayout.$element.addClass( 'oo-ui-bookletLayout-stackLayout' );
	if ( this.outlined ) {
		this.outlinePanel.$element
			.addClass( 'oo-ui-bookletLayout-outlinePanel' )
			.append( this.outlineSelectWidget.$element );
		if ( this.editable ) {
			this.outlinePanel.$element
				.addClass( 'oo-ui-bookletLayout-outlinePanel-editable' )
				.append( this.outlineControlsWidget.$element );
		}
	}
};

/* Setup */

OO.inheritClass( OO.ui.BookletLayout, OO.ui.MenuLayout );

/* Events */

/**
 * A 'set' event is emitted when a page is {@link #setPage set} to be displayed by the booklet layout.
 * @event set
 * @param {OO.ui.PageLayout} page Current page
 */

/**
 * An 'add' event is emitted when pages are {@link #addPages added} to the booklet layout.
 *
 * @event add
 * @param {OO.ui.PageLayout[]} page Added pages
 * @param {number} index Index pages were added at
 */

/**
 * A 'remove' event is emitted when pages are {@link #clearPages cleared} or
 * {@link #removePages removed} from the booklet.
 *
 * @event remove
 * @param {OO.ui.PageLayout[]} pages Removed pages
 */

/* Methods */

/**
 * Handle stack layout focus.
 *
 * @private
 * @param {jQuery.Event} e Focusin event
 */
OO.ui.BookletLayout.prototype.onStackLayoutFocus = function ( e ) {
	var name, $target;

	// Find the page that an element was focused within
	$target = $( e.target ).closest( '.oo-ui-pageLayout' );
	for ( name in this.pages ) {
		// Check for page match, exclude current page to find only page changes
		if ( this.pages[ name ].$element[ 0 ] === $target[ 0 ] && name !== this.currentPageName ) {
			this.setPage( name );
			break;
		}
	}
};

/**
 * Handle visibleItemChange events from the stackLayout
 *
 * The next visible page is set as the current page by selecting it
 * in the outline
 *
 * @param {OO.ui.PageLayout} page The next visible page in the layout
 */
OO.ui.BookletLayout.prototype.onStackLayoutVisibleItemChange = function ( page ) {
	// Set a flag to so that the resulting call to #onStackLayoutSet doesn't
	// try and scroll the item into view again.
	this.scrolling = true;
	this.outlineSelectWidget.selectItemByData( page.getName() );
	this.scrolling = false;
};

/**
 * Handle stack layout set events.
 *
 * @private
 * @param {OO.ui.PanelLayout|null} page The page panel that is now the current panel
 */
OO.ui.BookletLayout.prototype.onStackLayoutSet = function ( page ) {
	var promise, layout = this;
	// If everything is unselected, do nothing
	if ( !page ) {
		return;
	}
	// For continuous BookletLayouts, scroll the selected page into view first
	if ( this.stackLayout.continuous && !this.scrolling ) {
		promise = page.scrollElementIntoView();
	} else {
		promise = $.Deferred().resolve();
	}
	// Focus the first element on the newly selected panel.
	// Don't focus if the page was set by scrolling.
	if ( this.autoFocus && !OO.ui.isMobile() && !this.scrolling ) {
		promise.done( function () {
			layout.focus();
		} );
	}
};

/**
 * Focus the first input in the current page.
 *
 * If no page is selected, the first selectable page will be selected.
 * If the focus is already in an element on the current page, nothing will happen.
 *
 * @param {number} [itemIndex] A specific item to focus on
 */
OO.ui.BookletLayout.prototype.focus = function ( itemIndex ) {
	var page,
		items = this.stackLayout.getItems();

	if ( itemIndex !== undefined && items[ itemIndex ] ) {
		page = items[ itemIndex ];
	} else {
		page = this.stackLayout.getCurrentItem();
	}

	if ( !page && this.outlined ) {
		this.selectFirstSelectablePage();
		page = this.stackLayout.getCurrentItem();
	}
	if ( !page ) {
		return;
	}
	// Only change the focus if is not already in the current page
	if ( !OO.ui.contains( page.$element[ 0 ], this.getElementDocument().activeElement, true ) ) {
		page.focus();
	}
};

/**
 * Find the first focusable input in the booklet layout and focus
 * on it.
 */
OO.ui.BookletLayout.prototype.focusFirstFocusable = function () {
	OO.ui.findFocusable( this.stackLayout.$element ).focus();
};

/**
 * Handle outline widget select events.
 *
 * @private
 * @param {OO.ui.OptionWidget|null} item Selected item
 */
OO.ui.BookletLayout.prototype.onOutlineSelectWidgetSelect = function ( item ) {
	if ( item ) {
		this.setPage( item.getData() );
	}
};

/**
 * Check if booklet has an outline.
 *
 * @return {boolean} Booklet has an outline
 */
OO.ui.BookletLayout.prototype.isOutlined = function () {
	return this.outlined;
};

/**
 * Check if booklet has editing controls.
 *
 * @return {boolean} Booklet is editable
 */
OO.ui.BookletLayout.prototype.isEditable = function () {
	return this.editable;
};

/**
 * Check if booklet has a visible outline.
 *
 * @return {boolean} Outline is visible
 */
OO.ui.BookletLayout.prototype.isOutlineVisible = function () {
	return this.outlined && this.outlineVisible;
};

/**
 * Hide or show the outline.
 *
 * @param {boolean} [show] Show outline, omit to invert current state
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.toggleOutline = function ( show ) {
	var booklet = this;

	if ( this.outlined ) {
		show = show === undefined ? !this.outlineVisible : !!show;
		this.outlineVisible = show;
		this.toggleMenu( show );
		if ( show && this.editable ) {
			// HACK: Kill dumb scrollbars when the sidebar stops animating, see T161798. Only necessary when
			// outline controls are present, delay matches transition on `.oo-ui-menuLayout-menu`.
			setTimeout( function () {
				OO.ui.Element.static.reconsiderScrollbars( booklet.outlinePanel.$element[ 0 ] );
			}, OO.ui.theme.getDialogTransitionDuration() );
		}
	}

	return this;
};

/**
 * Find the page closest to the specified page.
 *
 * @param {OO.ui.PageLayout} page Page to use as a reference point
 * @return {OO.ui.PageLayout|null} Page closest to the specified page
 */
OO.ui.BookletLayout.prototype.findClosestPage = function ( page ) {
	var next, prev, level,
		pages = this.stackLayout.getItems(),
		index = pages.indexOf( page );

	if ( index !== -1 ) {
		next = pages[ index + 1 ];
		prev = pages[ index - 1 ];
		// Prefer adjacent pages at the same level
		if ( this.outlined ) {
			level = this.outlineSelectWidget.findItemFromData( page.getName() ).getLevel();
			if (
				prev &&
				level === this.outlineSelectWidget.findItemFromData( prev.getName() ).getLevel()
			) {
				return prev;
			}
			if (
				next &&
				level === this.outlineSelectWidget.findItemFromData( next.getName() ).getLevel()
			) {
				return next;
			}
		}
	}
	return prev || next || null;
};

/**
 * Get the outline widget.
 *
 * If the booklet is not outlined, the method will return `null`.
 *
 * @return {OO.ui.OutlineSelectWidget|null} Outline widget, or null if the booklet is not outlined
 */
OO.ui.BookletLayout.prototype.getOutline = function () {
	return this.outlineSelectWidget;
};

/**
 * Get the outline controls widget.
 *
 * If the outline is not editable, the method will return `null`.
 *
 * @return {OO.ui.OutlineControlsWidget|null} The outline controls widget.
 */
OO.ui.BookletLayout.prototype.getOutlineControls = function () {
	return this.outlineControlsWidget;
};

/**
 * Get a page by its symbolic name.
 *
 * @param {string} name Symbolic name of page
 * @return {OO.ui.PageLayout|undefined} Page, if found
 */
OO.ui.BookletLayout.prototype.getPage = function ( name ) {
	return this.pages[ name ];
};

/**
 * Get the current page.
 *
 * @return {OO.ui.PageLayout|undefined} Current page, if found
 */
OO.ui.BookletLayout.prototype.getCurrentPage = function () {
	var name = this.getCurrentPageName();
	return name ? this.getPage( name ) : undefined;
};

/**
 * Get the symbolic name of the current page.
 *
 * @return {string|null} Symbolic name of the current page
 */
OO.ui.BookletLayout.prototype.getCurrentPageName = function () {
	return this.currentPageName;
};

/**
 * Add pages to the booklet layout
 *
 * When pages are added with the same names as existing pages, the existing pages will be
 * automatically removed before the new pages are added.
 *
 * @param {OO.ui.PageLayout[]} pages Pages to add
 * @param {number} index Index of the insertion point
 * @fires add
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.addPages = function ( pages, index ) {
	var i, len, name, page, item, currentIndex,
		stackLayoutPages = this.stackLayout.getItems(),
		remove = [],
		items = [];

	// Remove pages with same names
	for ( i = 0, len = pages.length; i < len; i++ ) {
		page = pages[ i ];
		name = page.getName();

		if ( Object.prototype.hasOwnProperty.call( this.pages, name ) ) {
			// Correct the insertion index
			currentIndex = stackLayoutPages.indexOf( this.pages[ name ] );
			if ( currentIndex !== -1 && currentIndex + 1 < index ) {
				index--;
			}
			remove.push( this.pages[ name ] );
		}
	}
	if ( remove.length ) {
		this.removePages( remove );
	}

	// Add new pages
	for ( i = 0, len = pages.length; i < len; i++ ) {
		page = pages[ i ];
		name = page.getName();
		this.pages[ page.getName() ] = page;
		if ( this.outlined ) {
			item = new OO.ui.OutlineOptionWidget( { data: name } );
			page.setOutlineItem( item );
			items.push( item );
		}
	}

	if ( this.outlined && items.length ) {
		this.outlineSelectWidget.addItems( items, index );
		this.selectFirstSelectablePage();
	}
	this.stackLayout.addItems( pages, index );
	this.emit( 'add', pages, index );

	return this;
};

/**
 * Remove the specified pages from the booklet layout.
 *
 * To remove all pages from the booklet, you may wish to use the #clearPages method instead.
 *
 * @param {OO.ui.PageLayout[]} pages An array of pages to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.removePages = function ( pages ) {
	var i, len, name, page,
		items = [];

	for ( i = 0, len = pages.length; i < len; i++ ) {
		page = pages[ i ];
		name = page.getName();
		delete this.pages[ name ];
		if ( this.outlined ) {
			items.push( this.outlineSelectWidget.findItemFromData( name ) );
			page.setOutlineItem( null );
		}
	}
	if ( this.outlined && items.length ) {
		this.outlineSelectWidget.removeItems( items );
		this.selectFirstSelectablePage();
	}
	this.stackLayout.removeItems( pages );
	this.emit( 'remove', pages );

	return this;
};

/**
 * Clear all pages from the booklet layout.
 *
 * To remove only a subset of pages from the booklet, use the #removePages method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.clearPages = function () {
	var i, len,
		pages = this.stackLayout.getItems();

	this.pages = {};
	this.currentPageName = null;
	if ( this.outlined ) {
		this.outlineSelectWidget.clearItems();
		for ( i = 0, len = pages.length; i < len; i++ ) {
			pages[ i ].setOutlineItem( null );
		}
	}
	this.stackLayout.clearItems();

	this.emit( 'remove', pages );

	return this;
};

/**
 * Set the current page by symbolic name.
 *
 * @fires set
 * @param {string} name Symbolic name of page
 */
OO.ui.BookletLayout.prototype.setPage = function ( name ) {
	var selectedItem,
		$focused,
		page = this.pages[ name ],
		previousPage = this.currentPageName && this.pages[ this.currentPageName ];

	if ( name !== this.currentPageName ) {
		if ( this.outlined ) {
			selectedItem = this.outlineSelectWidget.findSelectedItem();
			if ( selectedItem && selectedItem.getData() !== name ) {
				this.outlineSelectWidget.selectItemByData( name );
			}
		}
		if ( page ) {
			if ( previousPage ) {
				previousPage.setActive( false );
				// Blur anything focused if the next page doesn't have anything focusable.
				// This is not needed if the next page has something focusable (because once it is focused
				// this blur happens automatically). If the layout is non-continuous, this check is
				// meaningless because the next page is not visible yet and thus can't hold focus.
				if (
					this.autoFocus &&
					!OO.ui.isMobile() &&
					this.stackLayout.continuous &&
					OO.ui.findFocusable( page.$element ).length !== 0
				) {
					$focused = previousPage.$element.find( ':focus' );
					if ( $focused.length ) {
						// eslint-disable-next-line jquery/no-event-shorthand
						$focused[ 0 ].blur();
					}
				}
			}
			this.currentPageName = name;
			page.setActive( true );
			this.stackLayout.setItem( page );
			if ( !this.stackLayout.continuous && previousPage ) {
				// This should not be necessary, since any inputs on the previous page should have been
				// blurred when it was hidden, but browsers are not very consistent about this.
				$focused = previousPage.$element.find( ':focus' );
				if ( $focused.length ) {
					// eslint-disable-next-line jquery/no-event-shorthand
					$focused[ 0 ].blur();
				}
			}
			this.emit( 'set', page );
		}
	}
};

/**
 * For outlined-continuous booklets, also reset the outlineSelectWidget to the first item.
 *
 * @inheritdoc
 */
OO.ui.BookletLayout.prototype.resetScroll = function () {
	// Parent method
	OO.ui.BookletLayout.parent.prototype.resetScroll.call( this );

	if ( this.outlined && this.stackLayout.continuous && this.outlineSelectWidget.findFirstSelectableItem() ) {
		this.scrolling = true;
		this.outlineSelectWidget.selectItem( this.outlineSelectWidget.findFirstSelectableItem() );
		this.scrolling = false;
	}
	return this;
};

/**
 * Select the first selectable page.
 *
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.selectFirstSelectablePage = function () {
	if ( !this.outlineSelectWidget.findSelectedItem() ) {
		this.outlineSelectWidget.selectItem( this.outlineSelectWidget.findFirstSelectableItem() );
	}

	return this;
};

/**
 * IndexLayouts contain {@link OO.ui.TabPanelLayout tab panel layouts} as well as
 * {@link OO.ui.TabSelectWidget tabs} that allow users to easily navigate through the tab panels and
 * select which one to display. By default, only one tab panel is displayed at a time. When a user
 * navigates to a new tab panel, the index layout automatically focuses on the first focusable element,
 * unless the default setting is changed.
 *
 * TODO: This class is similar to BookletLayout, we may want to refactor to reduce duplication
 *
 *     @example
 *     // Example of a IndexLayout that contains two TabPanelLayouts.
 *
 *     function TabPanelOneLayout( name, config ) {
 *         TabPanelOneLayout.parent.call( this, name, config );
 *         this.$element.append( '<p>First tab panel</p>' );
 *     }
 *     OO.inheritClass( TabPanelOneLayout, OO.ui.TabPanelLayout );
 *     TabPanelOneLayout.prototype.setupTabItem = function () {
 *         this.tabItem.setLabel( 'Tab panel one' );
 *     };
 *
 *     var tabPanel1 = new TabPanelOneLayout( 'one' ),
 *         tabPanel2 = new OO.ui.TabPanelLayout( 'two', { label: 'Tab panel two' } );
 *
 *     tabPanel2.$element.append( '<p>Second tab panel</p>' );
 *
 *     var index = new OO.ui.IndexLayout();
 *
 *     index.addTabPanels( [ tabPanel1, tabPanel2 ] );
 *     $( document.body ).append( index.$element );
 *
 * @class
 * @extends OO.ui.MenuLayout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [continuous=false] Show all tab panels, one after another
 * @cfg {boolean} [autoFocus=true] Focus on the first focusable element when a new tab panel is displayed. Disabled on mobile.
 */
OO.ui.IndexLayout = function OoUiIndexLayout( config ) {
	// Configuration initialization
	config = $.extend( {}, config, { menuPosition: 'top' } );

	// Parent constructor
	OO.ui.IndexLayout.parent.call( this, config );

	// Properties
	this.currentTabPanelName = null;
	this.tabPanels = {};

	this.ignoreFocus = false;
	this.stackLayout = new OO.ui.StackLayout( {
		continuous: !!config.continuous,
		expanded: this.expanded
	} );
	this.setContentPanel( this.stackLayout );
	this.autoFocus = config.autoFocus === undefined || !!config.autoFocus;

	this.tabSelectWidget = new OO.ui.TabSelectWidget();
	this.tabPanel = new OO.ui.PanelLayout( {
		expanded: this.expanded
	} );
	this.setMenuPanel( this.tabPanel );

	this.toggleMenu( true );

	// Events
	this.stackLayout.connect( this, { set: 'onStackLayoutSet' } );
	this.tabSelectWidget.connect( this, { select: 'onTabSelectWidgetSelect' } );
	if ( this.autoFocus ) {
		// Event 'focus' does not bubble, but 'focusin' does
		this.stackLayout.$element.on( 'focusin', this.onStackLayoutFocus.bind( this ) );
	}

	// Initialization
	this.$element.addClass( 'oo-ui-indexLayout' );
	this.stackLayout.$element.addClass( 'oo-ui-indexLayout-stackLayout' );
	this.tabPanel.$element
		.addClass( 'oo-ui-indexLayout-tabPanel' )
		.append( this.tabSelectWidget.$element );
};

/* Setup */

OO.inheritClass( OO.ui.IndexLayout, OO.ui.MenuLayout );

/* Events */

/**
 * A 'set' event is emitted when a tab panel is {@link #setTabPanel set} to be displayed by the index layout.
 * @event set
 * @param {OO.ui.TabPanelLayout} tabPanel Current tab panel
 */

/**
 * An 'add' event is emitted when tab panels are {@link #addTabPanels added} to the index layout.
 *
 * @event add
 * @param {OO.ui.TabPanelLayout[]} tabPanel Added tab panels
 * @param {number} index Index tab panels were added at
 */

/**
 * A 'remove' event is emitted when tab panels are {@link #clearTabPanels cleared} or
 * {@link #removeTabPanels removed} from the index.
 *
 * @event remove
 * @param {OO.ui.TabPanelLayout[]} tabPanel Removed tab panels
 */

/* Methods */

/**
 * Handle stack layout focus.
 *
 * @private
 * @param {jQuery.Event} e Focusing event
 */
OO.ui.IndexLayout.prototype.onStackLayoutFocus = function ( e ) {
	var name, $target;

	// Find the tab panel that an element was focused within
	$target = $( e.target ).closest( '.oo-ui-tabPanelLayout' );
	for ( name in this.tabPanels ) {
		// Check for tab panel match, exclude current tab panel to find only tab panel changes
		if ( this.tabPanels[ name ].$element[ 0 ] === $target[ 0 ] && name !== this.currentTabPanelName ) {
			this.setTabPanel( name );
			break;
		}
	}
};

/**
 * Handle stack layout set events.
 *
 * @private
 * @param {OO.ui.PanelLayout|null} tabPanel The tab panel that is now the current panel
 */
OO.ui.IndexLayout.prototype.onStackLayoutSet = function ( tabPanel ) {
	// If everything is unselected, do nothing
	if ( !tabPanel ) {
		return;
	}
	// Focus the first element on the newly selected panel
	if ( this.autoFocus && !OO.ui.isMobile() ) {
		this.focus();
	}
};

/**
 * Focus the first input in the current tab panel.
 *
 * If no tab panel is selected, the first selectable tab panel will be selected.
 * If the focus is already in an element on the current tab panel, nothing will happen.
 *
 * @param {number} [itemIndex] A specific item to focus on
 */
OO.ui.IndexLayout.prototype.focus = function ( itemIndex ) {
	var tabPanel,
		items = this.stackLayout.getItems();

	if ( itemIndex !== undefined && items[ itemIndex ] ) {
		tabPanel = items[ itemIndex ];
	} else {
		tabPanel = this.stackLayout.getCurrentItem();
	}

	if ( !tabPanel ) {
		this.selectFirstSelectableTabPanel();
		tabPanel = this.stackLayout.getCurrentItem();
	}
	if ( !tabPanel ) {
		return;
	}
	// Only change the focus if is not already in the current page
	if ( !OO.ui.contains( tabPanel.$element[ 0 ], this.getElementDocument().activeElement, true ) ) {
		tabPanel.focus();
	}
};

/**
 * Find the first focusable input in the index layout and focus
 * on it.
 */
OO.ui.IndexLayout.prototype.focusFirstFocusable = function () {
	OO.ui.findFocusable( this.stackLayout.$element ).focus();
};

/**
 * Handle tab widget select events.
 *
 * @private
 * @param {OO.ui.OptionWidget|null} item Selected item
 */
OO.ui.IndexLayout.prototype.onTabSelectWidgetSelect = function ( item ) {
	if ( item ) {
		this.setTabPanel( item.getData() );
	}
};

/**
 * Get the tab panel closest to the specified tab panel.
 *
 * @param {OO.ui.TabPanelLayout} tabPanel Tab panel to use as a reference point
 * @return {OO.ui.TabPanelLayout|null} Tab panel closest to the specified
 */
OO.ui.IndexLayout.prototype.getClosestTabPanel = function ( tabPanel ) {
	var next, prev, level,
		tabPanels = this.stackLayout.getItems(),
		index = tabPanels.indexOf( tabPanel );

	if ( index !== -1 ) {
		next = tabPanels[ index + 1 ];
		prev = tabPanels[ index - 1 ];
		// Prefer adjacent tab panels at the same level
		level = this.tabSelectWidget.findItemFromData( tabPanel.getName() ).getLevel();
		if (
			prev &&
			level === this.tabSelectWidget.findItemFromData( prev.getName() ).getLevel()
		) {
			return prev;
		}
		if (
			next &&
			level === this.tabSelectWidget.findItemFromData( next.getName() ).getLevel()
		) {
			return next;
		}
	}
	return prev || next || null;
};

/**
 * Get the tabs widget.
 *
 * @return {OO.ui.TabSelectWidget} Tabs widget
 */
OO.ui.IndexLayout.prototype.getTabs = function () {
	return this.tabSelectWidget;
};

/**
 * Get a tab panel by its symbolic name.
 *
 * @param {string} name Symbolic name of tab panel
 * @return {OO.ui.TabPanelLayout|undefined} Tab panel, if found
 */
OO.ui.IndexLayout.prototype.getTabPanel = function ( name ) {
	return this.tabPanels[ name ];
};

/**
 * Get the current tab panel.
 *
 * @return {OO.ui.TabPanelLayout|undefined} Current tab panel, if found
 */
OO.ui.IndexLayout.prototype.getCurrentTabPanel = function () {
	var name = this.getCurrentTabPanelName();
	return name ? this.getTabPanel( name ) : undefined;
};

/**
 * Get the symbolic name of the current tab panel.
 *
 * @return {string|null} Symbolic name of the current tab panel
 */
OO.ui.IndexLayout.prototype.getCurrentTabPanelName = function () {
	return this.currentTabPanelName;
};

/**
 * Add tab panels to the index layout
 *
 * When tab panels are added with the same names as existing tab panels, the existing tab panels
 * will be automatically removed before the new tab panels are added.
 *
 * @param {OO.ui.TabPanelLayout[]} tabPanels Tab panels to add
 * @param {number} index Index of the insertion point
 * @fires add
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.addTabPanels = function ( tabPanels, index ) {
	var i, len, name, tabPanel, item, currentIndex,
		stackLayoutTabPanels = this.stackLayout.getItems(),
		remove = [],
		items = [];

	// Remove tab panels with same names
	for ( i = 0, len = tabPanels.length; i < len; i++ ) {
		tabPanel = tabPanels[ i ];
		name = tabPanel.getName();

		if ( Object.prototype.hasOwnProperty.call( this.tabPanels, name ) ) {
			// Correct the insertion index
			currentIndex = stackLayoutTabPanels.indexOf( this.tabPanels[ name ] );
			if ( currentIndex !== -1 && currentIndex + 1 < index ) {
				index--;
			}
			remove.push( this.tabPanels[ name ] );
		}
	}
	if ( remove.length ) {
		this.removeTabPanels( remove );
	}

	// Add new tab panels
	for ( i = 0, len = tabPanels.length; i < len; i++ ) {
		tabPanel = tabPanels[ i ];
		name = tabPanel.getName();
		this.tabPanels[ tabPanel.getName() ] = tabPanel;
		item = new OO.ui.TabOptionWidget( { data: name } );
		tabPanel.setTabItem( item );
		items.push( item );
	}

	if ( items.length ) {
		this.tabSelectWidget.addItems( items, index );
		this.selectFirstSelectableTabPanel();
	}
	this.stackLayout.addItems( tabPanels, index );
	this.emit( 'add', tabPanels, index );

	return this;
};

/**
 * Remove the specified tab panels from the index layout.
 *
 * To remove all tab panels from the index, you may wish to use the #clearTabPanels method instead.
 *
 * @param {OO.ui.TabPanelLayout[]} tabPanels An array of tab panels to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.removeTabPanels = function ( tabPanels ) {
	var i, len, name, tabPanel,
		items = [];

	for ( i = 0, len = tabPanels.length; i < len; i++ ) {
		tabPanel = tabPanels[ i ];
		name = tabPanel.getName();
		delete this.tabPanels[ name ];
		items.push( this.tabSelectWidget.findItemFromData( name ) );
		tabPanel.setTabItem( null );
	}
	if ( items.length ) {
		this.tabSelectWidget.removeItems( items );
		this.selectFirstSelectableTabPanel();
	}
	this.stackLayout.removeItems( tabPanels );
	this.emit( 'remove', tabPanels );

	return this;
};

/**
 * Clear all tab panels from the index layout.
 *
 * To remove only a subset of tab panels from the index, use the #removeTabPanels method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.clearTabPanels = function () {
	var i, len,
		tabPanels = this.stackLayout.getItems();

	this.tabPanels = {};
	this.currentTabPanelName = null;
	this.tabSelectWidget.clearItems();
	for ( i = 0, len = tabPanels.length; i < len; i++ ) {
		tabPanels[ i ].setTabItem( null );
	}
	this.stackLayout.clearItems();

	this.emit( 'remove', tabPanels );

	return this;
};

/**
 * Set the current tab panel by symbolic name.
 *
 * @fires set
 * @param {string} name Symbolic name of tab panel
 */
OO.ui.IndexLayout.prototype.setTabPanel = function ( name ) {
	var selectedItem,
		$focused,
		previousTabPanel,
		tabPanel = this.tabPanels[ name ];

	if ( name !== this.currentTabPanelName ) {
		previousTabPanel = this.getCurrentTabPanel();
		selectedItem = this.tabSelectWidget.findSelectedItem();
		if ( selectedItem && selectedItem.getData() !== name ) {
			this.tabSelectWidget.selectItemByData( name );
		}
		if ( tabPanel ) {
			if ( previousTabPanel ) {
				previousTabPanel.setActive( false );
				// Blur anything focused if the next tab panel doesn't have anything focusable.
				// This is not needed if the next tab panel has something focusable (because once it is focused
				// this blur happens automatically). If the layout is non-continuous, this check is
				// meaningless because the next tab panel is not visible yet and thus can't hold focus.
				if (
					this.autoFocus &&
					!OO.ui.isMobile() &&
					this.stackLayout.continuous &&
					OO.ui.findFocusable( tabPanel.$element ).length !== 0
				) {
					$focused = previousTabPanel.$element.find( ':focus' );
					if ( $focused.length ) {
						// eslint-disable-next-line jquery/no-event-shorthand
						$focused[ 0 ].blur();
					}
				}
			}
			this.currentTabPanelName = name;
			tabPanel.setActive( true );
			this.stackLayout.setItem( tabPanel );
			if ( !this.stackLayout.continuous && previousTabPanel ) {
				// This should not be necessary, since any inputs on the previous tab panel should have been
				// blurred when it was hidden, but browsers are not very consistent about this.
				$focused = previousTabPanel.$element.find( ':focus' );
				if ( $focused.length ) {
					// eslint-disable-next-line jquery/no-event-shorthand
					$focused[ 0 ].blur();
				}
			}
			this.emit( 'set', tabPanel );
		}
	}
};

/**
 * Select the first selectable tab panel.
 *
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.selectFirstSelectableTabPanel = function () {
	if ( !this.tabSelectWidget.findSelectedItem() ) {
		this.tabSelectWidget.selectItem( this.tabSelectWidget.findFirstSelectableItem() );
	}

	return this;
};

/**
 * ToggleWidget implements basic behavior of widgets with an on/off state.
 * Please see OO.ui.ToggleButtonWidget and OO.ui.ToggleSwitchWidget for examples.
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle’s initial on/off state.
 *  By default, the toggle is in the 'off' state.
 */
OO.ui.ToggleWidget = function OoUiToggleWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ToggleWidget.parent.call( this, config );

	// Mixin constructor
	OO.ui.mixin.TitledElement.call( this, config );

	// Properties
	this.value = null;

	// Initialization
	this.$element.addClass( 'oo-ui-toggleWidget' );
	this.setValue( !!config.value );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ToggleWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the on/off state of the toggle changes.
 *
 * @param {boolean} value Value representing the new state of the toggle
 */

/* Methods */

/**
 * Get the value representing the toggle’s state.
 *
 * @return {boolean} The on/off state of the toggle
 */
OO.ui.ToggleWidget.prototype.getValue = function () {
	return this.value;
};

/**
 * Set the state of the toggle: `true` for 'on', `false` for 'off'.
 *
 * @param {boolean} value The state of the toggle
 * @fires change
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ToggleWidget.prototype.setValue = function ( value ) {
	value = !!value;
	if ( this.value !== value ) {
		this.value = value;
		this.emit( 'change', value );
		this.$element.toggleClass( 'oo-ui-toggleWidget-on', value );
		this.$element.toggleClass( 'oo-ui-toggleWidget-off', !value );
	}
	return this;
};

/**
 * ToggleButtons are buttons that have a state (‘on’ or ‘off’) that is represented by a
 * Boolean value. Like other {@link OO.ui.ButtonWidget buttons}, toggle buttons can be
 * configured with {@link OO.ui.mixin.IconElement icons}, {@link OO.ui.mixin.IndicatorElement indicators},
 * {@link OO.ui.mixin.TitledElement titles}, {@link OO.ui.mixin.FlaggedElement styling flags},
 * and {@link OO.ui.mixin.LabelElement labels}. Please see
 * the [OOUI documentation][1] on MediaWiki for more information.
 *
 *     @example
 *     // Toggle buttons in the 'off' and 'on' state.
 *     var toggleButton1 = new OO.ui.ToggleButtonWidget( {
 *             label: 'Toggle Button off'
 *         } ),
 *         toggleButton2 = new OO.ui.ToggleButtonWidget( {
 *             label: 'Toggle Button on',
 *             value: true
 *         } );
 *     // Append the buttons to the DOM.
 *     $( document.body ).append( toggleButton1.$element, toggleButton2.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#Toggle_buttons
 *
 * @class
 * @extends OO.ui.ToggleWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle button’s initial on/off
 *  state. By default, the button is in the 'off' state.
 */
OO.ui.ToggleButtonWidget = function OoUiToggleButtonWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ToggleButtonWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ButtonElement.call( this, $.extend( {}, config, { active: this.active } ) );
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$button } ) );

	// Events
	this.connect( this, { click: 'onAction' } );

	// Initialization
	this.$button.append( this.$icon, this.$label, this.$indicator );
	this.$element
		.addClass( 'oo-ui-toggleButtonWidget' )
		.append( this.$button );
	this.setTitledElement( this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleButtonWidget, OO.ui.ToggleWidget );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.TabIndexedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.static.tagName = 'span';

/* Methods */

/**
 * Handle the button action being triggered.
 *
 * @private
 */
OO.ui.ToggleButtonWidget.prototype.onAction = function () {
	this.setValue( !this.value );
};

/**
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.prototype.setValue = function ( value ) {
	value = !!value;
	if ( value !== this.value ) {
		// Might be called from parent constructor before ButtonElement constructor
		if ( this.$button ) {
			this.$button.attr( 'aria-pressed', value.toString() );
		}
		this.setActive( value );
	}

	// Parent method
	OO.ui.ToggleButtonWidget.parent.prototype.setValue.call( this, value );

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.prototype.setButtonElement = function ( $button ) {
	if ( this.$button ) {
		this.$button.removeAttr( 'aria-pressed' );
	}
	OO.ui.mixin.ButtonElement.prototype.setButtonElement.call( this, $button );
	this.$button.attr( 'aria-pressed', this.value.toString() );
};

/**
 * ToggleSwitches are switches that slide on and off. Their state is represented by a Boolean
 * value (`true` for ‘on’, and `false` otherwise, the default). The ‘off’ state is represented
 * visually by a slider in the leftmost position.
 *
 *     @example
 *     // Toggle switches in the 'off' and 'on' position.
 *     var toggleSwitch1 = new OO.ui.ToggleSwitchWidget(),
 *         toggleSwitch2 = new OO.ui.ToggleSwitchWidget( {
 *             value: true
 *         } );
 *         // Create a FieldsetLayout to layout and label switches.
 *         fieldset = new OO.ui.FieldsetLayout( {
 *             label: 'Toggle switches'
 *         } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( toggleSwitch1, {
 *             label: 'Off',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( toggleSwitch2, {
 *             label: 'On',
 *             align: 'top'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.ToggleWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle switch’s initial on/off state.
 *  By default, the toggle switch is in the 'off' position.
 */
OO.ui.ToggleSwitchWidget = function OoUiToggleSwitchWidget( config ) {
	// Parent constructor
	OO.ui.ToggleSwitchWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.TabIndexedElement.call( this, config );

	// Properties
	this.dragging = false;
	this.dragStart = null;
	this.sliding = false;
	this.$glow = $( '<span>' );
	this.$grip = $( '<span>' );

	// Events
	this.$element.on( {
		click: this.onClick.bind( this ),
		keypress: this.onKeyPress.bind( this )
	} );

	// Initialization
	this.$glow.addClass( 'oo-ui-toggleSwitchWidget-glow' );
	this.$grip.addClass( 'oo-ui-toggleSwitchWidget-grip' );
	this.$element
		.addClass( 'oo-ui-toggleSwitchWidget' )
		.attr( 'role', 'checkbox' )
		.append( this.$glow, this.$grip );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleSwitchWidget, OO.ui.ToggleWidget );
OO.mixinClass( OO.ui.ToggleSwitchWidget, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Handle mouse click events.
 *
 * @private
 * @param {jQuery.Event} e Mouse click event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.ToggleSwitchWidget.prototype.onClick = function ( e ) {
	if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
		this.setValue( !this.value );
	}
	return false;
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.ToggleSwitchWidget.prototype.onKeyPress = function ( e ) {
	if ( !this.isDisabled() && ( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER ) ) {
		this.setValue( !this.value );
		return false;
	}
};

/**
 * @inheritdoc
 */
OO.ui.ToggleSwitchWidget.prototype.setValue = function ( value ) {
	OO.ui.ToggleSwitchWidget.parent.prototype.setValue.call( this, value );
	this.$element.attr( 'aria-checked', this.value.toString() );
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.ToggleSwitchWidget.prototype.simulateLabelClick = function () {
	if ( !this.isDisabled() ) {
		this.setValue( !this.value );
	}
	this.focus();
};

/**
 * OutlineControlsWidget is a set of controls for an {@link OO.ui.OutlineSelectWidget outline select widget}.
 * Controls include moving items up and down, removing items, and adding different kinds of items.
 *
 * **Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}.**
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {OO.ui.OutlineSelectWidget} outline Outline to control
 * @param {Object} [config] Configuration options
 * @cfg {Object} [abilities] List of abilties
 * @cfg {boolean} [abilities.move=true] Allow moving movable items
 * @cfg {boolean} [abilities.remove=true] Allow removing removable items
 */
OO.ui.OutlineControlsWidget = function OoUiOutlineControlsWidget( outline, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( outline ) && config === undefined ) {
		config = outline;
		outline = config.outline;
	}

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.OutlineControlsWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, config );

	// Properties
	this.outline = outline;
	this.$movers = $( '<div>' );
	this.upButton = new OO.ui.ButtonWidget( {
		framed: false,
		icon: 'collapse',
		title: OO.ui.msg( 'ooui-outline-control-move-up' )
	} );
	this.downButton = new OO.ui.ButtonWidget( {
		framed: false,
		icon: 'expand',
		title: OO.ui.msg( 'ooui-outline-control-move-down' )
	} );
	this.removeButton = new OO.ui.ButtonWidget( {
		framed: false,
		icon: 'trash',
		title: OO.ui.msg( 'ooui-outline-control-remove' )
	} );
	this.abilities = { move: true, remove: true };

	// Events
	outline.connect( this, {
		select: 'onOutlineChange',
		add: 'onOutlineChange',
		remove: 'onOutlineChange'
	} );
	this.upButton.connect( this, { click: [ 'emit', 'move', -1 ] } );
	this.downButton.connect( this, { click: [ 'emit', 'move', 1 ] } );
	this.removeButton.connect( this, { click: [ 'emit', 'remove' ] } );

	// Initialization
	this.$element.addClass( 'oo-ui-outlineControlsWidget' );
	this.$group.addClass( 'oo-ui-outlineControlsWidget-items' );
	this.$movers
		.addClass( 'oo-ui-outlineControlsWidget-movers' )
		.append( this.removeButton.$element, this.upButton.$element, this.downButton.$element );
	this.$element.append( this.$icon, this.$group, this.$movers );
	this.setAbilities( config.abilities || {} );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineControlsWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.OutlineControlsWidget, OO.ui.mixin.GroupElement );

/* Events */

/**
 * @event move
 * @param {number} places Number of places to move
 */

/**
 * @event remove
 */

/* Methods */

/**
 * Set abilities.
 *
 * @param {Object} abilities List of abilties
 * @param {boolean} [abilities.move] Allow moving movable items
 * @param {boolean} [abilities.remove] Allow removing removable items
 */
OO.ui.OutlineControlsWidget.prototype.setAbilities = function ( abilities ) {
	var ability;

	for ( ability in this.abilities ) {
		if ( abilities[ ability ] !== undefined ) {
			this.abilities[ ability ] = !!abilities[ ability ];
		}
	}

	this.onOutlineChange();
};

/**
 * Handle outline change events.
 *
 * @private
 */
OO.ui.OutlineControlsWidget.prototype.onOutlineChange = function () {
	var i, len, firstMovable, lastMovable,
		items = this.outline.getItems(),
		selectedItem = this.outline.findSelectedItem(),
		movable = this.abilities.move && selectedItem && selectedItem.isMovable(),
		removable = this.abilities.remove && selectedItem && selectedItem.isRemovable();

	if ( movable ) {
		i = -1;
		len = items.length;
		while ( ++i < len ) {
			if ( items[ i ].isMovable() ) {
				firstMovable = items[ i ];
				break;
			}
		}
		i = len;
		while ( i-- ) {
			if ( items[ i ].isMovable() ) {
				lastMovable = items[ i ];
				break;
			}
		}
	}
	this.upButton.setDisabled( !movable || selectedItem === firstMovable );
	this.downButton.setDisabled( !movable || selectedItem === lastMovable );
	this.removeButton.setDisabled( !removable );
};

/**
 * OutlineOptionWidget is an item in an {@link OO.ui.OutlineSelectWidget OutlineSelectWidget}.
 *
 * Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}, which contain
 * {@link OO.ui.PageLayout page layouts}. See {@link OO.ui.BookletLayout BookletLayout}
 * for an example.
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number} [level] Indentation level
 * @cfg {boolean} [movable] Allow modification from {@link OO.ui.OutlineControlsWidget outline controls}.
 */
OO.ui.OutlineOptionWidget = function OoUiOutlineOptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.OutlineOptionWidget.parent.call( this, config );

	// Properties
	this.level = 0;
	this.movable = !!config.movable;
	this.removable = !!config.removable;

	// Initialization
	this.$element.addClass( 'oo-ui-outlineOptionWidget' );
	this.setLevel( config.level );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.static.highlightable = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.OutlineOptionWidget.static.levelClass = 'oo-ui-outlineOptionWidget-level-';

/**
 * @static
 * @inheritable
 * @property {number}
 */
OO.ui.OutlineOptionWidget.static.levels = 3;

/* Methods */

/**
 * Check if item is movable.
 *
 * Movability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @return {boolean} Item is movable
 */
OO.ui.OutlineOptionWidget.prototype.isMovable = function () {
	return this.movable;
};

/**
 * Check if item is removable.
 *
 * Removability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @return {boolean} Item is removable
 */
OO.ui.OutlineOptionWidget.prototype.isRemovable = function () {
	return this.removable;
};

/**
 * Get indentation level.
 *
 * @return {number} Indentation level
 */
OO.ui.OutlineOptionWidget.prototype.getLevel = function () {
	return this.level;
};

/**
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.prototype.setPressed = function ( state ) {
	OO.ui.OutlineOptionWidget.parent.prototype.setPressed.call( this, state );
	return this;
};

/**
 * Set movability.
 *
 * Movability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @param {boolean} movable Item is movable
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setMovable = function ( movable ) {
	this.movable = !!movable;
	this.updateThemeClasses();
	return this;
};

/**
 * Set removability.
 *
 * Removability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @param {boolean} removable Item is removable
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setRemovable = function ( removable ) {
	this.removable = !!removable;
	this.updateThemeClasses();
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.prototype.setSelected = function ( state ) {
	OO.ui.OutlineOptionWidget.parent.prototype.setSelected.call( this, state );
	return this;
};

/**
 * Set indentation level.
 *
 * @param {number} [level=0] Indentation level, in the range of [0,#maxLevel]
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setLevel = function ( level ) {
	var levels = this.constructor.static.levels,
		levelClass = this.constructor.static.levelClass,
		i = levels;

	this.level = level ? Math.max( 0, Math.min( levels - 1, level ) ) : 0;
	while ( i-- ) {
		if ( this.level === i ) {
			this.$element.addClass( levelClass + i );
		} else {
			this.$element.removeClass( levelClass + i );
		}
	}
	this.updateThemeClasses();

	return this;
};

/**
 * OutlineSelectWidget is a structured list that contains {@link OO.ui.OutlineOptionWidget outline options}
 * A set of controls can be provided with an {@link OO.ui.OutlineControlsWidget outline controls} widget.
 *
 * **Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}.**
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.OutlineSelectWidget = function OoUiOutlineSelectWidget( config ) {
	// Parent constructor
	OO.ui.OutlineSelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.TabIndexedElement.call( this, config );

	// Events
	this.$element.on( {
		focus: this.bindDocumentKeyDownListener.bind( this ),
		blur: this.unbindDocumentKeyDownListener.bind( this )
	} );

	// Initialization
	this.$element.addClass( 'oo-ui-outlineSelectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.OutlineSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * ButtonOptionWidget is a special type of {@link OO.ui.mixin.ButtonElement button element} that
 * can be selected and configured with data. The class is
 * used with OO.ui.ButtonSelectWidget to create a selection of button options. Please see the
 * [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_options
 *
 * @class
 * @extends OO.ui.OptionWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ButtonOptionWidget = function OoUiButtonOptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ButtonOptionWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ButtonElement.call( this, config );
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );

	// Initialization
	this.$element.addClass( 'oo-ui-buttonOptionWidget' );
	this.$button.append( this.$icon, this.$label, this.$indicator );
	this.$element.append( this.$button );
	this.setTitledElement( this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonOptionWidget, OO.ui.OptionWidget );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.IndicatorElement );

/* Static Properties */

/**
 * Allow button mouse down events to pass through so they can be handled by the parent select widget
 *
 * @static
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.static.cancelButtonMouseDownEvents = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.static.highlightable = false;

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.prototype.setSelected = function ( state ) {
	OO.ui.ButtonOptionWidget.parent.prototype.setSelected.call( this, state );

	if ( this.constructor.static.selectable ) {
		this.setActive( state );
	}

	return this;
};

/**
 * ButtonSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains
 * button options and is used together with
 * OO.ui.ButtonOptionWidget. The ButtonSelectWidget provides an interface for
 * highlighting, choosing, and selecting mutually exclusive options. Please see
 * the [OOUI documentation on MediaWiki] [1] for more information.
 *
 *     @example
 *     // A ButtonSelectWidget that contains three ButtonOptionWidgets.
 *     var option1 = new OO.ui.ButtonOptionWidget( {
 *             data: 1,
 *             label: 'Option 1',
 *             title: 'Button option 1'
 *         } ),
 *         option2 = new OO.ui.ButtonOptionWidget( {
 *             data: 2,
 *             label: 'Option 2',
 *             title: 'Button option 2'
 *         } ),
 *         option3 = new OO.ui.ButtonOptionWidget( {
 *             data: 3,
 *             label: 'Option 3',
 *             title: 'Button option 3'
 *         } ),
 *         buttonSelect = new OO.ui.ButtonSelectWidget( {
 *             items: [ option1, option2, option3 ]
 *         } );
 *     $( document.body ).append( buttonSelect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ButtonSelectWidget = function OoUiButtonSelectWidget( config ) {
	// Parent constructor
	OO.ui.ButtonSelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.TabIndexedElement.call( this, config );

	// Events
	this.$element.on( {
		focus: this.bindDocumentKeyDownListener.bind( this ),
		blur: this.unbindDocumentKeyDownListener.bind( this )
	} );

	// Initialization
	this.$element.addClass( 'oo-ui-buttonSelectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.ButtonSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * TabOptionWidget is an item in a {@link OO.ui.TabSelectWidget TabSelectWidget}.
 *
 * Currently, this class is only used by {@link OO.ui.IndexLayout index layouts}, which contain
 * {@link OO.ui.TabPanelLayout tab panel layouts}. See {@link OO.ui.IndexLayout IndexLayout}
 * for an example.
 *
 * @class
 * @extends OO.ui.OptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.TabOptionWidget = function OoUiTabOptionWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.TabOptionWidget.parent.call( this, config );

	// Initialization
	this.$element
		.addClass( 'oo-ui-tabOptionWidget' )
		.attr( 'role', 'tab' );
};

/* Setup */

OO.inheritClass( OO.ui.TabOptionWidget, OO.ui.OptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.TabOptionWidget.static.highlightable = false;

/**
 * TabSelectWidget is a list that contains {@link OO.ui.TabOptionWidget tab options}
 *
 * **Currently, this class is only used by {@link OO.ui.IndexLayout index layouts}.**
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.TabSelectWidget = function OoUiTabSelectWidget( config ) {
	// Parent constructor
	OO.ui.TabSelectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.TabIndexedElement.call( this, config );

	// Events
	this.$element.on( {
		focus: this.bindDocumentKeyDownListener.bind( this ),
		blur: this.unbindDocumentKeyDownListener.bind( this )
	} );

	// Initialization
	this.$element
		.addClass( 'oo-ui-tabSelectWidget' )
		.attr( 'role', 'tablist' );
};

/* Setup */

OO.inheritClass( OO.ui.TabSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.TabSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * TagItemWidgets are used within a {@link OO.ui.TagMultiselectWidget
 * TagMultiselectWidget} to display the selected items.
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.DraggableElement
 *
 * @constructor
 * @param {Object} [config] Configuration object
 * @cfg {boolean} [valid=true] Item is valid
 * @cfg {boolean} [fixed] Item is fixed. This means the item is
 *  always included in the values and cannot be removed.
 */
OO.ui.TagItemWidget = function OoUiTagItemWidget( config ) {
	config = config || {};

	// Parent constructor
	OO.ui.TagItemWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.ItemWidget.call( this );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, config );
	OO.ui.mixin.DraggableElement.call( this, config );

	this.valid = config.valid === undefined ? true : !!config.valid;
	this.fixed = !!config.fixed;

	this.closeButton = new OO.ui.ButtonWidget( {
		framed: false,
		icon: 'close',
		tabIndex: -1,
		title: OO.ui.msg( 'ooui-item-remove' )
	} );
	this.closeButton.setDisabled( this.isDisabled() );

	// Events
	this.closeButton
		.connect( this, { click: 'remove' } );
	this.$element
		.on( 'click', this.select.bind( this ) )
		.on( 'keydown', this.onKeyDown.bind( this ) )
		// Prevent propagation of mousedown; the tag item "lives" in the
		// clickable area of the TagMultiselectWidget, which listens to
		// mousedown to open the menu or popup. We want to prevent that
		// for clicks specifically on the tag itself, so the actions taken
		// are more deliberate. When the tag is clicked, it will emit the
		// selection event (similar to how #OO.ui.MultioptionWidget emits 'change')
		// and can be handled separately.
		.on( 'mousedown', function ( e ) { e.stopPropagation(); } );

	// Initialization
	this.$element
		.addClass( 'oo-ui-tagItemWidget' )
		.append( this.$label, this.closeButton.$element );
};

/* Initialization */

OO.inheritClass( OO.ui.TagItemWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.DraggableElement );

/* Events */

/**
 * @event remove
 *
 * A remove action was performed on the item
 */

/**
 * @event navigate
 * @param {string} direction Direction of the movement, forward or backwards
 *
 * A navigate action was performed on the item
 */

/**
 * @event select
 *
 * The tag widget was selected. This can occur when the widget
 * is either clicked or enter was pressed on it.
 */

/**
 * @event valid
 * @param {boolean} isValid Item is valid
 *
 * Item validity has changed
 */

/**
 * @event fixed
 * @param {boolean} isFixed Item is fixed
 *
 * Item fixed state has changed
 */

/* Methods */

/**
 * Set this item as fixed, meaning it cannot be removed
 *
 * @param {string} [state] Item is fixed
 * @fires fixed
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TagItemWidget.prototype.setFixed = function ( state ) {
	state = state === undefined ? !this.fixed : !!state;

	if ( this.fixed !== state ) {
		this.fixed = state;
		if ( this.closeButton ) {
			this.closeButton.toggle( !this.fixed );
		}

		if ( !this.fixed && this.elementGroup && !this.elementGroup.isDraggable() ) {
			// Only enable the state of the item if the
			// entire group is draggable
			this.toggleDraggable( !this.fixed );
		}
		this.$element.toggleClass( 'oo-ui-tagItemWidget-fixed', this.fixed );

		this.emit( 'fixed', this.isFixed() );
	}
	return this;
};

/**
 * Check whether the item is fixed
 * @return {boolean}
 */
OO.ui.TagItemWidget.prototype.isFixed = function () {
	return this.fixed;
};

/**
 * @inheritdoc
 */
OO.ui.TagItemWidget.prototype.setDisabled = function ( state ) {
	if ( state && this.elementGroup && !this.elementGroup.isDisabled() ) {
		OO.ui.warnDeprecation( 'TagItemWidget#setDisabled: Disabling individual items is deprecated and will result in inconsistent behavior. Use #setFixed instead. See T193571.' );
	}
	// Parent method
	OO.ui.TagItemWidget.parent.prototype.setDisabled.call( this, state );
	if (
		!state &&
		// Verify we have a group, and that the widget is ready
		this.toggleDraggable && this.elementGroup &&
		!this.isFixed() &&
		!this.elementGroup.isDraggable()
	) {
		// Only enable the draggable state of the item if the
		// entire group is draggable to begin with, and if the
		// item is not fixed
		this.toggleDraggable( !state );
	}

	if ( this.closeButton ) {
		this.closeButton.setDisabled( state );
	}

	return this;
};

/**
 * Handle removal of the item
 *
 * This is mainly for extensibility concerns, so other children
 * of this class can change the behavior if they need to. This
 * is called by both clicking the 'remove' button but also
 * on keypress, which is harder to override if needed.
 *
 * @fires remove
 */
OO.ui.TagItemWidget.prototype.remove = function () {
	if ( !this.isDisabled() && !this.isFixed() ) {
		this.emit( 'remove' );
	}
};

/**
 * Handle a keydown event on the widget
 *
 * @fires navigate
 * @fires remove
 * @param {jQuery.Event} e Key down event
 * @return {boolean|undefined} false to stop the operation
 */
OO.ui.TagItemWidget.prototype.onKeyDown = function ( e ) {
	var movement;

	if ( !this.isDisabled() && !this.isFixed() && ( e.keyCode === OO.ui.Keys.BACKSPACE || e.keyCode === OO.ui.Keys.DELETE ) ) {
		this.remove();
		return false;
	} else if ( e.keyCode === OO.ui.Keys.ENTER ) {
		this.select();
		return false;
	} else if (
		e.keyCode === OO.ui.Keys.LEFT ||
		e.keyCode === OO.ui.Keys.RIGHT
	) {
		if ( OO.ui.Element.static.getDir( this.$element ) === 'rtl' ) {
			movement = {
				left: 'forwards',
				right: 'backwards'
			};
		} else {
			movement = {
				left: 'backwards',
				right: 'forwards'
			};
		}

		this.emit(
			'navigate',
			e.keyCode === OO.ui.Keys.LEFT ?
				movement.left : movement.right
		);
		return false;
	}
};

/**
 * Select this item
 *
 * @fires select
 */
OO.ui.TagItemWidget.prototype.select = function () {
	if ( !this.isDisabled() ) {
		this.emit( 'select' );
	}
};

/**
 * Set the valid state of this item
 *
 * @param {boolean} [valid] Item is valid
 * @fires valid
 */
OO.ui.TagItemWidget.prototype.toggleValid = function ( valid ) {
	valid = valid === undefined ? !this.valid : !!valid;

	if ( this.valid !== valid ) {
		this.valid = valid;

		this.setFlags( { invalid: !this.valid } );

		this.emit( 'valid', this.valid );
	}
};

/**
 * Check whether the item is valid
 *
 * @return {boolean} Item is valid
 */
OO.ui.TagItemWidget.prototype.isValid = function () {
	return this.valid;
};

/**
 * A basic tag multiselect widget, similar in concept to {@link OO.ui.ComboBoxInputWidget combo box widget}
 * that allows the user to add multiple values that are displayed in a tag area.
 *
 * This widget is a base widget; see {@link OO.ui.MenuTagMultiselectWidget MenuTagMultiselectWidget} and
 * {@link OO.ui.PopupTagMultiselectWidget PopupTagMultiselectWidget} for the implementations that use
 * a menu and a popup respectively.
 *
 *     @example
 *     // A TagMultiselectWidget.
 *     var widget = new OO.ui.TagMultiselectWidget( {
 *         inputPosition: 'outline',
 *         allowedValues: [ 'Option 1', 'Option 2', 'Option 3' ],
 *         selected: [ 'Option 1' ]
 *     } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 * @mixins OO.ui.mixin.DraggableGroupElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} config Configuration object
 * @cfg {Object} [input] Configuration options for the input widget
 * @cfg {OO.ui.InputWidget} [inputWidget] An optional input widget. If given, it will
 *  replace the input widget used in the TagMultiselectWidget. If not given,
 *  TagMultiselectWidget creates its own.
 * @cfg {boolean} [inputPosition='inline'] Position of the input. Options are:
 *  - inline: The input is invisible, but exists inside the tag list, so
 *    the user types into the tag groups to add tags.
 *  - outline: The input is underneath the tag area.
 *  - none: No input supplied
 * @cfg {boolean} [allowEditTags=true] Allow editing of the tags by clicking them
 * @cfg {boolean} [allowArbitrary=false] Allow data items to be added even if
 *  not present in the menu.
 * @cfg {Object[]} [allowedValues] An array representing the allowed items
 *  by their datas.
 * @cfg {boolean} [allowDuplicates=false] Allow duplicate items to be added
 * @cfg {boolean} [allowDisplayInvalidTags=false] Allow the display of
 *  invalid tags. These tags will display with an invalid state, and
 *  the widget as a whole will have an invalid state if any invalid tags
 *  are present.
 * @cfg {number} [tagLimit] An optional limit on the number of selected options.
 *  If 'tagLimit' is set and is reached, the input is disabled, not allowing any
 *  additions. If 'tagLimit' is unset or is 0, an unlimited number of items can be
 *  added.
 * @cfg {boolean} [allowReordering=true] Allow reordering of the items
 * @cfg {Object[]|String[]} [selected] A set of selected tags. If given,
 *  these will appear in the tag list on initialization, as long as they
 *  pass the validity tests.
 */
OO.ui.TagMultiselectWidget = function OoUiTagMultiselectWidget( config ) {
	var inputEvents,
		rAF = window.requestAnimationFrame || setTimeout,
		widget = this,
		$tabFocus = $( '<span>' )
			.addClass( 'oo-ui-tagMultiselectWidget-focusTrap' );

	config = config || {};

	// Parent constructor
	OO.ui.TagMultiselectWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupWidget.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.DraggableGroupElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );

	this.toggleDraggable(
		config.allowReordering === undefined ?
			true : !!config.allowReordering
	);

	this.inputPosition =
		this.constructor.static.allowedInputPositions.indexOf( config.inputPosition ) > -1 ?
			config.inputPosition : 'inline';
	this.allowEditTags = config.allowEditTags === undefined ? true : !!config.allowEditTags;
	this.allowArbitrary = !!config.allowArbitrary;
	this.allowDuplicates = !!config.allowDuplicates;
	this.allowedValues = config.allowedValues || [];
	this.allowDisplayInvalidTags = config.allowDisplayInvalidTags;
	this.hasInput = this.inputPosition !== 'none';
	this.tagLimit = config.tagLimit;
	this.height = null;
	this.valid = true;

	this.$content = $( '<div>' )
		.addClass( 'oo-ui-tagMultiselectWidget-content' );
	this.$handle = $( '<div>' )
		.addClass( 'oo-ui-tagMultiselectWidget-handle' )
		.append(
			this.$indicator,
			this.$icon,
			this.$content
				.append(
					this.$group
						.addClass( 'oo-ui-tagMultiselectWidget-group' )
				)
		);

	// Events
	this.aggregate( {
		remove: 'itemRemove',
		navigate: 'itemNavigate',
		select: 'itemSelect',
		fixed: 'itemFixed'
	} );
	this.connect( this, {
		itemRemove: 'onTagRemove',
		itemSelect: 'onTagSelect',
		itemFixed: 'onTagFixed',
		itemNavigate: 'onTagNavigate',
		change: 'onChangeTags'
	} );
	this.$handle.on( {
		mousedown: this.onMouseDown.bind( this )
	} );

	// Initialize
	this.$element
		.addClass( 'oo-ui-tagMultiselectWidget' )
		.append( this.$handle );

	if ( this.hasInput ) {
		if ( config.inputWidget ) {
			this.input = config.inputWidget;
		} else {
			this.input = new OO.ui.TextInputWidget( $.extend( {
				placeholder: config.placeholder,
				classes: [ 'oo-ui-tagMultiselectWidget-input' ]
			}, config.input ) );
		}
		this.input.setDisabled( this.isDisabled() );

		inputEvents = {
			focus: this.onInputFocus.bind( this ),
			blur: this.onInputBlur.bind( this ),
			'propertychange change click mouseup keydown keyup input cut paste select focus':
				OO.ui.debounce( this.updateInputSize.bind( this ) ),
			keydown: this.onInputKeyDown.bind( this ),
			keypress: this.onInputKeyPress.bind( this )
		};

		this.input.$input.on( inputEvents );
		this.inputPlaceholder = this.input.$input.attr( 'placeholder' );

		if ( this.inputPosition === 'outline' ) {
			// Override max-height for the input widget
			// in the case the widget is outline so it can
			// stretch all the way if the widget is wide
			this.input.$element.css( 'max-width', 'inherit' );
			this.$element
				.addClass( 'oo-ui-tagMultiselectWidget-outlined' )
				.append( this.input.$element );
		} else {
			this.$element.addClass( 'oo-ui-tagMultiselectWidget-inlined' );
			// HACK: When the widget is using 'inline' input, the
			// behavior needs to only use the $input itself
			// so we style and size it accordingly (otherwise
			// the styling and sizing can get very convoluted
			// when the wrapping divs and other elements)
			// We are taking advantage of still being able to
			// call the widget itself for operations like
			// .getValue() and setDisabled() and .focus() but
			// having only the $input attached to the DOM
			this.$content.append( this.input.$input );
		}
	} else {
		this.$content.append( $tabFocus );
	}

	this.setTabIndexedElement(
		this.hasInput ?
			this.input.$input :
			$tabFocus
	);

	if ( config.selected ) {
		this.setValue( config.selected );
	}

	// HACK: Input size needs to be calculated after everything
	// else is rendered
	rAF( function () {
		if ( widget.hasInput ) {
			widget.updateInputSize();
		}
	} );
};

/* Initialization */

OO.inheritClass( OO.ui.TagMultiselectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.GroupWidget );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.DraggableGroupElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.TitledElement );

/* Static properties */

/**
 * Allowed input positions.
 * - inline: The input is inside the tag list
 * - outline: The input is under the tag list
 * - none: There is no input
 *
 * @property {Array}
 */
OO.ui.TagMultiselectWidget.static.allowedInputPositions = [ 'inline', 'outline', 'none' ];

/* Methods */

/**
 * Handle mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {boolean} False to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.onMouseDown = function ( e ) {
	if (
		!this.isDisabled() &&
		( !this.hasInput || e.target !== this.input.$input[ 0 ] ) &&
		e.which === OO.ui.MouseButtons.LEFT
	) {
		this.focus();
		return false;
	}
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.onInputKeyPress = function ( e ) {
	var stopOrContinue,
		withMetaKey = e.metaKey || e.ctrlKey;

	if ( !this.isDisabled() ) {
		if ( e.which === OO.ui.Keys.ENTER ) {
			stopOrContinue = this.doInputEnter( e, withMetaKey );
		}

		// Make sure the input gets resized.
		setTimeout( this.updateInputSize.bind( this ), 0 );
		return stopOrContinue;
	}
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {boolean}
 */
OO.ui.TagMultiselectWidget.prototype.onInputKeyDown = function ( e ) {
	var movement, direction,
		widget = this,
		withMetaKey = e.metaKey || e.ctrlKey,
		isMovementInsideInput = function ( direction ) {
			var inputRange = widget.input.getRange(),
				inputValue = widget.hasInput && widget.input.getValue();

			if ( direction === 'forwards' && inputRange.to > inputValue.length - 1 ) {
				return false;
			}

			if ( direction === 'backwards' && inputRange.from <= 0 ) {
				return false;
			}

			return true;
		};

	if ( !this.isDisabled() ) {
		// 'keypress' event is not triggered for Backspace
		if ( e.keyCode === OO.ui.Keys.BACKSPACE ) {
			return this.doInputBackspace( e, withMetaKey );
		} else if ( e.keyCode === OO.ui.Keys.ESCAPE ) {
			return this.doInputEscape( e );
		} else if (
			e.keyCode === OO.ui.Keys.LEFT ||
			e.keyCode === OO.ui.Keys.RIGHT
		) {
			if ( OO.ui.Element.static.getDir( this.$element ) === 'rtl' ) {
				movement = {
					left: 'forwards',
					right: 'backwards'
				};
			} else {
				movement = {
					left: 'backwards',
					right: 'forwards'
				};
			}
			direction = e.keyCode === OO.ui.Keys.LEFT ?
				movement.left : movement.right;

			if ( !this.hasInput || !isMovementInsideInput( direction ) ) {
				return this.doInputArrow( e, direction, withMetaKey );
			}
		}
	}
};

/**
 * Respond to input focus event
 */
OO.ui.TagMultiselectWidget.prototype.onInputFocus = function () {
	this.$element.addClass( 'oo-ui-tagMultiselectWidget-focus' );
	// Reset validity
	this.toggleValid( true );
};

/**
 * Respond to input blur event
 */
OO.ui.TagMultiselectWidget.prototype.onInputBlur = function () {
	this.$element.removeClass( 'oo-ui-tagMultiselectWidget-focus' );

	// Set the widget as invalid if there's text in the input
	this.addTagFromInput();
	this.toggleValid( this.checkValidity() && ( !this.hasInput || !this.input.getValue() ) );
};

/**
 * Perform an action after the enter key on the input
 *
 * @param {jQuery.Event} e Event data
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 * a meta key like 'ctrl'
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.doInputEnter = function () {
	this.addTagFromInput();
	return false;
};

/**
 * Perform an action responding to the enter key on the input
 *
 * @param {jQuery.Event} e Event data
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 * a meta key like 'ctrl'
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.doInputBackspace = function ( e, withMetaKey ) {
	var items, item;

	if (
		this.inputPosition === 'inline' &&
		this.input.getValue() === '' &&
		!this.isEmpty()
	) {
		// Delete the last item
		items = this.getItems();
		item = items[ items.length - 1 ];

		if ( !item.isDisabled() && !item.isFixed() ) {
			this.removeItems( [ item ] );
			// If Ctrl/Cmd was pressed, delete item entirely.
			// Otherwise put it into the text field for editing.
			if ( !withMetaKey ) {
				this.input.setValue( item.getData() );
			}
		}

		return false;
	}
};

/**
 * Perform an action after the escape key on the input
 *
 * @param {jQuery.Event} e Event data
 */
OO.ui.TagMultiselectWidget.prototype.doInputEscape = function () {
	this.clearInput();
};

/**
 * Perform an action after the arrow key on the input, select the previous
 * item from the input.
 * See #getPreviousItem
 *
 * @param {jQuery.Event} e Event data
 * @param {string} direction Direction of the movement; forwards or backwards
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 *  a meta key like 'ctrl'
 */
OO.ui.TagMultiselectWidget.prototype.doInputArrow = function ( e, direction ) {
	if (
		this.inputPosition === 'inline' &&
		!this.isEmpty() &&
		direction === 'backwards'
	) {
		// Get previous item
		this.getPreviousItem().focus();
	}
};

/**
 * Respond to item select event
 *
 * @param {OO.ui.TagItemWidget} item Selected item
 */
OO.ui.TagMultiselectWidget.prototype.onTagSelect = function ( item ) {
	if ( this.hasInput && this.allowEditTags && !item.isFixed() ) {
		if ( this.input.getValue() ) {
			this.addTagFromInput();
		}
		// 1. Get the label of the tag into the input
		this.input.setValue( item.getData() );
		// 2. Remove the tag
		this.removeItems( [ item ] );
		// 3. Focus the input
		this.focus();
	}
};

/**
 * Respond to item fixed state change
 *
 * @param {OO.ui.TagItemWidget} item Selected item
 */
OO.ui.TagMultiselectWidget.prototype.onTagFixed = function ( item ) {
	var i,
		items = this.getItems();

	// Move item to the end of the static items
	for ( i = 0; i < items.length; i++ ) {
		if ( items[ i ] !== item && !items[ i ].isFixed() ) {
			break;
		}
	}
	this.addItems( item, i );
};
/**
 * Respond to change event, where items were added, removed, or cleared.
 */
OO.ui.TagMultiselectWidget.prototype.onChangeTags = function () {
	var isUnderLimit = this.isUnderLimit();

	// Reset validity
	this.toggleValid(
		this.checkValidity() &&
		!( this.hasInput && this.input.getValue() )
	);

	if ( this.hasInput ) {
		this.updateInputSize();
		if ( !isUnderLimit ) {
			// Clear the input
			this.input.setValue( '' );
		}
		if ( this.inputPosition === 'outline' ) {
			// Show/clear the placeholder and enable/disable the input
			// based on whether we are/aren't under the specified limit
			this.input.$input.attr( 'placeholder', isUnderLimit ? this.inputPlaceholder : '' );
			this.input.setDisabled( !isUnderLimit );
		} else {
			// Show/hide the input
			this.input.$input.toggleClass( 'oo-ui-element-hidden', !isUnderLimit );
		}
	}
	this.updateIfHeightChanged();
};

/**
 * @inheritdoc
 */
OO.ui.TagMultiselectWidget.prototype.setDisabled = function ( isDisabled ) {
	// Parent method
	OO.ui.TagMultiselectWidget.parent.prototype.setDisabled.call( this, isDisabled );

	if ( this.hasInput && this.input ) {
		if ( !isDisabled ) {
			this.updateInputSize();
		}
		this.input.setDisabled( !!isDisabled && !this.isUnderLimit() );
	}

	if ( this.items ) {
		this.getItems().forEach( function ( item ) {
			item.setDisabled( !!isDisabled );
		} );
	}
};

/**
 * Respond to tag remove event
 * @param {OO.ui.TagItemWidget} item Removed tag
 */
OO.ui.TagMultiselectWidget.prototype.onTagRemove = function ( item ) {
	this.removeTagByData( item.getData() );
};

/**
 * Respond to navigate event on the tag
 *
 * @param {OO.ui.TagItemWidget} item Removed tag
 * @param {string} direction Direction of movement; 'forwards' or 'backwards'
 */
OO.ui.TagMultiselectWidget.prototype.onTagNavigate = function ( item, direction ) {
	var firstItem = this.getItems()[ 0 ];

	if ( direction === 'forwards' ) {
		this.getNextItem( item ).focus();
	} else if ( !this.inputPosition === 'inline' || item !== firstItem ) {
		// If the widget has an inline input, we want to stop at the starting edge
		// of the tags
		this.getPreviousItem( item ).focus();
	}
};

/**
 * Add tag from input value
 */
OO.ui.TagMultiselectWidget.prototype.addTagFromInput = function () {
	var val = this.input.getValue(),
		isValid = this.isAllowedData( val );

	if ( !val ) {
		return;
	}

	if ( isValid || this.allowDisplayInvalidTags ) {
		this.clearInput();
		this.addTag( val );
	}
};

/**
 * Clear the input
 */
OO.ui.TagMultiselectWidget.prototype.clearInput = function () {
	this.input.setValue( '' );
};

/**
 * Check whether the given value is a duplicate of an existing
 * tag already in the list.
 *
 * @param {string|Object} data Requested value
 * @return {boolean} Value is duplicate
 */
OO.ui.TagMultiselectWidget.prototype.isDuplicateData = function ( data ) {
	return !!this.findItemFromData( data );
};

/**
 * Check whether a given value is allowed to be added
 *
 * @param {string|Object} data Requested value
 * @return {boolean} Value is allowed
 */
OO.ui.TagMultiselectWidget.prototype.isAllowedData = function ( data ) {
	if (
		!this.allowDuplicates &&
		this.isDuplicateData( data )
	) {
		return false;
	}

	if ( this.allowArbitrary ) {
		return true;
	}

	// Check with allowed values
	if (
		this.getAllowedValues().some( function ( value ) {
			return data === value;
		} )
	) {
		return true;
	}

	return false;
};

/**
 * Get the allowed values list
 *
 * @return {string[]} Allowed data values
 */
OO.ui.TagMultiselectWidget.prototype.getAllowedValues = function () {
	return this.allowedValues;
};

/**
 * Add a value to the allowed values list
 *
 * @param {string} value Allowed data value
 */
OO.ui.TagMultiselectWidget.prototype.addAllowedValue = function ( value ) {
	if ( this.allowedValues.indexOf( value ) === -1 ) {
		this.allowedValues.push( value );
	}
};

/**
 * Get the datas of the currently selected items
 *
 * @return {string[]|Object[]} Datas of currently selected items
 */
OO.ui.TagMultiselectWidget.prototype.getValue = function () {
	return this.getItems()
		.filter( function ( item ) {
			return item.isValid();
		} )
		.map( function ( item ) {
			return item.getData();
		} );
};

/**
 * Set the value of this widget by datas.
 *
 * @param {string|string[]|Object|Object[]} valueObject An object representing the data
 *  and label of the value. If the widget allows arbitrary values,
 *  the items will be added as-is. Otherwise, the data value will
 *  be checked against allowedValues.
 *  This object must contain at least a data key. Example:
 *  { data: 'foo', label: 'Foo item' }
 *  For multiple items, use an array of objects. For example:
 *  [
 *     { data: 'foo', label: 'Foo item' },
 *     { data: 'bar', label: 'Bar item' }
 *  ]
 *  Value can also be added with plaintext array, for example:
 *  [ 'foo', 'bar', 'bla' ] or a single string, like 'foo'
 */
OO.ui.TagMultiselectWidget.prototype.setValue = function ( valueObject ) {
	valueObject = Array.isArray( valueObject ) ? valueObject : [ valueObject ];

	this.clearItems();
	valueObject.forEach( function ( obj ) {
		if ( typeof obj === 'string' ) {
			this.addTag( obj );
		} else {
			this.addTag( obj.data, obj.label );
		}
	}.bind( this ) );
};

/**
 * Add tag to the display area
 *
 * @param {string|Object} data Tag data
 * @param {string} [label] Tag label. If no label is provided, the
 *  stringified version of the data will be used instead.
 * @return {boolean} Item was added successfully
 */
OO.ui.TagMultiselectWidget.prototype.addTag = function ( data, label ) {
	var newItemWidget,
		isValid = this.isAllowedData( data );

	if ( this.isUnderLimit() && ( isValid || this.allowDisplayInvalidTags ) ) {
		newItemWidget = this.createTagItemWidget( data, label );
		newItemWidget.toggleValid( isValid );
		this.addItems( [ newItemWidget ] );
		return true;
	}

	return false;
};

/**
 * Check whether the number of current tags is within the limit.
 *
 * @return {boolean} True if current tag count is within the limit or
 *  if 'tagLimit' is not set
 */
OO.ui.TagMultiselectWidget.prototype.isUnderLimit = function () {
	return !this.tagLimit ||
		this.getItemCount() < this.tagLimit;
};

/**
 * Remove tag by its data property.
 *
 * @param {string|Object} data Tag data
 */
OO.ui.TagMultiselectWidget.prototype.removeTagByData = function ( data ) {
	var item = this.findItemFromData( data );

	this.removeItems( [ item ] );
};

/**
 * Construct a OO.ui.TagItemWidget (or a subclass thereof) from given label and data.
 *
 * @protected
 * @param {string} data Item data
 * @param {string} label The label text.
 * @return {OO.ui.TagItemWidget}
 */
OO.ui.TagMultiselectWidget.prototype.createTagItemWidget = function ( data, label ) {
	label = label || data;

	return new OO.ui.TagItemWidget( { data: data, label: label } );
};

/**
 * Given an item, returns the item after it. If the item is already the
 * last item, return `this.input`. If no item is passed, returns the
 * very first item.
 *
 * @protected
 * @param {OO.ui.TagItemWidget} [item] Tag item
 * @return {OO.ui.Widget} The next widget available.
 */
OO.ui.TagMultiselectWidget.prototype.getNextItem = function ( item ) {
	var itemIndex = this.items.indexOf( item );

	if ( item === undefined || itemIndex === -1 ) {
		return this.items[ 0 ];
	}

	if ( itemIndex === this.items.length - 1 ) { // Last item
		if ( this.hasInput ) {
			return this.input;
		} else {
			// Return first item
			return this.items[ 0 ];
		}
	} else {
		return this.items[ itemIndex + 1 ];
	}
};

/**
 * Given an item, returns the item before it. If the item is already the
 * first item, return `this.input`. If no item is passed, returns the
 * very last item.
 *
 * @protected
 * @param {OO.ui.TagItemWidget} [item] Tag item
 * @return {OO.ui.Widget} The previous widget available.
 */
OO.ui.TagMultiselectWidget.prototype.getPreviousItem = function ( item ) {
	var itemIndex = this.items.indexOf( item );

	if ( item === undefined || itemIndex === -1 ) {
		return this.items[ this.items.length - 1 ];
	}

	if ( itemIndex === 0 ) {
		if ( this.hasInput ) {
			return this.input;
		} else {
			// Return the last item
			return this.items[ this.items.length - 1 ];
		}
	} else {
		return this.items[ itemIndex - 1 ];
	}
};

/**
 * Update the dimensions of the text input field to encompass all available area.
 * This is especially relevant for when the input is at the edge of a line
 * and should get smaller. The usual operation (as an inline-block with min-width)
 * does not work in that case, pushing the input downwards to the next line.
 *
 * @private
 */
OO.ui.TagMultiselectWidget.prototype.updateInputSize = function () {
	var $lastItem, direction, contentWidth, currentWidth, bestWidth;
	if ( this.inputPosition === 'inline' && !this.isDisabled() ) {
		if ( this.input.$input[ 0 ].scrollWidth === 0 ) {
			// Input appears to be attached but not visible.
			// Don't attempt to adjust its size, because our measurements
			// are going to fail anyway.
			return;
		}
		this.input.$input.css( 'width', '1em' );
		$lastItem = this.$group.children().last();
		direction = OO.ui.Element.static.getDir( this.$handle );

		// Get the width of the input with the placeholder text as
		// the value and save it so that we don't keep recalculating
		if (
			this.contentWidthWithPlaceholder === undefined &&
			this.input.getValue() === '' &&
			this.input.$input.attr( 'placeholder' ) !== undefined
		) {
			this.input.setValue( this.input.$input.attr( 'placeholder' ) );
			this.contentWidthWithPlaceholder = this.input.$input[ 0 ].scrollWidth;
			this.input.setValue( '' );

		}

		// Always keep the input wide enough for the placeholder text
		contentWidth = Math.max(
			this.input.$input[ 0 ].scrollWidth,
			// undefined arguments in Math.max lead to NaN
			( this.contentWidthWithPlaceholder === undefined ) ?
				0 : this.contentWidthWithPlaceholder
		);
		currentWidth = this.input.$input.width();

		if ( contentWidth < currentWidth ) {
			this.updateIfHeightChanged();
			// All is fine, don't perform expensive calculations
			return;
		}

		if ( $lastItem.length === 0 ) {
			bestWidth = this.$content.innerWidth();
		} else {
			bestWidth = direction === 'ltr' ?
				this.$content.innerWidth() - $lastItem.position().left - $lastItem.outerWidth() :
				$lastItem.position().left;
		}

		// Some safety margin for sanity, because I *really* don't feel like finding out where the few
		// pixels this is off by are coming from.
		bestWidth -= 13;
		if ( contentWidth > bestWidth ) {
			// This will result in the input getting shifted to the next line
			bestWidth = this.$content.innerWidth() - 13;
		}
		this.input.$input.width( Math.floor( bestWidth ) );
		this.updateIfHeightChanged();
	} else {
		this.updateIfHeightChanged();
	}
};

/**
 * Determine if widget height changed, and if so,
 * emit the resize event. This is useful for when there are either
 * menus or popups attached to the bottom of the widget, to allow
 * them to change their positioning in case the widget moved down
 * or up.
 *
 * @private
 */
OO.ui.TagMultiselectWidget.prototype.updateIfHeightChanged = function () {
	var height = this.$element.height();
	if ( height !== this.height ) {
		this.height = height;
		this.emit( 'resize' );
	}
};

/**
 * Check whether all items in the widget are valid
 *
 * @return {boolean} Widget is valid
 */
OO.ui.TagMultiselectWidget.prototype.checkValidity = function () {
	return this.getItems().every( function ( item ) {
		return item.isValid();
	} );
};

/**
 * Set the valid state of this item
 *
 * @param {boolean} [valid] Item is valid
 * @fires valid
 */
OO.ui.TagMultiselectWidget.prototype.toggleValid = function ( valid ) {
	valid = valid === undefined ? !this.valid : !!valid;

	if ( this.valid !== valid ) {
		this.valid = valid;

		this.setFlags( { invalid: !this.valid } );

		this.emit( 'valid', this.valid );
	}
};

/**
 * Get the current valid state of the widget
 *
 * @return {boolean} Widget is valid
 */
OO.ui.TagMultiselectWidget.prototype.isValid = function () {
	return this.valid;
};

/**
 * PopupTagMultiselectWidget is a {@link OO.ui.TagMultiselectWidget OO.ui.TagMultiselectWidget} intended
 * to use a popup. The popup can be configured to have a default input to insert values into the widget.
 *
 *     @example
 *     // A PopupTagMultiselectWidget.
 *     var widget = new OO.ui.PopupTagMultiselectWidget();
 *     $( document.body ).append( widget.$element );
 *
 *     // Example: A PopupTagMultiselectWidget with an external popup.
 *     var popupInput = new OO.ui.TextInputWidget(),
 *         widget = new OO.ui.PopupTagMultiselectWidget( {
 *            popupInput: popupInput,
 *            popup: {
 *               $content: popupInput.$element
 *            }
 *         } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.TagMultiselectWidget
 * @mixins OO.ui.mixin.PopupElement
 *
 * @param {Object} config Configuration object
 * @cfg {jQuery} [$overlay] An overlay for the popup.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {Object} [popup] Configuration options for the popup
 * @cfg {OO.ui.InputWidget} [popupInput] An input widget inside the popup that will be
 *  focused when the popup is opened and will be used as replacement for the
 *  general input in the widget.
 * @deprecated
 */
OO.ui.PopupTagMultiselectWidget = function OoUiPopupTagMultiselectWidget( config ) {
	var defaultInput,
		defaultConfig = { popup: {} };

	config = config || {};

	// Parent constructor
	OO.ui.PopupTagMultiselectWidget.parent.call( this, $.extend( { inputPosition: 'none' }, config ) );

	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

	if ( !config.popup ) {
		// For the default base implementation, we give a popup
		// with an input widget inside it. For any other use cases
		// the popup needs to be populated externally and the
		// event handled to add tags separately and manually
		defaultInput = new OO.ui.TextInputWidget();

		defaultConfig.popupInput = defaultInput;
		defaultConfig.popup.$content = defaultInput.$element;
		defaultConfig.popup.padded = true;

		this.$element.addClass( 'oo-ui-popupTagMultiselectWidget-defaultPopup' );
	}

	// Add overlay, and add that to the autoCloseIgnore
	defaultConfig.popup.$overlay = this.$overlay;
	defaultConfig.popup.$autoCloseIgnore = this.hasInput ?
		this.input.$element.add( this.$overlay ) : this.$overlay;

	// Allow extending any of the above
	config = $.extend( defaultConfig, config );

	// Mixin constructors
	OO.ui.mixin.PopupElement.call( this, config );

	if ( this.hasInput ) {
		this.input.$input.on( 'focus', this.popup.toggle.bind( this.popup, true ) );
	}

	// Configuration options
	this.popupInput = config.popupInput;
	if ( this.popupInput ) {
		this.popupInput.connect( this, {
			enter: 'onPopupInputEnter'
		} );
	}

	// Events
	this.on( 'resize', this.popup.updateDimensions.bind( this.popup ) );
	this.popup.connect( this, { toggle: 'onPopupToggle' } );
	this.$tabIndexed
		.on( 'focus', this.onFocus.bind( this ) );

	// Initialize
	this.$element
		.append( this.popup.$element )
		.addClass( 'oo-ui-popupTagMultiselectWidget' );

	// Deprecation warning
	OO.ui.warnDeprecation( 'PopupTagMultiselectWidget: Deprecated widget. Use MenuTagMultiselectWidget instead. See T208821.' );
};

/* Initialization */

OO.inheritClass( OO.ui.PopupTagMultiselectWidget, OO.ui.TagMultiselectWidget );
OO.mixinClass( OO.ui.PopupTagMultiselectWidget, OO.ui.mixin.PopupElement );

/* Methods */

/**
 * Focus event handler.
 *
 * @private
 */
OO.ui.PopupTagMultiselectWidget.prototype.onFocus = function () {
	this.popup.toggle( true );
};

/**
 * Respond to popup toggle event
 *
 * @param {boolean} isVisible Popup is visible
 */
OO.ui.PopupTagMultiselectWidget.prototype.onPopupToggle = function ( isVisible ) {
	if ( isVisible && this.popupInput ) {
		this.popupInput.focus();
	}
};

/**
 * Respond to popup input enter event
 */
OO.ui.PopupTagMultiselectWidget.prototype.onPopupInputEnter = function () {
	if ( this.popupInput ) {
		this.addTagByPopupValue( this.popupInput.getValue() );
		this.popupInput.setValue( '' );
	}
};

/**
 * @inheritdoc
 */
OO.ui.PopupTagMultiselectWidget.prototype.onTagSelect = function ( item ) {
	if ( this.popupInput && this.allowEditTags ) {
		this.popupInput.setValue( item.getData() );
		this.removeItems( [ item ] );

		this.popup.toggle( true );
		this.popupInput.focus();
	} else {
		// Parent
		OO.ui.PopupTagMultiselectWidget.parent.prototype.onTagSelect.call( this, item );
	}
};

/**
 * Add a tag by the popup value.
 * Whatever is responsible for setting the value in the popup should call
 * this method to add a tag, or use the regular methods like #addTag or
 * #setValue directly.
 *
 * @param {string} data The value of item
 * @param {string} [label] The label of the tag. If not given, the data is used.
 */
OO.ui.PopupTagMultiselectWidget.prototype.addTagByPopupValue = function ( data, label ) {
	this.addTag( data, label );
};

/**
 * MenuTagMultiselectWidget is a {@link OO.ui.TagMultiselectWidget OO.ui.TagMultiselectWidget} intended
 * to use a menu of selectable options.
 *
 *     @example
 *     // A basic MenuTagMultiselectWidget.
 *     var widget = new OO.ui.MenuTagMultiselectWidget( {
 *         inputPosition: 'outline',
 *         options: [
 *            { data: 'option1', label: 'Option 1', icon: 'tag' },
 *            { data: 'option2', label: 'Option 2' },
 *            { data: 'option3', label: 'Option 3' },
 *         ],
 *         selected: [ 'option1', 'option2' ]
 *     } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.TagMultiselectWidget
 *
 * @constructor
 * @param {Object} [config] Configuration object
 * @cfg {boolean} [clearInputOnChoose=true] Clear the text input value when a menu option is chosen
 * @cfg {Object} [menu] Configuration object for the menu widget
 * @cfg {jQuery} [$overlay] An overlay for the menu.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 */
OO.ui.MenuTagMultiselectWidget = function OoUiMenuTagMultiselectWidget( config ) {
	config = config || {};

	// Parent constructor
	OO.ui.MenuTagMultiselectWidget.parent.call( this, config );

	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
	this.clearInputOnChoose = config.clearInputOnChoose === undefined || !!config.clearInputOnChoose;
	this.menu = this.createMenuWidget( $.extend( {
		widget: this,
		input: this.hasInput ? this.input : null,
		$input: this.hasInput ? this.input.$input : null,
		filterFromInput: !!this.hasInput,
		$autoCloseIgnore: this.hasInput ?
			this.input.$element : $( [] ),
		$floatableContainer: this.hasInput && this.inputPosition === 'outline' ?
			this.input.$element : this.$element,
		$overlay: this.$overlay,
		disabled: this.isDisabled()
	}, config.menu ) );
	this.addOptions( config.options || [] );

	// Events
	this.menu.connect( this, {
		choose: 'onMenuChoose',
		toggle: 'onMenuToggle'
	} );
	if ( this.hasInput ) {
		this.input.connect( this, { change: 'onInputChange' } );
	}
	this.connect( this, { resize: 'onResize' } );

	// Initialization
	this.$overlay
		.append( this.menu.$element );
	this.$element
		.addClass( 'oo-ui-menuTagMultiselectWidget' );
	// Remove MenuSelectWidget's generic focus owner ARIA attribute
	// TODO: Should this widget have a `role` that is compatible with this attribute?
	this.menu.$focusOwner.removeAttr( 'aria-expanded' );
	// TagMultiselectWidget already does this, but it doesn't work right because this.menu is not yet
	// set up while the parent constructor runs, and #getAllowedValues rejects everything.
	if ( config.selected ) {
		this.setValue( config.selected );
	}
};

/* Initialization */

OO.inheritClass( OO.ui.MenuTagMultiselectWidget, OO.ui.TagMultiselectWidget );

/* Methods */

/**
 * Respond to resize event
 */
OO.ui.MenuTagMultiselectWidget.prototype.onResize = function () {
	// Reposition the menu
	this.menu.position();
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.onInputFocus = function () {
	// Parent method
	OO.ui.MenuTagMultiselectWidget.parent.prototype.onInputFocus.call( this );

	this.menu.toggle( true );
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.onInputBlur = function () {
	// Parent method
	OO.ui.MenuTagMultiselectWidget.parent.prototype.onInputBlur.call( this );

	this.menu.toggle( false );
};

/**
 * Respond to input change event
 */
OO.ui.MenuTagMultiselectWidget.prototype.onInputChange = function () {
	this.menu.toggle( true );
	this.initializeMenuSelection();
};

/**
 * Respond to menu choose event
 *
 * @param {OO.ui.OptionWidget} menuItem Chosen menu item
 */
OO.ui.MenuTagMultiselectWidget.prototype.onMenuChoose = function ( menuItem ) {
	if ( this.hasInput && this.clearInputOnChoose ) {
		this.input.setValue( '' );
	}
	// Add tag
	this.addTag( menuItem.getData(), menuItem.getLabel() );
};

/**
 * Respond to menu toggle event. Reset item highlights on hide.
 *
 * @param {boolean} isVisible The menu is visible
 */
OO.ui.MenuTagMultiselectWidget.prototype.onMenuToggle = function ( isVisible ) {
	if ( !isVisible ) {
		this.menu.selectItem( null );
		this.menu.highlightItem( null );
	} else {
		this.initializeMenuSelection();
	}
	setTimeout( function () {
		// Remove MenuSelectWidget's generic focus owner ARIA attribute
		// TODO: Should this widget have a `role` that is compatible with this attribute?
		this.menu.$focusOwner.removeAttr( 'aria-expanded' );
	}.bind( this ) );
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.onTagSelect = function ( tagItem ) {
	var menuItem = this.menu.findItemFromData( tagItem.getData() );
	if ( !this.allowArbitrary ) {
		// Override the base behavior from TagMultiselectWidget; the base behavior
		// in TagMultiselectWidget is to remove the tag to edit it in the input,
		// but in our case, we want to utilize the menu selection behavior, and
		// definitely not remove the item.

		// If there is an input that is used for filtering, erase the value so we don't filter
		if ( this.hasInput && this.menu.filterFromInput ) {
			this.input.setValue( '' );
		}

		// Select the menu item
		this.menu.selectItem( menuItem );

		this.focus();
	} else {
		// Use the default
		OO.ui.MenuTagMultiselectWidget.parent.prototype.onTagSelect.call( this, tagItem );
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.setDisabled = function ( isDisabled ) {
	// Parent method
	OO.ui.MenuTagMultiselectWidget.parent.prototype.setDisabled.call( this, isDisabled );

	if ( this.menu ) {
		// Protect against calling setDisabled() before the menu was initialized
		this.menu.setDisabled( isDisabled );
	}
};

/**
 * Highlight the first selectable item in the menu, if configured.
 *
 * @private
 * @chainable
 */
OO.ui.MenuTagMultiselectWidget.prototype.initializeMenuSelection = function () {
	if ( !this.menu.findSelectedItem() ) {
		this.menu.highlightItem(
			this.allowArbitrary ?
				null :
				this.menu.findFirstSelectableItem()
		);
	}
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.addTagFromInput = function () {
	var val = this.input.getValue(),
		// Look for a highlighted item first
		// Then look for the element that fits the data
		item = this.menu.findHighlightedItem() || this.menu.findItemFromData( val ),
		data = item ? item.getData() : val,
		isValid = this.isAllowedData( data );

	// Override the parent method so we add from the menu
	// rather than directly from the input

	if ( !val ) {
		return;
	}

	if ( isValid || this.allowDisplayInvalidTags ) {
		this.clearInput();
		if ( item ) {
			this.addTag( data, item.getLabel() );
		} else {
			this.addTag( val );
		}
	}
};

/**
 * Return the visible items in the menu. This is mainly used for when
 * the menu is filtering results.
 *
 * @return {OO.ui.MenuOptionWidget[]} Visible results
 */
OO.ui.MenuTagMultiselectWidget.prototype.getMenuVisibleItems = function () {
	return this.menu.getItems().filter( function ( menuItem ) {
		return menuItem.isVisible();
	} );
};

/**
 * Create the menu for this widget. This is in a separate method so that
 * child classes can override this without polluting the constructor with
 * unnecessary extra objects that will be overidden.
 *
 * @param {Object} menuConfig Configuration options
 * @return {OO.ui.MenuSelectWidget} Menu widget
 */
OO.ui.MenuTagMultiselectWidget.prototype.createMenuWidget = function ( menuConfig ) {
	return new OO.ui.MenuSelectWidget( menuConfig );
};

/**
 * Add options to the menu
 *
 * @param {Object[]} menuOptions Object defining options
 */
OO.ui.MenuTagMultiselectWidget.prototype.addOptions = function ( menuOptions ) {
	var widget = this,
		items = menuOptions.map( function ( obj ) {
			return widget.createMenuOptionWidget( obj.data, obj.label, obj.icon );
		} );

	this.menu.addItems( items );
};

/**
 * Create a menu option widget.
 *
 * @param {string} data Item data
 * @param {string} [label] Item label
 * @param {string} [icon] Symbolic icon name
 * @return {OO.ui.OptionWidget} Option widget
 */
OO.ui.MenuTagMultiselectWidget.prototype.createMenuOptionWidget = function ( data, label, icon ) {
	return new OO.ui.MenuOptionWidget( {
		data: data,
		label: label || data,
		icon: icon
	} );
};

/**
 * Get the menu
 *
 * @return {OO.ui.MenuSelectWidget} Menu
 */
OO.ui.MenuTagMultiselectWidget.prototype.getMenu = function () {
	return this.menu;
};

/**
 * Get the allowed values list
 *
 * @return {string[]} Allowed data values
 */
OO.ui.MenuTagMultiselectWidget.prototype.getAllowedValues = function () {
	var menuDatas = [];
	if ( this.menu ) {
		// If the parent constructor is calling us, we're not ready yet, this.menu is not set up.
		menuDatas = this.menu.getItems().map( function ( menuItem ) {
			return menuItem.getData();
		} );
	}
	return this.allowedValues.concat( menuDatas );
};

/**
 * SelectFileWidgets allow for selecting files, using the HTML5 File API. These
 * widgets can be configured with {@link OO.ui.mixin.IconElement icons}, {@link
 * OO.ui.mixin.IndicatorElement indicators} and {@link OO.ui.mixin.TitledElement titles}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 *     @example
 *     // A file select widget.
 *     var selectFile = new OO.ui.SelectFileWidget();
 *     $( document.body ).append( selectFile.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.PendingElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string[]|null} [accept=null] MIME types to accept. null accepts all types.
 * @cfg {string} [placeholder] Text to display when no file is selected.
 * @cfg {string} [notsupported] Text to display when file support is missing in the browser.
 * @cfg {boolean} [droppable=true] Whether to accept files by drag and drop.
 * @cfg {boolean} [showDropTarget=false] Whether to show a drop target. Requires droppable to be true.
 * @cfg {number} [thumbnailSizeLimit=20] File size limit in MiB above which to not try and show a
 *  preview (for performance)
 */
OO.ui.SelectFileWidget = function OoUiSelectFileWidget( config ) {
	var dragHandler;

	// Configuration initialization
	config = $.extend( {
		accept: null,
		placeholder: OO.ui.msg( 'ooui-selectfile-placeholder' ),
		notsupported: OO.ui.msg( 'ooui-selectfile-not-supported' ),
		droppable: true,
		showDropTarget: false,
		thumbnailSizeLimit: 20
	}, config );

	// Parent constructor
	OO.ui.SelectFileWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.PendingElement.call( this, $.extend( {}, config, { $pending: this.$info } ) );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );

	// Properties
	this.$info = $( '<span>' );
	this.showDropTarget = config.showDropTarget;
	this.thumbnailSizeLimit = config.thumbnailSizeLimit;
	this.isSupported = this.constructor.static.isSupported();
	this.currentFile = null;
	if ( Array.isArray( config.accept ) ) {
		this.accept = config.accept;
	} else {
		this.accept = null;
	}
	this.placeholder = config.placeholder;
	this.notsupported = config.notsupported;
	this.onFileSelectedHandler = this.onFileSelected.bind( this );

	this.selectButton = new OO.ui.ButtonWidget( {
		$element: $( '<label>' ),
		classes: [ 'oo-ui-selectFileWidget-selectButton' ],
		label: OO.ui.msg( 'ooui-selectfile-button-select' ),
		disabled: this.disabled || !this.isSupported
	} );

	this.clearButton = new OO.ui.ButtonWidget( {
		classes: [ 'oo-ui-selectFileWidget-clearButton' ],
		framed: false,
		icon: 'clear',
		disabled: this.disabled
	} );

	// Events
	this.selectButton.$button.on( {
		keypress: this.onKeyPress.bind( this )
	} );
	this.clearButton.connect( this, {
		click: 'onClearClick'
	} );
	if ( config.droppable ) {
		dragHandler = this.onDragEnterOrOver.bind( this );
		this.$element.on( {
			dragenter: dragHandler,
			dragover: dragHandler,
			dragleave: this.onDragLeave.bind( this ),
			drop: this.onDrop.bind( this )
		} );
	}

	// Initialization
	this.addInput();
	this.$label.addClass( 'oo-ui-selectFileWidget-label' );
	this.$info
		.addClass( 'oo-ui-selectFileWidget-info' )
		.append( this.$icon, this.$label, this.clearButton.$element, this.$indicator );

	if ( config.droppable && config.showDropTarget ) {
		this.selectButton.setIcon( 'upload' );
		this.$thumbnail = $( '<div>' ).addClass( 'oo-ui-selectFileWidget-thumbnail' );
		this.setPendingElement( this.$thumbnail );
		this.$element
			.addClass( 'oo-ui-selectFileWidget-dropTarget oo-ui-selectFileWidget' )
			.on( {
				click: this.onDropTargetClick.bind( this )
			} )
			.append(
				this.$thumbnail,
				this.$info,
				this.selectButton.$element,
				$( '<span>' )
					.addClass( 'oo-ui-selectFileWidget-dropLabel' )
					.text( OO.ui.msg( 'ooui-selectfile-dragdrop-placeholder' ) )
			);
	} else {
		this.$element
			.addClass( 'oo-ui-selectFileWidget' )
			.append( this.$info, this.selectButton.$element );
	}
	this.updateUI();
};

/* Setup */

OO.inheritClass( OO.ui.SelectFileWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.PendingElement );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * Check if this widget is supported
 *
 * @static
 * @return {boolean}
 */
OO.ui.SelectFileWidget.static.isSupported = function () {
	var $input;
	if ( OO.ui.SelectFileWidget.static.isSupportedCache === null ) {
		$input = $( '<input>' ).attr( 'type', 'file' );
		OO.ui.SelectFileWidget.static.isSupportedCache = $input[ 0 ].files !== undefined;
	}
	return OO.ui.SelectFileWidget.static.isSupportedCache;
};

OO.ui.SelectFileWidget.static.isSupportedCache = null;

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the on/off state of the toggle changes.
 *
 * @param {File|null} value New value
 */

/* Methods */

/**
 * Get the current value of the field
 *
 * @return {File|null}
 */
OO.ui.SelectFileWidget.prototype.getValue = function () {
	return this.currentFile;
};

/**
 * Set the current value of the field
 *
 * @param {File|null} file File to select
 */
OO.ui.SelectFileWidget.prototype.setValue = function ( file ) {
	if ( this.currentFile !== file ) {
		this.currentFile = file;
		this.updateUI();
		this.emit( 'change', this.currentFile );
	}
};

/**
 * Focus the widget.
 *
 * Focusses the select file button.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectFileWidget.prototype.focus = function () {
	this.selectButton.focus();
	return this;
};

/**
 * Blur the widget.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectFileWidget.prototype.blur = function () {
	this.selectButton.blur();
	return this;
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.simulateLabelClick = function () {
	this.focus();
};

/**
 * Update the user interface when a file is selected or unselected
 *
 * @protected
 */
OO.ui.SelectFileWidget.prototype.updateUI = function () {
	var $label;
	if ( !this.isSupported ) {
		this.$element.addClass( 'oo-ui-selectFileWidget-notsupported' );
		this.$element.removeClass( 'oo-ui-selectFileWidget-empty' );
		this.setLabel( this.notsupported );
	} else {
		this.$element.addClass( 'oo-ui-selectFileWidget-supported' );
		if ( this.currentFile ) {
			this.$element.removeClass( 'oo-ui-selectFileWidget-empty' );
			$label = $( [] );
			$label = $label.add(
				$( '<span>' )
					.addClass( 'oo-ui-selectFileWidget-fileName' )
					.text( this.currentFile.name )
			);
			this.setLabel( $label );

			if ( this.showDropTarget ) {
				this.pushPending();
				this.loadAndGetImageUrl().done( function ( url ) {
					this.$thumbnail.css( 'background-image', 'url( ' + url + ' )' );
				}.bind( this ) ).fail( function () {
					this.$thumbnail.append(
						new OO.ui.IconWidget( {
							icon: 'attachment',
							classes: [ 'oo-ui-selectFileWidget-noThumbnail-icon' ]
						} ).$element
					);
				}.bind( this ) ).always( function () {
					this.popPending();
				}.bind( this ) );
				this.$element.off( 'click' );
			}
		} else {
			if ( this.showDropTarget ) {
				this.$element.off( 'click' );
				this.$element.on( {
					click: this.onDropTargetClick.bind( this )
				} );
				this.$thumbnail
					.empty()
					.css( 'background-image', '' );
			}
			this.$element.addClass( 'oo-ui-selectFileWidget-empty' );
			this.setLabel( this.placeholder );
		}
	}
};

/**
 * If the selected file is an image, get its URL and load it.
 *
 * @return {jQuery.Promise} Promise resolves with the image URL after it has loaded
 */
OO.ui.SelectFileWidget.prototype.loadAndGetImageUrl = function () {
	var deferred = $.Deferred(),
		file = this.currentFile,
		reader = new FileReader();

	if (
		file &&
		( OO.getProp( file, 'type' ) || '' ).indexOf( 'image/' ) === 0 &&
		file.size < this.thumbnailSizeLimit * 1024 * 1024
	) {
		reader.onload = function ( event ) {
			var img = document.createElement( 'img' );
			img.addEventListener( 'load', function () {
				if (
					img.naturalWidth === 0 ||
					img.naturalHeight === 0 ||
					img.complete === false
				) {
					deferred.reject();
				} else {
					deferred.resolve( event.target.result );
				}
			} );
			img.src = event.target.result;
		};
		reader.readAsDataURL( file );
	} else {
		deferred.reject();
	}

	return deferred.promise();
};

/**
 * Add the input to the widget
 *
 * @private
 */
OO.ui.SelectFileWidget.prototype.addInput = function () {
	if ( this.$input ) {
		this.$input.remove();
	}

	if ( !this.isSupported ) {
		this.$input = null;
		return;
	}

	this.$input = $( '<input>' ).attr( 'type', 'file' );
	this.$input.on( 'change', this.onFileSelectedHandler );
	this.$input.on( 'click', function ( e ) {
		// Prevents dropTarget to get clicked which calls
		// a click on this input
		e.stopPropagation();
	} );
	this.$input.attr( {
		tabindex: -1
	} );
	if ( this.accept ) {
		this.$input.attr( 'accept', this.accept.join( ', ' ) );
	}
	this.selectButton.$button.append( this.$input );
};

/**
 * Determine if we should accept this file
 *
 * @private
 * @param {string} mimeType File MIME type
 * @return {boolean}
 */
OO.ui.SelectFileWidget.prototype.isAllowedType = function ( mimeType ) {
	var i, mimeTest;

	if ( !this.accept || !mimeType ) {
		return true;
	}

	for ( i = 0; i < this.accept.length; i++ ) {
		mimeTest = this.accept[ i ];
		if ( mimeTest === mimeType ) {
			return true;
		} else if ( mimeTest.substr( -2 ) === '/*' ) {
			mimeTest = mimeTest.substr( 0, mimeTest.length - 1 );
			if ( mimeType.substr( 0, mimeTest.length ) === mimeTest ) {
				return true;
			}
		}
	}

	return false;
};

/**
 * Handle file selection from the input
 *
 * @private
 * @param {jQuery.Event} e
 */
OO.ui.SelectFileWidget.prototype.onFileSelected = function ( e ) {
	var file = OO.getProp( e.target, 'files', 0 ) || null;

	if ( file && !this.isAllowedType( file.type ) ) {
		file = null;
	}

	this.setValue( file );
	this.addInput();
};

/**
 * Handle clear button click events.
 *
 * @private
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onClearClick = function () {
	this.setValue( null );
	return false;
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onKeyPress = function ( e ) {
	if ( this.isSupported && !this.isDisabled() && this.$input &&
		( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		this.$input.click();
		return false;
	}
};

/**
 * Handle drop target click events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDropTargetClick = function () {
	if ( this.isSupported && !this.isDisabled() && this.$input ) {
		this.$input.click();
		return false;
	}
};

/**
 * Handle drag enter and over events
 *
 * @private
 * @param {jQuery.Event} e Drag event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDragEnterOrOver = function ( e ) {
	var itemOrFile,
		droppableFile = false,
		dt = e.originalEvent.dataTransfer;

	e.preventDefault();
	e.stopPropagation();

	if ( this.isDisabled() || !this.isSupported ) {
		this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );
		dt.dropEffect = 'none';
		return false;
	}

	// DataTransferItem and File both have a type property, but in Chrome files
	// have no information at this point.
	itemOrFile = OO.getProp( dt, 'items', 0 ) || OO.getProp( dt, 'files', 0 );
	if ( itemOrFile ) {
		if ( this.isAllowedType( itemOrFile.type ) ) {
			droppableFile = true;
		}
	// dt.types is Array-like, but not an Array
	} else if ( Array.prototype.indexOf.call( OO.getProp( dt, 'types' ) || [], 'Files' ) !== -1 ) {
		// File information is not available at this point for security so just assume
		// it is acceptable for now.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=640534
		droppableFile = true;
	}

	this.$element.toggleClass( 'oo-ui-selectFileWidget-canDrop', droppableFile );
	if ( !droppableFile ) {
		dt.dropEffect = 'none';
	}

	return false;
};

/**
 * Handle drag leave events
 *
 * @private
 * @param {jQuery.Event} e Drag event
 */
OO.ui.SelectFileWidget.prototype.onDragLeave = function () {
	this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );
};

/**
 * Handle drop events
 *
 * @private
 * @param {jQuery.Event} e Drop event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDrop = function ( e ) {
	var file = null,
		dt = e.originalEvent.dataTransfer;

	e.preventDefault();
	e.stopPropagation();
	this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );

	if ( this.isDisabled() || !this.isSupported ) {
		return false;
	}

	file = OO.getProp( dt, 'files', 0 );
	if ( file && !this.isAllowedType( file.type ) ) {
		file = null;
	}
	if ( file ) {
		this.setValue( file );
	}

	return false;
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.setDisabled = function ( disabled ) {
	OO.ui.SelectFileWidget.parent.prototype.setDisabled.call( this, disabled );
	if ( this.selectButton ) {
		this.selectButton.setDisabled( disabled );
	}
	if ( this.clearButton ) {
		this.clearButton.setDisabled( disabled );
	}
	return this;
};

/**
 * SearchWidgets combine a {@link OO.ui.TextInputWidget text input field}, where users can type a search query,
 * and a menu of search results, which is displayed beneath the query
 * field. Unlike {@link OO.ui.mixin.LookupElement lookup menus}, search result menus are always visible to the user.
 * Users can choose an item from the menu or type a query into the text field to search for a matching result item.
 * In general, search widgets are used inside a separate {@link OO.ui.Dialog dialog} window.
 *
 * Each time the query is changed, the search result menu is cleared and repopulated. Please see
 * the [OOUI demos][1] for an example.
 *
 * [1]: https://doc.wikimedia.org/oojs-ui/master/demos/#SearchInputWidget-type-search
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string|jQuery} [placeholder] Placeholder text for query input
 * @cfg {string} [value] Initial query value
 */
OO.ui.SearchWidget = function OoUiSearchWidget( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.SearchWidget.parent.call( this, config );

	// Properties
	this.query = new OO.ui.TextInputWidget( {
		icon: 'search',
		placeholder: config.placeholder,
		value: config.value
	} );
	this.results = new OO.ui.SelectWidget();
	this.$query = $( '<div>' );
	this.$results = $( '<div>' );

	// Events
	this.query.connect( this, {
		change: 'onQueryChange',
		enter: 'onQueryEnter'
	} );
	this.query.$input.on( 'keydown', this.onQueryKeydown.bind( this ) );

	// Initialization
	this.$query
		.addClass( 'oo-ui-searchWidget-query' )
		.append( this.query.$element );
	this.$results
		.addClass( 'oo-ui-searchWidget-results' )
		.append( this.results.$element );
	this.$element
		.addClass( 'oo-ui-searchWidget' )
		.append( this.$results, this.$query );
};

/* Setup */

OO.inheritClass( OO.ui.SearchWidget, OO.ui.Widget );

/* Methods */

/**
 * Handle query key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 */
OO.ui.SearchWidget.prototype.onQueryKeydown = function ( e ) {
	var highlightedItem, nextItem,
		dir = e.which === OO.ui.Keys.DOWN ? 1 : ( e.which === OO.ui.Keys.UP ? -1 : 0 );

	if ( dir ) {
		highlightedItem = this.results.findHighlightedItem();
		if ( !highlightedItem ) {
			highlightedItem = this.results.findSelectedItem();
		}
		nextItem = this.results.findRelativeSelectableItem( highlightedItem, dir );
		this.results.highlightItem( nextItem );
		nextItem.scrollElementIntoView();
	}
};

/**
 * Handle select widget select events.
 *
 * Clears existing results. Subclasses should repopulate items according to new query.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.SearchWidget.prototype.onQueryChange = function () {
	// Reset
	this.results.clearItems();
};

/**
 * Handle select widget enter key events.
 *
 * Chooses highlighted item.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.SearchWidget.prototype.onQueryEnter = function () {
	var highlightedItem = this.results.findHighlightedItem();
	if ( highlightedItem ) {
		this.results.chooseItem( highlightedItem );
	}
};

/**
 * Get the query input.
 *
 * @return {OO.ui.TextInputWidget} Query input
 */
OO.ui.SearchWidget.prototype.getQuery = function () {
	return this.query;
};

/**
 * Get the search results menu.
 *
 * @return {OO.ui.SelectWidget} Menu of search results
 */
OO.ui.SearchWidget.prototype.getResults = function () {
	return this.results;
};

}( OO ) );

//# sourceMappingURL=oojs-ui-widgets.js.map.json
/*!
 * OOUI v0.30.2
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2019 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2019-01-23T01:14:20Z
 */
( function ( OO ) {

'use strict';

/**
 * Toolbars are complex interface components that permit users to easily access a variety
 * of {@link OO.ui.Tool tools} (e.g., formatting commands) and actions, which are additional commands that are
 * part of the toolbar, but not configured as tools.
 *
 * Individual tools are customized and then registered with a {@link OO.ui.ToolFactory tool factory}, which creates
 * the tools on demand. Each tool has a symbolic name (used when registering the tool), a title (e.g., ‘Insert
 * image’), and an icon.
 *
 * Individual tools are organized in {@link OO.ui.ToolGroup toolgroups}, which can be {@link OO.ui.MenuToolGroup menus}
 * of tools, {@link OO.ui.ListToolGroup lists} of tools, or a single {@link OO.ui.BarToolGroup bar} of tools.
 * The arrangement and order of the toolgroups is customized when the toolbar is set up. Tools can be presented in
 * any order, but each can only appear once in the toolbar.
 *
 * The toolbar can be synchronized with the state of the external "application", like a text
 * editor's editing area, marking tools as active/inactive (e.g. a 'bold' tool would be shown as
 * active when the text cursor was inside bolded text) or enabled/disabled (e.g. a table caption
 * tool would be disabled while the user is not editing a table). A state change is signalled by
 * emitting the {@link #event-updateState 'updateState' event}, which calls Tools'
 * {@link OO.ui.Tool#onUpdateState onUpdateState method}.
 *
 * The following is an example of a basic toolbar.
 *
 *     @example
 *     // Example of a toolbar
 *     // Create the toolbar
 *     var toolFactory = new OO.ui.ToolFactory();
 *     var toolGroupFactory = new OO.ui.ToolGroupFactory();
 *     var toolbar = new OO.ui.Toolbar( toolFactory, toolGroupFactory );
 *
 *     // We will be placing status text in this element when tools are used
 *     var $area = $( '<p>' ).text( 'Toolbar example' );
 *
 *     // Define the tools that we're going to place in our toolbar
 *
 *     // Create a class inheriting from OO.ui.Tool
 *     function SearchTool() {
 *         SearchTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( SearchTool, OO.ui.Tool );
 *     // Each tool must have a 'name' (used as an internal identifier, see later) and at least one
 *     // of 'icon' and 'title' (displayed icon and text).
 *     SearchTool.static.name = 'search';
 *     SearchTool.static.icon = 'search';
 *     SearchTool.static.title = 'Search...';
 *     // Defines the action that will happen when this tool is selected (clicked).
 *     SearchTool.prototype.onSelect = function () {
 *         $area.text( 'Search tool clicked!' );
 *         // Never display this tool as "active" (selected).
 *         this.setActive( false );
 *     };
 *     SearchTool.prototype.onUpdateState = function () {};
 *     // Make this tool available in our toolFactory and thus our toolbar
 *     toolFactory.register( SearchTool );
 *
 *     // Register two more tools, nothing interesting here
 *     function SettingsTool() {
 *         SettingsTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( SettingsTool, OO.ui.Tool );
 *     SettingsTool.static.name = 'settings';
 *     SettingsTool.static.icon = 'settings';
 *     SettingsTool.static.title = 'Change settings';
 *     SettingsTool.prototype.onSelect = function () {
 *         $area.text( 'Settings tool clicked!' );
 *         this.setActive( false );
 *     };
 *     SettingsTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( SettingsTool );
 *
 *     // Register two more tools, nothing interesting here
 *     function StuffTool() {
 *         StuffTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( StuffTool, OO.ui.Tool );
 *     StuffTool.static.name = 'stuff';
 *     StuffTool.static.icon = 'ellipsis';
 *     StuffTool.static.title = 'More stuff';
 *     StuffTool.prototype.onSelect = function () {
 *         $area.text( 'More stuff tool clicked!' );
 *         this.setActive( false );
 *     };
 *     StuffTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( StuffTool );
 *
 *     // This is a PopupTool. Rather than having a custom 'onSelect' action, it will display a
 *     // little popup window (a PopupWidget).
 *     function HelpTool( toolGroup, config ) {
 *         OO.ui.PopupTool.call( this, toolGroup, $.extend( { popup: {
 *             padded: true,
 *             label: 'Help',
 *             head: true
 *         } }, config ) );
 *         this.popup.$body.append( '<p>I am helpful!</p>' );
 *     }
 *     OO.inheritClass( HelpTool, OO.ui.PopupTool );
 *     HelpTool.static.name = 'help';
 *     HelpTool.static.icon = 'help';
 *     HelpTool.static.title = 'Help';
 *     toolFactory.register( HelpTool );
 *
 *     // Finally define which tools and in what order appear in the toolbar. Each tool may only be
 *     // used once (but not all defined tools must be used).
 *     toolbar.setup( [
 *         {
 *             // 'bar' tool groups display tools' icons only, side-by-side.
 *             type: 'bar',
 *             include: [ 'search', 'help' ]
 *         },
 *         {
 *             // 'list' tool groups display both the titles and icons, in a dropdown list.
 *             type: 'list',
 *             indicator: 'down',
 *             label: 'More',
 *             include: [ 'settings', 'stuff' ]
 *         }
 *         // Note how the tools themselves are toolgroup-agnostic - the same tool can be displayed
 *         // either in a 'list' or a 'bar'. There is a 'menu' tool group too, not showcased here,
 *         // since it's more complicated to use. (See the next example snippet on this page.)
 *     ] );
 *
 *     // Create some UI around the toolbar and place it in the document
 *     var frame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true
 *     } );
 *     var contentFrame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         padded: true
 *     } );
 *     frame.$element.append(
 *         toolbar.$element,
 *         contentFrame.$element.append( $area )
 *     );
 *     $( document.body ).append( frame.$element );
 *
 *     // Here is where the toolbar is actually built. This must be done after inserting it into the
 *     // document.
 *     toolbar.initialize();
 *     toolbar.emit( 'updateState' );
 *
 * The following example extends the previous one to illustrate 'menu' toolgroups and the usage of
 * {@link #event-updateState 'updateState' event}.
 *
 *     @example
 *     // Create the toolbar
 *     var toolFactory = new OO.ui.ToolFactory();
 *     var toolGroupFactory = new OO.ui.ToolGroupFactory();
 *     var toolbar = new OO.ui.Toolbar( toolFactory, toolGroupFactory );
 *
 *     // We will be placing status text in this element when tools are used
 *     var $area = $( '<p>' ).text( 'Toolbar example' );
 *
 *     // Define the tools that we're going to place in our toolbar
 *
 *     // Create a class inheriting from OO.ui.Tool
 *     function SearchTool() {
 *         SearchTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( SearchTool, OO.ui.Tool );
 *     // Each tool must have a 'name' (used as an internal identifier, see later) and at least one
 *     // of 'icon' and 'title' (displayed icon and text).
 *     SearchTool.static.name = 'search';
 *     SearchTool.static.icon = 'search';
 *     SearchTool.static.title = 'Search...';
 *     // Defines the action that will happen when this tool is selected (clicked).
 *     SearchTool.prototype.onSelect = function () {
 *         $area.text( 'Search tool clicked!' );
 *         // Never display this tool as "active" (selected).
 *         this.setActive( false );
 *     };
 *     SearchTool.prototype.onUpdateState = function () {};
 *     // Make this tool available in our toolFactory and thus our toolbar
 *     toolFactory.register( SearchTool );
 *
 *     // Register two more tools, nothing interesting here
 *     function SettingsTool() {
 *         SettingsTool.parent.apply( this, arguments );
 *         this.reallyActive = false;
 *     }
 *     OO.inheritClass( SettingsTool, OO.ui.Tool );
 *     SettingsTool.static.name = 'settings';
 *     SettingsTool.static.icon = 'settings';
 *     SettingsTool.static.title = 'Change settings';
 *     SettingsTool.prototype.onSelect = function () {
 *         $area.text( 'Settings tool clicked!' );
 *         // Toggle the active state on each click
 *         this.reallyActive = !this.reallyActive;
 *         this.setActive( this.reallyActive );
 *         // To update the menu label
 *         this.toolbar.emit( 'updateState' );
 *     };
 *     SettingsTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( SettingsTool );
 *
 *     // Register two more tools, nothing interesting here
 *     function StuffTool() {
 *         StuffTool.parent.apply( this, arguments );
 *         this.reallyActive = false;
 *     }
 *     OO.inheritClass( StuffTool, OO.ui.Tool );
 *     StuffTool.static.name = 'stuff';
 *     StuffTool.static.icon = 'ellipsis';
 *     StuffTool.static.title = 'More stuff';
 *     StuffTool.prototype.onSelect = function () {
 *         $area.text( 'More stuff tool clicked!' );
 *         // Toggle the active state on each click
 *         this.reallyActive = !this.reallyActive;
 *         this.setActive( this.reallyActive );
 *         // To update the menu label
 *         this.toolbar.emit( 'updateState' );
 *     };
 *     StuffTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( StuffTool );
 *
 *     // This is a PopupTool. Rather than having a custom 'onSelect' action, it will display a
 *     // little popup window (a PopupWidget). 'onUpdateState' is also already implemented.
 *     function HelpTool( toolGroup, config ) {
 *         OO.ui.PopupTool.call( this, toolGroup, $.extend( { popup: {
 *             padded: true,
 *             label: 'Help',
 *             head: true
 *         } }, config ) );
 *         this.popup.$body.append( '<p>I am helpful!</p>' );
 *     }
 *     OO.inheritClass( HelpTool, OO.ui.PopupTool );
 *     HelpTool.static.name = 'help';
 *     HelpTool.static.icon = 'help';
 *     HelpTool.static.title = 'Help';
 *     toolFactory.register( HelpTool );
 *
 *     // Finally define which tools and in what order appear in the toolbar. Each tool may only be
 *     // used once (but not all defined tools must be used).
 *     toolbar.setup( [
 *         {
 *             // 'bar' tool groups display tools' icons only, side-by-side.
 *             type: 'bar',
 *             include: [ 'search', 'help' ]
 *         },
 *         {
 *             // 'menu' tool groups display both the titles and icons, in a dropdown menu.
 *             // Menu label indicates which items are selected.
 *             type: 'menu',
 *             indicator: 'down',
 *             include: [ 'settings', 'stuff' ]
 *         }
 *     ] );
 *
 *     // Create some UI around the toolbar and place it in the document
 *     var frame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true
 *     } );
 *     var contentFrame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         padded: true
 *     } );
 *     frame.$element.append(
 *         toolbar.$element,
 *         contentFrame.$element.append( $area )
 *     );
 *     $( document.body ).append( frame.$element );
 *
 *     // Here is where the toolbar is actually built. This must be done after inserting it into the
 *     // document.
 *     toolbar.initialize();
 *     toolbar.emit( 'updateState' );
 *
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {OO.ui.ToolFactory} toolFactory Factory for creating tools
 * @param {OO.ui.ToolGroupFactory} toolGroupFactory Factory for creating toolgroups
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [actions] Add an actions section to the toolbar. Actions are commands that are included
 *  in the toolbar, but are not configured as tools. By default, actions are displayed on the right side of
 *  the toolbar.
 * @cfg {string} [position='top'] Whether the toolbar is positioned above ('top') or below ('bottom') content.
 * @cfg {jQuery} [$overlay] An overlay for the popup.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.Toolbar = function OoUiToolbar( toolFactory, toolGroupFactory, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolFactory ) && config === undefined ) {
		config = toolFactory;
		toolFactory = config.toolFactory;
		toolGroupFactory = config.toolGroupFactory;
	}

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.Toolbar.parent.call( this, config );

	// Mixin constructors
	OO.EventEmitter.call( this );
	OO.ui.mixin.GroupElement.call( this, config );

	// Properties
	this.toolFactory = toolFactory;
	this.toolGroupFactory = toolGroupFactory;
	this.groupsByName = {};
	this.activeToolGroups = 0;
	this.tools = {};
	this.position = config.position || 'top';
	this.$bar = $( '<div>' );
	this.$actions = $( '<div>' );
	this.$popups = $( '<div>' );
	this.initialized = false;
	this.narrowThreshold = null;
	this.onWindowResizeHandler = this.onWindowResize.bind( this );
	this.$overlay = ( config.$overlay === true ? OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

	// Events
	this.$element
		.add( this.$bar ).add( this.$group ).add( this.$actions )
		.on( 'mousedown keydown', this.onPointerDown.bind( this ) );

	// Initialization
	this.$group.addClass( 'oo-ui-toolbar-tools' );
	if ( config.actions ) {
		this.$bar.append( this.$actions.addClass( 'oo-ui-toolbar-actions' ) );
	}
	this.$popups.addClass( 'oo-ui-toolbar-popups' );
	this.$bar
		.addClass( 'oo-ui-toolbar-bar' )
		.append( this.$group, '<div style="clear:both"></div>' );
	// Possible classes: oo-ui-toolbar-position-top, oo-ui-toolbar-position-bottom
	this.$element.addClass( 'oo-ui-toolbar oo-ui-toolbar-position-' + this.position ).append( this.$bar );
	this.$overlay.append( this.$popups );
};

/* Setup */

OO.inheritClass( OO.ui.Toolbar, OO.ui.Element );
OO.mixinClass( OO.ui.Toolbar, OO.EventEmitter );
OO.mixinClass( OO.ui.Toolbar, OO.ui.mixin.GroupElement );

/* Events */

/**
 * @event updateState
 *
 * An 'updateState' event must be emitted on the Toolbar (by calling `toolbar.emit( 'updateState' )`)
 * every time the state of the application using the toolbar changes, and an update to the state of
 * tools is required.
 *
 * @param {...Mixed} data Application-defined parameters
 */

/**
 * @event active
 *
 * An 'active' event is emitted when the number of active toolgroups increases from 0, or
 * returns to 0.
 *
 * @param {boolean} There are active toolgroups in this toolbar
 */

/* Methods */

/**
 * Get the tool factory.
 *
 * @return {OO.ui.ToolFactory} Tool factory
 */
OO.ui.Toolbar.prototype.getToolFactory = function () {
	return this.toolFactory;
};

/**
 * Get the toolgroup factory.
 *
 * @return {OO.Factory} Toolgroup factory
 */
OO.ui.Toolbar.prototype.getToolGroupFactory = function () {
	return this.toolGroupFactory;
};

/**
 * Handles mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.Toolbar.prototype.onPointerDown = function ( e ) {
	var $closestWidgetToEvent = $( e.target ).closest( '.oo-ui-widget' ),
		$closestWidgetToToolbar = this.$element.closest( '.oo-ui-widget' );
	if ( !$closestWidgetToEvent.length || $closestWidgetToEvent[ 0 ] === $closestWidgetToToolbar[ 0 ] ) {
		return false;
	}
};

/**
 * Handle window resize event.
 *
 * @private
 * @param {jQuery.Event} e Window resize event
 */
OO.ui.Toolbar.prototype.onWindowResize = function () {
	this.$element.add( this.$popups ).toggleClass(
		'oo-ui-toolbar-narrow',
		this.$bar[ 0 ].clientWidth <= this.getNarrowThreshold()
	);
};

/**
 * Get the (lazily-computed) width threshold for applying the oo-ui-toolbar-narrow
 * class.
 *
 * @private
 * @return {number} Width threshold in pixels
 */
OO.ui.Toolbar.prototype.getNarrowThreshold = function () {
	if ( this.narrowThreshold === null ) {
		this.narrowThreshold = this.$group[ 0 ].offsetWidth + this.$actions[ 0 ].offsetWidth;
	}
	return this.narrowThreshold;
};

/**
 * Sets up handles and preloads required information for the toolbar to work.
 * This must be called after it is attached to a visible document and before doing anything else.
 */
OO.ui.Toolbar.prototype.initialize = function () {
	if ( !this.initialized ) {
		this.initialized = true;
		$( this.getElementWindow() ).on( 'resize', this.onWindowResizeHandler );
		this.onWindowResize();
	}
};

/**
 * Set up the toolbar.
 *
 * The toolbar is set up with a list of toolgroup configurations that specify the type of
 * toolgroup ({@link OO.ui.BarToolGroup bar}, {@link OO.ui.MenuToolGroup menu}, or {@link OO.ui.ListToolGroup list})
 * to add and which tools to include, exclude, promote, or demote within that toolgroup. Please
 * see {@link OO.ui.ToolGroup toolgroups} for more information about including tools in toolgroups.
 *
 * @param {Object.<string,Array>} groups List of toolgroup configurations
 * @param {string} [groups.name] Symbolic name for this toolgroup
 * @param {string} [groups.type] Toolgroup type, should exist in the toolgroup factory
 * @param {Array|string} [groups.include] Tools to include in the toolgroup
 * @param {Array|string} [groups.exclude] Tools to exclude from the toolgroup
 * @param {Array|string} [groups.promote] Tools to promote to the beginning of the toolgroup
 * @param {Array|string} [groups.demote] Tools to demote to the end of the toolgroup
 */
OO.ui.Toolbar.prototype.setup = function ( groups ) {
	var i, len, type, toolGroup, groupConfig,
		items = [],
		defaultType = 'bar';

	// Cleanup previous groups
	this.reset();

	// Build out new groups
	for ( i = 0, len = groups.length; i < len; i++ ) {
		groupConfig = groups[ i ];
		if ( groupConfig.include === '*' ) {
			// Apply defaults to catch-all groups
			if ( groupConfig.type === undefined ) {
				groupConfig.type = 'list';
			}
			if ( groupConfig.label === undefined ) {
				groupConfig.label = OO.ui.msg( 'ooui-toolbar-more' );
			}
		}
		// Check type has been registered
		type = this.getToolGroupFactory().lookup( groupConfig.type ) ? groupConfig.type : defaultType;
		toolGroup = this.getToolGroupFactory().create( type, this, groupConfig );
		items.push( toolGroup );
		if ( groupConfig.name ) {
			this.groupsByName[ groupConfig.name ] = toolGroup;
		} else {
			// Groups without name are deprecated
			OO.ui.warnDeprecation( 'Toolgroups must have a \'name\' property' );
		}
		toolGroup.connect( this, { active: 'onToolGroupActive' } );
	}
	this.addItems( items );
};

/**
 * Handle active events from tool groups
 *
 * @param {boolean} active Tool group has become active, inactive if false
 * @fires active
 */
OO.ui.Toolbar.prototype.onToolGroupActive = function ( active ) {
	if ( active ) {
		this.activeToolGroups++;
		if ( this.activeToolGroups === 1 ) {
			this.emit( 'active', true );
		}
	} else {
		this.activeToolGroups--;
		if ( this.activeToolGroups === 0 ) {
			this.emit( 'active', false );
		}
	}
};

/**
 * Get a toolgroup by name
 *
 * @param {string} name Group name
 * @return {OO.ui.ToolGroup|null} Tool group, or null if none found by that name
 */
OO.ui.Toolbar.prototype.getToolGroupByName = function ( name ) {
	return this.groupsByName[ name ] || null;
};

/**
 * Remove all tools and toolgroups from the toolbar.
 */
OO.ui.Toolbar.prototype.reset = function () {
	var i, len;

	this.groupsByName = {};
	this.tools = {};
	for ( i = 0, len = this.items.length; i < len; i++ ) {
		this.items[ i ].destroy();
	}
	this.clearItems();
};

/**
 * Destroy the toolbar.
 *
 * Destroying the toolbar removes all event handlers and DOM elements that constitute the toolbar. Call
 * this method whenever you are done using a toolbar.
 */
OO.ui.Toolbar.prototype.destroy = function () {
	$( this.getElementWindow() ).off( 'resize', this.onWindowResizeHandler );
	this.reset();
	this.$element.remove();
};

/**
 * Check if the tool is available.
 *
 * Available tools are ones that have not yet been added to the toolbar.
 *
 * @param {string} name Symbolic name of tool
 * @return {boolean} Tool is available
 */
OO.ui.Toolbar.prototype.isToolAvailable = function ( name ) {
	return !this.tools[ name ];
};

/**
 * Prevent tool from being used again.
 *
 * @param {OO.ui.Tool} tool Tool to reserve
 */
OO.ui.Toolbar.prototype.reserveTool = function ( tool ) {
	this.tools[ tool.getName() ] = tool;
};

/**
 * Allow tool to be used again.
 *
 * @param {OO.ui.Tool} tool Tool to release
 */
OO.ui.Toolbar.prototype.releaseTool = function ( tool ) {
	delete this.tools[ tool.getName() ];
};

/**
 * Get accelerator label for tool.
 *
 * The OOUI library does not contain an accelerator system, but this is the hook for one. To
 * use an accelerator system, subclass the toolbar and override this method, which is meant to return a label
 * that describes the accelerator keys for the tool passed (by symbolic name) to the method.
 *
 * @param {string} name Symbolic name of tool
 * @return {string|undefined} Tool accelerator label if available
 */
OO.ui.Toolbar.prototype.getToolAccelerator = function () {
	return undefined;
};

/**
 * Tools, together with {@link OO.ui.ToolGroup toolgroups}, constitute {@link OO.ui.Toolbar toolbars}.
 * Each tool is configured with a static name, title, and icon and is customized with the command to carry
 * out when the tool is selected. Tools must also be registered with a {@link OO.ui.ToolFactory tool factory},
 * which creates the tools on demand.
 *
 * Every Tool subclass must implement two methods:
 *
 * - {@link #onUpdateState}
 * - {@link #onSelect}
 *
 * Tools are added to toolgroups ({@link OO.ui.ListToolGroup ListToolGroup},
 * {@link OO.ui.BarToolGroup BarToolGroup}, or {@link OO.ui.MenuToolGroup MenuToolGroup}), which determine how
 * the tool is displayed in the toolbar. See {@link OO.ui.Toolbar toolbars} for an example.
 *
 * For more information, please see the [OOUI documentation on MediaWiki][1].
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 * @cfg {string|Function} [title] Title text or a function that returns text. If this config is omitted, the value of
 *  the {@link #static-title static title} property is used.
 *
 *  The title is used in different ways depending on the type of toolgroup that contains the tool. The
 *  title is used as a tooltip if the tool is part of a {@link OO.ui.BarToolGroup bar} toolgroup, or as the label text if the tool is
 *  part of a {@link OO.ui.ListToolGroup list} or {@link OO.ui.MenuToolGroup menu} toolgroup.
 *
 *  For bar toolgroups, a description of the accelerator key is appended to the title if an accelerator key
 *  is associated with an action by the same name as the tool and accelerator functionality has been added to the application.
 *  To add accelerator key functionality, you must subclass OO.ui.Toolbar and override the {@link OO.ui.Toolbar#getToolAccelerator getToolAccelerator} method.
 */
OO.ui.Tool = function OoUiTool( toolGroup, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolGroup ) && config === undefined ) {
		config = toolGroup;
		toolGroup = config.toolGroup;
	}

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.Tool.parent.call( this, config );

	// Properties
	this.toolGroup = toolGroup;
	this.toolbar = this.toolGroup.getToolbar();
	this.active = false;
	this.$title = $( '<span>' );
	this.$accel = $( '<span>' );
	this.$link = $( '<a>' );
	this.title = null;
	this.checkIcon = new OO.ui.IconWidget( {
		icon: 'check',
		classes: [ 'oo-ui-tool-checkIcon' ]
	} );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$link } ) );

	// Events
	this.toolbar.connect( this, { updateState: 'onUpdateState' } );

	// Initialization
	this.$title.addClass( 'oo-ui-tool-title' );
	this.$accel
		.addClass( 'oo-ui-tool-accel' )
		.prop( {
			// This may need to be changed if the key names are ever localized,
			// but for now they are essentially written in English
			dir: 'ltr',
			lang: 'en'
		} );
	this.$link
		.addClass( 'oo-ui-tool-link' )
		.append( this.checkIcon.$element, this.$icon, this.$title, this.$accel )
		.attr( 'role', 'button' );
	this.$element
		.data( 'oo-ui-tool', this )
		.addClass( 'oo-ui-tool' )
		.addClass( 'oo-ui-tool-name-' + this.constructor.static.name.replace( /^([^/]+)\/([^/]+).*$/, '$1-$2' ) )
		.toggleClass( 'oo-ui-tool-with-label', this.constructor.static.displayBothIconAndLabel )
		.append( this.$link );
	this.setTitle( config.title || this.constructor.static.title );
};

/* Setup */

OO.inheritClass( OO.ui.Tool, OO.ui.Widget );
OO.mixinClass( OO.ui.Tool, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.Tool, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.Tool, OO.ui.mixin.TabIndexedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.Tool.static.tagName = 'span';

/**
 * Symbolic name of tool.
 *
 * The symbolic name is used internally to register the tool with a {@link OO.ui.ToolFactory ToolFactory}. It can
 * also be used when adding tools to toolgroups.
 *
 * @abstract
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Tool.static.name = '';

/**
 * Symbolic name of the group.
 *
 * The group name is used to associate tools with each other so that they can be selected later by
 * a {@link OO.ui.ToolGroup toolgroup}.
 *
 * @abstract
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Tool.static.group = '';

/**
 * Tool title text or a function that returns title text. The value of the static property is overridden if the #title config option is used.
 *
 * @abstract
 * @static
 * @inheritable
 * @property {string|Function}
 */
OO.ui.Tool.static.title = '';

/**
 * Display both icon and label when the tool is used in a {@link OO.ui.BarToolGroup bar} toolgroup.
 * Normally only the icon is displayed, or only the label if no icon is given.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.Tool.static.displayBothIconAndLabel = false;

/**
 * Add tool to catch-all groups automatically.
 *
 * A catch-all group, which contains all tools that do not currently belong to a toolgroup,
 * can be included in a toolgroup using the wildcard selector, an asterisk (*).
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.Tool.static.autoAddToCatchall = true;

/**
 * Add tool to named groups automatically.
 *
 * By default, tools that are configured with a static ‘group’ property are added
 * to that group and will be selected when the symbolic name of the group is specified (e.g., when
 * toolgroups include tools by group name).
 *
 * @static
 * @property {boolean}
 * @inheritable
 */
OO.ui.Tool.static.autoAddToGroup = true;

/**
 * Check if this tool is compatible with given data.
 *
 * This is a stub that can be overridden to provide support for filtering tools based on an
 * arbitrary piece of information  (e.g., where the cursor is in a document). The implementation
 * must also call this method so that the compatibility check can be performed.
 *
 * @static
 * @inheritable
 * @param {Mixed} data Data to check
 * @return {boolean} Tool can be used with data
 */
OO.ui.Tool.static.isCompatibleWith = function () {
	return false;
};

/* Methods */

/**
 * Handle the toolbar state being updated. This method is called when the
 * {@link OO.ui.Toolbar#event-updateState 'updateState' event} is emitted on the
 * {@link OO.ui.Toolbar Toolbar} that uses this tool, and should set the state of this tool
 * depending on application state (usually by calling #setDisabled to enable or disable the tool,
 * or #setActive to mark is as currently in-use or not).
 *
 * This is an abstract method that must be overridden in a concrete subclass.
 *
 * @method
 * @protected
 * @abstract
 */
OO.ui.Tool.prototype.onUpdateState = null;

/**
 * Handle the tool being selected. This method is called when the user triggers this tool,
 * usually by clicking on its label/icon.
 *
 * This is an abstract method that must be overridden in a concrete subclass.
 *
 * @method
 * @protected
 * @abstract
 */
OO.ui.Tool.prototype.onSelect = null;

/**
 * Check if the tool is active.
 *
 * Tools become active when their #onSelect or #onUpdateState handlers change them to appear pressed
 * with the #setActive method. Additional CSS is applied to the tool to reflect the active state.
 *
 * @return {boolean} Tool is active
 */
OO.ui.Tool.prototype.isActive = function () {
	return this.active;
};

/**
 * Make the tool appear active or inactive.
 *
 * This method should be called within #onSelect or #onUpdateState event handlers to make the tool
 * appear pressed or not.
 *
 * @param {boolean} state Make tool appear active
 */
OO.ui.Tool.prototype.setActive = function ( state ) {
	this.active = !!state;
	this.$element.toggleClass( 'oo-ui-tool-active', this.active );
	this.updateThemeClasses();
};

/**
 * Set the tool #title.
 *
 * @param {string|Function} title Title text or a function that returns text
 * @chainable
 * @return {OO.ui.Tool} The tool, for chaining
 */
OO.ui.Tool.prototype.setTitle = function ( title ) {
	this.title = OO.ui.resolveMsg( title );
	this.updateTitle();
	return this;
};

/**
 * Get the tool #title.
 *
 * @return {string} Title text
 */
OO.ui.Tool.prototype.getTitle = function () {
	return this.title;
};

/**
 * Get the tool's symbolic name.
 *
 * @return {string} Symbolic name of tool
 */
OO.ui.Tool.prototype.getName = function () {
	return this.constructor.static.name;
};

/**
 * Update the title.
 */
OO.ui.Tool.prototype.updateTitle = function () {
	var titleTooltips = this.toolGroup.constructor.static.titleTooltips,
		accelTooltips = this.toolGroup.constructor.static.accelTooltips,
		accel = this.toolbar.getToolAccelerator( this.constructor.static.name ),
		tooltipParts = [];

	this.$title.text( this.title );
	this.$accel.text( accel );

	if ( titleTooltips && typeof this.title === 'string' && this.title.length ) {
		tooltipParts.push( this.title );
	}
	if ( accelTooltips && typeof accel === 'string' && accel.length ) {
		tooltipParts.push( accel );
	}
	if ( tooltipParts.length ) {
		this.$link.attr( 'title', tooltipParts.join( ' ' ) );
	} else {
		this.$link.removeAttr( 'title' );
	}
};

/**
 * Destroy tool.
 *
 * Destroying the tool removes all event handlers and the tool’s DOM elements.
 * Call this method whenever you are done using a tool.
 */
OO.ui.Tool.prototype.destroy = function () {
	this.toolbar.disconnect( this );
	this.$element.remove();
};

/**
 * ToolGroups are collections of {@link OO.ui.Tool tools} that are used in a {@link OO.ui.Toolbar toolbar}.
 * The type of toolgroup ({@link OO.ui.ListToolGroup list}, {@link OO.ui.BarToolGroup bar}, or {@link OO.ui.MenuToolGroup menu})
 * to which a tool belongs determines how the tool is arranged and displayed in the toolbar. Toolgroups
 * themselves are created on demand with a {@link OO.ui.ToolGroupFactory toolgroup factory}.
 *
 * Toolgroups can contain individual tools, groups of tools, or all available tools, as specified
 * using the `include` config option. See OO.ui.ToolFactory#extract on documentation of the format.
 * The options `exclude`, `promote`, and `demote` support the same formats.
 *
 * See {@link OO.ui.Toolbar toolbars} for a full example. For more information about toolbars in general,
 * please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {OO.ui.Toolbar} toolbar
 * @param {Object} [config] Configuration options
 * @cfg {Array|string} [include] List of tools to include in the toolgroup, see above.
 * @cfg {Array|string} [exclude] List of tools to exclude from the toolgroup, see above.
 * @cfg {Array|string} [promote] List of tools to promote to the beginning of the toolgroup, see above.
 * @cfg {Array|string} [demote] List of tools to demote to the end of the toolgroup, see above.
 *  This setting is particularly useful when tools have been added to the toolgroup
 *  en masse (e.g., via the catch-all selector).
 */
OO.ui.ToolGroup = function OoUiToolGroup( toolbar, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolbar ) && config === undefined ) {
		config = toolbar;
		toolbar = config.toolbar;
	}

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.ToolGroup.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.GroupElement.call( this, config );

	// Properties
	this.toolbar = toolbar;
	this.tools = {};
	this.pressed = null;
	this.autoDisabled = false;
	this.include = config.include || [];
	this.exclude = config.exclude || [];
	this.promote = config.promote || [];
	this.demote = config.demote || [];
	this.onDocumentMouseKeyUpHandler = this.onDocumentMouseKeyUp.bind( this );

	// Events
	this.$group.on( {
		mousedown: this.onMouseKeyDown.bind( this ),
		mouseup: this.onMouseKeyUp.bind( this ),
		keydown: this.onMouseKeyDown.bind( this ),
		keyup: this.onMouseKeyUp.bind( this ),
		focus: this.onMouseOverFocus.bind( this ),
		blur: this.onMouseOutBlur.bind( this ),
		mouseover: this.onMouseOverFocus.bind( this ),
		mouseout: this.onMouseOutBlur.bind( this )
	} );
	this.toolbar.getToolFactory().connect( this, { register: 'onToolFactoryRegister' } );
	this.aggregate( { disable: 'itemDisable' } );
	this.connect( this, {
		itemDisable: 'updateDisabled',
		disable: 'onDisable'
	} );

	// Initialization
	this.$group.addClass( 'oo-ui-toolGroup-tools' );
	this.$element
		.addClass( 'oo-ui-toolGroup' )
		.append( this.$group );
	this.onDisable( this.isDisabled() );
	this.populate();
};

/* Setup */

OO.inheritClass( OO.ui.ToolGroup, OO.ui.Widget );
OO.mixinClass( OO.ui.ToolGroup, OO.ui.mixin.GroupElement );

/* Events */

/**
 * @event update
 */

/**
 * @event active
 *
 * An 'active' event is emitted when any popup is shown/hidden.
 *
 * @param {boolean} The popup is visible
 */

/* Static Properties */

/**
 * Show labels in tooltips.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.ToolGroup.static.titleTooltips = false;

/**
 * Show acceleration labels in tooltips.
 *
 * Note: The OOUI library does not include an accelerator system, but does contain
 * a hook for one. To use an accelerator system, subclass the {@link OO.ui.Toolbar toolbar} and
 * override the {@link OO.ui.Toolbar#getToolAccelerator getToolAccelerator} method, which is
 * meant to return a label that describes the accelerator keys for a given tool (e.g., 'Ctrl + M').
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.ToolGroup.static.accelTooltips = false;

/**
 * Automatically disable the toolgroup when all tools are disabled
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.ToolGroup.static.autoDisable = true;

/**
 * @abstract
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.ToolGroup.static.name = null;

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.ToolGroup.prototype.isDisabled = function () {
	return this.autoDisabled || OO.ui.ToolGroup.parent.prototype.isDisabled.apply( this, arguments );
};

/**
 * @inheritdoc
 */
OO.ui.ToolGroup.prototype.updateDisabled = function () {
	var i, item, allDisabled = true;

	if ( this.constructor.static.autoDisable ) {
		for ( i = this.items.length - 1; i >= 0; i-- ) {
			item = this.items[ i ];
			if ( !item.isDisabled() ) {
				allDisabled = false;
				break;
			}
		}
		this.autoDisabled = allDisabled;
	}
	OO.ui.ToolGroup.parent.prototype.updateDisabled.apply( this, arguments );
};

/**
 * Handle disable events.
 *
 * @protected
 * @param {boolean} isDisabled
 */
OO.ui.ToolGroup.prototype.onDisable = function ( isDisabled ) {
	this.$group.toggleClass( 'oo-ui-toolGroup-disabled-tools', isDisabled );
	this.$group.toggleClass( 'oo-ui-toolGroup-enabled-tools', !isDisabled );
};

/**
 * Handle mouse down and key down events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse down or key down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.ToolGroup.prototype.onMouseKeyDown = function ( e ) {
	if (
		!this.isDisabled() &&
		( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		this.pressed = this.findTargetTool( e );
		if ( this.pressed ) {
			this.pressed.setActive( true );
			this.getElementDocument().addEventListener( 'mouseup', this.onDocumentMouseKeyUpHandler, true );
			this.getElementDocument().addEventListener( 'keyup', this.onDocumentMouseKeyUpHandler, true );
			return false;
		}
	}
};

/**
 * Handle document mouse up and key up events.
 *
 * @protected
 * @param {MouseEvent|KeyboardEvent} e Mouse up or key up event
 */
OO.ui.ToolGroup.prototype.onDocumentMouseKeyUp = function ( e ) {
	this.getElementDocument().removeEventListener( 'mouseup', this.onDocumentMouseKeyUpHandler, true );
	this.getElementDocument().removeEventListener( 'keyup', this.onDocumentMouseKeyUpHandler, true );
	// onMouseKeyUp may be called a second time, depending on where the mouse is when the button is
	// released, but since `this.pressed` will no longer be true, the second call will be ignored.
	this.onMouseKeyUp( e );
};

// Deprecated alias since 0.28.3
OO.ui.ToolGroup.prototype.onCapturedMouseKeyUp = function () {
	OO.ui.warnDeprecation( 'onCapturedMouseKeyUp is deprecated, use onDocumentMouseKeyUp instead' );
	this.onDocumentMouseKeyUp.apply( this, arguments );
};

/**
 * Handle mouse up and key up events.
 *
 * @protected
 * @param {MouseEvent|KeyboardEvent} e Mouse up or key up event
 */
OO.ui.ToolGroup.prototype.onMouseKeyUp = function ( e ) {
	var tool = this.findTargetTool( e );

	if (
		!this.isDisabled() && this.pressed && this.pressed === tool &&
		( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		this.pressed.onSelect();
		this.pressed = null;
		e.preventDefault();
		e.stopPropagation();
	}

	this.pressed = null;
};

/**
 * Handle mouse over and focus events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse over or focus event
 */
OO.ui.ToolGroup.prototype.onMouseOverFocus = function ( e ) {
	var tool = this.findTargetTool( e );

	if ( this.pressed && this.pressed === tool ) {
		this.pressed.setActive( true );
	}
};

/**
 * Handle mouse out and blur events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse out or blur event
 */
OO.ui.ToolGroup.prototype.onMouseOutBlur = function ( e ) {
	var tool = this.findTargetTool( e );

	if ( this.pressed && this.pressed === tool ) {
		this.pressed.setActive( false );
	}
};

/**
 * Get the closest tool to a jQuery.Event.
 *
 * Only tool links are considered, which prevents other elements in the tool such as popups from
 * triggering tool group interactions.
 *
 * @private
 * @param {jQuery.Event} e
 * @return {OO.ui.Tool|null} Tool, `null` if none was found
 */
OO.ui.ToolGroup.prototype.findTargetTool = function ( e ) {
	var tool,
		$item = $( e.target ).closest( '.oo-ui-tool-link' );

	if ( $item.length ) {
		tool = $item.parent().data( 'oo-ui-tool' );
	}

	return tool && !tool.isDisabled() ? tool : null;
};

/**
 * Handle tool registry register events.
 *
 * If a tool is registered after the group is created, we must repopulate the list to account for:
 *
 * - a tool being added that may be included
 * - a tool already included being overridden
 *
 * @protected
 * @param {string} name Symbolic name of tool
 */
OO.ui.ToolGroup.prototype.onToolFactoryRegister = function () {
	this.populate();
};

/**
 * Get the toolbar that contains the toolgroup.
 *
 * @return {OO.ui.Toolbar} Toolbar that contains the toolgroup
 */
OO.ui.ToolGroup.prototype.getToolbar = function () {
	return this.toolbar;
};

/**
 * Add and remove tools based on configuration.
 */
OO.ui.ToolGroup.prototype.populate = function () {
	var i, len, name, tool,
		toolFactory = this.toolbar.getToolFactory(),
		names = {},
		add = [],
		remove = [],
		list = this.toolbar.getToolFactory().getTools(
			this.include, this.exclude, this.promote, this.demote
		);

	// Build a list of needed tools
	for ( i = 0, len = list.length; i < len; i++ ) {
		name = list[ i ];
		if (
			// Tool exists
			toolFactory.lookup( name ) &&
			// Tool is available or is already in this group
			( this.toolbar.isToolAvailable( name ) || this.tools[ name ] )
		) {
			// Hack to prevent infinite recursion via ToolGroupTool. We need to reserve the tool before
			// creating it, but we can't call reserveTool() yet because we haven't created the tool.
			this.toolbar.tools[ name ] = true;
			tool = this.tools[ name ];
			if ( !tool ) {
				// Auto-initialize tools on first use
				this.tools[ name ] = tool = toolFactory.create( name, this );
				tool.updateTitle();
			}
			this.toolbar.reserveTool( tool );
			add.push( tool );
			names[ name ] = true;
		}
	}
	// Remove tools that are no longer needed
	for ( name in this.tools ) {
		if ( !names[ name ] ) {
			this.tools[ name ].destroy();
			this.toolbar.releaseTool( this.tools[ name ] );
			remove.push( this.tools[ name ] );
			delete this.tools[ name ];
		}
	}
	if ( remove.length ) {
		this.removeItems( remove );
	}
	// Update emptiness state
	if ( add.length ) {
		this.$element.removeClass( 'oo-ui-toolGroup-empty' );
	} else {
		this.$element.addClass( 'oo-ui-toolGroup-empty' );
	}
	// Re-add tools (moving existing ones to new locations)
	this.addItems( add );
	// Disabled state may depend on items
	this.updateDisabled();
};

/**
 * Destroy toolgroup.
 */
OO.ui.ToolGroup.prototype.destroy = function () {
	var name;

	this.clearItems();
	this.toolbar.getToolFactory().disconnect( this );
	for ( name in this.tools ) {
		this.toolbar.releaseTool( this.tools[ name ] );
		this.tools[ name ].disconnect( this ).destroy();
		delete this.tools[ name ];
	}
	this.$element.remove();
};

/**
 * A ToolFactory creates tools on demand. All tools ({@link OO.ui.Tool Tools}, {@link OO.ui.PopupTool PopupTools},
 * and {@link OO.ui.ToolGroupTool ToolGroupTools}) must be registered with a tool factory. Tools are
 * registered by their symbolic name. See {@link OO.ui.Toolbar toolbars} for an example.
 *
 * For more information about toolbars in general, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @class
 * @extends OO.Factory
 * @constructor
 */
OO.ui.ToolFactory = function OoUiToolFactory() {
	// Parent constructor
	OO.ui.ToolFactory.parent.call( this );
};

/* Setup */

OO.inheritClass( OO.ui.ToolFactory, OO.Factory );

/* Methods */

/**
 * Get tools from the factory
 *
 * @param {Array|string} [include] Included tools, see #extract for format
 * @param {Array|string} [exclude] Excluded tools, see #extract for format
 * @param {Array|string} [promote] Promoted tools, see #extract for format
 * @param {Array|string} [demote] Demoted tools, see #extract for format
 * @return {string[]} List of tools
 */
OO.ui.ToolFactory.prototype.getTools = function ( include, exclude, promote, demote ) {
	var i, len, included, promoted, demoted,
		auto = [],
		used = {};

	// Collect included and not excluded tools
	included = OO.simpleArrayDifference( this.extract( include ), this.extract( exclude ) );

	// Promotion
	promoted = this.extract( promote, used );
	demoted = this.extract( demote, used );

	// Auto
	for ( i = 0, len = included.length; i < len; i++ ) {
		if ( !used[ included[ i ] ] ) {
			auto.push( included[ i ] );
		}
	}

	return promoted.concat( auto ).concat( demoted );
};

/**
 * Get a flat list of names from a list of names or groups.
 *
 * Normally, `collection` is an array of tool specifications. Tools can be specified in the
 * following ways:
 *
 * - To include an individual tool, use the symbolic name: `{ name: 'tool-name' }` or `'tool-name'`.
 * - To include all tools in a group, use the group name: `{ group: 'group-name' }`. (To assign the
 *   tool to a group, use OO.ui.Tool.static.group.)
 *
 * Alternatively, to include all tools that are not yet assigned to any other toolgroup, use the
 * catch-all selector `'*'`.
 *
 * If `used` is passed, tool names that appear as properties in this object will be considered
 * already assigned, and will not be returned even if specified otherwise. The tool names extracted
 * by this function call will be added as new properties in the object.
 *
 * @private
 * @param {Array|string} collection List of tools, see above
 * @param {Object} [used] Object containing information about used tools, see above
 * @return {string[]} List of extracted tool names
 */
OO.ui.ToolFactory.prototype.extract = function ( collection, used ) {
	var i, len, item, name, tool,
		names = [];

	collection = !Array.isArray( collection ) ? [ collection ] : collection;

	for ( i = 0, len = collection.length; i < len; i++ ) {
		item = collection[ i ];
		if ( item === '*' ) {
			for ( name in this.registry ) {
				tool = this.registry[ name ];
				if (
					// Only add tools by group name when auto-add is enabled
					tool.static.autoAddToCatchall &&
					// Exclude already used tools
					( !used || !used[ name ] )
				) {
					names.push( name );
					if ( used ) {
						used[ name ] = true;
					}
				}
			}
		} else {
			// Allow plain strings as shorthand for named tools
			if ( typeof item === 'string' ) {
				item = { name: item };
			}
			if ( OO.isPlainObject( item ) ) {
				if ( item.group ) {
					for ( name in this.registry ) {
						tool = this.registry[ name ];
						if (
							// Include tools with matching group
							tool.static.group === item.group &&
							// Only add tools by group name when auto-add is enabled
							tool.static.autoAddToGroup &&
							// Exclude already used tools
							( !used || !used[ name ] )
						) {
							names.push( name );
							if ( used ) {
								used[ name ] = true;
							}
						}
					}
				// Include tools with matching name and exclude already used tools
				} else if ( item.name && ( !used || !used[ item.name ] ) ) {
					names.push( item.name );
					if ( used ) {
						used[ item.name ] = true;
					}
				}
			}
		}
	}
	return names;
};

/**
 * ToolGroupFactories create {@link OO.ui.ToolGroup toolgroups} on demand. The toolgroup classes must
 * specify a symbolic name and be registered with the factory. The following classes are registered by
 * default:
 *
 * - {@link OO.ui.BarToolGroup BarToolGroups} (‘bar’)
 * - {@link OO.ui.MenuToolGroup MenuToolGroups} (‘menu’)
 * - {@link OO.ui.ListToolGroup ListToolGroups} (‘list’)
 *
 * See {@link OO.ui.Toolbar toolbars} for an example.
 *
 * For more information about toolbars in general, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @class
 * @extends OO.Factory
 * @constructor
 */
OO.ui.ToolGroupFactory = function OoUiToolGroupFactory() {
	var i, l, defaultClasses;
	// Parent constructor
	OO.Factory.call( this );

	defaultClasses = this.constructor.static.getDefaultClasses();

	// Register default toolgroups
	for ( i = 0, l = defaultClasses.length; i < l; i++ ) {
		this.register( defaultClasses[ i ] );
	}
};

/* Setup */

OO.inheritClass( OO.ui.ToolGroupFactory, OO.Factory );

/* Static Methods */

/**
 * Get a default set of classes to be registered on construction.
 *
 * @return {Function[]} Default classes
 */
OO.ui.ToolGroupFactory.static.getDefaultClasses = function () {
	return [
		OO.ui.BarToolGroup,
		OO.ui.ListToolGroup,
		OO.ui.MenuToolGroup
	];
};

/**
 * Popup tools open a popup window when they are selected from the {@link OO.ui.Toolbar toolbar}. Each popup tool is configured
 * with a static name, title, and icon, as well with as any popup configurations. Unlike other tools, popup tools do not require that developers specify
 * an #onSelect or #onUpdateState method, as these methods have been implemented already.
 *
 *     // Example of a popup tool. When selected, a popup tool displays
 *     // a popup window.
 *     function HelpTool( toolGroup, config ) {
 *        OO.ui.PopupTool.call( this, toolGroup, $.extend( { popup: {
 *            padded: true,
 *            label: 'Help',
 *            head: true
 *        } }, config ) );
 *        this.popup.$body.append( '<p>I am helpful!</p>' );
 *     };
 *     OO.inheritClass( HelpTool, OO.ui.PopupTool );
 *     HelpTool.static.name = 'help';
 *     HelpTool.static.icon = 'help';
 *     HelpTool.static.title = 'Help';
 *     toolFactory.register( HelpTool );
 *
 * For an example of a toolbar that contains a popup tool, see {@link OO.ui.Toolbar toolbars}. For more information about
 * toolbars in general, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @abstract
 * @class
 * @extends OO.ui.Tool
 * @mixins OO.ui.mixin.PopupElement
 *
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
OO.ui.PopupTool = function OoUiPopupTool( toolGroup, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolGroup ) && config === undefined ) {
		config = toolGroup;
		toolGroup = config.toolGroup;
	}

	// Parent constructor
	OO.ui.PopupTool.parent.call( this, toolGroup, config );

	// Mixin constructors
	OO.ui.mixin.PopupElement.call( this, config );

	// Events
	this.popup.connect( this, { toggle: 'onPopupToggle' } );

	// Initialization
	this.popup.setAutoFlip( false );
	this.popup.setPosition( toolGroup.getToolbar().position === 'bottom' ? 'above' : 'below' );
	this.$element.addClass( 'oo-ui-popupTool' );
	this.popup.$element.addClass( 'oo-ui-popupTool-popup' );
	this.toolbar.$popups.append( this.popup.$element );
};

/* Setup */

OO.inheritClass( OO.ui.PopupTool, OO.ui.Tool );
OO.mixinClass( OO.ui.PopupTool, OO.ui.mixin.PopupElement );

/* Methods */

/**
 * Handle the tool being selected.
 *
 * @inheritdoc
 */
OO.ui.PopupTool.prototype.onSelect = function () {
	if ( !this.isDisabled() ) {
		this.popup.toggle();
	}
	return false;
};

/**
 * Handle the toolbar state being updated.
 *
 * @inheritdoc
 */
OO.ui.PopupTool.prototype.onUpdateState = function () {
};

/**
 * Handle popup visibility being toggled.
 *
 * @param {boolean} isVisible
 */
OO.ui.PopupTool.prototype.onPopupToggle = function ( isVisible ) {
	this.setActive( isVisible );
	this.toolGroup.emit( 'active', isVisible );
};

/**
 * A ToolGroupTool is a special sort of tool that can contain other {@link OO.ui.Tool tools}
 * and {@link OO.ui.ToolGroup toolgroups}. The ToolGroupTool was specifically designed to be used
 * inside a {@link OO.ui.BarToolGroup bar} toolgroup to provide access to additional tools from
 * the bar item. Included tools will be displayed in a dropdown {@link OO.ui.ListToolGroup list}
 * when the ToolGroupTool is selected.
 *
 *     // Example: ToolGroupTool with two nested tools, 'setting1' and 'setting2', defined elsewhere.
 *
 *     function SettingsTool() {
 *         SettingsTool.parent.apply( this, arguments );
 *     };
 *     OO.inheritClass( SettingsTool, OO.ui.ToolGroupTool );
 *     SettingsTool.static.name = 'settings';
 *     SettingsTool.static.title = 'Change settings';
 *     SettingsTool.static.groupConfig = {
 *         icon: 'settings',
 *         label: 'ToolGroupTool',
 *         include: [  'setting1', 'setting2'  ]
 *     };
 *     toolFactory.register( SettingsTool );
 *
 * For more information, please see the [OOUI documentation on MediaWiki][1].
 *
 * Please note that this implementation is subject to change per [T74159] [2].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars#ToolGroupTool
 * [2]: https://phabricator.wikimedia.org/T74159
 *
 * @abstract
 * @class
 * @extends OO.ui.Tool
 *
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
OO.ui.ToolGroupTool = function OoUiToolGroupTool( toolGroup, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolGroup ) && config === undefined ) {
		config = toolGroup;
		toolGroup = config.toolGroup;
	}

	// Parent constructor
	OO.ui.ToolGroupTool.parent.call( this, toolGroup, config );

	// Properties
	this.innerToolGroup = this.createGroup( this.constructor.static.groupConfig );

	// Events
	this.innerToolGroup.connect( this, {
		disable: 'onToolGroupDisable',
		// Re-emit active events from the innerToolGroup on the parent toolGroup
		active: this.toolGroup.emit.bind( this.toolGroup, 'active' )
	} );

	// Initialization
	this.$link.remove();
	this.$element
		.addClass( 'oo-ui-toolGroupTool' )
		.append( this.innerToolGroup.$element );
};

/* Setup */

OO.inheritClass( OO.ui.ToolGroupTool, OO.ui.Tool );

/* Static Properties */

/**
 * Toolgroup configuration.
 *
 * The toolgroup configuration consists of the tools to include, as well as an icon and label
 * to use for the bar item. Tools can be included by symbolic name, group, or with the
 * wildcard selector. Please see {@link OO.ui.ToolGroup toolgroup} for more information.
 *
 * @property {Object.<string,Array>}
 */
OO.ui.ToolGroupTool.static.groupConfig = {};

/* Methods */

/**
 * Handle the tool being selected.
 *
 * @inheritdoc
 */
OO.ui.ToolGroupTool.prototype.onSelect = function () {
	this.innerToolGroup.setActive( !this.innerToolGroup.active );
	return false;
};

/**
 * Synchronize disabledness state of the tool with the inner toolgroup.
 *
 * @private
 * @param {boolean} disabled Element is disabled
 */
OO.ui.ToolGroupTool.prototype.onToolGroupDisable = function ( disabled ) {
	this.setDisabled( disabled );
};

/**
 * Handle the toolbar state being updated.
 *
 * @inheritdoc
 */
OO.ui.ToolGroupTool.prototype.onUpdateState = function () {
	this.setActive( false );
};

/**
 * Build a {@link OO.ui.ToolGroup toolgroup} from the specified configuration.
 *
 * @param {Object.<string,Array>} group Toolgroup configuration. Please see {@link OO.ui.ToolGroup toolgroup} for
 *  more information.
 * @return {OO.ui.ListToolGroup}
 */
OO.ui.ToolGroupTool.prototype.createGroup = function ( group ) {
	if ( group.include === '*' ) {
		// Apply defaults to catch-all groups
		if ( group.label === undefined ) {
			group.label = OO.ui.msg( 'ooui-toolbar-more' );
		}
	}

	return this.toolbar.getToolGroupFactory().create( 'list', this.toolbar, group );
};

/**
 * BarToolGroups are one of three types of {@link OO.ui.ToolGroup toolgroups} that are used to
 * create {@link OO.ui.Toolbar toolbars} (the other types of groups are {@link OO.ui.MenuToolGroup MenuToolGroup}
 * and {@link OO.ui.ListToolGroup ListToolGroup}). The {@link OO.ui.Tool tools} in a BarToolGroup are
 * displayed by icon in a single row. The title of the tool is displayed when users move the mouse over
 * the tool.
 *
 * BarToolGroups are created by a {@link OO.ui.ToolGroupFactory tool group factory} when the toolbar is
 * set up.
 *
 *     @example
 *     // Example of a BarToolGroup with two tools
 *     var toolFactory = new OO.ui.ToolFactory();
 *     var toolGroupFactory = new OO.ui.ToolGroupFactory();
 *     var toolbar = new OO.ui.Toolbar( toolFactory, toolGroupFactory );
 *
 *     // We will be placing status text in this element when tools are used
 *     var $area = $( '<p>' ).text( 'Example of a BarToolGroup with two tools.' );
 *
 *     // Define the tools that we're going to place in our toolbar
 *
 *     // Create a class inheriting from OO.ui.Tool
 *     function SearchTool() {
 *         SearchTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( SearchTool, OO.ui.Tool );
 *     // Each tool must have a 'name' (used as an internal identifier, see later) and at least one
 *     // of 'icon' and 'title' (displayed icon and text).
 *     SearchTool.static.name = 'search';
 *     SearchTool.static.icon = 'search';
 *     SearchTool.static.title = 'Search...';
 *     // Defines the action that will happen when this tool is selected (clicked).
 *     SearchTool.prototype.onSelect = function () {
 *         $area.text( 'Search tool clicked!' );
 *         // Never display this tool as "active" (selected).
 *         this.setActive( false );
 *     };
 *     SearchTool.prototype.onUpdateState = function () {};
 *     // Make this tool available in our toolFactory and thus our toolbar
 *     toolFactory.register( SearchTool );
 *
 *     // This is a PopupTool. Rather than having a custom 'onSelect' action, it will display a
 *     // little popup window (a PopupWidget).
 *     function HelpTool( toolGroup, config ) {
 *         OO.ui.PopupTool.call( this, toolGroup, $.extend( { popup: {
 *             padded: true,
 *             label: 'Help',
 *             head: true
 *         } }, config ) );
 *         this.popup.$body.append( '<p>I am helpful!</p>' );
 *     }
 *     OO.inheritClass( HelpTool, OO.ui.PopupTool );
 *     HelpTool.static.name = 'help';
 *     HelpTool.static.icon = 'help';
 *     HelpTool.static.title = 'Help';
 *     toolFactory.register( HelpTool );
 *
 *     // Finally define which tools and in what order appear in the toolbar. Each tool may only be
 *     // used once (but not all defined tools must be used).
 *     toolbar.setup( [
 *         {
 *             // 'bar' tool groups display tools by icon only
 *             type: 'bar',
 *             include: [ 'search', 'help' ]
 *         }
 *     ] );
 *
 *     // Create some UI around the toolbar and place it in the document
 *     var frame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true
 *     } );
 *     var contentFrame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         padded: true
 *     } );
 *     frame.$element.append(
 *         toolbar.$element,
 *         contentFrame.$element.append( $area )
 *     );
 *     $( document.body ).append( frame.$element );
 *
 *     // Here is where the toolbar is actually built. This must be done after inserting it into the
 *     // document.
 *     toolbar.initialize();
 *
 * For more information about how to add tools to a bar tool group, please see {@link OO.ui.ToolGroup toolgroup}.
 * For more information about toolbars in general, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @class
 * @extends OO.ui.ToolGroup
 *
 * @constructor
 * @param {OO.ui.Toolbar} toolbar
 * @param {Object} [config] Configuration options
 */
OO.ui.BarToolGroup = function OoUiBarToolGroup( toolbar, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolbar ) && config === undefined ) {
		config = toolbar;
		toolbar = config.toolbar;
	}

	// Parent constructor
	OO.ui.BarToolGroup.parent.call( this, toolbar, config );

	// Initialization
	this.$element.addClass( 'oo-ui-barToolGroup' );
	this.$group.addClass( 'oo-ui-barToolGroup-tools' );
};

/* Setup */

OO.inheritClass( OO.ui.BarToolGroup, OO.ui.ToolGroup );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.BarToolGroup.static.titleTooltips = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.BarToolGroup.static.accelTooltips = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.BarToolGroup.static.name = 'bar';

/**
 * PopupToolGroup is an abstract base class used by both {@link OO.ui.MenuToolGroup MenuToolGroup}
 * and {@link OO.ui.ListToolGroup ListToolGroup} to provide a popup (an overlaid menu or list of tools with an
 * optional icon and label). This class can be used for other base classes that also use this functionality.
 *
 * @abstract
 * @class
 * @extends OO.ui.ToolGroup
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.ClippableElement
 * @mixins OO.ui.mixin.FloatableElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {OO.ui.Toolbar} toolbar
 * @param {Object} [config] Configuration options
 * @cfg {string} [header] Text to display at the top of the popup
 */
OO.ui.PopupToolGroup = function OoUiPopupToolGroup( toolbar, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolbar ) && config === undefined ) {
		config = toolbar;
		toolbar = config.toolbar;
	}

	// Configuration initialization
	config = $.extend( {
		indicator: config.indicator === undefined ? ( toolbar.position === 'bottom' ? 'up' : 'down' ) : config.indicator
	}, config );

	// Parent constructor
	OO.ui.PopupToolGroup.parent.call( this, toolbar, config );

	// Properties
	this.active = false;
	this.dragging = false;
	// Don't conflict with parent method of the same name
	this.onPopupDocumentMouseKeyUpHandler = this.onPopupDocumentMouseKeyUp.bind( this );
	this.$handle = $( '<span>' );

	// Mixin constructors
	OO.ui.mixin.IconElement.call( this, config );
	OO.ui.mixin.IndicatorElement.call( this, config );
	OO.ui.mixin.LabelElement.call( this, config );
	OO.ui.mixin.TitledElement.call( this, config );
	OO.ui.mixin.FlaggedElement.call( this, config );
	OO.ui.mixin.ClippableElement.call( this, $.extend( {}, config, { $clippable: this.$group } ) );
	OO.ui.mixin.FloatableElement.call( this, $.extend( {}, config, {
		$floatable: this.$group,
		$floatableContainer: this.$handle,
		hideWhenOutOfView: false,
		verticalPosition: this.toolbar.position === 'bottom' ? 'above' : 'below'
	} ) );
	OO.ui.mixin.TabIndexedElement.call( this, $.extend( {}, config, { $tabIndexed: this.$handle } ) );

	// Events
	this.$handle.on( {
		keydown: this.onHandleMouseKeyDown.bind( this ),
		keyup: this.onHandleMouseKeyUp.bind( this ),
		mousedown: this.onHandleMouseKeyDown.bind( this ),
		mouseup: this.onHandleMouseKeyUp.bind( this )
	} );

	// Initialization
	this.$handle
		.addClass( 'oo-ui-popupToolGroup-handle' )
		.attr( 'role', 'button' )
		.append( this.$icon, this.$label, this.$indicator );
	// If the pop-up should have a header, add it to the top of the toolGroup.
	// Note: If this feature is useful for other widgets, we could abstract it into an
	// OO.ui.HeaderedElement mixin constructor.
	if ( config.header !== undefined ) {
		this.$group
			.prepend( $( '<span>' )
				.addClass( 'oo-ui-popupToolGroup-header' )
				.text( config.header )
			);
	}
	this.$element
		.addClass( 'oo-ui-popupToolGroup' )
		.prepend( this.$handle );
	this.$group.addClass( 'oo-ui-popupToolGroup-tools' );
	this.toolbar.$popups.append( this.$group );
};

/* Setup */

OO.inheritClass( OO.ui.PopupToolGroup, OO.ui.ToolGroup );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.ClippableElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.FloatableElement );
OO.mixinClass( OO.ui.PopupToolGroup, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.PopupToolGroup.prototype.setDisabled = function () {
	// Parent method
	OO.ui.PopupToolGroup.parent.prototype.setDisabled.apply( this, arguments );

	if ( this.isDisabled() && this.isElementAttached() ) {
		this.setActive( false );
	}
};

/**
 * Handle document mouse up and key up events.
 *
 * @protected
 * @param {MouseEvent|KeyboardEvent} e Mouse up or key up event
 */
OO.ui.PopupToolGroup.prototype.onPopupDocumentMouseKeyUp = function ( e ) {
	var $target = $( e.target );
	// Only deactivate when clicking outside the dropdown element
	if ( $target.closest( '.oo-ui-popupToolGroup' )[ 0 ] === this.$element[ 0 ] ) {
		return;
	}
	if ( $target.closest( '.oo-ui-popupToolGroup-tools' )[ 0 ] === this.$group[ 0 ] ) {
		return;
	}
	this.setActive( false );
};

// Deprecated alias since 0.28.3
OO.ui.PopupToolGroup.prototype.onBlur = function () {
	OO.ui.warnDeprecation( 'onBlur is deprecated, use onPopupDocumentMouseKeyUp instead' );
	this.onPopupDocumentMouseKeyUp.apply( this, arguments );
};

/**
 * @inheritdoc
 */
OO.ui.PopupToolGroup.prototype.onMouseKeyUp = function ( e ) {
	// Only close toolgroup when a tool was actually selected
	if (
		!this.isDisabled() && this.pressed && this.pressed === this.findTargetTool( e ) &&
		( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		this.setActive( false );
	}
	return OO.ui.PopupToolGroup.parent.prototype.onMouseKeyUp.call( this, e );
};

/**
 * @inheritdoc
 */
OO.ui.PopupToolGroup.prototype.onMouseKeyDown = function ( e ) {
	var $focused, $firstFocusable, $lastFocusable;
	// Shift-Tab on the first tool in the group jumps to the handle.
	// Tab on the last tool in the group jumps to the next group.
	if ( !this.isDisabled() && e.which === OO.ui.Keys.TAB ) {
		// (We can't use this.items because ListToolGroup inserts the extra fake expand/collapse tool.)
		$focused = $( document.activeElement );
		$firstFocusable = OO.ui.findFocusable( this.$group );
		if ( $focused[ 0 ] === $firstFocusable[ 0 ] && e.shiftKey ) {
			this.$handle.focus();
			return false;
		}
		$lastFocusable = OO.ui.findFocusable( this.$group, true );
		if ( $focused[ 0 ] === $lastFocusable[ 0 ] && !e.shiftKey ) {
			// Focus this group's handle and let the browser's tab handling happen (no 'return false').
			// This way we don't have to fiddle with other ToolGroups' business, or worry what to do
			// if the next group is not a PopupToolGroup or doesn't exist at all.
			this.$handle.focus();
			// Close the popup so that we don't move back inside it (if this is the last group).
			this.setActive( false );
		}
	}
	return OO.ui.PopupToolGroup.parent.prototype.onMouseKeyDown.call( this, e );
};

/**
 * Handle mouse up and key up events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse up or key up event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.PopupToolGroup.prototype.onHandleMouseKeyUp = function ( e ) {
	if (
		!this.isDisabled() &&
		( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		return false;
	}
};

/**
 * Handle mouse down and key down events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse down or key down event
 * @return {undefined/boolean} False to prevent default if event is handled
 */
OO.ui.PopupToolGroup.prototype.onHandleMouseKeyDown = function ( e ) {
	var $focusable;
	if ( !this.isDisabled() ) {
		// Tab on the handle jumps to the first tool in the group (if the popup is open).
		if ( e.which === OO.ui.Keys.TAB && !e.shiftKey ) {
			$focusable = OO.ui.findFocusable( this.$group );
			if ( $focusable.length ) {
				$focusable.trigger( 'focus' );
				return false;
			}
		}
		if ( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER ) {
			this.setActive( !this.active );
			return false;
		}
	}
};

/**
 * Check if the tool group is active.
 *
 * @return {boolean} Tool group is active
 */
OO.ui.PopupToolGroup.prototype.isActive = function () {
	return this.active;
};

/**
 * Switch into 'active' mode.
 *
 * When active, the popup is visible. A mouseup event anywhere in the document will trigger
 * deactivation.
 *
 * @param {boolean} value The active state to set
 * @fires active
 */
OO.ui.PopupToolGroup.prototype.setActive = function ( value ) {
	var containerWidth, containerLeft;
	value = !!value;
	if ( this.active !== value ) {
		this.active = value;
		if ( value ) {
			this.getElementDocument().addEventListener( 'mouseup', this.onPopupDocumentMouseKeyUpHandler, true );
			this.getElementDocument().addEventListener( 'keyup', this.onPopupDocumentMouseKeyUpHandler, true );

			this.$clippable.css( 'left', '' );
			this.$element.addClass( 'oo-ui-popupToolGroup-active' );
			this.$group.addClass( 'oo-ui-popupToolGroup-active-tools' );
			this.togglePositioning( true );
			this.toggleClipping( true );

			// Try anchoring the popup to the left first
			this.setHorizontalPosition( 'start' );

			if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
				// Anchoring to the left caused the popup to clip, so anchor it to the right instead
				this.setHorizontalPosition( 'end' );
			}
			if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
				// Anchoring to the right also caused the popup to clip, so just make it fill the container
				containerWidth = this.$clippableScrollableContainer.width();
				containerLeft = this.$clippableScrollableContainer[ 0 ] === document.documentElement ?
					0 :
					this.$clippableScrollableContainer.offset().left;

				this.toggleClipping( false );
				this.setHorizontalPosition( 'start' );

				this.$clippable.css( {
					'margin-left': -( this.$element.offset().left - containerLeft ),
					width: containerWidth
				} );
			}
		} else {
			this.getElementDocument().removeEventListener( 'mouseup', this.onPopupDocumentMouseKeyUpHandler, true );
			this.getElementDocument().removeEventListener( 'keyup', this.onPopupDocumentMouseKeyUpHandler, true );
			this.$element.removeClass( 'oo-ui-popupToolGroup-active' );
			this.$group.removeClass( 'oo-ui-popupToolGroup-active-tools' );
			this.togglePositioning( false );
			this.toggleClipping( false );
		}
		this.emit( 'active', this.active );
		this.updateThemeClasses();
	}
};

/**
 * ListToolGroups are one of three types of {@link OO.ui.ToolGroup toolgroups} that are used to
 * create {@link OO.ui.Toolbar toolbars} (the other types of groups are {@link OO.ui.MenuToolGroup MenuToolGroup}
 * and {@link OO.ui.BarToolGroup BarToolGroup}). The {@link OO.ui.Tool tools} in a ListToolGroup are displayed
 * by label in a dropdown menu. The title of the tool is used as the label text. The menu itself can be configured
 * with a label, icon, indicator, header, and title.
 *
 * ListToolGroups can be configured to be expanded and collapsed. Collapsed lists will have a ‘More’ option that
 * users can select to see the full list of tools. If a collapsed toolgroup is expanded, a ‘Fewer’ option permits
 * users to collapse the list again.
 *
 * ListToolGroups are created by a {@link OO.ui.ToolGroupFactory toolgroup factory} when the toolbar is set up. The factory
 * requires the ListToolGroup's symbolic name, 'list', which is specified along with the other configurations. For more
 * information about how to add tools to a ListToolGroup, please see {@link OO.ui.ToolGroup toolgroup}.
 *
 *     @example
 *     // Example of a ListToolGroup
 *     var toolFactory = new OO.ui.ToolFactory();
 *     var toolGroupFactory = new OO.ui.ToolGroupFactory();
 *     var toolbar = new OO.ui.Toolbar( toolFactory, toolGroupFactory );
 *
 *     // Configure and register two tools
 *     function SettingsTool() {
 *         SettingsTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( SettingsTool, OO.ui.Tool );
 *     SettingsTool.static.name = 'settings';
 *     SettingsTool.static.icon = 'settings';
 *     SettingsTool.static.title = 'Change settings';
 *     SettingsTool.prototype.onSelect = function () {
 *         this.setActive( false );
 *     };
 *     SettingsTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( SettingsTool );
 *     // Register two more tools, nothing interesting here
 *     function StuffTool() {
 *         StuffTool.parent.apply( this, arguments );
 *     }
 *     OO.inheritClass( StuffTool, OO.ui.Tool );
 *     StuffTool.static.name = 'stuff';
 *     StuffTool.static.icon = 'search';
 *     StuffTool.static.title = 'Change the world';
 *     StuffTool.prototype.onSelect = function () {
 *         this.setActive( false );
 *     };
 *     StuffTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( StuffTool );
 *     toolbar.setup( [
 *         {
 *             // Configurations for list toolgroup.
 *             type: 'list',
 *             label: 'ListToolGroup',
 *             icon: 'ellipsis',
 *             title: 'This is the title, displayed when user moves the mouse over the list toolgroup',
 *             header: 'This is the header',
 *             include: [ 'settings', 'stuff' ],
 *             allowCollapse: ['stuff']
 *         }
 *     ] );
 *
 *     // Create some UI around the toolbar and place it in the document
 *     var frame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true
 *     } );
 *     frame.$element.append(
 *         toolbar.$element
 *     );
 *     $( document.body ).append( frame.$element );
 *     // Build the toolbar. This must be done after the toolbar has been appended to the document.
 *     toolbar.initialize();
 *
 * For more information about toolbars in general, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @class
 * @extends OO.ui.PopupToolGroup
 *
 * @constructor
 * @param {OO.ui.Toolbar} toolbar
 * @param {Object} [config] Configuration options
 * @cfg {Array} [allowCollapse] Allow the specified tools to be collapsed. By default, collapsible tools
 *  will only be displayed if users click the ‘More’ option displayed at the bottom of the list. If
 *  the list is expanded, a ‘Fewer’ option permits users to collapse the list again. Any tools that
 *  are included in the toolgroup, but are not designated as collapsible, will always be displayed.
 *  To open a collapsible list in its expanded state, set #expanded to 'true'.
 * @cfg {Array} [forceExpand] Expand the specified tools. All other tools will be designated as collapsible.
 *  Unless #expanded is set to true, the collapsible tools will be collapsed when the list is first opened.
 * @cfg {boolean} [expanded=false] Expand collapsible tools. This config is only relevant if tools have
 *  been designated as collapsible. When expanded is set to true, all tools in the group will be displayed
 *  when the list is first opened. Users can collapse the list with a ‘Fewer’ option at the bottom.
 */
OO.ui.ListToolGroup = function OoUiListToolGroup( toolbar, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolbar ) && config === undefined ) {
		config = toolbar;
		toolbar = config.toolbar;
	}

	// Configuration initialization
	config = config || {};

	// Properties (must be set before parent constructor, which calls #populate)
	this.allowCollapse = config.allowCollapse;
	this.forceExpand = config.forceExpand;
	this.expanded = config.expanded !== undefined ? config.expanded : false;
	this.collapsibleTools = [];

	// Parent constructor
	OO.ui.ListToolGroup.parent.call( this, toolbar, config );

	// Initialization
	this.$element.addClass( 'oo-ui-listToolGroup' );
	this.$group.addClass( 'oo-ui-listToolGroup-tools' );
};

/* Setup */

OO.inheritClass( OO.ui.ListToolGroup, OO.ui.PopupToolGroup );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ListToolGroup.static.name = 'list';

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.ListToolGroup.prototype.populate = function () {
	var i, len, allowCollapse = [];

	OO.ui.ListToolGroup.parent.prototype.populate.call( this );

	// Update the list of collapsible tools
	if ( this.allowCollapse !== undefined ) {
		allowCollapse = this.allowCollapse;
	} else if ( this.forceExpand !== undefined ) {
		allowCollapse = OO.simpleArrayDifference( Object.keys( this.tools ), this.forceExpand );
	}

	this.collapsibleTools = [];
	for ( i = 0, len = allowCollapse.length; i < len; i++ ) {
		if ( this.tools[ allowCollapse[ i ] ] !== undefined ) {
			this.collapsibleTools.push( this.tools[ allowCollapse[ i ] ] );
		}
	}

	// Keep at the end, even when tools are added
	this.$group.append( this.getExpandCollapseTool().$element );

	this.getExpandCollapseTool().toggle( this.collapsibleTools.length !== 0 );
	this.updateCollapsibleState();
};

/**
 * Get the expand/collapse tool for this group
 *
 * @return {OO.ui.Tool} Expand collapse tool
 */
OO.ui.ListToolGroup.prototype.getExpandCollapseTool = function () {
	var ExpandCollapseTool;
	if ( this.expandCollapseTool === undefined ) {
		ExpandCollapseTool = function () {
			ExpandCollapseTool.parent.apply( this, arguments );
		};

		OO.inheritClass( ExpandCollapseTool, OO.ui.Tool );

		ExpandCollapseTool.prototype.onSelect = function () {
			this.toolGroup.expanded = !this.toolGroup.expanded;
			this.toolGroup.updateCollapsibleState();
			this.setActive( false );
		};
		ExpandCollapseTool.prototype.onUpdateState = function () {
			// Do nothing. Tool interface requires an implementation of this function.
		};

		ExpandCollapseTool.static.name = 'more-fewer';

		this.expandCollapseTool = new ExpandCollapseTool( this );
	}
	return this.expandCollapseTool;
};

/**
 * @inheritdoc
 */
OO.ui.ListToolGroup.prototype.onMouseKeyUp = function ( e ) {
	// Do not close the popup when the user wants to show more/fewer tools
	if (
		$( e.target ).closest( '.oo-ui-tool-name-more-fewer' ).length &&
		( e.which === OO.ui.MouseButtons.LEFT || e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
	) {
		// HACK: Prevent the popup list from being hidden. Skip the PopupToolGroup implementation (which
		// hides the popup list when a tool is selected) and call ToolGroup's implementation directly.
		return OO.ui.ListToolGroup.parent.parent.prototype.onMouseKeyUp.call( this, e );
	} else {
		return OO.ui.ListToolGroup.parent.prototype.onMouseKeyUp.call( this, e );
	}
};

OO.ui.ListToolGroup.prototype.updateCollapsibleState = function () {
	var i, icon, len;

	if ( this.toolbar.position !== 'bottom' ) {
		icon = this.expanded ? 'collapse' : 'expand';
	} else {
		icon = this.expanded ? 'expand' : 'collapse';
	}

	this.getExpandCollapseTool()
		.setIcon( icon )
		.setTitle( OO.ui.msg( this.expanded ? 'ooui-toolgroup-collapse' : 'ooui-toolgroup-expand' ) );

	for ( i = 0, len = this.collapsibleTools.length; i < len; i++ ) {
		this.collapsibleTools[ i ].toggle( this.expanded );
	}

	// Re-evaluate clipping, because our height has changed
	this.clip();
};

/**
 * MenuToolGroups are one of three types of {@link OO.ui.ToolGroup toolgroups} that are used to
 * create {@link OO.ui.Toolbar toolbars} (the other types of groups are {@link OO.ui.BarToolGroup BarToolGroup}
 * and {@link OO.ui.ListToolGroup ListToolGroup}). MenuToolGroups contain selectable {@link OO.ui.Tool tools},
 * which are displayed by label in a dropdown menu. The tool's title is used as the label text, and the
 * menu label is updated to reflect which tool or tools are currently selected. If no tools are selected,
 * the menu label is empty. The menu can be configured with an indicator, icon, title, and/or header.
 *
 * MenuToolGroups are created by a {@link OO.ui.ToolGroupFactory tool group factory} when the toolbar
 * is set up.
 *
 *     @example
 *     // Example of a MenuToolGroup
 *     var toolFactory = new OO.ui.ToolFactory();
 *     var toolGroupFactory = new OO.ui.ToolGroupFactory();
 *     var toolbar = new OO.ui.Toolbar( toolFactory, toolGroupFactory );
 *
 *     // We will be placing status text in this element when tools are used
 *     var $area = $( '<p>' ).text( 'An example of a MenuToolGroup. Select a tool from the dropdown menu.' );
 *
 *     // Define the tools that we're going to place in our toolbar
 *
 *     function SettingsTool() {
 *         SettingsTool.parent.apply( this, arguments );
 *         this.reallyActive = false;
 *     }
 *     OO.inheritClass( SettingsTool, OO.ui.Tool );
 *     SettingsTool.static.name = 'settings';
 *     SettingsTool.static.icon = 'settings';
 *     SettingsTool.static.title = 'Change settings';
 *     SettingsTool.prototype.onSelect = function () {
 *         $area.text( 'Settings tool clicked!' );
 *         // Toggle the active state on each click
 *         this.reallyActive = !this.reallyActive;
 *         this.setActive( this.reallyActive );
 *         // To update the menu label
 *         this.toolbar.emit( 'updateState' );
 *     };
 *     SettingsTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( SettingsTool );
 *
 *     function StuffTool() {
 *         StuffTool.parent.apply( this, arguments );
 *         this.reallyActive = false;
 *     }
 *     OO.inheritClass( StuffTool, OO.ui.Tool );
 *     StuffTool.static.name = 'stuff';
 *     StuffTool.static.icon = 'ellipsis';
 *     StuffTool.static.title = 'More stuff';
 *     StuffTool.prototype.onSelect = function () {
 *         $area.text( 'More stuff tool clicked!' );
 *         // Toggle the active state on each click
 *         this.reallyActive = !this.reallyActive;
 *         this.setActive( this.reallyActive );
 *         // To update the menu label
 *         this.toolbar.emit( 'updateState' );
 *     };
 *     StuffTool.prototype.onUpdateState = function () {};
 *     toolFactory.register( StuffTool );
 *
 *     // Finally define which tools and in what order appear in the toolbar. Each tool may only be
 *     // used once (but not all defined tools must be used).
 *     toolbar.setup( [
 *         {
 *             type: 'menu',
 *             header: 'This is the (optional) header',
 *             title: 'This is the (optional) title',
 *             include: [ 'settings', 'stuff' ]
 *         }
 *     ] );
 *
 *     // Create some UI around the toolbar and place it in the document
 *     var frame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true
 *     } );
 *     var contentFrame = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         padded: true
 *     } );
 *     frame.$element.append(
 *         toolbar.$element,
 *         contentFrame.$element.append( $area )
 *     );
 *     $( document.body ).append( frame.$element );
 *
 *     // Here is where the toolbar is actually built. This must be done after inserting it into the
 *     // document.
 *     toolbar.initialize();
 *     toolbar.emit( 'updateState' );
 *
 * For more information about how to add tools to a MenuToolGroup, please see {@link OO.ui.ToolGroup toolgroup}.
 * For more information about toolbars in general, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Toolbars
 *
 * @class
 * @extends OO.ui.PopupToolGroup
 *
 * @constructor
 * @param {OO.ui.Toolbar} toolbar
 * @param {Object} [config] Configuration options
 */
OO.ui.MenuToolGroup = function OoUiMenuToolGroup( toolbar, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( toolbar ) && config === undefined ) {
		config = toolbar;
		toolbar = config.toolbar;
	}

	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.MenuToolGroup.parent.call( this, toolbar, config );

	// Events
	this.toolbar.connect( this, { updateState: 'onUpdateState' } );

	// Initialization
	this.$element.addClass( 'oo-ui-menuToolGroup' );
	this.$group.addClass( 'oo-ui-menuToolGroup-tools' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuToolGroup, OO.ui.PopupToolGroup );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuToolGroup.static.name = 'menu';

/* Methods */

/**
 * Handle the toolbar state being updated.
 *
 * When the state changes, the title of each active item in the menu will be joined together and
 * used as a label for the group. The label will be empty if none of the items are active.
 *
 * @private
 */
OO.ui.MenuToolGroup.prototype.onUpdateState = function () {
	var name,
		labelTexts = [];

	for ( name in this.tools ) {
		if ( this.tools[ name ].isActive() ) {
			labelTexts.push( this.tools[ name ].getTitle() );
		}
	}

	this.setLabel( labelTexts.join( ', ' ) || ' ' );
};

}( OO ) );

//# sourceMappingURL=oojs-ui-toolbars.js.map.json
/*!
 * OOUI v0.30.2
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2019 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2019-01-23T01:14:20Z
 */
( function ( OO ) {

'use strict';

/**
 * An ActionWidget is a {@link OO.ui.ButtonWidget button widget} that executes an action.
 * Action widgets are used with OO.ui.ActionSet, which manages the behavior and availability
 * of the actions.
 *
 * Both actions and action sets are primarily used with {@link OO.ui.Dialog Dialogs}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information
 * and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs#Action_sets
 *
 * @class
 * @extends OO.ui.ButtonWidget
 * @mixins OO.ui.mixin.PendingElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [action] Symbolic name of the action (e.g., ‘continue’ or ‘cancel’).
 * @cfg {string[]} [modes] Symbolic names of the modes (e.g., ‘edit’ or ‘read’) in which the action
 *  should be made available. See the action set's {@link OO.ui.ActionSet#setMode setMode} method
 *  for more information about setting modes.
 * @cfg {boolean} [framed=false] Render the action button with a frame
 */
OO.ui.ActionWidget = function OoUiActionWidget( config ) {
	// Configuration initialization
	config = $.extend( { framed: false }, config );

	// Parent constructor
	OO.ui.ActionWidget.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.PendingElement.call( this, config );

	// Properties
	this.action = config.action || '';
	this.modes = config.modes || [];
	this.width = 0;
	this.height = 0;

	// Initialization
	this.$element.addClass( 'oo-ui-actionWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.ActionWidget, OO.ui.ButtonWidget );
OO.mixinClass( OO.ui.ActionWidget, OO.ui.mixin.PendingElement );

/* Methods */

/**
 * Check if the action is configured to be available in the specified `mode`.
 *
 * @param {string} mode Name of mode
 * @return {boolean} The action is configured with the mode
 */
OO.ui.ActionWidget.prototype.hasMode = function ( mode ) {
	return this.modes.indexOf( mode ) !== -1;
};

/**
 * Get the symbolic name of the action (e.g., ‘continue’ or ‘cancel’).
 *
 * @return {string}
 */
OO.ui.ActionWidget.prototype.getAction = function () {
	return this.action;
};

/**
 * Get the symbolic name of the mode or modes for which the action is configured to be available.
 *
 * The current mode is set with the action set's {@link OO.ui.ActionSet#setMode setMode} method.
 * Only actions that are configured to be available in the current mode will be visible. All other actions
 * are hidden.
 *
 * @return {string[]}
 */
OO.ui.ActionWidget.prototype.getModes = function () {
	return this.modes.slice();
};

/* eslint-disable no-unused-vars */
/**
 * ActionSets manage the behavior of the {@link OO.ui.ActionWidget action widgets} that comprise them.
 * Actions can be made available for specific contexts (modes) and circumstances
 * (abilities). Action sets are primarily used with {@link OO.ui.Dialog Dialogs}.
 *
 * ActionSets contain two types of actions:
 *
 * - Special: Special actions are the first visible actions with special flags, such as 'safe' and 'primary', the default special flags. Additional special flags can be configured in subclasses with the static #specialFlags property.
 * - Other: Other actions include all non-special visible actions.
 *
 * See the [OOUI documentation on MediaWiki][1] for more information.
 *
 *     @example
 *     // Example: An action set used in a process dialog
 *     function MyProcessDialog( config ) {
 *         MyProcessDialog.parent.call( this, config );
 *     }
 *     OO.inheritClass( MyProcessDialog, OO.ui.ProcessDialog );
 *     MyProcessDialog.static.title = 'An action set in a process dialog';
 *     MyProcessDialog.static.name = 'myProcessDialog';
 *     // An action set that uses modes ('edit' and 'help' mode, in this example).
 *     MyProcessDialog.static.actions = [
 *         { action: 'continue', modes: 'edit', label: 'Continue', flags: [ 'primary', 'progressive' ] },
 *         { action: 'help', modes: 'edit', label: 'Help' },
 *         { modes: 'edit', label: 'Cancel', flags: 'safe' },
 *         { action: 'back', modes: 'help', label: 'Back', flags: 'safe' }
 *     ];
 *
 *     MyProcessDialog.prototype.initialize = function () {
 *         MyProcessDialog.parent.prototype.initialize.apply( this, arguments );
 *         this.panel1 = new OO.ui.PanelLayout( { padded: true, expanded: false } );
 *         this.panel1.$element.append( '<p>This dialog uses an action set (continue, help, cancel, back) configured with modes. This is edit mode. Click \'help\' to see help mode.</p>' );
 *         this.panel2 = new OO.ui.PanelLayout( { padded: true, expanded: false } );
 *         this.panel2.$element.append( '<p>This is help mode. Only the \'back\' action widget is configured to be visible here. Click \'back\' to return to \'edit\' mode.</p>' );
 *         this.stackLayout = new OO.ui.StackLayout( {
 *             items: [ this.panel1, this.panel2 ]
 *         } );
 *         this.$body.append( this.stackLayout.$element );
 *     };
 *     MyProcessDialog.prototype.getSetupProcess = function ( data ) {
 *         return MyProcessDialog.parent.prototype.getSetupProcess.call( this, data )
 *             .next( function () {
 *                 this.actions.setMode( 'edit' );
 *             }, this );
 *     };
 *     MyProcessDialog.prototype.getActionProcess = function ( action ) {
 *         if ( action === 'help' ) {
 *             this.actions.setMode( 'help' );
 *             this.stackLayout.setItem( this.panel2 );
 *         } else if ( action === 'back' ) {
 *             this.actions.setMode( 'edit' );
 *             this.stackLayout.setItem( this.panel1 );
 *         } else if ( action === 'continue' ) {
 *             var dialog = this;
 *             return new OO.ui.Process( function () {
 *                 dialog.close();
 *             } );
 *         }
 *         return MyProcessDialog.parent.prototype.getActionProcess.call( this, action );
 *     };
 *     MyProcessDialog.prototype.getBodyHeight = function () {
 *         return this.panel1.$element.outerHeight( true );
 *     };
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *     var dialog = new MyProcessDialog( {
 *         size: 'medium'
 *     } );
 *     windowManager.addWindows( [ dialog ] );
 *     windowManager.openWindow( dialog );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs#Action_sets
 *
 * @abstract
 * @class
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ActionSet = function OoUiActionSet( config ) {
	// Configuration initialization
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Properties
	this.list = [];
	this.categories = {
		actions: 'getAction',
		flags: 'getFlags',
		modes: 'getModes'
	};
	this.categorized = {};
	this.special = {};
	this.others = [];
	this.organized = false;
	this.changing = false;
	this.changed = false;
};
/* eslint-enable no-unused-vars */

/* Setup */

OO.mixinClass( OO.ui.ActionSet, OO.EventEmitter );

/* Static Properties */

/**
 * Symbolic name of the flags used to identify special actions. Special actions are displayed in the
 *  header of a {@link OO.ui.ProcessDialog process dialog}.
 *  See the [OOUI documentation on MediaWiki][2] for more information and examples.
 *
 *  [2]:https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs
 *
 * @abstract
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.ActionSet.static.specialFlags = [ 'safe', 'primary' ];

/* Events */

/**
 * @event click
 *
 * A 'click' event is emitted when an action is clicked.
 *
 * @param {OO.ui.ActionWidget} action Action that was clicked
 */

/**
 * @event add
 *
 * An 'add' event is emitted when actions are {@link #method-add added} to the action set.
 *
 * @param {OO.ui.ActionWidget[]} added Actions added
 */

/**
 * @event remove
 *
 * A 'remove' event is emitted when actions are {@link #method-remove removed}
 *  or {@link #clear cleared}.
 *
 * @param {OO.ui.ActionWidget[]} added Actions removed
 */

/**
 * @event change
 *
 * A 'change' event is emitted when actions are {@link #method-add added}, {@link #clear cleared},
 * or {@link #method-remove removed} from the action set or when the {@link #setMode mode} is changed.
 *
 */

/* Methods */

/**
 * Handle action change events.
 *
 * @private
 * @fires change
 */
OO.ui.ActionSet.prototype.onActionChange = function () {
	this.organized = false;
	if ( this.changing ) {
		this.changed = true;
	} else {
		this.emit( 'change' );
	}
};

/**
 * Check if an action is one of the special actions.
 *
 * @param {OO.ui.ActionWidget} action Action to check
 * @return {boolean} Action is special
 */
OO.ui.ActionSet.prototype.isSpecial = function ( action ) {
	var flag;

	for ( flag in this.special ) {
		if ( action === this.special[ flag ] ) {
			return true;
		}
	}

	return false;
};

/**
 * Get action widgets based on the specified filter: ‘actions’, ‘flags’, ‘modes’, ‘visible’,
 *  or ‘disabled’.
 *
 * @param {Object} [filters] Filters to use, omit to get all actions
 * @param {string|string[]} [filters.actions] Actions that action widgets must have
 * @param {string|string[]} [filters.flags] Flags that action widgets must have (e.g., 'safe')
 * @param {string|string[]} [filters.modes] Modes that action widgets must have
 * @param {boolean} [filters.visible] Action widgets must be visible
 * @param {boolean} [filters.disabled] Action widgets must be disabled
 * @return {OO.ui.ActionWidget[]} Action widgets matching all criteria
 */
OO.ui.ActionSet.prototype.get = function ( filters ) {
	var i, len, list, category, actions, index, match, matches;

	if ( filters ) {
		this.organize();

		// Collect category candidates
		matches = [];
		for ( category in this.categorized ) {
			list = filters[ category ];
			if ( list ) {
				if ( !Array.isArray( list ) ) {
					list = [ list ];
				}
				for ( i = 0, len = list.length; i < len; i++ ) {
					actions = this.categorized[ category ][ list[ i ] ];
					if ( Array.isArray( actions ) ) {
						matches.push.apply( matches, actions );
					}
				}
			}
		}
		// Remove by boolean filters
		for ( i = 0, len = matches.length; i < len; i++ ) {
			match = matches[ i ];
			if (
				( filters.visible !== undefined && match.isVisible() !== filters.visible ) ||
				( filters.disabled !== undefined && match.isDisabled() !== filters.disabled )
			) {
				matches.splice( i, 1 );
				len--;
				i--;
			}
		}
		// Remove duplicates
		for ( i = 0, len = matches.length; i < len; i++ ) {
			match = matches[ i ];
			index = matches.lastIndexOf( match );
			while ( index !== i ) {
				matches.splice( index, 1 );
				len--;
				index = matches.lastIndexOf( match );
			}
		}
		return matches;
	}
	return this.list.slice();
};

/**
 * Get 'special' actions.
 *
 * Special actions are the first visible action widgets with special flags, such as 'safe' and 'primary'.
 * Special flags can be configured in subclasses by changing the static #specialFlags property.
 *
 * @return {OO.ui.ActionWidget[]|null} 'Special' action widgets.
 */
OO.ui.ActionSet.prototype.getSpecial = function () {
	this.organize();
	return $.extend( {}, this.special );
};

/**
 * Get 'other' actions.
 *
 * Other actions include all non-special visible action widgets.
 *
 * @return {OO.ui.ActionWidget[]} 'Other' action widgets
 */
OO.ui.ActionSet.prototype.getOthers = function () {
	this.organize();
	return this.others.slice();
};

/**
 * Set the mode  (e.g., ‘edit’ or ‘view’). Only {@link OO.ui.ActionWidget#modes actions} configured
 * to be available in the specified mode will be made visible. All other actions will be hidden.
 *
 * @param {string} mode The mode. Only actions configured to be available in the specified
 *  mode will be made visible.
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 * @fires toggle
 * @fires change
 */
OO.ui.ActionSet.prototype.setMode = function ( mode ) {
	var i, len, action;

	this.changing = true;
	for ( i = 0, len = this.list.length; i < len; i++ ) {
		action = this.list[ i ];
		action.toggle( action.hasMode( mode ) );
	}

	this.organized = false;
	this.changing = false;
	this.emit( 'change' );

	return this;
};

/**
 * Set the abilities of the specified actions.
 *
 * Action widgets that are configured with the specified actions will be enabled
 * or disabled based on the boolean values specified in the `actions`
 * parameter.
 *
 * @param {Object.<string,boolean>} actions A list keyed by action name with boolean
 *  values that indicate whether or not the action should be enabled.
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 */
OO.ui.ActionSet.prototype.setAbilities = function ( actions ) {
	var i, len, action, item;

	for ( i = 0, len = this.list.length; i < len; i++ ) {
		item = this.list[ i ];
		action = item.getAction();
		if ( actions[ action ] !== undefined ) {
			item.setDisabled( !actions[ action ] );
		}
	}

	return this;
};

/**
 * Executes a function once per action.
 *
 * When making changes to multiple actions, use this method instead of iterating over the actions
 * manually to defer emitting a #change event until after all actions have been changed.
 *
 * @param {Object|null} filter Filters to use to determine which actions to iterate over; see #get
 * @param {Function} callback Callback to run for each action; callback is invoked with three
 *   arguments: the action, the action's index, the list of actions being iterated over
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 */
OO.ui.ActionSet.prototype.forEach = function ( filter, callback ) {
	this.changed = false;
	this.changing = true;
	this.get( filter ).forEach( callback );
	this.changing = false;
	if ( this.changed ) {
		this.emit( 'change' );
	}

	return this;
};

/**
 * Add action widgets to the action set.
 *
 * @param {OO.ui.ActionWidget[]} actions Action widgets to add
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 * @fires add
 * @fires change
 */
OO.ui.ActionSet.prototype.add = function ( actions ) {
	var i, len, action;

	this.changing = true;
	for ( i = 0, len = actions.length; i < len; i++ ) {
		action = actions[ i ];
		action.connect( this, {
			click: [ 'emit', 'click', action ],
			toggle: [ 'onActionChange' ]
		} );
		this.list.push( action );
	}
	this.organized = false;
	this.emit( 'add', actions );
	this.changing = false;
	this.emit( 'change' );

	return this;
};

/**
 * Remove action widgets from the set.
 *
 * To remove all actions, you may wish to use the #clear method instead.
 *
 * @param {OO.ui.ActionWidget[]} actions Action widgets to remove
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 * @fires remove
 * @fires change
 */
OO.ui.ActionSet.prototype.remove = function ( actions ) {
	var i, len, index, action;

	this.changing = true;
	for ( i = 0, len = actions.length; i < len; i++ ) {
		action = actions[ i ];
		index = this.list.indexOf( action );
		if ( index !== -1 ) {
			action.disconnect( this );
			this.list.splice( index, 1 );
		}
	}
	this.organized = false;
	this.emit( 'remove', actions );
	this.changing = false;
	this.emit( 'change' );

	return this;
};

/**
 * Remove all action widgets from the set.
 *
 * To remove only specified actions, use the {@link #method-remove remove} method instead.
 *
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 * @fires remove
 * @fires change
 */
OO.ui.ActionSet.prototype.clear = function () {
	var i, len, action,
		removed = this.list.slice();

	this.changing = true;
	for ( i = 0, len = this.list.length; i < len; i++ ) {
		action = this.list[ i ];
		action.disconnect( this );
	}

	this.list = [];

	this.organized = false;
	this.emit( 'remove', removed );
	this.changing = false;
	this.emit( 'change' );

	return this;
};

/**
 * Organize actions.
 *
 * This is called whenever organized information is requested. It will only reorganize the actions
 * if something has changed since the last time it ran.
 *
 * @private
 * @chainable
 * @return {OO.ui.ActionSet} The widget, for chaining
 */
OO.ui.ActionSet.prototype.organize = function () {
	var i, iLen, j, jLen, flag, action, category, list, item, special,
		specialFlags = this.constructor.static.specialFlags;

	if ( !this.organized ) {
		this.categorized = {};
		this.special = {};
		this.others = [];
		for ( i = 0, iLen = this.list.length; i < iLen; i++ ) {
			action = this.list[ i ];
			if ( action.isVisible() ) {
				// Populate categories
				for ( category in this.categories ) {
					if ( !this.categorized[ category ] ) {
						this.categorized[ category ] = {};
					}
					list = action[ this.categories[ category ] ]();
					if ( !Array.isArray( list ) ) {
						list = [ list ];
					}
					for ( j = 0, jLen = list.length; j < jLen; j++ ) {
						item = list[ j ];
						if ( !this.categorized[ category ][ item ] ) {
							this.categorized[ category ][ item ] = [];
						}
						this.categorized[ category ][ item ].push( action );
					}
				}
				// Populate special/others
				special = false;
				for ( j = 0, jLen = specialFlags.length; j < jLen; j++ ) {
					flag = specialFlags[ j ];
					if ( !this.special[ flag ] && action.hasFlag( flag ) ) {
						this.special[ flag ] = action;
						special = true;
						break;
					}
				}
				if ( !special ) {
					this.others.push( action );
				}
			}
		}
		this.organized = true;
	}

	return this;
};

/**
 * Errors contain a required message (either a string or jQuery selection) that is used to describe what went wrong
 * in a {@link OO.ui.Process process}. The error's #recoverable and #warning configurations are used to customize the
 * appearance and functionality of the error interface.
 *
 * The basic error interface contains a formatted error message as well as two buttons: 'Dismiss' and 'Try again' (i.e., the error
 * is 'recoverable' by default). If the error is not recoverable, the 'Try again' button will not be rendered and the widget
 * that initiated the failed process will be disabled.
 *
 * If the error is a warning, the error interface will include a 'Dismiss' and a 'Continue' button, which will try the
 * process again.
 *
 * For an example of error interfaces, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs#Processes_and_errors
 *
 * @class
 *
 * @constructor
 * @param {string|jQuery} message Description of error
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [recoverable=true] Error is recoverable.
 *  By default, errors are recoverable, and users can try the process again.
 * @cfg {boolean} [warning=false] Error is a warning.
 *  If the error is a warning, the error interface will include a
 *  'Dismiss' and a 'Continue' button. It is the responsibility of the developer to ensure that the warning
 *  is not triggered a second time if the user chooses to continue.
 */
OO.ui.Error = function OoUiError( message, config ) {
	// Allow passing positional parameters inside the config object
	if ( OO.isPlainObject( message ) && config === undefined ) {
		config = message;
		message = config.message;
	}

	// Configuration initialization
	config = config || {};

	// Properties
	this.message = message instanceof $ ? message : String( message );
	this.recoverable = config.recoverable === undefined || !!config.recoverable;
	this.warning = !!config.warning;
};

/* Setup */

OO.initClass( OO.ui.Error );

/* Methods */

/**
 * Check if the error is recoverable.
 *
 * If the error is recoverable, users are able to try the process again.
 *
 * @return {boolean} Error is recoverable
 */
OO.ui.Error.prototype.isRecoverable = function () {
	return this.recoverable;
};

/**
 * Check if the error is a warning.
 *
 * If the error is a warning, the error interface will include a 'Dismiss' and a 'Continue' button.
 *
 * @return {boolean} Error is warning
 */
OO.ui.Error.prototype.isWarning = function () {
	return this.warning;
};

/**
 * Get error message as DOM nodes.
 *
 * @return {jQuery} Error message in DOM nodes
 */
OO.ui.Error.prototype.getMessage = function () {
	return this.message instanceof $ ?
		this.message.clone() :
		$( '<div>' ).text( this.message ).contents();
};

/**
 * Get the error message text.
 *
 * @return {string} Error message
 */
OO.ui.Error.prototype.getMessageText = function () {
	return this.message instanceof $ ? this.message.text() : this.message;
};

/**
 * A Process is a list of steps that are called in sequence. The step can be a number, a jQuery promise,
 * or a function:
 *
 * - **number**: the process will wait for the specified number of milliseconds before proceeding.
 * - **promise**: the process will continue to the next step when the promise is successfully resolved
 *  or stop if the promise is rejected.
 * - **function**: the process will execute the function. The process will stop if the function returns
 *  either a boolean `false` or a promise that is rejected; if the function returns a number, the process
 *  will wait for that number of milliseconds before proceeding.
 *
 * If the process fails, an {@link OO.ui.Error error} is generated. Depending on how the error is
 * configured, users can dismiss the error and try the process again, or not. If a process is stopped,
 * its remaining steps will not be performed.
 *
 * @class
 *
 * @constructor
 * @param {number|jQuery.Promise|Function} step Number of milliseconds to wait before proceeding, promise
 *  that must be resolved before proceeding, or a function to execute. See #createStep for more information. see #createStep for more information
 * @param {Object} [context=null] Execution context of the function. The context is ignored if the step is
 *  a number or promise.
 */
OO.ui.Process = function ( step, context ) {
	// Properties
	this.steps = [];

	// Initialization
	if ( step !== undefined ) {
		this.next( step, context );
	}
};

/* Setup */

OO.initClass( OO.ui.Process );

/* Methods */

/**
 * Start the process.
 *
 * @return {jQuery.Promise} Promise that is resolved when all steps have successfully completed.
 *  If any of the steps return a promise that is rejected or a boolean false, this promise is rejected
 *  and any remaining steps are not performed.
 */
OO.ui.Process.prototype.execute = function () {
	var i, len, promise;

	/**
	 * Continue execution.
	 *
	 * @ignore
	 * @param {Array} step A function and the context it should be called in
	 * @return {Function} Function that continues the process
	 */
	function proceed( step ) {
		return function () {
			// Execute step in the correct context
			var deferred,
				result = step.callback.call( step.context );

			if ( result === false ) {
				// Use rejected promise for boolean false results
				return $.Deferred().reject( [] ).promise();
			}
			if ( typeof result === 'number' ) {
				if ( result < 0 ) {
					throw new Error( 'Cannot go back in time: flux capacitor is out of service' );
				}
				// Use a delayed promise for numbers, expecting them to be in milliseconds
				deferred = $.Deferred();
				setTimeout( deferred.resolve, result );
				return deferred.promise();
			}
			if ( result instanceof OO.ui.Error ) {
				// Use rejected promise for error
				return $.Deferred().reject( [ result ] ).promise();
			}
			if ( Array.isArray( result ) && result.length && result[ 0 ] instanceof OO.ui.Error ) {
				// Use rejected promise for list of errors
				return $.Deferred().reject( result ).promise();
			}
			// Duck-type the object to see if it can produce a promise
			if ( result && typeof result.promise === 'function' ) {
				// Use a promise generated from the result
				return result.promise();
			}
			// Use resolved promise for other results
			return $.Deferred().resolve().promise();
		};
	}

	if ( this.steps.length ) {
		// Generate a chain reaction of promises
		promise = proceed( this.steps[ 0 ] )();
		for ( i = 1, len = this.steps.length; i < len; i++ ) {
			promise = promise.then( proceed( this.steps[ i ] ) );
		}
	} else {
		promise = $.Deferred().resolve().promise();
	}

	return promise;
};

/**
 * Create a process step.
 *
 * @private
 * @param {number|jQuery.Promise|Function} step
 *
 * - Number of milliseconds to wait before proceeding
 * - Promise that must be resolved before proceeding
 * - Function to execute
 *   - If the function returns a boolean false the process will stop
 *   - If the function returns a promise, the process will continue to the next
 *     step when the promise is resolved or stop if the promise is rejected
 *   - If the function returns a number, the process will wait for that number of
 *     milliseconds before proceeding
 * @param {Object} [context=null] Execution context of the function. The context is
 *  ignored if the step is a number or promise.
 * @return {Object} Step object, with `callback` and `context` properties
 */
OO.ui.Process.prototype.createStep = function ( step, context ) {
	if ( typeof step === 'number' || typeof step.promise === 'function' ) {
		return {
			callback: function () {
				return step;
			},
			context: null
		};
	}
	if ( typeof step === 'function' ) {
		return {
			callback: step,
			context: context
		};
	}
	throw new Error( 'Cannot create process step: number, promise or function expected' );
};

/**
 * Add step to the beginning of the process.
 *
 * @inheritdoc #createStep
 * @return {OO.ui.Process} this
 * @chainable
 */
OO.ui.Process.prototype.first = function ( step, context ) {
	this.steps.unshift( this.createStep( step, context ) );
	return this;
};

/**
 * Add step to the end of the process.
 *
 * @inheritdoc #createStep
 * @return {OO.ui.Process} this
 * @chainable
 */
OO.ui.Process.prototype.next = function ( step, context ) {
	this.steps.push( this.createStep( step, context ) );
	return this;
};

/**
 * A window instance represents the life cycle for one single opening of a window
 * until its closing.
 *
 * While OO.ui.WindowManager will reuse OO.ui.Window objects, each time a window is
 * opened, a new lifecycle starts.
 *
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows
 *
 * @class
 *
 * @constructor
 */
OO.ui.WindowInstance = function OoUiWindowInstance() {
	var deferreds = {
		opening: $.Deferred(),
		opened: $.Deferred(),
		closing: $.Deferred(),
		closed: $.Deferred()
	};

	/**
	 * @private
	 * @property {Object}
	 */
	this.deferreds = deferreds;

	// Set these up as chained promises so that rejecting of
	// an earlier stage automatically rejects the subsequent
	// would-be stages as well.

	/**
	 * @property {jQuery.Promise}
	 */
	this.opening = deferreds.opening.promise();
	/**
	 * @property {jQuery.Promise}
	 */
	this.opened = this.opening.then( function () {
		return deferreds.opened;
	} );
	/**
	 * @property {jQuery.Promise}
	 */
	this.closing = this.opened.then( function () {
		return deferreds.closing;
	} );
	/**
	 * @property {jQuery.Promise}
	 */
	this.closed = this.closing.then( function () {
		return deferreds.closed;
	} );
};

/* Setup */

OO.initClass( OO.ui.WindowInstance );

/**
 * Check if window is opening.
 *
 * @return {boolean} Window is opening
 */
OO.ui.WindowInstance.prototype.isOpening = function () {
	return this.deferreds.opened.state() === 'pending';
};

/**
 * Check if window is opened.
 *
 * @return {boolean} Window is opened
 */
OO.ui.WindowInstance.prototype.isOpened = function () {
	return this.deferreds.opened.state() === 'resolved' &&
		this.deferreds.closing.state() === 'pending';
};

/**
 * Check if window is closing.
 *
 * @return {boolean} Window is closing
 */
OO.ui.WindowInstance.prototype.isClosing = function () {
	return this.deferreds.closing.state() === 'resolved' &&
		this.deferreds.closed.state() === 'pending';
};

/**
 * Check if window is closed.
 *
 * @return {boolean} Window is closed
 */
OO.ui.WindowInstance.prototype.isClosed = function () {
	return this.deferreds.closed.state() === 'resolved';
};

/**
 * Window managers are used to open and close {@link OO.ui.Window windows} and control their presentation.
 * Managed windows are mutually exclusive. If a new window is opened while a current window is opening
 * or is opened, the current window will be closed and any ongoing {@link OO.ui.Process process} will be cancelled. Windows
 * themselves are persistent and—rather than being torn down when closed—can be repopulated with the
 * pertinent data and reused.
 *
 * Over the lifecycle of a window, the window manager makes available three promises: `opening`,
 * `opened`, and `closing`, which represent the primary stages of the cycle:
 *
 * **Opening**: the opening stage begins when the window manager’s #openWindow or a window’s
 * {@link OO.ui.Window#open open} method is used, and the window manager begins to open the window.
 *
 * - an `opening` event is emitted with an `opening` promise
 * - the #getSetupDelay method is called and the returned value is used to time a pause in execution before the
 *   window’s {@link OO.ui.Window#method-setup setup} method is called which executes OO.ui.Window#getSetupProcess.
 * - a `setup` progress notification is emitted from the `opening` promise
 * - the #getReadyDelay method is called the returned value is used to time a pause in execution before the
 *   window’s {@link OO.ui.Window#method-ready ready} method is called which executes OO.ui.Window#getReadyProcess.
 * - a `ready` progress notification is emitted from the `opening` promise
 * - the `opening` promise is resolved with an `opened` promise
 *
 * **Opened**: the window is now open.
 *
 * **Closing**: the closing stage begins when the window manager's #closeWindow or the
 * window's {@link OO.ui.Window#close close} methods is used, and the window manager begins
 * to close the window.
 *
 * - the `opened` promise is resolved with `closing` promise and a `closing` event is emitted
 * - the #getHoldDelay method is called and the returned value is used to time a pause in execution before
 *   the window's {@link OO.ui.Window#getHoldProcess getHoldProcess} method is called on the
 *   window and its result executed
 * - a `hold` progress notification is emitted from the `closing` promise
 * - the #getTeardownDelay() method is called and the returned value is used to time a pause in execution before
 *   the window's {@link OO.ui.Window#getTeardownProcess getTeardownProcess} method is called on the
 *   window and its result executed
 * - a `teardown` progress notification is emitted from the `closing` promise
 * - the `closing` promise is resolved. The window is now closed
 *
 * See the [OOUI documentation on MediaWiki][1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Window_managers
 *
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.Factory} [factory] Window factory to use for automatic instantiation
 *  Note that window classes that are instantiated with a factory must have
 *  a {@link OO.ui.Dialog#static-name static name} property that specifies a symbolic name.
 * @cfg {boolean} [modal=true] Prevent interaction outside the dialog
 */
OO.ui.WindowManager = function OoUiWindowManager( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.WindowManager.parent.call( this, config );

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Properties
	this.factory = config.factory;
	this.modal = config.modal === undefined || !!config.modal;
	this.windows = {};
	// Deprecated placeholder promise given to compatOpening in openWindow()
	// that is resolved in closeWindow().
	this.compatOpened = null;
	this.preparingToOpen = null;
	this.preparingToClose = null;
	this.currentWindow = null;
	this.globalEvents = false;
	this.$returnFocusTo = null;
	this.$ariaHidden = null;
	this.onWindowResizeTimeout = null;
	this.onWindowResizeHandler = this.onWindowResize.bind( this );
	this.afterWindowResizeHandler = this.afterWindowResize.bind( this );

	// Initialization
	this.$element
		.addClass( 'oo-ui-windowManager' )
		.toggleClass( 'oo-ui-windowManager-modal', this.modal );
	if ( this.modal ) {
		this.$element.attr( 'aria-hidden', true );
	}
};

/* Setup */

OO.inheritClass( OO.ui.WindowManager, OO.ui.Element );
OO.mixinClass( OO.ui.WindowManager, OO.EventEmitter );

/* Events */

/**
 * An 'opening' event is emitted when the window begins to be opened.
 *
 * @event opening
 * @param {OO.ui.Window} win Window that's being opened
 * @param {jQuery.Promise} opened A promise resolved with a value when the window is opened successfully.
 *  This promise also emits `setup` and `ready` notifications. When this promise is resolved, the first
 *  argument of the value is an 'closed' promise, the second argument is the opening data.
 * @param {Object} data Window opening data
 */

/**
 * A 'closing' event is emitted when the window begins to be closed.
 *
 * @event closing
 * @param {OO.ui.Window} win Window that's being closed
 * @param {jQuery.Promise} closed A promise resolved with a value when the window is closed successfully.
 *  This promise also emits `hold` and `teardown` notifications. When this promise is resolved, the first
 *  argument of its value is the closing data.
 * @param {Object} data Window closing data
 */

/**
 * A 'resize' event is emitted when a window is resized.
 *
 * @event resize
 * @param {OO.ui.Window} win Window that was resized
 */

/* Static Properties */

/**
 * Map of the symbolic name of each window size and its CSS properties.
 *
 * @static
 * @inheritable
 * @property {Object}
 */
OO.ui.WindowManager.static.sizes = {
	small: {
		width: 300
	},
	medium: {
		width: 500
	},
	large: {
		width: 700
	},
	larger: {
		width: 900
	},
	full: {
		// These can be non-numeric because they are never used in calculations
		width: '100%',
		height: '100%'
	}
};

/**
 * Symbolic name of the default window size.
 *
 * The default size is used if the window's requested size is not recognized.
 *
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.WindowManager.static.defaultSize = 'medium';

/* Methods */

/**
 * Handle window resize events.
 *
 * @private
 * @param {jQuery.Event} e Window resize event
 */
OO.ui.WindowManager.prototype.onWindowResize = function () {
	clearTimeout( this.onWindowResizeTimeout );
	this.onWindowResizeTimeout = setTimeout( this.afterWindowResizeHandler, 200 );
};

/**
 * Handle window resize events.
 *
 * @private
 * @param {jQuery.Event} e Window resize event
 */
OO.ui.WindowManager.prototype.afterWindowResize = function () {
	var currentFocusedElement = document.activeElement;
	if ( this.currentWindow ) {
		this.updateWindowSize( this.currentWindow );

		// Restore focus to the original element if it has changed.
		// When a layout change is made on resize inputs lose focus
		// on Android (Chrome and Firefox). See T162127.
		if ( currentFocusedElement !== document.activeElement ) {
			currentFocusedElement.focus();
		}
	}
};

/**
 * Check if window is opening.
 *
 * @param {OO.ui.Window} win Window to check
 * @return {boolean} Window is opening
 */
OO.ui.WindowManager.prototype.isOpening = function ( win ) {
	return win === this.currentWindow && !!this.lifecycle &&
		this.lifecycle.isOpening();
};

/**
 * Check if window is closing.
 *
 * @param {OO.ui.Window} win Window to check
 * @return {boolean} Window is closing
 */
OO.ui.WindowManager.prototype.isClosing = function ( win ) {
	return win === this.currentWindow && !!this.lifecycle &&
		this.lifecycle.isClosing();
};

/**
 * Check if window is opened.
 *
 * @param {OO.ui.Window} win Window to check
 * @return {boolean} Window is opened
 */
OO.ui.WindowManager.prototype.isOpened = function ( win ) {
	return win === this.currentWindow && !!this.lifecycle &&
		this.lifecycle.isOpened();
};

/**
 * Check if a window is being managed.
 *
 * @param {OO.ui.Window} win Window to check
 * @return {boolean} Window is being managed
 */
OO.ui.WindowManager.prototype.hasWindow = function ( win ) {
	var name;

	for ( name in this.windows ) {
		if ( this.windows[ name ] === win ) {
			return true;
		}
	}

	return false;
};

/**
 * Get the number of milliseconds to wait after opening begins before executing the ‘setup’ process.
 *
 * @param {OO.ui.Window} win Window being opened
 * @param {Object} [data] Window opening data
 * @return {number} Milliseconds to wait
 */
OO.ui.WindowManager.prototype.getSetupDelay = function () {
	return 0;
};

/**
 * Get the number of milliseconds to wait after setup has finished before executing the ‘ready’ process.
 *
 * @param {OO.ui.Window} win Window being opened
 * @param {Object} [data] Window opening data
 * @return {number} Milliseconds to wait
 */
OO.ui.WindowManager.prototype.getReadyDelay = function () {
	return this.modal ? OO.ui.theme.getDialogTransitionDuration() : 0;
};

/**
 * Get the number of milliseconds to wait after closing has begun before executing the 'hold' process.
 *
 * @param {OO.ui.Window} win Window being closed
 * @param {Object} [data] Window closing data
 * @return {number} Milliseconds to wait
 */
OO.ui.WindowManager.prototype.getHoldDelay = function () {
	return 0;
};

/**
 * Get the number of milliseconds to wait after the ‘hold’ process has finished before
 * executing the ‘teardown’ process.
 *
 * @param {OO.ui.Window} win Window being closed
 * @param {Object} [data] Window closing data
 * @return {number} Milliseconds to wait
 */
OO.ui.WindowManager.prototype.getTeardownDelay = function () {
	return this.modal ? OO.ui.theme.getDialogTransitionDuration() : 0;
};

/**
 * Get a window by its symbolic name.
 *
 * If the window is not yet instantiated and its symbolic name is recognized by a factory, it will be
 * instantiated and added to the window manager automatically. Please see the [OOUI documentation on MediaWiki][3]
 * for more information about using factories.
 * [3]: https://www.mediawiki.org/wiki/OOUI/Windows/Window_managers
 *
 * @param {string} name Symbolic name of the window
 * @return {jQuery.Promise} Promise resolved with matching window, or rejected with an OO.ui.Error
 * @throws {Error} An error is thrown if the symbolic name is not recognized by the factory.
 * @throws {Error} An error is thrown if the named window is not recognized as a managed window.
 */
OO.ui.WindowManager.prototype.getWindow = function ( name ) {
	var deferred = $.Deferred(),
		win = this.windows[ name ];

	if ( !( win instanceof OO.ui.Window ) ) {
		if ( this.factory ) {
			if ( !this.factory.lookup( name ) ) {
				deferred.reject( new OO.ui.Error(
					'Cannot auto-instantiate window: symbolic name is unrecognized by the factory'
				) );
			} else {
				win = this.factory.create( name );
				this.addWindows( [ win ] );
				deferred.resolve( win );
			}
		} else {
			deferred.reject( new OO.ui.Error(
				'Cannot get unmanaged window: symbolic name unrecognized as a managed window'
			) );
		}
	} else {
		deferred.resolve( win );
	}

	return deferred.promise();
};

/**
 * Get current window.
 *
 * @return {OO.ui.Window|null} Currently opening/opened/closing window
 */
OO.ui.WindowManager.prototype.getCurrentWindow = function () {
	return this.currentWindow;
};

/* eslint-disable valid-jsdoc */
/**
 * Open a window.
 *
 * @param {OO.ui.Window|string} win Window object or symbolic name of window to open
 * @param {Object} [data] Window opening data
 * @param {jQuery|null} [data.$returnFocusTo] Element to which the window will return focus when closed.
 *  Defaults the current activeElement. If set to null, focus isn't changed on close.
 * @return {OO.ui.WindowInstance} A lifecycle object representing this particular
 *  opening of the window. For backwards-compatibility, then object is also a Thenable that is resolved
 *  when the window is done opening, with nested promise for when closing starts. This behaviour
 *  is deprecated and is not compatible with jQuery 3. See T163510.
 * @fires opening
 */
OO.ui.WindowManager.prototype.openWindow = function ( win, data, lifecycle, compatOpening ) {
	/* eslint-enable valid-jsdoc */
	var error,
		manager = this;
	data = data || {};

	// Internal parameter 'lifecycle' allows this method to always return
	// a lifecycle even if the window still needs to be created
	// asynchronously when 'win' is a string.
	lifecycle = lifecycle || new OO.ui.WindowInstance();
	compatOpening = compatOpening || $.Deferred();

	// Turn lifecycle into a Thenable for backwards-compatibility with
	// the deprecated nested-promise behaviour, see T163510.
	[ 'state', 'always', 'catch', 'pipe', 'then', 'promise', 'progress', 'done', 'fail' ]
		.forEach( function ( method ) {
			lifecycle[ method ] = function () {
				OO.ui.warnDeprecation(
					'Using the return value of openWindow as a promise is deprecated. ' +
					'Use .openWindow( ... ).opening.' + method + '( ... ) instead.'
				);
				return compatOpening[ method ].apply( this, arguments );
			};
		} );

	// Argument handling
	if ( typeof win === 'string' ) {
		this.getWindow( win ).then(
			function ( win ) {
				manager.openWindow( win, data, lifecycle, compatOpening );
			},
			function ( err ) {
				lifecycle.deferreds.opening.reject( err );
			}
		);
		return lifecycle;
	}

	// Error handling
	if ( !this.hasWindow( win ) ) {
		error = 'Cannot open window: window is not attached to manager';
	} else if ( this.lifecycle && this.lifecycle.isOpened() ) {
		error = 'Cannot open window: another window is open';
	} else if ( this.preparingToOpen || ( this.lifecycle && this.lifecycle.isOpening() ) ) {
		error = 'Cannot open window: another window is opening';
	}

	if ( error ) {
		compatOpening.reject( new OO.ui.Error( error ) );
		lifecycle.deferreds.opening.reject( new OO.ui.Error( error ) );
		return lifecycle;
	}

	// If a window is currently closing, wait for it to complete
	this.preparingToOpen = $.when( this.lifecycle && this.lifecycle.closed );
	// Ensure handlers get called after preparingToOpen is set
	this.preparingToOpen.done( function () {
		if ( manager.modal ) {
			manager.toggleGlobalEvents( true );
			manager.toggleAriaIsolation( true );
		}
		manager.$returnFocusTo = data.$returnFocusTo !== undefined ? data.$returnFocusTo : $( document.activeElement );
		manager.currentWindow = win;
		manager.lifecycle = lifecycle;
		manager.preparingToOpen = null;
		manager.emit( 'opening', win, compatOpening, data );
		lifecycle.deferreds.opening.resolve( data );
		setTimeout( function () {
			manager.compatOpened = $.Deferred();
			win.setup( data ).then( function () {
				compatOpening.notify( { state: 'setup' } );
				setTimeout( function () {
					win.ready( data ).then( function () {
						compatOpening.notify( { state: 'ready' } );
						lifecycle.deferreds.opened.resolve( data );
						compatOpening.resolve( manager.compatOpened.promise(), data );
					}, function () {
						lifecycle.deferreds.opened.reject();
						compatOpening.reject();
						manager.closeWindow( win );
					} );
				}, manager.getReadyDelay() );
			}, function () {
				lifecycle.deferreds.opened.reject();
				compatOpening.reject();
				manager.closeWindow( win );
			} );
		}, manager.getSetupDelay() );
	} );

	return lifecycle;
};

/**
 * Close a window.
 *
 * @param {OO.ui.Window|string} win Window object or symbolic name of window to close
 * @param {Object} [data] Window closing data
 * @return {OO.ui.WindowInstance} A lifecycle object representing this particular
 *  opening of the window. For backwards-compatibility, the object is also a Thenable that is resolved
 *  when the window is done closing, see T163510.
 * @fires closing
 */
OO.ui.WindowManager.prototype.closeWindow = function ( win, data ) {
	var error,
		manager = this,
		compatClosing = $.Deferred(),
		lifecycle = this.lifecycle,
		compatOpened;

	// Argument handling
	if ( typeof win === 'string' ) {
		win = this.windows[ win ];
	} else if ( !this.hasWindow( win ) ) {
		win = null;
	}

	// Error handling
	if ( !lifecycle ) {
		error = 'Cannot close window: no window is currently open';
	} else if ( !win ) {
		error = 'Cannot close window: window is not attached to manager';
	} else if ( win !== this.currentWindow || this.lifecycle.isClosed() ) {
		error = 'Cannot close window: window already closed with different data';
	} else if ( this.preparingToClose || this.lifecycle.isClosing() ) {
		error = 'Cannot close window: window already closing with different data';
	}

	if ( error ) {
		// This function was called for the wrong window and we don't want to mess with the current
		// window's state.
		lifecycle = new OO.ui.WindowInstance();
		// Pretend the window has been opened, so that we can pretend to fail to close it.
		lifecycle.deferreds.opening.resolve( {} );
		lifecycle.deferreds.opened.resolve( {} );
	}

	// Turn lifecycle into a Thenable for backwards-compatibility with
	// the deprecated nested-promise behaviour, see T163510.
	[ 'state', 'always', 'catch', 'pipe', 'then', 'promise', 'progress', 'done', 'fail' ]
		.forEach( function ( method ) {
			lifecycle[ method ] = function () {
				OO.ui.warnDeprecation(
					'Using the return value of closeWindow as a promise is deprecated. ' +
					'Use .closeWindow( ... ).closed.' + method + '( ... ) instead.'
				);
				return compatClosing[ method ].apply( this, arguments );
			};
		} );

	if ( error ) {
		compatClosing.reject( new OO.ui.Error( error ) );
		lifecycle.deferreds.closing.reject( new OO.ui.Error( error ) );
		return lifecycle;
	}

	// If the window is currently opening, close it when it's done
	this.preparingToClose = $.when( this.lifecycle.opened );
	// Ensure handlers get called after preparingToClose is set
	this.preparingToClose.always( function () {
		manager.preparingToClose = null;
		manager.emit( 'closing', win, compatClosing, data );
		lifecycle.deferreds.closing.resolve( data );
		compatOpened = manager.compatOpened;
		manager.compatOpened = null;
		compatOpened.resolve( compatClosing.promise(), data );
		setTimeout( function () {
			win.hold( data ).then( function () {
				compatClosing.notify( { state: 'hold' } );
				setTimeout( function () {
					win.teardown( data ).then( function () {
						compatClosing.notify( { state: 'teardown' } );
						if ( manager.modal ) {
							manager.toggleGlobalEvents( false );
							manager.toggleAriaIsolation( false );
						}
						if ( manager.$returnFocusTo && manager.$returnFocusTo.length ) {
							manager.$returnFocusTo[ 0 ].focus();
						}
						manager.currentWindow = null;
						manager.lifecycle = null;
						lifecycle.deferreds.closed.resolve( data );
						compatClosing.resolve( data );
					} );
				}, manager.getTeardownDelay() );
			} );
		}, manager.getHoldDelay() );
	} );

	return lifecycle;
};

/**
 * Add windows to the window manager.
 *
 * Windows can be added by reference, symbolic name, or explicitly defined symbolic names.
 * See the [OOUI documentation on MediaWiki] [2] for examples.
 * [2]: https://www.mediawiki.org/wiki/OOUI/Windows/Window_managers
 *
 * This function can be called in two manners:
 *
 * 1. `.addWindows( [ windowA, windowB, ... ] )` (where `windowA`, `windowB` are OO.ui.Window objects)
 *
 *    This syntax registers windows under the symbolic names defined in their `.static.name`
 *    properties. For example, if `windowA.constructor.static.name` is `'nameA'`, calling
 *    `.openWindow( 'nameA' )` afterwards will open the window `windowA`. This syntax requires the
 *    static name to be set, otherwise an exception will be thrown.
 *
 *    This is the recommended way, as it allows for an easier switch to using a window factory.
 *
 * 2. `.addWindows( { nameA: windowA, nameB: windowB, ... } )`
 *
 *    This syntax registers windows under the explicitly given symbolic names. In this example,
 *    calling `.openWindow( 'nameA' )` afterwards will open the window `windowA`, regardless of what
 *    its `.static.name` is set to. The static name is not required to be set.
 *
 *    This should only be used if you need to override the default symbolic names.
 *
 * Example:
 *
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *
 *     // Add a window under the default name: see OO.ui.MessageDialog.static.name
 *     windowManager.addWindows( [ new OO.ui.MessageDialog() ] );
 *     // Add a window under an explicit name
 *     windowManager.addWindows( { myMessageDialog: new OO.ui.MessageDialog() } );
 *
 *     // Open window by default name
 *     windowManager.openWindow( 'message' );
 *     // Open window by explicitly given name
 *     windowManager.openWindow( 'myMessageDialog' );
 *
 *
 * @param {Object.<string,OO.ui.Window>|OO.ui.Window[]} windows An array of window objects specified
 *  by reference, symbolic name, or explicitly defined symbolic names.
 * @throws {Error} An error is thrown if a window is added by symbolic name, but has neither an
 *  explicit nor a statically configured symbolic name.
 */
OO.ui.WindowManager.prototype.addWindows = function ( windows ) {
	var i, len, win, name, list;

	if ( Array.isArray( windows ) ) {
		// Convert to map of windows by looking up symbolic names from static configuration
		list = {};
		for ( i = 0, len = windows.length; i < len; i++ ) {
			name = windows[ i ].constructor.static.name;
			if ( !name ) {
				throw new Error( 'Windows must have a `name` static property defined.' );
			}
			list[ name ] = windows[ i ];
		}
	} else if ( OO.isPlainObject( windows ) ) {
		list = windows;
	}

	// Add windows
	for ( name in list ) {
		win = list[ name ];
		this.windows[ name ] = win.toggle( false );
		this.$element.append( win.$element );
		win.setManager( this );
	}
};

/**
 * Remove the specified windows from the windows manager.
 *
 * Windows will be closed before they are removed. If you wish to remove all windows, you may wish to use
 * the #clearWindows method instead. If you no longer need the window manager and want to ensure that it no
 * longer listens to events, use the #destroy method.
 *
 * @param {string[]} names Symbolic names of windows to remove
 * @return {jQuery.Promise} Promise resolved when window is closed and removed
 * @throws {Error} An error is thrown if the named windows are not managed by the window manager.
 */
OO.ui.WindowManager.prototype.removeWindows = function ( names ) {
	var i, len, win, name, cleanupWindow,
		manager = this,
		promises = [],
		cleanup = function ( name, win ) {
			delete manager.windows[ name ];
			win.$element.detach();
		};

	for ( i = 0, len = names.length; i < len; i++ ) {
		name = names[ i ];
		win = this.windows[ name ];
		if ( !win ) {
			throw new Error( 'Cannot remove window' );
		}
		cleanupWindow = cleanup.bind( null, name, win );
		promises.push( this.closeWindow( name ).closed.then( cleanupWindow, cleanupWindow ) );
	}

	return $.when.apply( $, promises );
};

/**
 * Remove all windows from the window manager.
 *
 * Windows will be closed before they are removed. Note that the window manager, though not in use, will still
 * listen to events. If the window manager will not be used again, you may wish to use the #destroy method instead.
 * To remove just a subset of windows, use the #removeWindows method.
 *
 * @return {jQuery.Promise} Promise resolved when all windows are closed and removed
 */
OO.ui.WindowManager.prototype.clearWindows = function () {
	return this.removeWindows( Object.keys( this.windows ) );
};

/**
 * Set dialog size. In general, this method should not be called directly.
 *
 * Fullscreen mode will be used if the dialog is too wide to fit in the screen.
 *
 * @param {OO.ui.Window} win Window to update, should be the current window
 * @chainable
 * @return {OO.ui.WindowManager} The manager, for chaining
 */
OO.ui.WindowManager.prototype.updateWindowSize = function ( win ) {
	var isFullscreen;

	// Bypass for non-current, and thus invisible, windows
	if ( win !== this.currentWindow ) {
		return;
	}

	isFullscreen = win.getSize() === 'full';

	this.$element.toggleClass( 'oo-ui-windowManager-fullscreen', isFullscreen );
	this.$element.toggleClass( 'oo-ui-windowManager-floating', !isFullscreen );
	win.setDimensions( win.getSizeProperties() );

	this.emit( 'resize', win );

	return this;
};

/**
 * Bind or unbind global events for scrolling.
 *
 * @private
 * @param {boolean} [on] Bind global events
 * @chainable
 * @return {OO.ui.WindowManager} The manager, for chaining
 */
OO.ui.WindowManager.prototype.toggleGlobalEvents = function ( on ) {
	var scrollWidth, bodyMargin,
		$body = $( this.getElementDocument().body ),
		// We could have multiple window managers open so only modify
		// the body css at the bottom of the stack
		stackDepth = $body.data( 'windowManagerGlobalEvents' ) || 0;

	on = on === undefined ? !!this.globalEvents : !!on;

	if ( on ) {
		if ( !this.globalEvents ) {
			$( this.getElementWindow() ).on( {
				// Start listening for top-level window dimension changes
				'orientationchange resize': this.onWindowResizeHandler
			} );
			if ( stackDepth === 0 ) {
				scrollWidth = window.innerWidth - document.documentElement.clientWidth;
				bodyMargin = parseFloat( $body.css( 'margin-right' ) ) || 0;
				$body.addClass( 'oo-ui-windowManager-modal-active' );
				$body.css( 'margin-right', bodyMargin + scrollWidth );
			}
			stackDepth++;
			this.globalEvents = true;
		}
	} else if ( this.globalEvents ) {
		$( this.getElementWindow() ).off( {
			// Stop listening for top-level window dimension changes
			'orientationchange resize': this.onWindowResizeHandler
		} );
		stackDepth--;
		if ( stackDepth === 0 ) {
			$body.removeClass( 'oo-ui-windowManager-modal-active' );
			$body.css( 'margin-right', '' );
		}
		this.globalEvents = false;
	}
	$body.data( 'windowManagerGlobalEvents', stackDepth );

	return this;
};

/**
 * Toggle screen reader visibility of content other than the window manager.
 *
 * @private
 * @param {boolean} [isolate] Make only the window manager visible to screen readers
 * @chainable
 * @return {OO.ui.WindowManager} The manager, for chaining
 */
OO.ui.WindowManager.prototype.toggleAriaIsolation = function ( isolate ) {
	var $topLevelElement;
	isolate = isolate === undefined ? !this.$ariaHidden : !!isolate;

	if ( isolate ) {
		if ( !this.$ariaHidden ) {
			// Find the top level element containing the window manager or the
			// window manager's element itself in case its a direct child of body
			$topLevelElement = this.$element.parentsUntil( 'body' ).last();
			$topLevelElement = $topLevelElement.length === 0 ? this.$element : $topLevelElement;

			// In case previously set by another window manager
			this.$element.removeAttr( 'aria-hidden' );

			// Hide everything other than the window manager from screen readers
			this.$ariaHidden = $( document.body )
				.children()
				.not( 'script' )
				.not( $topLevelElement )
				.attr( 'aria-hidden', true );
		}
	} else if ( this.$ariaHidden ) {
		// Restore screen reader visibility
		this.$ariaHidden.removeAttr( 'aria-hidden' );
		this.$ariaHidden = null;

		// and hide the window manager
		this.$element.attr( 'aria-hidden', true );
	}

	return this;
};

/**
 * Destroy the window manager.
 *
 * Destroying the window manager ensures that it will no longer listen to events. If you would like to
 * continue using the window manager, but wish to remove all windows from it, use the #clearWindows method
 * instead.
 */
OO.ui.WindowManager.prototype.destroy = function () {
	this.toggleGlobalEvents( false );
	this.toggleAriaIsolation( false );
	this.clearWindows();
	this.$element.remove();
};

/**
 * A window is a container for elements that are in a child frame. They are used with
 * a window manager (OO.ui.WindowManager), which is used to open and close the window and control
 * its presentation. The size of a window is specified using a symbolic name (e.g., ‘small’, ‘medium’,
 * ‘large’), which is interpreted by the window manager. If the requested size is not recognized,
 * the window manager will choose a sensible fallback.
 *
 * The lifecycle of a window has three primary stages (opening, opened, and closing) in which
 * different processes are executed:
 *
 * **opening**: The opening stage begins when the window manager's {@link OO.ui.WindowManager#openWindow
 * openWindow} or the window's {@link #open open} methods are used, and the window manager begins to open
 * the window.
 *
 * - {@link #getSetupProcess} method is called and its result executed
 * - {@link #getReadyProcess} method is called and its result executed
 *
 * **opened**: The window is now open
 *
 * **closing**: The closing stage begins when the window manager's
 * {@link OO.ui.WindowManager#closeWindow closeWindow}
 * or the window's {@link #close} methods are used, and the window manager begins to close the window.
 *
 * - {@link #getHoldProcess} method is called and its result executed
 * - {@link #getTeardownProcess} method is called and its result executed. The window is now closed
 *
 * Each of the window's processes (setup, ready, hold, and teardown) can be extended in subclasses
 * by overriding the window's #getSetupProcess, #getReadyProcess, #getHoldProcess and #getTeardownProcess
 * methods. Note that each {@link OO.ui.Process process} is executed in series, so asynchronous
 * processing can complete. Always assume window processes are executed asynchronously.
 *
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows
 *
 * @abstract
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [size] Symbolic name of the dialog size: `small`, `medium`, `large`, `larger` or
 *  `full`.  If omitted, the value of the {@link #static-size static size} property will be used.
 */
OO.ui.Window = function OoUiWindow( config ) {
	// Configuration initialization
	config = config || {};

	// Parent constructor
	OO.ui.Window.parent.call( this, config );

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Properties
	this.manager = null;
	this.size = config.size || this.constructor.static.size;
	this.$frame = $( '<div>' );
	/**
	 * Overlay element to use for the `$overlay` configuration option of widgets that support it.
	 * Things put inside of it are overlaid on top of the window and are not bound to its dimensions.
	 * See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
	 *
	 *     MyDialog.prototype.initialize = function () {
	 *       ...
	 *       var popupButton = new OO.ui.PopupButtonWidget( {
	 *         $overlay: this.$overlay,
	 *         label: 'Popup button',
	 *         popup: {
	 *           $content: $( '<p>Popup contents.</p><p>Popup contents.</p><p>Popup contents.</p>' ),
	 *           padded: true
	 *         }
	 *       } );
	 *       ...
	 *     };
	 *
	 * @property {jQuery}
	 */
	this.$overlay = $( '<div>' );
	this.$content = $( '<div>' );

	this.$focusTrapBefore = $( '<div>' ).prop( 'tabIndex', 0 );
	this.$focusTrapAfter = $( '<div>' ).prop( 'tabIndex', 0 );
	this.$focusTraps = this.$focusTrapBefore.add( this.$focusTrapAfter );

	// Initialization
	this.$overlay.addClass( 'oo-ui-window-overlay' );
	this.$content
		.addClass( 'oo-ui-window-content' )
		.attr( 'tabindex', 0 );
	this.$frame
		.addClass( 'oo-ui-window-frame' )
		.append( this.$focusTrapBefore, this.$content, this.$focusTrapAfter );

	this.$element
		.addClass( 'oo-ui-window' )
		.append( this.$frame, this.$overlay );

	// Initially hidden - using #toggle may cause errors if subclasses override toggle with methods
	// that reference properties not initialized at that time of parent class construction
	// TODO: Find a better way to handle post-constructor setup
	this.visible = false;
	this.$element.addClass( 'oo-ui-element-hidden' );
};

/* Setup */

OO.inheritClass( OO.ui.Window, OO.ui.Element );
OO.mixinClass( OO.ui.Window, OO.EventEmitter );

/* Static Properties */

/**
 * Symbolic name of the window size: `small`, `medium`, `large`, `larger` or `full`.
 *
 * The static size is used if no #size is configured during construction.
 *
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Window.static.size = 'medium';

/* Methods */

/**
 * Handle mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.onMouseDown = function ( e ) {
	// Prevent clicking on the click-block from stealing focus
	if ( e.target === this.$element[ 0 ] ) {
		return false;
	}
};

/**
 * Check if the window has been initialized.
 *
 * Initialization occurs when a window is added to a manager.
 *
 * @return {boolean} Window has been initialized
 */
OO.ui.Window.prototype.isInitialized = function () {
	return !!this.manager;
};

/**
 * Check if the window is visible.
 *
 * @return {boolean} Window is visible
 */
OO.ui.Window.prototype.isVisible = function () {
	return this.visible;
};

/**
 * Check if the window is opening.
 *
 * This method is a wrapper around the window manager's {@link OO.ui.WindowManager#isOpening isOpening}
 * method.
 *
 * @return {boolean} Window is opening
 */
OO.ui.Window.prototype.isOpening = function () {
	return this.manager.isOpening( this );
};

/**
 * Check if the window is closing.
 *
 * This method is a wrapper around the window manager's {@link OO.ui.WindowManager#isClosing isClosing} method.
 *
 * @return {boolean} Window is closing
 */
OO.ui.Window.prototype.isClosing = function () {
	return this.manager.isClosing( this );
};

/**
 * Check if the window is opened.
 *
 * This method is a wrapper around the window manager's {@link OO.ui.WindowManager#isOpened isOpened} method.
 *
 * @return {boolean} Window is opened
 */
OO.ui.Window.prototype.isOpened = function () {
	return this.manager.isOpened( this );
};

/**
 * Get the window manager.
 *
 * All windows must be attached to a window manager, which is used to open
 * and close the window and control its presentation.
 *
 * @return {OO.ui.WindowManager} Manager of window
 */
OO.ui.Window.prototype.getManager = function () {
	return this.manager;
};

/**
 * Get the symbolic name of the window size (e.g., `small` or `medium`).
 *
 * @return {string} Symbolic name of the size: `small`, `medium`, `large`, `larger`, `full`
 */
OO.ui.Window.prototype.getSize = function () {
	var viewport = OO.ui.Element.static.getDimensions( this.getElementWindow() ),
		sizes = this.manager.constructor.static.sizes,
		size = this.size;

	if ( !sizes[ size ] ) {
		size = this.manager.constructor.static.defaultSize;
	}
	if ( size !== 'full' && viewport.rect.right - viewport.rect.left < sizes[ size ].width ) {
		size = 'full';
	}

	return size;
};

/**
 * Get the size properties associated with the current window size
 *
 * @return {Object} Size properties
 */
OO.ui.Window.prototype.getSizeProperties = function () {
	return this.manager.constructor.static.sizes[ this.getSize() ];
};

/**
 * Disable transitions on window's frame for the duration of the callback function, then enable them
 * back.
 *
 * @private
 * @param {Function} callback Function to call while transitions are disabled
 */
OO.ui.Window.prototype.withoutSizeTransitions = function ( callback ) {
	// Temporarily resize the frame so getBodyHeight() can use scrollHeight measurements.
	// Disable transitions first, otherwise we'll get values from when the window was animating.
	// We need to build the transition CSS properties using these specific properties since
	// Firefox doesn't return anything useful when asked just for 'transition'.
	var oldTransition = this.$frame.css( 'transition-property' ) + ' ' +
		this.$frame.css( 'transition-duration' ) + ' ' +
		this.$frame.css( 'transition-timing-function' ) + ' ' +
		this.$frame.css( 'transition-delay' );

	this.$frame.css( 'transition', 'none' );
	callback();

	// Force reflow to make sure the style changes done inside callback
	// really are not transitioned
	this.$frame.height();
	this.$frame.css( 'transition', oldTransition );
};

/**
 * Get the height of the full window contents (i.e., the window head, body and foot together).
 *
 * What constitutes the head, body, and foot varies depending on the window type.
 * A {@link OO.ui.MessageDialog message dialog} displays a title and message in its body,
 * and any actions in the foot. A {@link OO.ui.ProcessDialog process dialog} displays a title
 * and special actions in the head, and dialog content in the body.
 *
 * To get just the height of the dialog body, use the #getBodyHeight method.
 *
 * @return {number} The height of the window contents (the dialog head, body and foot) in pixels
 */
OO.ui.Window.prototype.getContentHeight = function () {
	var bodyHeight,
		win = this,
		bodyStyleObj = this.$body[ 0 ].style,
		frameStyleObj = this.$frame[ 0 ].style;

	// Temporarily resize the frame so getBodyHeight() can use scrollHeight measurements.
	// Disable transitions first, otherwise we'll get values from when the window was animating.
	this.withoutSizeTransitions( function () {
		var oldHeight = frameStyleObj.height,
			oldPosition = bodyStyleObj.position;
		frameStyleObj.height = '1px';
		// Force body to resize to new width
		bodyStyleObj.position = 'relative';
		bodyHeight = win.getBodyHeight();
		frameStyleObj.height = oldHeight;
		bodyStyleObj.position = oldPosition;
	} );

	return (
		// Add buffer for border
		( this.$frame.outerHeight() - this.$frame.innerHeight() ) +
		// Use combined heights of children
		( this.$head.outerHeight( true ) + bodyHeight + this.$foot.outerHeight( true ) )
	);
};

/**
 * Get the height of the window body.
 *
 * To get the height of the full window contents (the window body, head, and foot together),
 * use #getContentHeight.
 *
 * When this function is called, the window will temporarily have been resized
 * to height=1px, so .scrollHeight measurements can be taken accurately.
 *
 * @return {number} Height of the window body in pixels
 */
OO.ui.Window.prototype.getBodyHeight = function () {
	return this.$body[ 0 ].scrollHeight;
};

/**
 * Get the directionality of the frame (right-to-left or left-to-right).
 *
 * @return {string} Directionality: `'ltr'` or `'rtl'`
 */
OO.ui.Window.prototype.getDir = function () {
	return OO.ui.Element.static.getDir( this.$content ) || 'ltr';
};

/**
 * Get the 'setup' process.
 *
 * The setup process is used to set up a window for use in a particular context, based on the `data`
 * argument. This method is called during the opening phase of the window’s lifecycle (before the
 * opening animation). You can add elements to the window in this process or set their default
 * values.
 *
 * Override this method to add additional steps to the ‘setup’ process the parent method provides
 * using the {@link OO.ui.Process#first first} and {@link OO.ui.Process#next next} methods
 * of OO.ui.Process.
 *
 * To add window content that persists between openings, you may wish to use the #initialize method
 * instead.
 *
 * @param {Object} [data] Window opening data
 * @return {OO.ui.Process} Setup process
 */
OO.ui.Window.prototype.getSetupProcess = function () {
	return new OO.ui.Process();
};

/**
 * Get the ‘ready’ process.
 *
 * The ready process is used to ready a window for use in a particular context, based on the `data`
 * argument. This method is called during the opening phase of the window’s lifecycle, after the
 * window has been {@link #getSetupProcess setup} (after the opening animation). You can focus
 * elements in the window in this process, or open their dropdowns.
 *
 * Override this method to add additional steps to the ‘ready’ process the parent method
 * provides using the {@link OO.ui.Process#first first} and {@link OO.ui.Process#next next}
 * methods of OO.ui.Process.
 *
 * @param {Object} [data] Window opening data
 * @return {OO.ui.Process} Ready process
 */
OO.ui.Window.prototype.getReadyProcess = function () {
	return new OO.ui.Process();
};

/**
 * Get the 'hold' process.
 *
 * The hold process is used to keep a window from being used in a particular context, based on the
 * `data` argument. This method is called during the closing phase of the window’s lifecycle (before
 * the closing animation). You can close dropdowns of elements in the window in this process, if
 * they do not get closed automatically.
 *
 * Override this method to add additional steps to the 'hold' process the parent method provides
 * using the {@link OO.ui.Process#first first} and {@link OO.ui.Process#next next} methods
 * of OO.ui.Process.
 *
 * @param {Object} [data] Window closing data
 * @return {OO.ui.Process} Hold process
 */
OO.ui.Window.prototype.getHoldProcess = function () {
	return new OO.ui.Process();
};

/**
 * Get the ‘teardown’ process.
 *
 * The teardown process is used to teardown a window after use. During teardown, user interactions
 * within the window are conveyed and the window is closed, based on the `data` argument. This
 * method is called during the closing phase of the window’s lifecycle (after the closing
 * animation). You can remove elements in the window in this process or clear their values.
 *
 * Override this method to add additional steps to the ‘teardown’ process the parent method provides
 * using the {@link OO.ui.Process#first first} and {@link OO.ui.Process#next next} methods
 * of OO.ui.Process.
 *
 * @param {Object} [data] Window closing data
 * @return {OO.ui.Process} Teardown process
 */
OO.ui.Window.prototype.getTeardownProcess = function () {
	return new OO.ui.Process();
};

/**
 * Set the window manager.
 *
 * This will cause the window to initialize. Calling it more than once will cause an error.
 *
 * @param {OO.ui.WindowManager} manager Manager for this window
 * @throws {Error} An error is thrown if the method is called more than once
 * @chainable
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.setManager = function ( manager ) {
	if ( this.manager ) {
		throw new Error( 'Cannot set window manager, window already has a manager' );
	}

	this.manager = manager;
	this.initialize();

	return this;
};

/**
 * Set the window size by symbolic name (e.g., 'small' or 'medium')
 *
 * @param {string} size Symbolic name of size: `small`, `medium`, `large`, `larger` or
 *  `full`
 * @chainable
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.setSize = function ( size ) {
	this.size = size;
	this.updateSize();
	return this;
};

/**
 * Update the window size.
 *
 * @throws {Error} An error is thrown if the window is not attached to a window manager
 * @chainable
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.updateSize = function () {
	if ( !this.manager ) {
		throw new Error( 'Cannot update window size, must be attached to a manager' );
	}

	this.manager.updateWindowSize( this );

	return this;
};

/**
 * Set window dimensions. This method is called by the {@link OO.ui.WindowManager window manager}
 * when the window is opening. In general, setDimensions should not be called directly.
 *
 * To set the size of the window, use the #setSize method.
 *
 * @param {Object} dim CSS dimension properties
 * @param {string|number} [dim.width] Width
 * @param {string|number} [dim.minWidth] Minimum width
 * @param {string|number} [dim.maxWidth] Maximum width
 * @param {string|number} [dim.height] Height, omit to set based on height of contents
 * @param {string|number} [dim.minHeight] Minimum height
 * @param {string|number} [dim.maxHeight] Maximum height
 * @chainable
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.setDimensions = function ( dim ) {
	var height,
		win = this,
		styleObj = this.$frame[ 0 ].style;

	// Calculate the height we need to set using the correct width
	if ( dim.height === undefined ) {
		this.withoutSizeTransitions( function () {
			var oldWidth = styleObj.width;
			win.$frame.css( 'width', dim.width || '' );
			height = win.getContentHeight();
			styleObj.width = oldWidth;
		} );
	} else {
		height = dim.height;
	}

	this.$frame.css( {
		width: dim.width || '',
		minWidth: dim.minWidth || '',
		maxWidth: dim.maxWidth || '',
		height: height || '',
		minHeight: dim.minHeight || '',
		maxHeight: dim.maxHeight || ''
	} );

	return this;
};

/**
 * Initialize window contents.
 *
 * Before the window is opened for the first time, #initialize is called so that content that
 * persists between openings can be added to the window.
 *
 * To set up a window with new content each time the window opens, use #getSetupProcess.
 *
 * @throws {Error} An error is thrown if the window is not attached to a window manager
 * @chainable
 * @return {OO.ui.Window} The window, for chaining
 */
OO.ui.Window.prototype.initialize = function () {
	if ( !this.manager ) {
		throw new Error( 'Cannot initialize window, must be attached to a manager' );
	}

	// Properties
	this.$head = $( '<div>' );
	this.$body = $( '<div>' );
	this.$foot = $( '<div>' );
	this.$document = $( this.getElementDocument() );

	// Events
	this.$element.on( 'mousedown', this.onMouseDown.bind( this ) );

	// Initialization
	this.$head.addClass( 'oo-ui-window-head' );
	this.$body.addClass( 'oo-ui-window-body' );
	this.$foot.addClass( 'oo-ui-window-foot' );
	this.$content.append( this.$head, this.$body, this.$foot );

	return this;
};

/**
 * Called when someone tries to focus the hidden element at the end of the dialog.
 * Sends focus back to the start of the dialog.
 *
 * @param {jQuery.Event} event Focus event
 */
OO.ui.Window.prototype.onFocusTrapFocused = function ( event ) {
	var backwards = this.$focusTrapBefore.is( event.target ),
		element = OO.ui.findFocusable( this.$content, backwards );
	if ( element ) {
		// There's a focusable element inside the content, at the front or
		// back depending on which focus trap we hit; select it.
		element.focus();
	} else {
		// There's nothing focusable inside the content. As a fallback,
		// this.$content is focusable, and focusing it will keep our focus
		// properly trapped. It's not a *meaningful* focus, since it's just
		// the content-div for the Window, but it's better than letting focus
		// escape into the page.
		this.$content.focus();
	}
};

/**
 * Open the window.
 *
 * This method is a wrapper around a call to the window
 * manager’s {@link OO.ui.WindowManager#openWindow openWindow} method.
 *
 * To customize the window each time it opens, use #getSetupProcess or #getReadyProcess.
 *
 * @param {Object} [data] Window opening data
 * @return {OO.ui.WindowInstance} See OO.ui.WindowManager#openWindow
 * @throws {Error} An error is thrown if the window is not attached to a window manager
 */
OO.ui.Window.prototype.open = function ( data ) {
	if ( !this.manager ) {
		throw new Error( 'Cannot open window, must be attached to a manager' );
	}

	return this.manager.openWindow( this, data );
};

/**
 * Close the window.
 *
 * This method is a wrapper around a call to the window
 * manager’s {@link OO.ui.WindowManager#closeWindow closeWindow} method.
 *
 * The window's #getHoldProcess and #getTeardownProcess methods are called during the closing
 * phase of the window’s lifecycle and can be used to specify closing behavior each time
 * the window closes.
 *
 * @param {Object} [data] Window closing data
 * @return {OO.ui.WindowInstance} See OO.ui.WindowManager#closeWindow
 * @throws {Error} An error is thrown if the window is not attached to a window manager
 */
OO.ui.Window.prototype.close = function ( data ) {
	if ( !this.manager ) {
		throw new Error( 'Cannot close window, must be attached to a manager' );
	}

	return this.manager.closeWindow( this, data );
};

/**
 * Setup window.
 *
 * This is called by OO.ui.WindowManager during window opening (before the animation), and should
 * not be called directly by other systems.
 *
 * @param {Object} [data] Window opening data
 * @return {jQuery.Promise} Promise resolved when window is setup
 */
OO.ui.Window.prototype.setup = function ( data ) {
	var win = this;

	this.toggle( true );

	this.focusTrapHandler = OO.ui.bind( this.onFocusTrapFocused, this );
	this.$focusTraps.on( 'focus', this.focusTrapHandler );

	return this.getSetupProcess( data ).execute().then( function () {
		win.updateSize();
		// Force redraw by asking the browser to measure the elements' widths
		win.$element.addClass( 'oo-ui-window-active oo-ui-window-setup' ).width();
		win.$content.addClass( 'oo-ui-window-content-setup' ).width();
	} );
};

/**
 * Ready window.
 *
 * This is called by OO.ui.WindowManager during window opening (after the animation), and should not
 * be called directly by other systems.
 *
 * @param {Object} [data] Window opening data
 * @return {jQuery.Promise} Promise resolved when window is ready
 */
OO.ui.Window.prototype.ready = function ( data ) {
	var win = this;

	this.$content.focus();
	return this.getReadyProcess( data ).execute().then( function () {
		// Force redraw by asking the browser to measure the elements' widths
		win.$element.addClass( 'oo-ui-window-ready' ).width();
		win.$content.addClass( 'oo-ui-window-content-ready' ).width();
	} );
};

/**
 * Hold window.
 *
 * This is called by OO.ui.WindowManager during window closing (before the animation), and should
 * not be called directly by other systems.
 *
 * @param {Object} [data] Window closing data
 * @return {jQuery.Promise} Promise resolved when window is held
 */
OO.ui.Window.prototype.hold = function ( data ) {
	var win = this;

	return this.getHoldProcess( data ).execute().then( function () {
		// Get the focused element within the window's content
		var $focus = win.$content.find( OO.ui.Element.static.getDocument( win.$content ).activeElement );

		// Blur the focused element
		if ( $focus.length ) {
			// eslint-disable-next-line jquery/no-event-shorthand
			$focus[ 0 ].blur();
		}

		// Force redraw by asking the browser to measure the elements' widths
		win.$element.removeClass( 'oo-ui-window-ready oo-ui-window-setup' ).width();
		win.$content.removeClass( 'oo-ui-window-content-ready oo-ui-window-content-setup' ).width();
	} );
};

/**
 * Teardown window.
 *
 * This is called by OO.ui.WindowManager during window closing (after the animation), and should not be called directly
 * by other systems.
 *
 * @param {Object} [data] Window closing data
 * @return {jQuery.Promise} Promise resolved when window is torn down
 */
OO.ui.Window.prototype.teardown = function ( data ) {
	var win = this;

	return this.getTeardownProcess( data ).execute().then( function () {
		// Force redraw by asking the browser to measure the elements' widths
		win.$element.removeClass( 'oo-ui-window-active' ).width();

		win.$focusTraps.off( 'focus', win.focusTrapHandler );
		win.toggle( false );
	} );
};

/**
 * The Dialog class serves as the base class for the other types of dialogs.
 * Unless extended to include controls, the rendered dialog box is a simple window
 * that users can close by hitting the ‘Esc’ key. Dialog windows are used with OO.ui.WindowManager,
 * which opens, closes, and controls the presentation of the window. See the
 * [OOUI documentation on MediaWiki] [1] for more information.
 *
 *     @example
 *     // A simple dialog window.
 *     function MyDialog( config ) {
 *         MyDialog.parent.call( this, config );
 *     }
 *     OO.inheritClass( MyDialog, OO.ui.Dialog );
 *     MyDialog.static.name = 'myDialog';
 *     MyDialog.prototype.initialize = function () {
 *         MyDialog.parent.prototype.initialize.call( this );
 *         this.content = new OO.ui.PanelLayout( { padded: true, expanded: false } );
 *         this.content.$element.append( '<p>A simple dialog window. Press \'Esc\' to close.</p>' );
 *         this.$body.append( this.content.$element );
 *     };
 *     MyDialog.prototype.getBodyHeight = function () {
 *         return this.content.$element.outerHeight( true );
 *     };
 *     var myDialog = new MyDialog( {
 *         size: 'medium'
 *     } );
 *     // Create and append a window manager, which opens and closes the window.
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *     windowManager.addWindows( [ myDialog ] );
 *     // Open the window!
 *     windowManager.openWindow( myDialog );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Dialogs
 *
 * @abstract
 * @class
 * @extends OO.ui.Window
 * @mixins OO.ui.mixin.PendingElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.Dialog = function OoUiDialog( config ) {
	// Parent constructor
	OO.ui.Dialog.parent.call( this, config );

	// Mixin constructors
	OO.ui.mixin.PendingElement.call( this );

	// Properties
	this.actions = new OO.ui.ActionSet();
	this.attachedActions = [];
	this.currentAction = null;
	this.onDialogKeyDownHandler = this.onDialogKeyDown.bind( this );

	// Events
	this.actions.connect( this, {
		click: 'onActionClick',
		change: 'onActionsChange'
	} );

	// Initialization
	this.$element
		.addClass( 'oo-ui-dialog' )
		.attr( 'role', 'dialog' );
};

/* Setup */

OO.inheritClass( OO.ui.Dialog, OO.ui.Window );
OO.mixinClass( OO.ui.Dialog, OO.ui.mixin.PendingElement );

/* Static Properties */

/**
 * Symbolic name of dialog.
 *
 * The dialog class must have a symbolic name in order to be registered with OO.Factory.
 * Please see the [OOUI documentation on MediaWiki] [3] for more information.
 *
 * [3]: https://www.mediawiki.org/wiki/OOUI/Windows/Window_managers
 *
 * @abstract
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Dialog.static.name = '';

/**
 * The dialog title.
 *
 * The title can be specified as a plaintext string, a {@link OO.ui.mixin.LabelElement Label} node, or a function
 * that will produce a Label node or string. The title can also be specified with data passed to the
 * constructor (see #getSetupProcess). In this case, the static value will be overridden.
 *
 * @abstract
 * @static
 * @inheritable
 * @property {jQuery|string|Function}
 */
OO.ui.Dialog.static.title = '';

/**
 * An array of configured {@link OO.ui.ActionWidget action widgets}.
 *
 * Actions can also be specified with data passed to the constructor (see #getSetupProcess). In this case, the static
 * value will be overridden.
 *
 * [2]: https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs#Action_sets
 *
 * @static
 * @inheritable
 * @property {Object[]}
 */
OO.ui.Dialog.static.actions = [];

/**
 * Close the dialog when the 'Esc' key is pressed.
 *
 * @static
 * @abstract
 * @inheritable
 * @property {boolean}
 */
OO.ui.Dialog.static.escapable = true;

/* Methods */

/**
 * Handle frame document key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 */
OO.ui.Dialog.prototype.onDialogKeyDown = function ( e ) {
	var actions;
	if ( e.which === OO.ui.Keys.ESCAPE && this.constructor.static.escapable ) {
		this.executeAction( '' );
		e.preventDefault();
		e.stopPropagation();
	} else if ( e.which === OO.ui.Keys.ENTER && ( e.ctrlKey || e.metaKey ) ) {
		actions = this.actions.get( { flags: 'primary', visible: true, disabled: false } );
		if ( actions.length > 0 ) {
			this.executeAction( actions[ 0 ].getAction() );
			e.preventDefault();
			e.stopPropagation();
		}
	}
};

/**
 * Handle action click events.
 *
 * @private
 * @param {OO.ui.ActionWidget} action Action that was clicked
 */
OO.ui.Dialog.prototype.onActionClick = function ( action ) {
	if ( !this.isPending() ) {
		this.executeAction( action.getAction() );
	}
};

/**
 * Handle actions change event.
 *
 * @private
 */
OO.ui.Dialog.prototype.onActionsChange = function () {
	this.detachActions();
	if ( !this.isClosing() ) {
		this.attachActions();
		if ( !this.isOpening() ) {
			// If the dialog is currently opening, this will be called automatically soon.
			this.updateSize();
		}
	}
};

/**
 * Get the set of actions used by the dialog.
 *
 * @return {OO.ui.ActionSet}
 */
OO.ui.Dialog.prototype.getActions = function () {
	return this.actions;
};

/**
 * Get a process for taking action.
 *
 * When you override this method, you can create a new OO.ui.Process and return it, or add additional
 * accept steps to the process the parent method provides using the {@link OO.ui.Process#first 'first'}
 * and {@link OO.ui.Process#next 'next'} methods of OO.ui.Process.
 *
 * @param {string} [action] Symbolic name of action
 * @return {OO.ui.Process} Action process
 */
OO.ui.Dialog.prototype.getActionProcess = function ( action ) {
	return new OO.ui.Process()
		.next( function () {
			if ( !action ) {
				// An empty action always closes the dialog without data, which should always be
				// safe and make no changes
				this.close();
			}
		}, this );
};

/**
 * @inheritdoc
 *
 * @param {Object} [data] Dialog opening data
 * @param {jQuery|string|Function|null} [data.title] Dialog title, omit to use
 *  the {@link #static-title static title}
 * @param {Object[]} [data.actions] List of configuration options for each
 *   {@link OO.ui.ActionWidget action widget}, omit to use {@link #static-actions static actions}.
 */
OO.ui.Dialog.prototype.getSetupProcess = function ( data ) {
	data = data || {};

	// Parent method
	return OO.ui.Dialog.parent.prototype.getSetupProcess.call( this, data )
		.next( function () {
			var config = this.constructor.static,
				actions = data.actions !== undefined ? data.actions : config.actions,
				title = data.title !== undefined ? data.title : config.title;

			this.title.setLabel( title ).setTitle( title );
			this.actions.add( this.getActionWidgets( actions ) );

			this.$element.on( 'keydown', this.onDialogKeyDownHandler );
		}, this );
};

/**
 * @inheritdoc
 */
OO.ui.Dialog.prototype.getTeardownProcess = function ( data ) {
	// Parent method
	return OO.ui.Dialog.parent.prototype.getTeardownProcess.call( this, data )
		.first( function () {
			this.$element.off( 'keydown', this.onDialogKeyDownHandler );

			this.actions.clear();
			this.currentAction = null;
		}, this );
};

/**
 * @inheritdoc
 */
OO.ui.Dialog.prototype.initialize = function () {
	// Parent method
	OO.ui.Dialog.parent.prototype.initialize.call( this );

	// Properties
	this.title = new OO.ui.LabelWidget();

	// Initialization
	this.$content.addClass( 'oo-ui-dialog-content' );
	this.$element.attr( 'aria-labelledby', this.title.getElementId() );
	this.setPendingElement( this.$head );
};

/**
 * Get action widgets from a list of configs
 *
 * @param {Object[]} actions Action widget configs
 * @return {OO.ui.ActionWidget[]} Action widgets
 */
OO.ui.Dialog.prototype.getActionWidgets = function ( actions ) {
	var i, len, widgets = [];
	for ( i = 0, len = actions.length; i < len; i++ ) {
		widgets.push( this.getActionWidget( actions[ i ] ) );
	}
	return widgets;
};

/**
 * Get action widget from config
 *
 * Override this method to change the action widget class used.
 *
 * @param {Object} config Action widget config
 * @return {OO.ui.ActionWidget} Action widget
 */
OO.ui.Dialog.prototype.getActionWidget = function ( config ) {
	return new OO.ui.ActionWidget( this.getActionWidgetConfig( config ) );
};

/**
 * Get action widget config
 *
 * Override this method to modify the action widget config
 *
 * @param {Object} config Initial action widget config
 * @return {Object} Action widget config
 */
OO.ui.Dialog.prototype.getActionWidgetConfig = function ( config ) {
	return config;
};

/**
 * Attach action actions.
 *
 * @protected
 */
OO.ui.Dialog.prototype.attachActions = function () {
	// Remember the list of potentially attached actions
	this.attachedActions = this.actions.get();
};

/**
 * Detach action actions.
 *
 * @protected
 * @chainable
 * @return {OO.ui.Dialog} The dialog, for chaining
 */
OO.ui.Dialog.prototype.detachActions = function () {
	var i, len;

	// Detach all actions that may have been previously attached
	for ( i = 0, len = this.attachedActions.length; i < len; i++ ) {
		this.attachedActions[ i ].$element.detach();
	}
	this.attachedActions = [];

	return this;
};

/**
 * Execute an action.
 *
 * @param {string} action Symbolic name of action to execute
 * @return {jQuery.Promise} Promise resolved when action completes, rejected if it fails
 */
OO.ui.Dialog.prototype.executeAction = function ( action ) {
	this.pushPending();
	this.currentAction = action;
	return this.getActionProcess( action ).execute()
		.always( this.popPending.bind( this ) );
};

/**
 * MessageDialogs display a confirmation or alert message. By default, the rendered dialog box
 * consists of a header that contains the dialog title, a body with the message, and a footer that
 * contains any {@link OO.ui.ActionWidget action widgets}. The MessageDialog class is the only type
 * of {@link OO.ui.Dialog dialog} that is usually instantiated directly.
 *
 * There are two basic types of message dialogs, confirmation and alert:
 *
 * - **confirmation**: the dialog title describes what a progressive action will do and the message provides
 *  more details about the consequences.
 * - **alert**: the dialog title describes which event occurred and the message provides more information
 *  about why the event occurred.
 *
 * The MessageDialog class specifies two actions: ‘accept’, the primary
 * action (e.g., ‘ok’) and ‘reject,’ the safe action (e.g., ‘cancel’). Both will close the window,
 * passing along the selected action.
 *
 * For more information and examples, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // Example: Creating and opening a message dialog window.
 *     var messageDialog = new OO.ui.MessageDialog();
 *
 *     // Create and append a window manager.
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *     windowManager.addWindows( [ messageDialog ] );
 *     // Open the window.
 *     windowManager.openWindow( messageDialog, {
 *         title: 'Basic message dialog',
 *         message: 'This is the message'
 *     } );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Message_Dialogs
 *
 * @class
 * @extends OO.ui.Dialog
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.MessageDialog = function OoUiMessageDialog( config ) {
	// Parent constructor
	OO.ui.MessageDialog.parent.call( this, config );

	// Properties
	this.verticalActionLayout = null;

	// Initialization
	this.$element.addClass( 'oo-ui-messageDialog' );
};

/* Setup */

OO.inheritClass( OO.ui.MessageDialog, OO.ui.Dialog );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MessageDialog.static.name = 'message';

/**
 * @static
 * @inheritdoc
 */
OO.ui.MessageDialog.static.size = 'small';

/**
 * Dialog title.
 *
 * The title of a confirmation dialog describes what a progressive action will do. The
 * title of an alert dialog describes which event occurred.
 *
 * @static
 * @inheritable
 * @property {jQuery|string|Function|null}
 */
OO.ui.MessageDialog.static.title = null;

/**
 * The message displayed in the dialog body.
 *
 * A confirmation message describes the consequences of a progressive action. An alert
 * message describes why an event occurred.
 *
 * @static
 * @inheritable
 * @property {jQuery|string|Function|null}
 */
OO.ui.MessageDialog.static.message = null;

/**
 * @static
 * @inheritdoc
 */
OO.ui.MessageDialog.static.actions = [
	// Note that OO.ui.alert() and OO.ui.confirm() rely on these.
	{ action: 'accept', label: OO.ui.deferMsg( 'ooui-dialog-message-accept' ), flags: 'primary' },
	{ action: 'reject', label: OO.ui.deferMsg( 'ooui-dialog-message-reject' ), flags: 'safe' }
];

/* Methods */

/**
 * Toggle action layout between vertical and horizontal.
 *
 * @private
 * @param {boolean} [value] Layout actions vertically, omit to toggle
 * @chainable
 * @return {OO.ui.MessageDialog} The dialog, for chaining
 */
OO.ui.MessageDialog.prototype.toggleVerticalActionLayout = function ( value ) {
	value = value === undefined ? !this.verticalActionLayout : !!value;

	if ( value !== this.verticalActionLayout ) {
		this.verticalActionLayout = value;
		this.$actions
			.toggleClass( 'oo-ui-messageDialog-actions-vertical', value )
			.toggleClass( 'oo-ui-messageDialog-actions-horizontal', !value );
	}

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.getActionProcess = function ( action ) {
	if ( action ) {
		return new OO.ui.Process( function () {
			this.close( { action: action } );
		}, this );
	}
	return OO.ui.MessageDialog.parent.prototype.getActionProcess.call( this, action );
};

/**
 * @inheritdoc
 *
 * @param {Object} [data] Dialog opening data
 * @param {jQuery|string|Function|null} [data.title] Description of the action being confirmed
 * @param {jQuery|string|Function|null} [data.message] Description of the action's consequence
 * @param {string} [data.size] Symbolic name of the dialog size, see OO.ui.Window
 * @param {Object[]} [data.actions] List of OO.ui.ActionOptionWidget configuration options for each
 *   action item
 */
OO.ui.MessageDialog.prototype.getSetupProcess = function ( data ) {
	data = data || {};

	// Parent method
	return OO.ui.MessageDialog.parent.prototype.getSetupProcess.call( this, data )
		.next( function () {
			this.title.setLabel(
				data.title !== undefined ? data.title : this.constructor.static.title
			);
			this.message.setLabel(
				data.message !== undefined ? data.message : this.constructor.static.message
			);
			this.size = data.size !== undefined ? data.size : this.constructor.static.size;
		}, this );
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.getReadyProcess = function ( data ) {
	data = data || {};

	// Parent method
	return OO.ui.MessageDialog.parent.prototype.getReadyProcess.call( this, data )
		.next( function () {
			// Focus the primary action button
			var actions = this.actions.get();
			actions = actions.filter( function ( action ) {
				return action.getFlags().indexOf( 'primary' ) > -1;
			} );
			if ( actions.length > 0 ) {
				actions[ 0 ].focus();
			}
		}, this );
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.getBodyHeight = function () {
	var bodyHeight, oldOverflow,
		$scrollable = this.container.$element;

	oldOverflow = $scrollable[ 0 ].style.overflow;
	$scrollable[ 0 ].style.overflow = 'hidden';

	OO.ui.Element.static.reconsiderScrollbars( $scrollable[ 0 ] );

	bodyHeight = this.text.$element.outerHeight( true );
	$scrollable[ 0 ].style.overflow = oldOverflow;

	return bodyHeight;
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.setDimensions = function ( dim ) {
	var
		dialog = this,
		$scrollable = this.container.$element;
	OO.ui.MessageDialog.parent.prototype.setDimensions.call( this, dim );

	// Twiddle the overflow property, otherwise an unnecessary scrollbar will be produced.
	// Need to do it after transition completes (250ms), add 50ms just in case.
	setTimeout( function () {
		var oldOverflow = $scrollable[ 0 ].style.overflow,
			activeElement = document.activeElement;

		$scrollable[ 0 ].style.overflow = 'hidden';

		OO.ui.Element.static.reconsiderScrollbars( $scrollable[ 0 ] );

		// Check reconsiderScrollbars didn't destroy our focus, as we
		// are doing this after the ready process.
		if ( activeElement && activeElement !== document.activeElement && activeElement.focus ) {
			activeElement.focus();
		}

		$scrollable[ 0 ].style.overflow = oldOverflow;
	}, 300 );

	dialog.fitActions();
	// Wait for CSS transition to finish and do it again :(
	setTimeout( function () {
		dialog.fitActions();
	}, 300 );

	return this;
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.initialize = function () {
	// Parent method
	OO.ui.MessageDialog.parent.prototype.initialize.call( this );

	// Properties
	this.$actions = $( '<div>' );
	this.container = new OO.ui.PanelLayout( {
		scrollable: true, classes: [ 'oo-ui-messageDialog-container' ]
	} );
	this.text = new OO.ui.PanelLayout( {
		padded: true, expanded: false, classes: [ 'oo-ui-messageDialog-text' ]
	} );
	this.message = new OO.ui.LabelWidget( {
		classes: [ 'oo-ui-messageDialog-message' ]
	} );

	// Initialization
	this.title.$element.addClass( 'oo-ui-messageDialog-title' );
	this.$content.addClass( 'oo-ui-messageDialog-content' );
	this.container.$element.append( this.text.$element );
	this.text.$element.append( this.title.$element, this.message.$element );
	this.$body.append( this.container.$element );
	this.$actions.addClass( 'oo-ui-messageDialog-actions' );
	this.$foot.append( this.$actions );
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.getActionWidgetConfig = function ( config ) {
	// Force unframed
	return $.extend( {}, config, { framed: false } );
};

/**
 * @inheritdoc
 */
OO.ui.MessageDialog.prototype.attachActions = function () {
	var i, len, special, others;

	// Parent method
	OO.ui.MessageDialog.parent.prototype.attachActions.call( this );

	special = this.actions.getSpecial();
	others = this.actions.getOthers();

	if ( special.safe ) {
		this.$actions.append( special.safe.$element );
		special.safe.toggleFramed( true );
	}
	for ( i = 0, len = others.length; i < len; i++ ) {
		this.$actions.append( others[ i ].$element );
		others[ i ].toggleFramed( true );
	}
	if ( special.primary ) {
		this.$actions.append( special.primary.$element );
		special.primary.toggleFramed( true );
	}
};

/**
 * Fit action actions into columns or rows.
 *
 * Columns will be used if all labels can fit without overflow, otherwise rows will be used.
 *
 * @private
 */
OO.ui.MessageDialog.prototype.fitActions = function () {
	var i, len, action,
		previous = this.verticalActionLayout,
		actions = this.actions.get();

	// Detect clipping
	this.toggleVerticalActionLayout( false );
	for ( i = 0, len = actions.length; i < len; i++ ) {
		action = actions[ i ];
		if ( action.$element[ 0 ].scrollWidth > action.$element[ 0 ].clientWidth ) {
			this.toggleVerticalActionLayout( true );
			break;
		}
	}

	// Move the body out of the way of the foot
	this.$body.css( 'bottom', this.$foot.outerHeight( true ) );

	if ( this.verticalActionLayout !== previous ) {
		// We changed the layout, window height might need to be updated.
		this.updateSize();
	}
};

/**
 * ProcessDialog windows encapsulate a {@link OO.ui.Process process} and all of the code necessary
 * to complete it. If the process terminates with an error, a customizable {@link OO.ui.Error error
 * interface} alerts users to the trouble, permitting the user to dismiss the error and try again when
 * relevant. The ProcessDialog class is always extended and customized with the actions and content
 * required for each process.
 *
 * The process dialog box consists of a header that visually represents the ‘working’ state of long
 * processes with an animation. The header contains the dialog title as well as
 * two {@link OO.ui.ActionWidget action widgets}:  a ‘safe’ action on the left (e.g., ‘Cancel’) and
 * a ‘primary’ action on the right (e.g., ‘Done’).
 *
 * Like other windows, the process dialog is managed by a {@link OO.ui.WindowManager window manager}.
 * Please see the [OOUI documentation on MediaWiki][1] for more information and examples.
 *
 *     @example
 *     // Example: Creating and opening a process dialog window.
 *     function MyProcessDialog( config ) {
 *         MyProcessDialog.parent.call( this, config );
 *     }
 *     OO.inheritClass( MyProcessDialog, OO.ui.ProcessDialog );
 *
 *     MyProcessDialog.static.name = 'myProcessDialog';
 *     MyProcessDialog.static.title = 'Process dialog';
 *     MyProcessDialog.static.actions = [
 *         { action: 'save', label: 'Done', flags: 'primary' },
 *         { label: 'Cancel', flags: 'safe' }
 *     ];
 *
 *     MyProcessDialog.prototype.initialize = function () {
 *         MyProcessDialog.parent.prototype.initialize.apply( this, arguments );
 *         this.content = new OO.ui.PanelLayout( { padded: true, expanded: false } );
 *         this.content.$element.append( '<p>This is a process dialog window. The header contains the title and two buttons: \'Cancel\' (a safe action) on the left and \'Done\' (a primary action)  on the right.</p>' );
 *         this.$body.append( this.content.$element );
 *     };
 *     MyProcessDialog.prototype.getActionProcess = function ( action ) {
 *         var dialog = this;
 *         if ( action ) {
 *             return new OO.ui.Process( function () {
 *                 dialog.close( { action: action } );
 *             } );
 *         }
 *         return MyProcessDialog.parent.prototype.getActionProcess.call( this, action );
 *     };
 *
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *
 *     var dialog = new MyProcessDialog();
 *     windowManager.addWindows( [ dialog ] );
 *     windowManager.openWindow( dialog );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Windows/Process_Dialogs
 *
 * @abstract
 * @class
 * @extends OO.ui.Dialog
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ProcessDialog = function OoUiProcessDialog( config ) {
	// Parent constructor
	OO.ui.ProcessDialog.parent.call( this, config );

	// Properties
	this.fitOnOpen = false;

	// Initialization
	this.$element.addClass( 'oo-ui-processDialog' );
};

/* Setup */

OO.inheritClass( OO.ui.ProcessDialog, OO.ui.Dialog );

/* Methods */

/**
 * Handle dismiss button click events.
 *
 * Hides errors.
 *
 * @private
 */
OO.ui.ProcessDialog.prototype.onDismissErrorButtonClick = function () {
	this.hideErrors();
};

/**
 * Handle retry button click events.
 *
 * Hides errors and then tries again.
 *
 * @private
 */
OO.ui.ProcessDialog.prototype.onRetryButtonClick = function () {
	this.hideErrors();
	this.executeAction( this.currentAction );
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.initialize = function () {
	// Parent method
	OO.ui.ProcessDialog.parent.prototype.initialize.call( this );

	// Properties
	this.$navigation = $( '<div>' );
	this.$location = $( '<div>' );
	this.$safeActions = $( '<div>' );
	this.$primaryActions = $( '<div>' );
	this.$otherActions = $( '<div>' );
	this.dismissButton = new OO.ui.ButtonWidget( {
		label: OO.ui.msg( 'ooui-dialog-process-dismiss' )
	} );
	this.retryButton = new OO.ui.ButtonWidget();
	this.$errors = $( '<div>' );
	this.$errorsTitle = $( '<div>' );

	// Events
	this.dismissButton.connect( this, { click: 'onDismissErrorButtonClick' } );
	this.retryButton.connect( this, { click: 'onRetryButtonClick' } );
	this.title.connect( this, { labelChange: 'fitLabel' } );

	// Initialization
	this.title.$element.addClass( 'oo-ui-processDialog-title' );
	this.$location
		.append( this.title.$element )
		.addClass( 'oo-ui-processDialog-location' );
	this.$safeActions.addClass( 'oo-ui-processDialog-actions-safe' );
	this.$primaryActions.addClass( 'oo-ui-processDialog-actions-primary' );
	this.$otherActions.addClass( 'oo-ui-processDialog-actions-other' );
	this.$errorsTitle
		.addClass( 'oo-ui-processDialog-errors-title' )
		.text( OO.ui.msg( 'ooui-dialog-process-error' ) );
	this.$errors
		.addClass( 'oo-ui-processDialog-errors oo-ui-element-hidden' )
		.append( this.$errorsTitle, this.dismissButton.$element, this.retryButton.$element );
	this.$content
		.addClass( 'oo-ui-processDialog-content' )
		.append( this.$errors );
	this.$navigation
		.addClass( 'oo-ui-processDialog-navigation' )
		// Note: Order of appends below is important. These are in the order
		// we want tab to go through them. Display-order is handled entirely
		// by CSS absolute-positioning. As such, primary actions like "done"
		// should go first.
		.append( this.$primaryActions, this.$location, this.$safeActions );
	this.$head.append( this.$navigation );
	this.$foot.append( this.$otherActions );
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.getActionWidgetConfig = function ( config ) {
	var isMobile = OO.ui.isMobile();

	// Default to unframed on mobile
	config = $.extend( { framed: !isMobile }, config );
	// Change back buttons to icon only on mobile
	if (
		isMobile &&
		( config.flags === 'back' || ( Array.isArray( config.flags ) && config.flags.indexOf( 'back' ) !== -1 ) )
	) {
		$.extend( config, {
			icon: 'previous',
			label: ''
		} );
	}

	return config;
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.attachActions = function () {
	var i, len, other, special, others;

	// Parent method
	OO.ui.ProcessDialog.parent.prototype.attachActions.call( this );

	special = this.actions.getSpecial();
	others = this.actions.getOthers();
	if ( special.primary ) {
		this.$primaryActions.append( special.primary.$element );
	}
	for ( i = 0, len = others.length; i < len; i++ ) {
		other = others[ i ];
		this.$otherActions.append( other.$element );
	}
	if ( special.safe ) {
		this.$safeActions.append( special.safe.$element );
	}
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.executeAction = function ( action ) {
	var process = this;
	return OO.ui.ProcessDialog.parent.prototype.executeAction.call( this, action )
		.fail( function ( errors ) {
			process.showErrors( errors || [] );
		} );
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.setDimensions = function () {
	var dialog = this;

	// Parent method
	OO.ui.ProcessDialog.parent.prototype.setDimensions.apply( this, arguments );

	this.fitLabel();

	// If there are many actions, they might be shown on multiple lines. Their layout can change when
	// resizing the dialog and when changing the actions. Adjust the height of the footer to fit them.
	dialog.$body.css( 'bottom', dialog.$foot.outerHeight( true ) );
	// Wait for CSS transition to finish and do it again :(
	setTimeout( function () {
		dialog.$body.css( 'bottom', dialog.$foot.outerHeight( true ) );
	}, 300 );
};

/**
 * Fit label between actions.
 *
 * @private
 * @chainable
 * @return {OO.ui.MessageDialog} The dialog, for chaining
 */
OO.ui.ProcessDialog.prototype.fitLabel = function () {
	var safeWidth, primaryWidth, biggerWidth, labelWidth, navigationWidth, leftWidth, rightWidth,
		size = this.getSizeProperties();

	if ( typeof size.width !== 'number' ) {
		if ( this.isOpened() ) {
			navigationWidth = this.$head.width() - 20;
		} else if ( this.isOpening() ) {
			if ( !this.fitOnOpen ) {
				// Size is relative and the dialog isn't open yet, so wait.
				// FIXME: This should ideally be handled by setup somehow.
				this.manager.lifecycle.opened.done( this.fitLabel.bind( this ) );
				this.fitOnOpen = true;
			}
			return;
		} else {
			return;
		}
	} else {
		navigationWidth = size.width - 20;
	}

	safeWidth = this.$safeActions.is( ':visible' ) ? this.$safeActions.width() : 0;
	primaryWidth = this.$primaryActions.is( ':visible' ) ? this.$primaryActions.width() : 0;
	biggerWidth = Math.max( safeWidth, primaryWidth );

	labelWidth = this.title.$element.width();

	if ( 2 * biggerWidth + labelWidth < navigationWidth ) {
		// We have enough space to center the label
		leftWidth = rightWidth = biggerWidth;
	} else {
		// Let's hope we at least have enough space not to overlap, because we can't wrap the label…
		if ( this.getDir() === 'ltr' ) {
			leftWidth = safeWidth;
			rightWidth = primaryWidth;
		} else {
			leftWidth = primaryWidth;
			rightWidth = safeWidth;
		}
	}

	this.$location.css( { paddingLeft: leftWidth, paddingRight: rightWidth } );

	return this;
};

/**
 * Handle errors that occurred during accept or reject processes.
 *
 * @private
 * @param {OO.ui.Error[]|OO.ui.Error} errors Errors to be handled
 */
OO.ui.ProcessDialog.prototype.showErrors = function ( errors ) {
	var i, len, $item, actions,
		items = [],
		abilities = {},
		recoverable = true,
		warning = false;

	if ( errors instanceof OO.ui.Error ) {
		errors = [ errors ];
	}

	for ( i = 0, len = errors.length; i < len; i++ ) {
		if ( !errors[ i ].isRecoverable() ) {
			recoverable = false;
		}
		if ( errors[ i ].isWarning() ) {
			warning = true;
		}
		$item = $( '<div>' )
			.addClass( 'oo-ui-processDialog-error' )
			.append( errors[ i ].getMessage() );
		items.push( $item[ 0 ] );
	}
	this.$errorItems = $( items );
	if ( recoverable ) {
		abilities[ this.currentAction ] = true;
		// Copy the flags from the first matching action
		actions = this.actions.get( { actions: this.currentAction } );
		if ( actions.length ) {
			this.retryButton.clearFlags().setFlags( actions[ 0 ].getFlags() );
		}
	} else {
		abilities[ this.currentAction ] = false;
		this.actions.setAbilities( abilities );
	}
	if ( warning ) {
		this.retryButton.setLabel( OO.ui.msg( 'ooui-dialog-process-continue' ) );
	} else {
		this.retryButton.setLabel( OO.ui.msg( 'ooui-dialog-process-retry' ) );
	}
	this.retryButton.toggle( recoverable );
	this.$errorsTitle.after( this.$errorItems );
	this.$errors.removeClass( 'oo-ui-element-hidden' ).scrollTop( 0 );
};

/**
 * Hide errors.
 *
 * @private
 */
OO.ui.ProcessDialog.prototype.hideErrors = function () {
	this.$errors.addClass( 'oo-ui-element-hidden' );
	if ( this.$errorItems ) {
		this.$errorItems.remove();
		this.$errorItems = null;
	}
};

/**
 * @inheritdoc
 */
OO.ui.ProcessDialog.prototype.getTeardownProcess = function ( data ) {
	// Parent method
	return OO.ui.ProcessDialog.parent.prototype.getTeardownProcess.call( this, data )
		.first( function () {
			// Make sure to hide errors
			this.hideErrors();
			this.fitOnOpen = false;
		}, this );
};

/**
 * @class OO.ui
 */

/**
 * Lazy-initialize and return a global OO.ui.WindowManager instance, used by OO.ui.alert and
 * OO.ui.confirm.
 *
 * @private
 * @return {OO.ui.WindowManager}
 */
OO.ui.getWindowManager = function () {
	if ( !OO.ui.windowManager ) {
		OO.ui.windowManager = new OO.ui.WindowManager();
		$( document.body ).append( OO.ui.windowManager.$element );
		OO.ui.windowManager.addWindows( [ new OO.ui.MessageDialog() ] );
	}
	return OO.ui.windowManager;
};

/**
 * Display a quick modal alert dialog, using a OO.ui.MessageDialog. While the dialog is open, the
 * rest of the page will be dimmed out and the user won't be able to interact with it. The dialog
 * has only one action button, labelled "OK", clicking it will simply close the dialog.
 *
 * A window manager is created automatically when this function is called for the first time.
 *
 *     @example
 *     OO.ui.alert( 'Something happened!' ).done( function () {
 *         console.log( 'User closed the dialog.' );
 *     } );
 *
 *     OO.ui.alert( 'Something larger happened!', { size: 'large' } );
 *
 * @param {jQuery|string} text Message text to display
 * @param {Object} [options] Additional options, see OO.ui.MessageDialog#getSetupProcess
 * @return {jQuery.Promise} Promise resolved when the user closes the dialog
 */
OO.ui.alert = function ( text, options ) {
	return OO.ui.getWindowManager().openWindow( 'message', $.extend( {
		message: text,
		actions: [ OO.ui.MessageDialog.static.actions[ 0 ] ]
	}, options ) ).closed.then( function () {
		return undefined;
	} );
};

/**
 * Display a quick modal confirmation dialog, using a OO.ui.MessageDialog. While the dialog is open,
 * the rest of the page will be dimmed out and the user won't be able to interact with it. The
 * dialog has two action buttons, one to confirm an operation (labelled "OK") and one to cancel it
 * (labelled "Cancel").
 *
 * A window manager is created automatically when this function is called for the first time.
 *
 *     @example
 *     OO.ui.confirm( 'Are you sure?' ).done( function ( confirmed ) {
 *         if ( confirmed ) {
 *             console.log( 'User clicked "OK"!' );
 *         } else {
 *             console.log( 'User clicked "Cancel" or closed the dialog.' );
 *         }
 *     } );
 *
 * @param {jQuery|string} text Message text to display
 * @param {Object} [options] Additional options, see OO.ui.MessageDialog#getSetupProcess
 * @return {jQuery.Promise} Promise resolved when the user closes the dialog. If the user chose to
 *  confirm, the promise will resolve to boolean `true`; otherwise, it will resolve to boolean
 *  `false`.
 */
OO.ui.confirm = function ( text, options ) {
	return OO.ui.getWindowManager().openWindow( 'message', $.extend( {
		message: text
	}, options ) ).closed.then( function ( data ) {
		return !!( data && data.action === 'accept' );
	} );
};

/**
 * Display a quick modal prompt dialog, using a OO.ui.MessageDialog. While the dialog is open,
 * the rest of the page will be dimmed out and the user won't be able to interact with it. The
 * dialog has a text input widget and two action buttons, one to confirm an operation (labelled "OK")
 * and one to cancel it (labelled "Cancel").
 *
 * A window manager is created automatically when this function is called for the first time.
 *
 *     @example
 *     OO.ui.prompt( 'Choose a line to go to', { textInput: { placeholder: 'Line number' } } ).done( function ( result ) {
 *         if ( result !== null ) {
 *             console.log( 'User typed "' + result + '" then clicked "OK".' );
 *         } else {
 *             console.log( 'User clicked "Cancel" or closed the dialog.' );
 *         }
 *     } );
 *
 * @param {jQuery|string} text Message text to display
 * @param {Object} [options] Additional options, see OO.ui.MessageDialog#getSetupProcess
 * @param {Object} [options.textInput] Additional options for text input widget, see OO.ui.TextInputWidget
 * @return {jQuery.Promise} Promise resolved when the user closes the dialog. If the user chose to
 *  confirm, the promise will resolve with the value of the text input widget; otherwise, it will
 *  resolve to `null`.
 */
OO.ui.prompt = function ( text, options ) {
	var instance,
		manager = OO.ui.getWindowManager(),
		textInput = new OO.ui.TextInputWidget( ( options && options.textInput ) || {} ),
		textField = new OO.ui.FieldLayout( textInput, {
			align: 'top',
			label: text
		} );

	instance = manager.openWindow( 'message', $.extend( {
		message: textField.$element
	}, options ) );

	// TODO: This is a little hacky, and could be done by extending MessageDialog instead.
	instance.opened.then( function () {
		textInput.on( 'enter', function () {
			manager.getCurrentWindow().close( { action: 'accept' } );
		} );
		textInput.focus();
	} );

	return instance.closed.then( function ( data ) {
		return data && data.action === 'accept' ? textInput.getValue() : null;
	} );
};

}( OO ) );

//# sourceMappingURL=oojs-ui-windows.js.map.json
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! oojs */ "./node_modules/oojs/dist/oojs.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./node_modules/oojs-ui/dist/themes/wikimediaui/images/icons/mapPin.svg":
/*!******************************************************************************!*\
  !*** ./node_modules/oojs-ui/dist/themes/wikimediaui/images/icons/mapPin.svg ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "../assets/images/mapPin.a306b6ab.svg";

/***/ }),

/***/ "./node_modules/oojs/dist/oojs.js":
/*!****************************************!*\
  !*** ./node_modules/oojs/dist/oojs.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * OOjs v2.2.2
 * https://www.mediawiki.org/wiki/OOjs
 *
 * Copyright 2011-2018 OOjs Team and other contributors.
 * Released under the MIT license
 * https://oojs.mit-license.org
 *
 * Date: 2018-06-14T20:13:14Z
 */
( function ( global ) {

'use strict';

/* exported toString */
var
	/**
	 * Namespace for all classes, static methods and static properties.
	 * @class OO
	 * @singleton
	 */
	oo = {},
	// Optimisation: Local reference to Object.prototype.hasOwnProperty
	hasOwn = oo.hasOwnProperty,
	toString = oo.toString;

/* Class Methods */

/**
 * Utility to initialize a class for OO inheritance.
 *
 * Currently this just initializes an empty static object.
 *
 * @param {Function} fn
 */
oo.initClass = function ( fn ) {
	fn.static = fn.static || {};
};

/**
 * Inherit from prototype to another using Object#create.
 *
 * Beware: This redefines the prototype, call before setting your prototypes.
 *
 * Beware: This redefines the prototype, can only be called once on a function.
 * If called multiple times on the same function, the previous prototype is lost.
 * This is how prototypal inheritance works, it can only be one straight chain
 * (just like classical inheritance in PHP for example). If you need to work with
 * multiple constructors consider storing an instance of the other constructor in a
 * property instead, or perhaps use a mixin (see OO.mixinClass).
 *
 *     function Thing() {}
 *     Thing.prototype.exists = function () {};
 *
 *     function Person() {
 *         Person.super.apply( this, arguments );
 *     }
 *     OO.inheritClass( Person, Thing );
 *     Person.static.defaultEyeCount = 2;
 *     Person.prototype.walk = function () {};
 *
 *     function Jumper() {
 *         Jumper.super.apply( this, arguments );
 *     }
 *     OO.inheritClass( Jumper, Person );
 *     Jumper.prototype.jump = function () {};
 *
 *     Jumper.static.defaultEyeCount === 2;
 *     var x = new Jumper();
 *     x.jump();
 *     x.walk();
 *     x instanceof Thing && x instanceof Person && x instanceof Jumper;
 *
 * @param {Function} targetFn
 * @param {Function} originFn
 * @throws {Error} If target already inherits from origin
 */
oo.inheritClass = function ( targetFn, originFn ) {
	var targetConstructor;

	if ( !originFn ) {
		throw new Error( 'inheritClass: Origin is not a function (actually ' + originFn + ')' );
	}
	if ( targetFn.prototype instanceof originFn ) {
		throw new Error( 'inheritClass: Target already inherits from origin' );
	}

	targetConstructor = targetFn.prototype.constructor;

	// [DEPRECATED] Provide .parent as alias for code supporting older browsers which
	// allows people to comply with their style guide.
	targetFn.super = targetFn.parent = originFn;

	targetFn.prototype = Object.create( originFn.prototype, {
		// Restore constructor property of targetFn
		constructor: {
			value: targetConstructor,
			enumerable: false,
			writable: true,
			configurable: true
		}
	} );

	// Extend static properties - always initialize both sides
	oo.initClass( originFn );
	targetFn.static = Object.create( originFn.static );
};

/**
 * Copy over *own* prototype properties of a mixin.
 *
 * The 'constructor' (whether implicit or explicit) is not copied over.
 *
 * This does not create inheritance to the origin. If you need inheritance,
 * use OO.inheritClass instead.
 *
 * Beware: This can redefine a prototype property, call before setting your prototypes.
 *
 * Beware: Don't call before OO.inheritClass.
 *
 *     function Foo() {}
 *     function Context() {}
 *
 *     // Avoid repeating this code
 *     function ContextLazyLoad() {}
 *     ContextLazyLoad.prototype.getContext = function () {
 *         if ( !this.context ) {
 *             this.context = new Context();
 *         }
 *         return this.context;
 *     };
 *
 *     function FooBar() {}
 *     OO.inheritClass( FooBar, Foo );
 *     OO.mixinClass( FooBar, ContextLazyLoad );
 *
 * @param {Function} targetFn
 * @param {Function} originFn
 */
oo.mixinClass = function ( targetFn, originFn ) {
	var key;

	if ( !originFn ) {
		throw new Error( 'mixinClass: Origin is not a function (actually ' + originFn + ')' );
	}

	// Copy prototype properties
	for ( key in originFn.prototype ) {
		if ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {
			targetFn.prototype[ key ] = originFn.prototype[ key ];
		}
	}

	// Copy static properties - always initialize both sides
	oo.initClass( targetFn );
	if ( originFn.static ) {
		for ( key in originFn.static ) {
			if ( hasOwn.call( originFn.static, key ) ) {
				targetFn.static[ key ] = originFn.static[ key ];
			}
		}
	} else {
		oo.initClass( originFn );
	}
};

/**
 * Test whether one class is a subclass of another, without instantiating it.
 *
 * Every class is considered a subclass of Object and of itself.
 *
 * @param {Function} testFn The class to be tested
 * @param {Function} baseFn The base class
 * @return {boolean} Whether testFn is a subclass of baseFn (or equal to it)
 */
oo.isSubclass = function ( testFn, baseFn ) {
	return testFn === baseFn || testFn.prototype instanceof baseFn;
};

/* Object Methods */

/**
 * Get a deeply nested property of an object using variadic arguments, protecting against
 * undefined property errors.
 *
 * `quux = OO.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`
 * except that the former protects against JS errors if one of the intermediate properties
 * is undefined. Instead of throwing an error, this function will return undefined in
 * that case.
 *
 * @param {Object} obj
 * @param {...Mixed} [keys]
 * @return {Object|undefined} obj[arguments[1]][arguments[2]].... or undefined
 */
oo.getProp = function ( obj ) {
	var i,
		retval = obj;
	for ( i = 1; i < arguments.length; i++ ) {
		if ( retval === undefined || retval === null ) {
			// Trying to access a property of undefined or null causes an error
			return undefined;
		}
		retval = retval[ arguments[ i ] ];
	}
	return retval;
};

/**
 * Set a deeply nested property of an object using variadic arguments, protecting against
 * undefined property errors.
 *
 * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that
 * the former protects against JS errors if one of the intermediate properties is
 * undefined. Instead of throwing an error, undefined intermediate properties will be
 * initialized to an empty object. If an intermediate property is not an object, or if obj itself
 * is not an object, this function will silently abort.
 *
 * @param {Object} obj
 * @param {...Mixed} [keys]
 * @param {Mixed} [value]
 */
oo.setProp = function ( obj ) {
	var i,
		prop = obj;
	if ( Object( obj ) !== obj || arguments.length < 2 ) {
		return;
	}
	for ( i = 1; i < arguments.length - 2; i++ ) {
		if ( prop[ arguments[ i ] ] === undefined ) {
			prop[ arguments[ i ] ] = {};
		}
		if ( Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {
			return;
		}
		prop = prop[ arguments[ i ] ];
	}
	prop[ arguments[ arguments.length - 2 ] ] = arguments[ arguments.length - 1 ];
};

/**
 * Delete a deeply nested property of an object using variadic arguments, protecting against
 * undefined property errors, and deleting resulting empty objects.
 *
 * @param {Object} obj
 * @param {...Mixed} [keys]
 */
oo.deleteProp = function ( obj ) {
	var i,
		prop = obj,
		props = [ prop ];
	if ( Object( obj ) !== obj || arguments.length < 2 ) {
		return;
	}
	for ( i = 1; i < arguments.length - 1; i++ ) {
		if ( prop[ arguments[ i ] ] === undefined || Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {
			return;
		}
		prop = prop[ arguments[ i ] ];
		props.push( prop );
	}
	delete prop[ arguments[ i ] ];
	// Walk back through props removing any plain empty objects
	while ( props.length > 1 && ( prop = props.pop() ) && oo.isPlainObject( prop ) && !Object.keys( prop ).length ) {
		delete props[ props.length - 1 ][ arguments[ props.length ] ];
	}
};

/**
 * Create a new object that is an instance of the same
 * constructor as the input, inherits from the same object
 * and contains the same own properties.
 *
 * This makes a shallow non-recursive copy of own properties.
 * To create a recursive copy of plain objects, use #copy.
 *
 *     var foo = new Person( mom, dad );
 *     foo.setAge( 21 );
 *     var foo2 = OO.cloneObject( foo );
 *     foo.setAge( 22 );
 *
 *     // Then
 *     foo2 !== foo; // true
 *     foo2 instanceof Person; // true
 *     foo2.getAge(); // 21
 *     foo.getAge(); // 22
 *
 * @param {Object} origin
 * @return {Object} Clone of origin
 */
oo.cloneObject = function ( origin ) {
	var key, r;

	r = Object.create( origin.constructor.prototype );

	for ( key in origin ) {
		if ( hasOwn.call( origin, key ) ) {
			r[ key ] = origin[ key ];
		}
	}

	return r;
};

/**
 * Get an array of all property values in an object.
 *
 * @param {Object} obj Object to get values from
 * @return {Array} List of object values
 */
oo.getObjectValues = function ( obj ) {
	var key, values;

	if ( obj !== Object( obj ) ) {
		throw new TypeError( 'Called on non-object' );
	}

	values = [];
	for ( key in obj ) {
		if ( hasOwn.call( obj, key ) ) {
			values[ values.length ] = obj[ key ];
		}
	}

	return values;
};

/**
 * Use binary search to locate an element in a sorted array.
 *
 * searchFunc is given an element from the array. `searchFunc(elem)` must return a number
 * above 0 if the element we're searching for is to the right of (has a higher index than) elem,
 * below 0 if it is to the left of elem, or zero if it's equal to elem.
 *
 * To search for a specific value with a comparator function (a `function cmp(a,b)` that returns
 * above 0 if `a > b`, below 0 if `a < b`, and 0 if `a == b`), you can use
 * `searchFunc = cmp.bind( null, value )`.
 *
 * @param {Array} arr Array to search in
 * @param {Function} searchFunc Search function
 * @param {boolean} [forInsertion] If not found, return index where val could be inserted
 * @return {number|null} Index where val was found, or null if not found
 */
oo.binarySearch = function ( arr, searchFunc, forInsertion ) {
	var mid, cmpResult,
		left = 0,
		right = arr.length;
	while ( left < right ) {
		// Equivalent to Math.floor( ( left + right ) / 2 ) but much faster
		// eslint-disable-next-line no-bitwise
		mid = ( left + right ) >> 1;
		cmpResult = searchFunc( arr[ mid ] );
		if ( cmpResult < 0 ) {
			right = mid;
		} else if ( cmpResult > 0 ) {
			left = mid + 1;
		} else {
			return mid;
		}
	}
	return forInsertion ? right : null;
};

/**
 * Recursively compare properties between two objects.
 *
 * A false result may be caused by property inequality or by properties in one object missing from
 * the other. An asymmetrical test may also be performed, which checks only that properties in the
 * first object are present in the second object, but not the inverse.
 *
 * If either a or b is null or undefined it will be treated as an empty object.
 *
 * @param {Object|undefined|null} a First object to compare
 * @param {Object|undefined|null} b Second object to compare
 * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's
 *  (i.e. a is a subset of b)
 * @return {boolean} If the objects contain the same values as each other
 */
oo.compare = function ( a, b, asymmetrical ) {
	var aValue, bValue, aType, bType, k;

	if ( a === b ) {
		return true;
	}

	a = a || {};
	b = b || {};

	if ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {
		return a.isEqualNode( b );
	}

	for ( k in a ) {
		if ( !hasOwn.call( a, k ) || a[ k ] === undefined || a[ k ] === b[ k ] ) {
			// Ignore undefined values, because there is no conceptual difference between
			// a key that is absent and a key that is present but whose value is undefined.
			continue;
		}

		aValue = a[ k ];
		bValue = b[ k ];
		aType = typeof aValue;
		bType = typeof bValue;
		if ( aType !== bType ||
			(
				( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&
				aValue !== bValue
			) ||
			( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {
			return false;
		}
	}
	// If the check is not asymmetrical, recursing with the arguments swapped will verify our result
	return asymmetrical ? true : oo.compare( b, a, true );
};

/**
 * Create a plain deep copy of any kind of object.
 *
 * Copies are deep, and will either be an object or an array depending on `source`.
 *
 * @param {Object} source Object to copy
 * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone
 * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.
 * @return {Object} Copy of source object
 */
oo.copy = function ( source, leafCallback, nodeCallback ) {
	var key, destination;

	if ( nodeCallback ) {
		// Extensibility: check before attempting to clone source.
		destination = nodeCallback( source );
		if ( destination !== undefined ) {
			return destination;
		}
	}

	if ( Array.isArray( source ) ) {
		// Array (fall through)
		destination = new Array( source.length );
	} else if ( source && typeof source.clone === 'function' ) {
		// Duck type object with custom clone method
		return leafCallback ? leafCallback( source.clone() ) : source.clone();
	} else if ( source && typeof source.cloneNode === 'function' ) {
		// DOM Node
		return leafCallback ?
			leafCallback( source.cloneNode( true ) ) :
			source.cloneNode( true );
	} else if ( oo.isPlainObject( source ) ) {
		// Plain objects (fall through)
		destination = {};
	} else {
		// Non-plain objects (incl. functions) and primitive values
		return leafCallback ? leafCallback( source ) : source;
	}

	// source is an array or a plain object
	for ( key in source ) {
		destination[ key ] = oo.copy( source[ key ], leafCallback, nodeCallback );
	}

	// This is an internal node, so we don't apply the leafCallback.
	return destination;
};

/**
 * Generate a hash of an object based on its name and data.
 *
 * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>
 *
 * To avoid two objects with the same values generating different hashes, we utilize the replacer
 * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may
 * not be the fastest way to do this; we should investigate this further.
 *
 * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()
 * function, we call that function and use its return value rather than hashing the object
 * ourselves. This allows classes to define custom hashing.
 *
 * @param {Object} val Object to generate hash for
 * @return {string} Hash of object
 */
oo.getHash = function ( val ) {
	return JSON.stringify( val, oo.getHash.keySortReplacer );
};

/**
 * Sort objects by key (helper function for OO.getHash).
 *
 * This is a callback passed into JSON.stringify.
 *
 * @method getHash_keySortReplacer
 * @param {string} key Property name of value being replaced
 * @param {Mixed} val Property value to replace
 * @return {Mixed} Replacement value
 */
oo.getHash.keySortReplacer = function ( key, val ) {
	var normalized, keys, i, len;
	if ( val && typeof val.getHashObject === 'function' ) {
		// This object has its own custom hash function, use it
		val = val.getHashObject();
	}
	if ( !Array.isArray( val ) && Object( val ) === val ) {
		// Only normalize objects when the key-order is ambiguous
		// (e.g. any object not an array).
		normalized = {};
		keys = Object.keys( val ).sort();
		i = 0;
		len = keys.length;
		for ( ; i < len; i += 1 ) {
			normalized[ keys[ i ] ] = val[ keys[ i ] ];
		}
		return normalized;
	} else {
		// Primitive values and arrays get stable hashes
		// by default. Lets those be stringified as-is.
		return val;
	}
};

/**
 * Get the unique values of an array, removing duplicates
 *
 * @param {Array} arr Array
 * @return {Array} Unique values in array
 */
oo.unique = function ( arr ) {
	return arr.reduce( function ( result, current ) {
		if ( result.indexOf( current ) === -1 ) {
			result.push( current );
		}
		return result;
	}, [] );
};

/**
 * Compute the union (duplicate-free merge) of a set of arrays.
 *
 * Arrays values must be convertable to object keys (strings).
 *
 * By building an object (with the values for keys) in parallel with
 * the array, a new item's existence in the union can be computed faster.
 *
 * @param {...Array} arrays Arrays to union
 * @return {Array} Union of the arrays
 */
oo.simpleArrayUnion = function () {
	var i, ilen, arr, j, jlen,
		obj = {},
		result = [];

	for ( i = 0, ilen = arguments.length; i < ilen; i++ ) {
		arr = arguments[ i ];
		for ( j = 0, jlen = arr.length; j < jlen; j++ ) {
			if ( !obj[ arr[ j ] ] ) {
				obj[ arr[ j ] ] = true;
				result.push( arr[ j ] );
			}
		}
	}

	return result;
};

/**
 * Combine arrays (intersection or difference).
 *
 * An intersection checks the item exists in 'b' while difference checks it doesn't.
 *
 * Arrays values must be convertable to object keys (strings).
 *
 * By building an object (with the values for keys) of 'b' we can
 * compute the result faster.
 *
 * @private
 * @param {Array} a First array
 * @param {Array} b Second array
 * @param {boolean} includeB Whether to items in 'b'
 * @return {Array} Combination (intersection or difference) of arrays
 */
function simpleArrayCombine( a, b, includeB ) {
	var i, ilen, isInB,
		bObj = {},
		result = [];

	for ( i = 0, ilen = b.length; i < ilen; i++ ) {
		bObj[ b[ i ] ] = true;
	}

	for ( i = 0, ilen = a.length; i < ilen; i++ ) {
		isInB = !!bObj[ a[ i ] ];
		if ( isInB === includeB ) {
			result.push( a[ i ] );
		}
	}

	return result;
}

/**
 * Compute the intersection of two arrays (items in both arrays).
 *
 * Arrays values must be convertable to object keys (strings).
 *
 * @param {Array} a First array
 * @param {Array} b Second array
 * @return {Array} Intersection of arrays
 */
oo.simpleArrayIntersection = function ( a, b ) {
	return simpleArrayCombine( a, b, true );
};

/**
 * Compute the difference of two arrays (items in 'a' but not 'b').
 *
 * Arrays values must be convertable to object keys (strings).
 *
 * @param {Array} a First array
 * @param {Array} b Second array
 * @return {Array} Intersection of arrays
 */
oo.simpleArrayDifference = function ( a, b ) {
	return simpleArrayCombine( a, b, false );
};

/* global hasOwn, toString */

/**
 * Assert whether a value is a plain object or not.
 *
 * @member OO
 * @param {Mixed} obj
 * @return {boolean}
 */
oo.isPlainObject = function ( obj ) {
	var proto;

	// Optimise for common case where internal [[Class]] property is not "Object"
	if ( !obj || toString.call( obj ) !== '[object Object]' ) {
		return false;
	}

	proto = Object.getPrototypeOf( obj );

	// Objects without prototype (e.g., `Object.create( null )`) are considered plain
	if ( !proto ) {
		return true;
	}

	// The 'isPrototypeOf' method is set on Object.prototype.
	return hasOwn.call( proto, 'isPrototypeOf' );
};

/* global hasOwn */

( function () {

	/**
	 * @class OO.EventEmitter
	 *
	 * @constructor
	 */
	oo.EventEmitter = function OoEventEmitter() {
		// Properties

		/**
		 * Storage of bound event handlers by event name.
		 *
		 * @property
		 */
		this.bindings = {};
	};

	oo.initClass( oo.EventEmitter );

	/* Private helper functions */

	/**
	 * Validate a function or method call in a context
	 *
	 * For a method name, check that it names a function in the context object
	 *
	 * @private
	 * @param {Function|string} method Function or method name
	 * @param {Mixed} context The context of the call
	 * @throws {Error} A method name is given but there is no context
	 * @throws {Error} In the context object, no property exists with the given name
	 * @throws {Error} In the context object, the named property is not a function
	 */
	function validateMethod( method, context ) {
		// Validate method and context
		if ( typeof method === 'string' ) {
			// Validate method
			if ( context === undefined || context === null ) {
				throw new Error( 'Method name "' + method + '" has no context.' );
			}
			if ( typeof context[ method ] !== 'function' ) {
				// Technically the property could be replaced by a function before
				// call time. But this probably signals a typo.
				throw new Error( 'Property "' + method + '" is not a function' );
			}
		} else if ( typeof method !== 'function' ) {
			throw new Error( 'Invalid callback. Function or method name expected.' );
		}
	}

	/**
	 * @private
	 * @param {OO.EventEmitter} eventEmitter Event emitter
	 * @param {string} event Event name
	 * @param {Object} binding
	 */
	function addBinding( eventEmitter, event, binding ) {
		var bindings;
		// Auto-initialize bindings list
		if ( hasOwn.call( eventEmitter.bindings, event ) ) {
			bindings = eventEmitter.bindings[ event ];
		} else {
			bindings = eventEmitter.bindings[ event ] = [];
		}
		// Add binding
		bindings.push( binding );
	}

	/* Methods */

	/**
	 * Add a listener to events of a specific event.
	 *
	 * The listener can be a function or the string name of a method; if the latter, then the
	 * name lookup happens at the time the listener is called.
	 *
	 * @param {string} event Type of event to listen to
	 * @param {Function|string} method Function or method name to call when event occurs
	 * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments
	 * @param {Object} [context=null] Context object for function or method call
	 * @chainable
	 * @throws {Error} Listener argument is not a function or a valid method name
	 */
	oo.EventEmitter.prototype.on = function ( event, method, args, context ) {
		validateMethod( method, context );

		// Ensure consistent object shape (optimisation)
		addBinding( this, event, {
			method: method,
			args: args,
			context: ( arguments.length < 4 ) ? null : context,
			once: false
		} );
		return this;
	};

	/**
	 * Add a one-time listener to a specific event.
	 *
	 * @param {string} event Type of event to listen to
	 * @param {Function} listener Listener to call when event occurs
	 * @chainable
	 */
	oo.EventEmitter.prototype.once = function ( event, listener ) {
		validateMethod( listener );

		// Ensure consistent object shape (optimisation)
		addBinding( this, event, {
			method: listener,
			args: undefined,
			context: null,
			once: true
		} );
		return this;
	};

	/**
	 * Remove a specific listener from a specific event.
	 *
	 * @param {string} event Type of event to remove listener from
	 * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed
	 * to "on". Omit to remove all listeners.
	 * @param {Object} [context=null] Context object function or method call
	 * @chainable
	 * @throws {Error} Listener argument is not a function or a valid method name
	 */
	oo.EventEmitter.prototype.off = function ( event, method, context ) {
		var i, bindings;

		if ( arguments.length === 1 ) {
			// Remove all bindings for event
			delete this.bindings[ event ];
			return this;
		}

		validateMethod( method, context );

		if ( !hasOwn.call( this.bindings, event ) || !this.bindings[ event ].length ) {
			// No matching bindings
			return this;
		}

		// Default to null context
		if ( arguments.length < 3 ) {
			context = null;
		}

		// Remove matching handlers
		bindings = this.bindings[ event ];
		i = bindings.length;
		while ( i-- ) {
			if ( bindings[ i ].method === method && bindings[ i ].context === context ) {
				bindings.splice( i, 1 );
			}
		}

		// Cleanup if now empty
		if ( bindings.length === 0 ) {
			delete this.bindings[ event ];
		}
		return this;
	};

	/**
	 * Emit an event.
	 *
	 * @param {string} event Type of event
	 * @param {...Mixed} args First in a list of variadic arguments passed to event handler (optional)
	 * @return {boolean} Whether the event was handled by at least one listener
	 */
	oo.EventEmitter.prototype.emit = function ( event ) {
		var args = [],
			i, len, binding, bindings, method;

		if ( hasOwn.call( this.bindings, event ) ) {
			// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings
			bindings = this.bindings[ event ].slice();
			for ( i = 1, len = arguments.length; i < len; i++ ) {
				args.push( arguments[ i ] );
			}
			for ( i = 0, len = bindings.length; i < len; i++ ) {
				binding = bindings[ i ];
				if ( typeof binding.method === 'string' ) {
					// Lookup method by name (late binding)
					method = binding.context[ binding.method ];
				} else {
					method = binding.method;
				}
				if ( binding.once ) {
					// Must unbind before calling method to avoid
					// any nested triggers.
					this.off( event, method );
				}
				method.apply(
					binding.context,
					binding.args ? binding.args.concat( args ) : args
				);
			}
			return true;
		}
		return false;
	};

	/**
	 * Connect event handlers to an object.
	 *
	 * @param {Object} context Object to call methods on when events occur
	 * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of
	 *  event bindings keyed by event name containing either method names, functions or arrays containing
	 *  method name or function followed by a list of arguments to be passed to callback before emitted
	 *  arguments.
	 * @chainable
	 */
	oo.EventEmitter.prototype.connect = function ( context, methods ) {
		var method, args, event;

		for ( event in methods ) {
			method = methods[ event ];
			// Allow providing additional args
			if ( Array.isArray( method ) ) {
				args = method.slice( 1 );
				method = method[ 0 ];
			} else {
				args = [];
			}
			// Add binding
			this.on( event, method, args, context );
		}
		return this;
	};

	/**
	 * Disconnect event handlers from an object.
	 *
	 * @param {Object} context Object to disconnect methods from
	 * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of
	 *  event bindings keyed by event name. Values can be either method names, functions or arrays
	 *  containing a method name.
	 *  NOTE: To allow matching call sites with connect(), array values are allowed to contain the
	 *  parameters as well, but only the method name is used to find bindings. Tt is discouraged to
	 *  have multiple bindings for the same event to the same listener, but if used (and only the
	 *  parameters vary), disconnecting one variation of (event name, event listener, parameters)
	 *  will disconnect other variations as well.
	 * @chainable
	 */
	oo.EventEmitter.prototype.disconnect = function ( context, methods ) {
		var i, event, method, bindings;

		if ( methods ) {
			// Remove specific connections to the context
			for ( event in methods ) {
				method = methods[ event ];
				if ( Array.isArray( method ) ) {
					method = method[ 0 ];
				}
				this.off( event, method, context );
			}
		} else {
			// Remove all connections to the context
			for ( event in this.bindings ) {
				bindings = this.bindings[ event ];
				i = bindings.length;
				while ( i-- ) {
					// bindings[i] may have been removed by the previous step's
					// this.off so check it still exists
					if ( bindings[ i ] && bindings[ i ].context === context ) {
						this.off( event, bindings[ i ].method, context );
					}
				}
			}
		}

		return this;
	};

}() );

( function () {

	/**
	 * Contain and manage a list of OO.EventEmitter items.
	 *
	 * Aggregates and manages their events collectively.
	 *
	 * This mixin must be used in a class that also mixes in OO.EventEmitter.
	 *
	 * @abstract
	 * @class OO.EmitterList
	 * @constructor
	 */
	oo.EmitterList = function OoEmitterList() {
		this.items = [];
		this.aggregateItemEvents = {};
	};

	/* Events */

	/**
	 * Item has been added
	 *
	 * @event add
	 * @param {OO.EventEmitter} item Added item
	 * @param {number} index Index items were added at
	 */

	/**
	 * Item has been moved to a new index
	 *
	 * @event move
	 * @param {OO.EventEmitter} item Moved item
	 * @param {number} index Index item was moved to
	 * @param {number} oldIndex The original index the item was in
	 */

	/**
	 * Item has been removed
	 *
	 * @event remove
	 * @param {OO.EventEmitter} item Removed item
	 * @param {number} index Index the item was removed from
	 */

	/**
	 * @event clear The list has been cleared of items
	 */

	/* Methods */

	/**
	 * Normalize requested index to fit into the bounds of the given array.
	 *
	 * @private
	 * @static
	 * @param {Array} arr Given array
	 * @param {number|undefined} index Requested index
	 * @return {number} Normalized index
	 */
	function normalizeArrayIndex( arr, index ) {
		return ( index === undefined || index < 0 || index >= arr.length ) ?
			arr.length :
			index;
	}

	/**
	 * Get all items.
	 *
	 * @return {OO.EventEmitter[]} Items in the list
	 */
	oo.EmitterList.prototype.getItems = function () {
		return this.items.slice( 0 );
	};

	/**
	 * Get the index of a specific item.
	 *
	 * @param {OO.EventEmitter} item Requested item
	 * @return {number} Index of the item
	 */
	oo.EmitterList.prototype.getItemIndex = function ( item ) {
		return this.items.indexOf( item );
	};

	/**
	 * Get number of items.
	 *
	 * @return {number} Number of items in the list
	 */
	oo.EmitterList.prototype.getItemCount = function () {
		return this.items.length;
	};

	/**
	 * Check if a list contains no items.
	 *
	 * @return {boolean} Group is empty
	 */
	oo.EmitterList.prototype.isEmpty = function () {
		return !this.items.length;
	};

	/**
	 * Aggregate the events emitted by the group.
	 *
	 * When events are aggregated, the group will listen to all contained items for the event,
	 * and then emit the event under a new name. The new event will contain an additional leading
	 * parameter containing the item that emitted the original event. Other arguments emitted from
	 * the original event are passed through.
	 *
	 * @param {Object.<string,string|null>} events An object keyed by the name of the event that should be
	 *  aggregated  (e.g., ‘click’) and the value of the new name to use (e.g., ‘groupClick’).
	 *  A `null` value will remove aggregated events.

	 * @throws {Error} If aggregation already exists
	 */
	oo.EmitterList.prototype.aggregate = function ( events ) {
		var i, item, add, remove, itemEvent, groupEvent;

		for ( itemEvent in events ) {
			groupEvent = events[ itemEvent ];

			// Remove existing aggregated event
			if ( Object.prototype.hasOwnProperty.call( this.aggregateItemEvents, itemEvent ) ) {
				// Don't allow duplicate aggregations
				if ( groupEvent ) {
					throw new Error( 'Duplicate item event aggregation for ' + itemEvent );
				}
				// Remove event aggregation from existing items
				for ( i = 0; i < this.items.length; i++ ) {
					item = this.items[ i ];
					if ( item.connect && item.disconnect ) {
						remove = {};
						remove[ itemEvent ] = [ 'emit', this.aggregateItemEvents[ itemEvent ], item ];
						item.disconnect( this, remove );
					}
				}
				// Prevent future items from aggregating event
				delete this.aggregateItemEvents[ itemEvent ];
			}

			// Add new aggregate event
			if ( groupEvent ) {
				// Make future items aggregate event
				this.aggregateItemEvents[ itemEvent ] = groupEvent;
				// Add event aggregation to existing items
				for ( i = 0; i < this.items.length; i++ ) {
					item = this.items[ i ];
					if ( item.connect && item.disconnect ) {
						add = {};
						add[ itemEvent ] = [ 'emit', groupEvent, item ];
						item.connect( this, add );
					}
				}
			}
		}
	};

	/**
	 * Add items to the list.
	 *
	 * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or
	 *  an array of items to add
	 * @param {number} [index] Index to add items at. If no index is
	 *  given, or if the index that is given is invalid, the item
	 *  will be added at the end of the list.
	 * @chainable
	 * @fires add
	 * @fires move
	 */
	oo.EmitterList.prototype.addItems = function ( items, index ) {
		var i, oldIndex;

		if ( !Array.isArray( items ) ) {
			items = [ items ];
		}

		if ( items.length === 0 ) {
			return this;
		}

		index = normalizeArrayIndex( this.items, index );
		for ( i = 0; i < items.length; i++ ) {
			oldIndex = this.items.indexOf( items[ i ] );
			if ( oldIndex !== -1 ) {
				// Move item to new index
				index = this.moveItem( items[ i ], index );
				this.emit( 'move', items[ i ], index, oldIndex );
			} else {
				// insert item at index
				index = this.insertItem( items[ i ], index );
				this.emit( 'add', items[ i ], index );
			}
			index++;
		}

		return this;
	};

	/**
	 * Move an item from its current position to a new index.
	 *
	 * The item is expected to exist in the list. If it doesn't,
	 * the method will throw an exception.
	 *
	 * @private
	 * @param {OO.EventEmitter} item Items to add
	 * @param {number} newIndex Index to move the item to
	 * @return {number} The index the item was moved to
	 * @throws {Error} If item is not in the list
	 */
	oo.EmitterList.prototype.moveItem = function ( item, newIndex ) {
		var existingIndex = this.items.indexOf( item );

		if ( existingIndex === -1 ) {
			throw new Error( 'Item cannot be moved, because it is not in the list.' );
		}

		newIndex = normalizeArrayIndex( this.items, newIndex );

		// Remove the item from the current index
		this.items.splice( existingIndex, 1 );

		// If necessary, adjust new index after removal
		if ( existingIndex < newIndex ) {
			newIndex--;
		}

		// Move the item to the new index
		this.items.splice( newIndex, 0, item );

		return newIndex;
	};

	/**
	 * Utility method to insert an item into the list, and
	 * connect it to aggregate events.
	 *
	 * Don't call this directly unless you know what you're doing.
	 * Use #addItems instead.
	 *
	 * This method can be extended in child classes to produce
	 * different behavior when an item is inserted. For example,
	 * inserted items may also be attached to the DOM or may
	 * interact with some other nodes in certain ways. Extending
	 * this method is allowed, but if overriden, the aggregation
	 * of events must be preserved, or behavior of emitted events
	 * will be broken.
	 *
	 * If you are extending this method, please make sure the
	 * parent method is called.
	 *
	 * @protected
	 * @param {OO.EventEmitter} item Items to add
	 * @param {number} index Index to add items at
	 * @return {number} The index the item was added at
	 */
	oo.EmitterList.prototype.insertItem = function ( item, index ) {
		var events, event;

		// Add the item to event aggregation
		if ( item.connect && item.disconnect ) {
			events = {};
			for ( event in this.aggregateItemEvents ) {
				events[ event ] = [ 'emit', this.aggregateItemEvents[ event ], item ];
			}
			item.connect( this, events );
		}

		index = normalizeArrayIndex( this.items, index );

		// Insert into items array
		this.items.splice( index, 0, item );
		return index;
	};

	/**
	 * Remove items.
	 *
	 * @param {OO.EventEmitter[]} items Items to remove
	 * @chainable
	 * @fires remove
	 */
	oo.EmitterList.prototype.removeItems = function ( items ) {
		var i, item, index;

		if ( !Array.isArray( items ) ) {
			items = [ items ];
		}

		if ( items.length === 0 ) {
			return this;
		}

		// Remove specific items
		for ( i = 0; i < items.length; i++ ) {
			item = items[ i ];
			index = this.items.indexOf( item );
			if ( index !== -1 ) {
				if ( item.connect && item.disconnect ) {
					// Disconnect all listeners from the item
					item.disconnect( this );
				}
				this.items.splice( index, 1 );
				this.emit( 'remove', item, index );
			}
		}

		return this;
	};

	/**
	 * Clear all items
	 *
	 * @chainable
	 * @fires clear
	 */
	oo.EmitterList.prototype.clearItems = function () {
		var i, item,
			cleared = this.items.splice( 0, this.items.length );

		// Disconnect all items
		for ( i = 0; i < cleared.length; i++ ) {
			item = cleared[ i ];
			if ( item.connect && item.disconnect ) {
				item.disconnect( this );
			}
		}

		this.emit( 'clear' );

		return this;
	};

}() );

/**
 * Manage a sorted list of OO.EmitterList objects.
 *
 * The sort order is based on a callback that compares two items. The return value of
 * callback( a, b ) must be less than zero if a < b, greater than zero if a > b, and zero
 * if a is equal to b. The callback should only return zero if the two objects are
 * considered equal.
 *
 * When an item changes in a way that could affect their sorting behavior, it must
 * emit the itemSortChange event. This will cause it to be re-sorted automatically.
 *
 * This mixin must be used in a class that also mixes in OO.EventEmitter.
 *
 * @abstract
 * @class OO.SortedEmitterList
 * @mixins OO.EmitterList
 * @constructor
 * @param {Function} sortingCallback Callback that compares two items.
 */
oo.SortedEmitterList = function OoSortedEmitterList( sortingCallback ) {
	// Mixin constructors
	oo.EmitterList.call( this );

	this.sortingCallback = sortingCallback;

	// Listen to sortChange event and make sure
	// we re-sort the changed item when that happens
	this.aggregate( {
		sortChange: 'itemSortChange'
	} );

	this.connect( this, {
		itemSortChange: 'onItemSortChange'
	} );
};

oo.mixinClass( oo.SortedEmitterList, oo.EmitterList );

/* Events */

/**
 * An item has changed properties that affect its sort positioning
 * inside the list.
 *
 * @private
 * @event itemSortChange
 */

/* Methods */

/**
 * Handle a case where an item changed a property that relates
 * to its sorted order
 *
 * @param {OO.EventEmitter} item Item in the list
 */
oo.SortedEmitterList.prototype.onItemSortChange = function ( item ) {
	// Remove the item
	this.removeItems( item );
	// Re-add the item so it is in the correct place
	this.addItems( item );
};

/**
 * Change the sorting callback for this sorted list.
 *
 * The callback receives two items. The return value of callback(a, b) must be less than zero
 * if a < b, greater than zero if a > b, and zero if a is equal to b.
 *
 * @param {Function} sortingCallback Sorting callback
 */
oo.SortedEmitterList.prototype.setSortingCallback = function ( sortingCallback ) {
	var items = this.getItems();

	this.sortingCallback = sortingCallback;

	// Empty the list
	this.clearItems();
	// Re-add the items in the new order
	this.addItems( items );
};

/**
 * Add items to the sorted list.
 *
 * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or
 *  an array of items to add
 * @chainable
 */
oo.SortedEmitterList.prototype.addItems = function ( items ) {
	var index, i, insertionIndex;

	if ( !Array.isArray( items ) ) {
		items = [ items ];
	}

	if ( items.length === 0 ) {
		return this;
	}

	for ( i = 0; i < items.length; i++ ) {
		// Find insertion index
		insertionIndex = this.findInsertionIndex( items[ i ] );

		// Check if the item exists using the sorting callback
		// and remove it first if it exists
		if (
			// First make sure the insertion index is not at the end
			// of the list (which means it does not point to any actual
			// items)
			insertionIndex <= this.items.length &&
			// Make sure there actually is an item in this index
			this.items[ insertionIndex ] &&
			// The callback returns 0 if the items are equal
			this.sortingCallback( this.items[ insertionIndex ], items[ i ] ) === 0
		) {
			// Remove the existing item
			this.removeItems( this.items[ insertionIndex ] );
		}

		// Insert item at the insertion index
		index = this.insertItem( items[ i ], insertionIndex );
		this.emit( 'add', items[ i ], index );
	}

	return this;
};

/**
 * Find the index a given item should be inserted at. If the item is already
 * in the list, this will return the index where the item currently is.
 *
 * @param {OO.EventEmitter} item Items to insert
 * @return {number} The index the item should be inserted at
 */
oo.SortedEmitterList.prototype.findInsertionIndex = function ( item ) {
	var list = this;

	return oo.binarySearch(
		this.items,
		// Fake a this.sortingCallback.bind( null, item ) call here
		// otherwise this doesn't pass tests in phantomJS
		function ( otherItem ) {
			return list.sortingCallback( item, otherItem );
		},
		true
	);

};

/* global hasOwn */

/**
 * A map interface for associating arbitrary data with a symbolic name. Used in
 * place of a plain object to provide additional {@link #method-register registration}
 * or {@link #method-lookup lookup} functionality.
 *
 * See <https://www.mediawiki.org/wiki/OOjs/Registries_and_factories>.
 *
 * @class OO.Registry
 * @mixins OO.EventEmitter
 *
 * @constructor
 */
oo.Registry = function OoRegistry() {
	// Mixin constructors
	oo.EventEmitter.call( this );

	// Properties
	this.registry = {};
};

/* Inheritance */

oo.mixinClass( oo.Registry, oo.EventEmitter );

/* Events */

/**
 * @event register
 * @param {string} name
 * @param {Mixed} data
 */

/**
 * @event unregister
 * @param {string} name
 * @param {Mixed} data Data removed from registry
 */

/* Methods */

/**
 * Associate one or more symbolic names with some data.
 *
 * Any existing entry with the same name will be overridden.
 *
 * @param {string|string[]} name Symbolic name or list of symbolic names
 * @param {Mixed} data Data to associate with symbolic name
 * @fires register
 * @throws {Error} Name argument must be a string or array
 */
oo.Registry.prototype.register = function ( name, data ) {
	var i, len;
	if ( typeof name === 'string' ) {
		this.registry[ name ] = data;
		this.emit( 'register', name, data );
	} else if ( Array.isArray( name ) ) {
		for ( i = 0, len = name.length; i < len; i++ ) {
			this.register( name[ i ], data );
		}
	} else {
		throw new Error( 'Name must be a string or array, cannot be a ' + typeof name );
	}
};

/**
 * Remove one or more symbolic names from the registry
 *
 * @param {string|string[]} name Symbolic name or list of symbolic names
 * @fires unregister
 * @throws {Error} Name argument must be a string or array
 */
oo.Registry.prototype.unregister = function ( name ) {
	var i, len, data;
	if ( typeof name === 'string' ) {
		data = this.lookup( name );
		if ( data !== undefined ) {
			delete this.registry[ name ];
			this.emit( 'unregister', name, data );
		}
	} else if ( Array.isArray( name ) ) {
		for ( i = 0, len = name.length; i < len; i++ ) {
			this.unregister( name[ i ] );
		}
	} else {
		throw new Error( 'Name must be a string or array, cannot be a ' + typeof name );
	}
};

/**
 * Get data for a given symbolic name.
 *
 * @param {string} name Symbolic name
 * @return {Mixed|undefined} Data associated with symbolic name
 */
oo.Registry.prototype.lookup = function ( name ) {
	if ( hasOwn.call( this.registry, name ) ) {
		return this.registry[ name ];
	}
};

/**
 * @class OO.Factory
 * @extends OO.Registry
 *
 * @constructor
 */
oo.Factory = function OoFactory() {
	// Parent constructor
	oo.Factory.super.call( this );
};

/* Inheritance */

oo.inheritClass( oo.Factory, oo.Registry );

/* Methods */

/**
 * Register a constructor with the factory.
 *
 * Classes must have a static `name` property to be registered.
 *
 *     function MyClass() {};
 *     OO.initClass( MyClass );
 *     // Adds a static property to the class defining a symbolic name
 *     MyClass.static.name = 'mine';
 *     // Registers class with factory, available via symbolic name 'mine'
 *     factory.register( MyClass );
 *
 * @param {Function} constructor Constructor to use when creating object
 * @throws {Error} Name must be a string and must not be empty
 * @throws {Error} Constructor must be a function
 */
oo.Factory.prototype.register = function ( constructor ) {
	var name;

	if ( typeof constructor !== 'function' ) {
		throw new Error( 'constructor must be a function, cannot be a ' + typeof constructor );
	}
	name = constructor.static && constructor.static.name;
	if ( typeof name !== 'string' || name === '' ) {
		throw new Error( 'Name must be a string and must not be empty' );
	}

	// Parent method
	oo.Factory.super.prototype.register.call( this, name, constructor );
};

/**
 * Unregister a constructor from the factory.
 *
 * @param {Function} constructor Constructor to unregister
 * @throws {Error} Name must be a string and must not be empty
 * @throws {Error} Constructor must be a function
 */
oo.Factory.prototype.unregister = function ( constructor ) {
	var name;

	if ( typeof constructor !== 'function' ) {
		throw new Error( 'constructor must be a function, cannot be a ' + typeof constructor );
	}
	name = constructor.static && constructor.static.name;
	if ( typeof name !== 'string' || name === '' ) {
		throw new Error( 'Name must be a string and must not be empty' );
	}

	// Parent method
	oo.Factory.super.prototype.unregister.call( this, name );
};

/**
 * Create an object based on a name.
 *
 * Name is used to look up the constructor to use, while all additional arguments are passed to the
 * constructor directly, so leaving one out will pass an undefined to the constructor.
 *
 * @param {string} name Object name
 * @param {...Mixed} [args] Arguments to pass to the constructor
 * @return {Object} The new object
 * @throws {Error} Unknown object name
 */
oo.Factory.prototype.create = function ( name ) {
	var obj, i,
		args = [],
		constructor = this.lookup( name );

	if ( !constructor ) {
		throw new Error( 'No class registered by that name: ' + name );
	}

	// Convert arguments to array and shift the first argument (name) off
	for ( i = 1; i < arguments.length; i++ ) {
		args.push( arguments[ i ] );
	}

	// We can't use the "new" operator with .apply directly because apply needs a
	// context. So instead just do what "new" does: create an object that inherits from
	// the constructor's prototype (which also makes it an "instanceof" the constructor),
	// then invoke the constructor with the object as context, and return it (ignoring
	// the constructor's return value).
	obj = Object.create( constructor.prototype );
	constructor.apply( obj, args );
	return obj;
};

/* eslint-env node */

/* istanbul ignore next */
if (  true && module.exports ) {
	module.exports = oo;
} else {
	global.OO = oo;
}

}( this ) );


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./node_modules/jquery/dist/jquery.js ./node_modules/oojs/dist/oojs.js ./node_modules/oojs-ui/dist/oojs-ui.js ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui.js ./node_modules/oojs-ui/dist/oojs-ui-core-wikimediaui.css ./node_modules/oojs-ui/dist/oojs-ui-widgets-wikimediaui.css ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-interactions.css ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-movement.css ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-wikimedia.css ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.js ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.messagestore.js ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.fallbacks.js ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.parser.js ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.emitter.js ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.language.js ./node_modules/@wikimedia/jquery.i18n/src/languages/he.js ./node_modules/@wikimedia/jquery.i18n/src/languages/fi.js ./node_modules/@wikimedia/jquery.i18n/src/languages/ml.js ./node_modules/jquery.uls/src/jquery.uls.data.js ./node_modules/jquery.uls/src/jquery.uls.data.utils.js ./node_modules/jquery.uls/src/jquery.uls.lcd.js ./node_modules/jquery.uls/src/jquery.uls.languagefilter.js ./node_modules/jquery.uls/src/jquery.uls.core.js ./node_modules/jquery.uls/css/jquery.uls.css ./node_modules/jquery.uls/css/jquery.uls.grid.css ./node_modules/jquery.uls/css/jquery.uls.lcd.css ./node_modules/leaflet/dist/leaflet.js ./node_modules/leaflet/dist/leaflet.css ./assets/app.js ./assets/app.less ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/jquery/dist/jquery.js */"./node_modules/jquery/dist/jquery.js");
__webpack_require__(/*! ./node_modules/oojs/dist/oojs.js */"./node_modules/oojs/dist/oojs.js");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui.js */"./node_modules/oojs-ui/dist/oojs-ui.js");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui.js */"./node_modules/oojs-ui/dist/oojs-ui-wikimediaui.js");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-core-wikimediaui.css */"./node_modules/oojs-ui/dist/oojs-ui-core-wikimediaui.css");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-widgets-wikimediaui.css */"./node_modules/oojs-ui/dist/oojs-ui-widgets-wikimediaui.css");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-interactions.css */"./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-interactions.css");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-movement.css */"./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-movement.css");
__webpack_require__(/*! ./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-wikimedia.css */"./node_modules/oojs-ui/dist/oojs-ui-wikimediaui-icons-wikimedia.css");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.messagestore.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.messagestore.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.fallbacks.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.fallbacks.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.parser.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.parser.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.emitter.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.emitter.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.language.js */"./node_modules/@wikimedia/jquery.i18n/src/jquery.i18n.language.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/languages/he.js */"./node_modules/@wikimedia/jquery.i18n/src/languages/he.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/languages/fi.js */"./node_modules/@wikimedia/jquery.i18n/src/languages/fi.js");
__webpack_require__(/*! ./node_modules/@wikimedia/jquery.i18n/src/languages/ml.js */"./node_modules/@wikimedia/jquery.i18n/src/languages/ml.js");
__webpack_require__(/*! ./node_modules/jquery.uls/src/jquery.uls.data.js */"./node_modules/jquery.uls/src/jquery.uls.data.js");
__webpack_require__(/*! ./node_modules/jquery.uls/src/jquery.uls.data.utils.js */"./node_modules/jquery.uls/src/jquery.uls.data.utils.js");
__webpack_require__(/*! ./node_modules/jquery.uls/src/jquery.uls.lcd.js */"./node_modules/jquery.uls/src/jquery.uls.lcd.js");
__webpack_require__(/*! ./node_modules/jquery.uls/src/jquery.uls.languagefilter.js */"./node_modules/jquery.uls/src/jquery.uls.languagefilter.js");
__webpack_require__(/*! ./node_modules/jquery.uls/src/jquery.uls.core.js */"./node_modules/jquery.uls/src/jquery.uls.core.js");
__webpack_require__(/*! ./node_modules/jquery.uls/css/jquery.uls.css */"./node_modules/jquery.uls/css/jquery.uls.css");
__webpack_require__(/*! ./node_modules/jquery.uls/css/jquery.uls.grid.css */"./node_modules/jquery.uls/css/jquery.uls.grid.css");
__webpack_require__(/*! ./node_modules/jquery.uls/css/jquery.uls.lcd.css */"./node_modules/jquery.uls/css/jquery.uls.lcd.css");
__webpack_require__(/*! ./node_modules/leaflet/dist/leaflet.js */"./node_modules/leaflet/dist/leaflet.js");
__webpack_require__(/*! ./node_modules/leaflet/dist/leaflet.css */"./node_modules/leaflet/dist/leaflet.css");
__webpack_require__(/*! ./assets/app.js */"./assets/app.js");
module.exports = __webpack_require__(/*! ./assets/app.less */"./assets/app.less");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL0ZsaWNrclRhZ1dpZGdldC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvVGFnTWVudU9wdGlvbldpZGdldC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9hcHAubGVzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdpa2ltZWRpYS9qcXVlcnkuaTE4bi9zcmMvanF1ZXJ5LmkxOG4uZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdpa2ltZWRpYS9qcXVlcnkuaTE4bi9zcmMvanF1ZXJ5LmkxOG4uZmFsbGJhY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2lraW1lZGlhL2pxdWVyeS5pMThuL3NyYy9qcXVlcnkuaTE4bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdpa2ltZWRpYS9qcXVlcnkuaTE4bi9zcmMvanF1ZXJ5LmkxOG4ubGFuZ3VhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3aWtpbWVkaWEvanF1ZXJ5LmkxOG4vc3JjL2pxdWVyeS5pMThuLm1lc3NhZ2VzdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdpa2ltZWRpYS9qcXVlcnkuaTE4bi9zcmMvanF1ZXJ5LmkxOG4ucGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2lraW1lZGlhL2pxdWVyeS5pMThuL3NyYy9sYW5ndWFnZXMvZmkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3aWtpbWVkaWEvanF1ZXJ5LmkxOG4vc3JjL2xhbmd1YWdlcy9oZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdpa2ltZWRpYS9qcXVlcnkuaTE4bi9zcmMvbGFuZ3VhZ2VzL21sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkudWxzL2Nzcy9qcXVlcnkudWxzLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnVscy9jc3MvanF1ZXJ5LnVscy5ncmlkLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnVscy9jc3MvanF1ZXJ5LnVscy5sY2QuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkudWxzL3NyYy9qcXVlcnkudWxzLmNvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS51bHMvc3JjL2pxdWVyeS51bHMuZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnVscy9zcmMvanF1ZXJ5LnVscy5kYXRhLnV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkudWxzL3NyYy9qcXVlcnkudWxzLmxhbmd1YWdlZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkudWxzL3NyYy9qcXVlcnkudWxzLmxjZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vb2pzLXVpL2Rpc3Qvb29qcy11aS1jb3JlLXdpa2ltZWRpYXVpLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb29qcy11aS9kaXN0L29vanMtdWktd2lkZ2V0cy13aWtpbWVkaWF1aS5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29vanMtdWkvZGlzdC9vb2pzLXVpLXdpa2ltZWRpYXVpLWljb25zLWludGVyYWN0aW9ucy5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29vanMtdWkvZGlzdC9vb2pzLXVpLXdpa2ltZWRpYXVpLWljb25zLW1vdmVtZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb29qcy11aS9kaXN0L29vanMtdWktd2lraW1lZGlhdWktaWNvbnMtd2lraW1lZGlhLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb29qcy11aS9kaXN0L29vanMtdWktd2lraW1lZGlhdWkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29vanMtdWkvZGlzdC9vb2pzLXVpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vb2pzLXVpL2Rpc3QvdGhlbWVzL3dpa2ltZWRpYXVpL2ltYWdlcy9pY29ucy9tYXBQaW4uc3ZnIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vb2pzL2Rpc3Qvb29qcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sIm5hbWVzIjpbIkZsaWNrclRhZ1dpZGdldCIsImZsaWNrclRhZ1dpZGdldCIsImNvbmZpZyIsIiQiLCJleHRlbmQiLCJhbGxvd0FyYml0cmFyeSIsInBhcmVudCIsImNhbGwiLCJjb25uZWN0IiwiY2hhbmdlIiwib25NdWx0aXNlbGVjdENoYW5nZSIsImlucHV0IiwiT08iLCJ1aSIsImRlYm91bmNlIiwib25JbnB1dENoYW5nZURlYm91bmNlZCIsImluaGVyaXRDbGFzcyIsIk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCIsInByb3RvdHlwZSIsInZhbHVlIiwiZ2V0VmFsdWUiLCJnZXRKU09OIiwiYXBwQ29uZmlnIiwiYmFzZVVybCIsInNlYXJjaENhbGxiYWNrIiwiYmluZCIsImRhdGEiLCJtZW51T3B0aW9uIiwic2VhcmNoUmVzdWx0IiwiaSIsIm9wdGlvbnMiLCJyZXF1aXJlIiwibGVuZ3RoIiwiVGFnTWVudU9wdGlvbldpZGdldCIsIiRlbGVtZW50IiwicHVzaCIsIm1lbnUiLCJjbGVhckl0ZW1zIiwiYWRkSXRlbXMiLCJ0b2dnbGUiLCJvbk1lbnVDaG9vc2UiLCJtZW51SXRlbSIsImFwcGx5IiwiYXJndW1lbnRzIiwiaXRlbWlkIiwidW5kZWZpbmVkIiwiYWRkVGFnIiwiZmxpY2tySW5wdXQiLCJpdGVtcyIsImdldEl0ZW1zIiwidGFnc0ZvckZsaWNrciIsInRhZyIsImluY2x1ZGVzIiwidmFsIiwiam9pbiIsInRhZ01lbnVPcHRpb25XaWRnZXQiLCIkZGVzY3JpcHRpb24iLCJ1cmwiLCJsYWJlbCIsIkh0bWxTbmlwcGV0Iiwic3VwZXIiLCJhZGRDbGFzcyIsImFwcGVuZCIsInRleHQiLCJkZXNjcmlwdGlvbiIsImFsaWFzZXMiLCJjb25zb2xlIiwibG9nIiwiaTE4biIsIk1lbnVPcHRpb25XaWRnZXQiLCJnbG9iYWwiLCJsYW5nIiwiYXR0ciIsIm1lc3NhZ2VzVG9Mb2FkVWxzIiwibWVzc2FnZXNUb0xvYWRBcHAiLCJhc3NldHNQYXRoIiwiZW4iLCJsb2NhbGUiLCJsb2FkIiwic2VhcmNoQnV0dG9uIiwiQnV0dG9uV2lkZ2V0IiwiZHVwZXNDb250YWluZXIiLCJwcm9ncmVzc0JhckZpZWxkIiwicHJvZ3Jlc3NCYXIiLCJQcm9ncmVzc0JhcldpZGdldCIsIm9uIiwiRmllbGRMYXlvdXQiLCJnZXROZXh0RHVwbGljYXRlIiwicGFnZU51bSIsImluZm8iLCJwYWdlcyIsInNldFByb2dyZXNzIiwiYWRkTWFya2VyIiwibGF0TG5nIiwibWFwUGluVXJsUGF0aCIsImljb24iLCJtYXAiLCJoYXNMYXllciIsIm1hcmtlciIsInJlbW92ZUxheWVyIiwiTCIsImljb25VcmwiLCJpY29uQW5jaG9yIiwiY2xpY2thYmxlIiwiZHJhZ2dhYmxlIiwiYWRkIiwicmVjb3JkTmV3Q29vcmRzIiwiZHJhZ2VuZCIsImFkZFRvIiwicGFuVG8iLCJnZXRMYXRMbmciLCJlIiwibG9jYXRpb25UZW1wbGF0ZSIsInBhZ2VUZXh0IiwibG9jYXRpb25UcGxQYXR0ZXJuIiwibmV3TGF0IiwiTWF0aCIsInJvdW5kIiwibGF0IiwibmV3TG9uIiwibG5nIiwiZmxpY2tyTGF0V2lkZ2V0Iiwic2V0VmFsdWUiLCJmbGlja3JMb25XSWRnZXQiLCJmbGlja3JBY2N1cmFjeVdpZGdldCIsImdldFpvb20iLCJjb21tb25zUGFnZVRleHRXaWRnZXQiLCJpbmZ1c2UiLCJtYXRjaCIsInJlcGxhY2UiLCJsb24iLCJmbGlja3JBY2N1cmFjeSIsIiRmbGlja3JMYXRJbnB1dCIsInBhcmVudHMiLCJtYXBPcHRpb25zIiwiY2VudGVyIiwiem9vbSIsInRpbGVMYXllciIsImxhdGxuZyIsIiRjb21tb25zVXBsb2FkRWxlbWVudCIsImNvbW1vbnNVcGxvYWRXaWRnZXQiLCJjb21tb25zVGl0bGVXaWRnZXQiLCJjb21tb25zQ2FwdGlvbldpZGdldCIsInNldERpc2FibGVkIiwiaXNTZWxlY3RlZCIsInByb3AiLCIkdGFnV2lkZ2V0RWxlbWVudCIsInRhZ1dpZGdldCIsInNlbGVjdGVkIiwiZm9yRWFjaCIsInJhdyIsIm5hbWUiLCJhZnRlciIsImhpZGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7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QUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN2S0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7Ozs7Ozs7Ozs7O0FDekxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU8sb0RBQW9ELElBQUk7QUFDM0UsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDdlNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxPQUFPLHdEQUF3RDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7Ozs7Ozs7Ozs7O0FDamZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDN0hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IseUJBQXlCO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFEQUFxRDtBQUNyRCx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNyVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7Ozs7Ozs7Ozs7O0FDaEREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7QUM5QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ2pHRCx1Qzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDLEdBQUcsRUFBRSxHQUFHOzs7Ozs7Ozs7Ozs7O0FDbGxMVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUEsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDOVREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGlDQUFpQztBQUNqQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3BXRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsU0FBUztBQUNuQjtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQSxVQUFVLFNBQVM7QUFDbkIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDMWREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNB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Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSx1Qzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELG9EOzs7Ozs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZ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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZSwyQ0FBMkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsa0JBQWtCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1C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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QVMsUUFBUTtBQUNqQixTQUFTLFFBQVE7QUFDakI7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQSxTQUFTLFFBQVE7QUFDakIsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakIsU0FBUyxrQkFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU8scUNBQXFDO0FBQ3ZELFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLE9BQU8saUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLGtDQUFrQywyQkFBMkI7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsNERBQTREO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFNBQVMsT0FBTztBQUNoQjtBQUNBLFNBQVMsT0FBTztBQUNoQixTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7QUFDQSwrREFBK0Qsd0JBQXdCOztBQUV2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakUsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsU0FBUyxRQUFRO0FBQ2pCLFNBQVMsT0FBTztBQUNoQixTQUFTLE9BQU87QUFDaEI7QUFDQSxTQUFTLFNBQVMsb0RBQW9ELG9CQUFvQjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQSxzQkFBc0IscUJBQXFCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLEdBQUc7QUFDMUUsMkNBQTJDLE1BQU0sdUNBQXVDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixTQUFTLGNBQWM7QUFDdkIsU0FBUyxPQUFPO0FBQ2hCLFNBQVMsT0FBTztBQUNoQixTQUFTLFFBQVE7QUFDakIsU0FBUyxRQUFRO0FBQ2pCLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXLHVCQUF1QjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBLGtCQUFrQiw2Q0FBNkM7QUFDL0Q7QUFDQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFNBQVMsY0FBYztBQUN2QixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyx1QkFBdUI7QUFDOUI7QUFDQTtBQUNBLCtEQUErRCxxQ0FBcUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlDQUFpQyxnQkFBZ0I7QUFDdkYsY0FBYyxnQ0FBZ0Msd0JBQXdCLDZCQUE2QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQsSUFBSSxvREFBb0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7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ZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJhc3NldHMvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIi8qKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuRmxpY2tyVGFnV2lkZ2V0ID0gZnVuY3Rpb24gZmxpY2tyVGFnV2lkZ2V0ICggY29uZmlnICkge1xuICAgIGNvbmZpZyA9ICQuZXh0ZW5kKCB7XG4gICAgICAgIGFsbG93QXJiaXRyYXJ5OiB0cnVlXG4gICAgfSwgY29uZmlnICk7XG4gICAgRmxpY2tyVGFnV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuICAgIHRoaXMuY29ubmVjdCggdGhpcywge1xuICAgICAgICBjaGFuZ2U6IHRoaXMub25NdWx0aXNlbGVjdENoYW5nZVxuICAgIH0gKTtcbiAgICB0aGlzLm9uTXVsdGlzZWxlY3RDaGFuZ2UoKTtcblxuICAgIHRoaXMuaW5wdXQuY29ubmVjdCggdGhpcywge1xuICAgICAgICBjaGFuZ2U6IE9PLnVpLmRlYm91bmNlKCB0aGlzLm9uSW5wdXRDaGFuZ2VEZWJvdW5jZWQsIDgwMCApXG4gICAgfSApO1xufTtcblxuT08uaW5oZXJpdENsYXNzKCBGbGlja3JUYWdXaWRnZXQsIE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCApO1xuXG5GbGlja3JUYWdXaWRnZXQucHJvdG90eXBlLm9uSW5wdXRDaGFuZ2VEZWJvdW5jZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC5nZXRWYWx1ZSgpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IFtdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgJC5nZXRKU09OKCBhcHBDb25maWcuYmFzZVVybCArICd0YWdzP3E9JyArIHZhbHVlLCB0aGlzLnNlYXJjaENhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xufTtcblxuRmxpY2tyVGFnV2lkZ2V0LnByb3RvdHlwZS5zZWFyY2hDYWxsYmFjayA9IGZ1bmN0aW9uICggZGF0YSApIHtcbiAgICB2YXIgbWVudU9wdGlvbiwgc2VhcmNoUmVzdWx0LCBpLFxuICAgICAgICBvcHRpb25zID0gW107XG4gICAgcmVxdWlyZSggJy4vVGFnTWVudU9wdGlvbldpZGdldCcgKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWFyY2hSZXN1bHQgPSBkYXRhW2ldO1xuICAgICAgICBtZW51T3B0aW9uID0gbmV3IFRhZ01lbnVPcHRpb25XaWRnZXQgKCBzZWFyY2hSZXN1bHQgKTtcbiAgICAgICAgbWVudU9wdGlvbi4kZWxlbWVudC5kYXRhKCAndGFnLWluZm8nLCBzZWFyY2hSZXN1bHQgKTtcbiAgICAgICAgb3B0aW9ucy5wdXNoKCBtZW51T3B0aW9uICk7XG4gICAgfVxuICAgIHRoaXMubWVudS5jbGVhckl0ZW1zKCk7XG4gICAgdGhpcy5tZW51LmFkZEl0ZW1zKCBvcHRpb25zICk7XG4gICAgdGhpcy5tZW51LnRvZ2dsZSggdHJ1ZSApO1xufTtcblxuRmxpY2tyVGFnV2lkZ2V0LnByb3RvdHlwZS5vbk1lbnVDaG9vc2UgPSBmdW5jdGlvbiAoIG1lbnVJdGVtICkge1xuICAgIEZsaWNrclRhZ1dpZGdldC5wYXJlbnQucHJvdG90eXBlLm9uTWVudUNob29zZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IG1lbnVJdGVtLiRlbGVtZW50LmRhdGEoICd0YWctaW5mbycgKTtcbiAgICBpZiAoIHNlYXJjaFJlc3VsdC5pdGVtaWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdGhpcy5hZGRUYWcoICd3aWtpZGF0YT0nICsgc2VhcmNoUmVzdWx0Lml0ZW1pZCApO1xuICAgIH1cbn07XG5cbkZsaWNrclRhZ1dpZGdldC5wcm90b3R5cGUub25NdWx0aXNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tySW5wdXQgPSAkKCAnOmlucHV0W25hbWU9XCJmbGlja3JbdGFnc11cIl0nICk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuICAgIHZhciB0YWdzRm9yRmxpY2tyID0gW107XG4gICAgZm9yICggaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIHRhZyA9IGl0ZW1zW2ldLmRhdGE7XG4gICAgICAgIGlmICh0YWcuaW5jbHVkZXMoJyAnICkgKSB7XG4gICAgICAgICAgICB0YWcgPSAnIFwiJyt0YWcrJ1wiJztcbiAgICAgICAgfVxuICAgICAgICB0YWdzRm9yRmxpY2tyLnB1c2goIHRhZyApO1xuICAgIH1cbiAgICBmbGlja3JJbnB1dC52YWwoIHRhZ3NGb3JGbGlja3Iuam9pbiggJyAnICkgKTtcbn07XG4iLCIvKipcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQGNmZyB7alF1ZXJ5fHN0cmluZ30gW2Rlc2NyaXB0aW9uPScnXSBTZWFyY2ggcmVzdWx0IGRlc2NyaXB0aW9uXG4gKi9cblRhZ01lbnVPcHRpb25XaWRnZXQgPSBmdW5jdGlvbiB0YWdNZW51T3B0aW9uV2lkZ2V0KCBjb25maWcgKSB7XG4gICAgdmFyICRkZXNjcmlwdGlvbiwgdXJsO1xuICAgIGlmICggY29uZmlnLmxhYmVsID09PSB1bmRlZmluZWQgJiYgY29uZmlnLmRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgY29uZmlnLmxhYmVsID0gY29uZmlnLmRhdGE7XG4gICAgfVxuXG4gICAgaWYgKCBjb25maWcuaXRlbWlkICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHVybCA9ICdodHRwczovL3d3dy53aWtpZGF0YS5vcmcvd2lraS8nK2NvbmZpZy5pdGVtaWQ7XG4gICAgICAgIGNvbmZpZy5sYWJlbCA9IG5ldyBPTy51aS5IdG1sU25pcHBldCgnPGEgaHJlZj1cIicrdXJsKydcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nK2NvbmZpZy5sYWJlbCsnPC9hPicpO1xuICAgIH1cblxuICAgIFRhZ01lbnVPcHRpb25XaWRnZXQuc3VwZXIuY2FsbCggdGhpcywgY29uZmlnICk7XG5cbiAgICAvLyBEZXNjcmlwdGlvbi5cbiAgICAkZGVzY3JpcHRpb24gPSAkKCAnPHNwYW4+JyApXG4gICAgICAgIC5hZGRDbGFzcyggJ2Rlc2NyaXB0aW9uJyApXG4gICAgICAgIC5hcHBlbmQoICQoICc8YmRpPicgKS50ZXh0KCBjb25maWcuZGVzY3JpcHRpb24gfHwgJycgKSApO1xuXG4gICAgaWYgKGNvbmZpZy5hbGlhc2VzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZy5hbGlhc2VzKTtcbiAgICAgICAgJGRlc2NyaXB0aW9uLmFwcGVuZCggJyA8c3BhbiBjbGFzcz1cImFsaWFzZXNcIj4nICsgJC5pMThuKCd3aWtpZGF0YS1hbGlhc2VzJykgKyAnICcgKyBjb25maWcuYWxpYXNlcy5qb2luKCcgJm1pZGRvdDsgJykgKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCggJGRlc2NyaXB0aW9uICk7XG59O1xuXG5PTy5pbmhlcml0Q2xhc3MoIFRhZ01lbnVPcHRpb25XaWRnZXQgLCBPTy51aS5NZW51T3B0aW9uV2lkZ2V0ICk7XG4iLCIvLyBXb3JrYXJvdW5kIGZvciBPT1VJIGFuZCBXZWJwYWNrIG5vdCBsb2FkaW5nIHRoaW5ncyB0byBnbG9iYWwgc2NvcGUuXG5nbG9iYWwuT08gPSBPTztcblxuLy8gTG9hZCBpMThuIG1lc3NhZ2UgZmlsZXMuXG4kKCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhbmcgPSAkKCAnaHRtbCcgKS5hdHRyKCAnbGFuZycgKSxcbiAgICAgICAgbWVzc2FnZXNUb0xvYWRVbHMgPSB7fSxcbiAgICAgICAgbWVzc2FnZXNUb0xvYWRBcHAgPSB7fTtcbiAgICBtZXNzYWdlc1RvTG9hZFVsc1sgbGFuZyBdID0gYXBwQ29uZmlnLmFzc2V0c1BhdGggKyAnL2kxOG4vanF1ZXJ5LnVscy8nICsgbGFuZyArICcuanNvbic7XG4gICAgbWVzc2FnZXNUb0xvYWRBcHBbIGxhbmcgXSA9IGFwcENvbmZpZy5hc3NldHNQYXRoICsgJy9pMThuL2FwcC8nICsgbGFuZyArICcuanNvbic7XG4gICAgaWYgKCBsYW5nICE9PSAnZW4nICkge1xuICAgICAgICAvLyBBbHNvIGxvYWQgRW5nbGlzaCBmaWxlcyBmb3IgZmFsbGJhY2suXG4gICAgICAgIG1lc3NhZ2VzVG9Mb2FkVWxzLmVuID0gYXBwQ29uZmlnLmFzc2V0c1BhdGggKyAnL2kxOG4vanF1ZXJ5LnVscy9lbi5qc29uJztcbiAgICAgICAgbWVzc2FnZXNUb0xvYWRBcHAuZW4gPSBhcHBDb25maWcuYXNzZXRzUGF0aCArICcvaTE4bi9hcHAvZW4uanNvbic7XG4gICAgfVxuICAgICQuaTE4bigpLmxvY2FsZSA9IGxhbmc7XG4gICAgJC5pMThuKCkubG9hZCggbWVzc2FnZXNUb0xvYWRVbHMgKTtcbiAgICAkLmkxOG4oKS5sb2FkKCBtZXNzYWdlc1RvTG9hZEFwcCApO1xufSApO1xuXG5cbiQoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNlYXJjaEJ1dHRvbiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHsgbGFiZWw6ICQuaTE4biggJ2ZsaWNrci1kdXBsaWNhdGVzLXNlYXJjaCcgKSB9ICksXG4gICAgICAgIGR1cGVzQ29udGFpbmVyID0gJChcIiNmbGlja3ItZHVwZXNcIiksXG4gICAgICAgIHByb2dyZXNzQmFyRmllbGQ7XG5cbiAgICBkdXBlc0NvbnRhaW5lci5hcHBlbmQoc2VhcmNoQnV0dG9uLiRlbGVtZW50KTtcblxuICAgIHZhciBwcm9ncmVzc0JhciA9IG5ldyBPTy51aS5Qcm9ncmVzc0JhcldpZGdldCgpO1xuXG5cbiAgICBzZWFyY2hCdXR0b24ub24oICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBwcm9ncmVzc0JhckZpZWxkID0gbmV3IE9PLnVpLkZpZWxkTGF5b3V0KHByb2dyZXNzQmFyLCB7XG4gICAgICAgICAgICAvL2FsaWduOiAndG9wJyxcbiAgICAgICAgICAgIGxhYmVsOiAkLmkxOG4oJ2ZsaWNrci1kdXBlcy1wcm9ncmVzcycpXG4gICAgICAgIH0pO1xuICAgICAgICBkdXBlc0NvbnRhaW5lci5hcHBlbmQocHJvZ3Jlc3NCYXJGaWVsZC4kZWxlbWVudCk7XG5cbiAgICAgICAgZ2V0TmV4dER1cGxpY2F0ZSggMSApO1xuXG4gICAgICAgIC8vICQuZ2V0SlNPTihkdXBlc0NvbnRhaW5lci5kYXRhKCdpbmZvLXVybCcpLCBmdW5jdGlvbiAoIGluZm8gKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhpbmZvKTtcbiAgICAgICAgLy8gICAgIGZvciAoIHZhciBwYWdlID0gMTsgcGFnZSA8IGluZm8ucGFnZXM7IHBhZ2UrKyApIHtcbiAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhwYWdlKTtcbiAgICAgICAgLy8gICAgICAgICBwcm9ncmVzc0Jhci5zZXRQcm9ncmVzcyggKCBwYWdlIC8gaW5mby5wYWdlcyApICogMTAwICk7XG4gICAgICAgIC8vICAgICAgICAgalF1ZXJ5LmFqYXgoe1xuICAgICAgICAvLyAgICAgICAgICAgICB1cmw6IGR1cGVzQ29udGFpbmVyLmRhdGEoJ2luZm8tdXJsJykgKyAnLycgKyBwYWdlLFxuICAgICAgICAvLyAgICAgICAgICAgICB0eXBlOiAnZ2V0JyxcbiAgICAgICAgLy8gICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgLy8gICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAvLyAgICAgICAgICAgICB9LFxuICAgICAgICAvLyAgICAgICAgICAgICAvL2FzeW5jOiBmYWxzZSxcbiAgICAgICAgLy8gICAgICAgICB9ICk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dER1cGxpY2F0ZSggcGFnZU51bSApIHtcbiAgICAgICAgJC5nZXRKU09OKGR1cGVzQ29udGFpbmVyLmRhdGEoJ2luZm8tdXJsJykrJy8nK3BhZ2VOdW0sIGZ1bmN0aW9uICggaW5mbyApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZm8pO1xuICAgICAgICAgICAgaWYgKGluZm8udXJsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmb3VuZCFcIiwgaW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE8gcmVkaXJlY3QgdG8gVVJMLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwYWdlTnVtLCBpbmZvLnBhZ2VzLCAoIHBhZ2VOdW0gLyBpbmZvLnBhZ2VzICkgKiAxMDAgKTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5zZXRQcm9ncmVzcyggKCBwYWdlTnVtIC8gaW5mby5wYWdlcyApICogMTAwICk7XG4gICAgICAgICAgICAgICAgZ2V0TmV4dER1cGxpY2F0ZSggcGFnZU51bSArIDEgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdmFyIHNlYXJjaEJ1dHRvbkVsZW1lbnQgPSAkKFwiI2ZsaWNrci1kdXBlcy1zZWFyY2gtYnV0dG9uXCIpO1xuICAgIC8vIGlmIChzZWFyY2hCdXR0b25FbGVtZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhzZWFyY2hCdXR0b25FbGVtZW50KTtcbiAgICAvLyAgICAgdmFyIHNlYXJjaEJ1dHRvbiA9IE9PLnVpLmluZnVzZShzZWFyY2hCdXR0b25FbGVtZW50KTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coc2VhcmNoQnV0dG9uKTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBpZiAoICQoICcjbWFwJyApLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgdmFyIGZsaWNrckxhdFdpZGdldCwgZmxpY2tyTG9uV0lkZ2V0LCBmbGlja3JBY2N1cmFjeVdpZGdldCxcbiAgICAgICAgICAgIGxhdCA9IDAsXG4gICAgICAgICAgICBsb24gPSAwLFxuICAgICAgICAgICAgZmxpY2tyQWNjdXJhY3kgPSA0LFxuICAgICAgICAgICAgJGZsaWNrckxhdElucHV0ID0gJChcIjppbnB1dFtuYW1lPSdmbGlja3JbbGF0aXR1ZGVdJ11cIik7XG4gICAgICAgIGlmICgkZmxpY2tyTGF0SW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmbGlja3JMYXRXaWRnZXQgPSBPTy51aS5pbmZ1c2UoJGZsaWNrckxhdElucHV0LnBhcmVudHMoJy5vby11aS13aWRnZXQnKSk7XG4gICAgICAgICAgICBsYXQgPSBmbGlja3JMYXRXaWRnZXQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGZsaWNrckxvbldJZGdldCA9IE9PLnVpLmluZnVzZSgkKFwiOmlucHV0W25hbWU9J2ZsaWNrcltsb25naXR1ZGVdJ11cIikucGFyZW50cygnLm9vLXVpLXdpZGdldCcpKTtcbiAgICAgICAgICAgIGxvbiA9IGZsaWNrckxvbldJZGdldC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZmxpY2tyQWNjdXJhY3lXaWRnZXQgPSBPTy51aS5pbmZ1c2UoJChcIjppbnB1dFtuYW1lPSdmbGlja3JbYWNjdXJhY3ldJ11cIikucGFyZW50cygnLm9vLXVpLXdpZGdldCcpKTtcbiAgICAgICAgICAgIGZsaWNrckFjY3VyYWN5ID0gZmxpY2tyQWNjdXJhY3lXaWRnZXQuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwT3B0aW9ucyA9IHtjZW50ZXI6IFtsYXQsIGxvbl0sIHpvb206IGZsaWNrckFjY3VyYWN5fTtcbiAgICAgICAgdmFyIG1hcCA9IEwubWFwKCAnbWFwJywgbWFwT3B0aW9ucyApLFxuICAgICAgICAgICAgbWFya2VyO1xuICAgICAgICBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnKS5hZGRUbyhtYXApO1xuICAgICAgICBpZiAoIGxhdCAmJiBsb24gKSB7XG4gICAgICAgICAgICBhZGRNYXJrZXIoe2xhdDogbGF0LCBsbmc6IGxvbn0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBhZGRNYXJrZXIoZS5sYXRsbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIGEgbWFya2VyIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtlcihsYXRMbmcpIHtcbiAgICAgICAgICAgIHZhciBtYXBQaW5VcmxQYXRoLCBpY29uO1xuICAgICAgICAgICAgaWYgKG1hcC5oYXNMYXllcihtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgbWFwLnJlbW92ZUxheWVyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBQaW5VcmxQYXRoID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL29vanMtdWkvZGlzdC90aGVtZXMvd2lraW1lZGlhdWkvaW1hZ2VzL2ljb25zL21hcFBpbi5zdmcnKTtcbiAgICAgICAgICAgIGljb24gPSBMLmljb24oe2ljb25Vcmw6IGFwcENvbmZpZy5iYXNlVXJsICsgJ2Fzc2V0cy8nICsgbWFwUGluVXJsUGF0aCwgaWNvbkFuY2hvcjogWzEwLCAyMF19KTtcbiAgICAgICAgICAgIG1hcmtlciA9IEwubWFya2VyKGxhdExuZywgeyBjbGlja2FibGU6dHJ1ZSwgZHJhZ2dhYmxlOnRydWUsIGljb246IGljb24gfSk7XG4gICAgICAgICAgICBtYXJrZXIub24oe2FkZDogcmVjb3JkTmV3Q29vcmRzLCBkcmFnZW5kOiByZWNvcmROZXdDb29yZHN9KTtcbiAgICAgICAgICAgIG1hcmtlci5hZGRUbyhtYXApO1xuICAgICAgICAgICAgbWFwLnBhblRvKG1hcmtlci5nZXRMYXRMbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVjb3JkTmV3Q29vcmRzKGUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblRlbXBsYXRlLCBwYWdlVGV4dCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvblRwbFBhdHRlcm4gPSAve3tsb2NhdGlvblxcfFstLjAtOV0rXFx8Wy0uMC05XStbXn1dKn19L2ksXG4gICAgICAgICAgICAgICAgbmV3TGF0ID0gTWF0aC5yb3VuZCggbWFya2VyLmdldExhdExuZygpLmxhdCAqIDEwMDAwMCApIC8gMTAwMDAwLFxuICAgICAgICAgICAgICAgIG5ld0xvbiA9IE1hdGgucm91bmQoIG1hcmtlci5nZXRMYXRMbmcoKS5sbmcgKiAxMDAwMDAgKSAvIDEwMDAwMDtcbiAgICAgICAgICAgIC8vIEZMaWNrci5cbiAgICAgICAgICAgIGlmIChmbGlja3JMYXRXaWRnZXQpIHtcbiAgICAgICAgICAgICAgICBmbGlja3JMYXRXaWRnZXQuc2V0VmFsdWUobmV3TGF0KTtcbiAgICAgICAgICAgICAgICBmbGlja3JMb25XSWRnZXQuc2V0VmFsdWUobmV3TG9uKTtcbiAgICAgICAgICAgICAgICBmbGlja3JBY2N1cmFjeVdpZGdldC5zZXRWYWx1ZShtYXAuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbW1vbnMuXG4gICAgICAgICAgICBjb21tb25zUGFnZVRleHRXaWRnZXQgPSBPTy51aS5pbmZ1c2UoJCgnI2NvbW1vbnMtcGFnZS10ZXh0LXdpZGdldCcpKTtcbiAgICAgICAgICAgIGxvY2F0aW9uVGVtcGxhdGUgPSAne3tsb2NhdGlvbnwnK25ld0xhdCsnfCcrbmV3TG9uKyd9fSc7XG4gICAgICAgICAgICBwYWdlVGV4dCA9IGNvbW1vbnNQYWdlVGV4dFdpZGdldC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKCBwYWdlVGV4dC5tYXRjaCggbG9jYXRpb25UcGxQYXR0ZXJuICkgKSB7XG4gICAgICAgICAgICAgICAgcGFnZVRleHQgPSBwYWdlVGV4dC5yZXBsYWNlKCBsb2NhdGlvblRwbFBhdHRlcm4sIGxvY2F0aW9uVGVtcGxhdGUgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFnZVRleHQgPSBwYWdlVGV4dCArICdcXG5cXG4nICsgbG9jYXRpb25UZW1wbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1vbnNQYWdlVGV4dFdpZGdldC5zZXRWYWx1ZSggcGFnZVRleHQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBDb21tb25zIGZvcm0gZm9yIEZsaWNrciBwaG90b3MgdGhhdCBhcmUgbm90IG9uIENvbW1vbnMgeWV0LlxuICAgICAqL1xuICAgIHZhciAkY29tbW9uc1VwbG9hZEVsZW1lbnQgPSAkKCcjY29tbW9ucy11cGxvYWQtd2lkZ2V0Jyk7XG4gICAgaWYgKCRjb21tb25zVXBsb2FkRWxlbWVudC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGNvbW1vbnNVcGxvYWRXaWRnZXQgPSBPTy51aS5pbmZ1c2UoJGNvbW1vbnNVcGxvYWRFbGVtZW50KSxcbiAgICAgICAgICAgIGNvbW1vbnNUaXRsZVdpZGdldCA9IE9PLnVpLmluZnVzZSgkKCcjY29tbW9ucy10aXRsZS13aWRnZXQnKSksXG4gICAgICAgICAgICBjb21tb25zQ2FwdGlvbldpZGdldCA9IE9PLnVpLmluZnVzZSgkKCcjY29tbW9ucy1jYXB0aW9uLXdpZGdldCcpKSxcbiAgICAgICAgICAgIGNvbW1vbnNQYWdlVGV4dFdpZGdldCA9IE9PLnVpLmluZnVzZSgkKCcjY29tbW9ucy1wYWdlLXRleHQtd2lkZ2V0JykpO1xuICAgICAgICBjb21tb25zVGl0bGVXaWRnZXQuc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgIGNvbW1vbnNDYXB0aW9uV2lkZ2V0LnNldERpc2FibGVkKHRydWUpO1xuICAgICAgICBjb21tb25zUGFnZVRleHRXaWRnZXQuc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgIGNvbW1vbnNVcGxvYWRXaWRnZXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29tbW9uc1RpdGxlV2lkZ2V0LnNldERpc2FibGVkKCFjb21tb25zVXBsb2FkV2lkZ2V0LmlzU2VsZWN0ZWQoKSk7XG4gICAgICAgICAgICBjb21tb25zQ2FwdGlvbldpZGdldC5zZXREaXNhYmxlZCghY29tbW9uc1VwbG9hZFdpZGdldC5pc1NlbGVjdGVkKCkpO1xuICAgICAgICAgICAgY29tbW9uc1BhZ2VUZXh0V2lkZ2V0LnNldERpc2FibGVkKCFjb21tb25zVXBsb2FkV2lkZ2V0LmlzU2VsZWN0ZWQoKSk7XG4gICAgICAgIH0gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBDb21tb25zIGVkaXQgc3VtbWFyeSByZXF1aXJlZCBpZiBhbnkgbW9kaWZpY2F0aW9uIGlzIG1hZGUgdG8gdGhlIHR3byBDb21tb25zIGZpZWxkcy5cbiAgICAgKi9cbiAgICAkKCAnOmlucHV0W25hbWVePWNvbW1vbnNdJyApLm9uKCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCAnOmlucHV0W25hbWU9XCJjb21tb25zW2NvbW1lbnRdXCJdJyApLnByb3AoICdyZXF1aXJlZCcsIHRydWUgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRhZ3MuXG4gICAgICovXG4gICAgdmFyICR0YWdXaWRnZXRFbGVtZW50ID0gJCggJzppbnB1dFtuYW1lPVwiZmxpY2tyW3RhZ3NdXCJdJyApLnBhcmVudHMoICcub28tdWktd2lkZ2V0JyApO1xuICAgIGlmICggJHRhZ1dpZGdldEVsZW1lbnQubGVuZ3RoID09PSAxICkge1xuICAgICAgICB2YXIgdGFnV2lkZ2V0ID0gT08udWkuaW5mdXNlKCAkdGFnV2lkZ2V0RWxlbWVudCApO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgdGFnV2lkZ2V0LmRhdGEuZm9yRWFjaCggZnVuY3Rpb24gKCB0YWcgKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5wdXNoKCB0YWcucmF3ICk7XG4gICAgICAgIH0gKTtcbiAgICAgICAgcmVxdWlyZSgnLi9GbGlja3JUYWdXaWRnZXQnKTtcbiAgICAgICAgdmFyIGZsaWNrclRhZ1dpZGdldCA9IG5ldyBGbGlja3JUYWdXaWRnZXQoIHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nXG4gICAgICAgIH0gKTtcbiAgICAgICAgdGFnV2lkZ2V0LiRlbGVtZW50LmFmdGVyKCBmbGlja3JUYWdXaWRnZXQuJGVsZW1lbnQgKTtcbiAgICAgICAgdGFnV2lkZ2V0LiRlbGVtZW50LmhpZGUoKTtcbiAgICB9XG5cbn0pO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiLyohXG4gKiBqUXVlcnkgSW50ZXJuYXRpb25hbGl6YXRpb24gbGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMS0yMDEzIFNhbnRob3NoIFRob3R0aW5nYWwsIE5laWwgS2FuZGFsZ2FvbmthclxuICpcbiAqIGpxdWVyeS5pMThuIGlzIGR1YWwgbGljZW5zZWQgR1BMdjIgb3IgbGF0ZXIgYW5kIE1JVC4gWW91IGRvbid0IGhhdmUgdG8gZG9cbiAqIGFueXRoaW5nIHNwZWNpYWwgdG8gY2hvb3NlIG9uZSBsaWNlbnNlIG9yIHRoZSBvdGhlciBhbmQgeW91IGRvbid0IGhhdmUgdG9cbiAqIG5vdGlmeSBhbnlvbmUgd2hpY2ggbGljZW5zZSB5b3UgYXJlIHVzaW5nLiBZb3UgYXJlIGZyZWUgdG8gdXNlXG4gKiBVbml2ZXJzYWxMYW5ndWFnZVNlbGVjdG9yIGluIGNvbW1lcmNpYWwgcHJvamVjdHMgYXMgbG9uZyBhcyB0aGUgY29weXJpZ2h0XG4gKiBoZWFkZXIgaXMgbGVmdCBpbnRhY3QuIFNlZSBmaWxlcyBHUEwtTElDRU5TRSBhbmQgTUlULUxJQ0VOU0UgZm9yIGRldGFpbHMuXG4gKlxuICogQGxpY2VuY2UgR05VIEdlbmVyYWwgUHVibGljIExpY2VuY2UgMi4wIG9yIGxhdGVyXG4gKiBAbGljZW5jZSBNSVQgTGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24gKCAkICkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIE1lc3NhZ2VQYXJzZXJFbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMubGFuZ3VhZ2UgPSAkLmkxOG4ubGFuZ3VhZ2VzWyBTdHJpbmcubG9jYWxlIF0gfHwgJC5pMThuLmxhbmd1YWdlc1sgJ2RlZmF1bHQnIF07XG5cdH07XG5cblx0TWVzc2FnZVBhcnNlckVtaXR0ZXIucHJvdG90eXBlID0ge1xuXHRcdGNvbnN0cnVjdG9yOiBNZXNzYWdlUGFyc2VyRW1pdHRlcixcblxuXHRcdC8qKlxuXHRcdCAqIChXZSBwdXQgdGhpcyBtZXRob2QgZGVmaW5pdGlvbiBoZXJlLCBhbmQgbm90IGluIHByb3RvdHlwZSwgdG8gbWFrZVxuXHRcdCAqIHN1cmUgaXQncyBub3Qgb3ZlcndyaXR0ZW4gYnkgYW55IG1hZ2ljLikgV2FsayBlbnRpcmUgbm9kZSBzdHJ1Y3R1cmUsXG5cdFx0ICogYXBwbHlpbmcgcmVwbGFjZW1lbnRzIGFuZCB0ZW1wbGF0ZSBmdW5jdGlvbnMgd2hlbiBhcHByb3ByaWF0ZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtNaXhlZH0gbm9kZSBhYnN0cmFjdCBzeW50YXggdHJlZSAodG9wIG5vZGUgb3Igc3Vibm9kZSlcblx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXBsYWNlbWVudHMgZm9yICQxLCAkMiwgLi4uICRuXG5cdFx0ICogQHJldHVybiB7TWl4ZWR9IHNpbmdsZS1zdHJpbmcgbm9kZSBvciBhcnJheSBvZiBub2RlcyBzdWl0YWJsZSBmb3Jcblx0XHQgKiAgalF1ZXJ5IGFwcGVuZGluZy5cblx0XHQgKi9cblx0XHRlbWl0OiBmdW5jdGlvbiAoIG5vZGUsIHJlcGxhY2VtZW50cyApIHtcblx0XHRcdHZhciByZXQsIHN1Ym5vZGVzLCBvcGVyYXRpb24sXG5cdFx0XHRcdG1lc3NhZ2VQYXJzZXJFbWl0dGVyID0gdGhpcztcblxuXHRcdFx0c3dpdGNoICggdHlwZW9mIG5vZGUgKSB7XG5cdFx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdFx0cmV0ID0gbm9kZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdFx0Ly8gbm9kZSBpcyBhbiBhcnJheSBvZiBub2Rlc1xuXHRcdFx0XHRcdHN1Ym5vZGVzID0gJC5tYXAoIG5vZGUuc2xpY2UoIDEgKSwgZnVuY3Rpb24gKCBuICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1lc3NhZ2VQYXJzZXJFbWl0dGVyLmVtaXQoIG4sIHJlcGxhY2VtZW50cyApO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdG9wZXJhdGlvbiA9IG5vZGVbIDAgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWVzc2FnZVBhcnNlckVtaXR0ZXJbIG9wZXJhdGlvbiBdID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0cmV0ID0gbWVzc2FnZVBhcnNlckVtaXR0ZXJbIG9wZXJhdGlvbiBdKCBzdWJub2RlcywgcmVwbGFjZW1lbnRzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3Vua25vd24gb3BlcmF0aW9uIFwiJyArIG9wZXJhdGlvbiArICdcIicgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAndW5kZWZpbmVkJzpcblx0XHRcdFx0Ly8gUGFyc2luZyB0aGUgZW1wdHkgc3RyaW5nIChhcyBhbiBlbnRpcmUgZXhwcmVzc2lvbiwgb3IgYXMgYVxuXHRcdFx0XHQvLyBwYXJhbUV4cHJlc3Npb24gaW4gYSB0ZW1wbGF0ZSkgcmVzdWx0cyBpbiB1bmRlZmluZWRcblx0XHRcdFx0Ly8gUGVyaGFwcyBhIG1vcmUgY2xldmVyIHBhcnNlciBjYW4gZGV0ZWN0IHRoaXMsIGFuZCByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGVtcHR5IHN0cmluZz8gT3IgaXMgdGhhdCB1c2VmdWwgaW5mb3JtYXRpb24/XG5cdFx0XHRcdC8vIFRoZSBsb2dpY2FsIHRoaW5nIGlzIHByb2JhYmx5IHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGhlcmVcblx0XHRcdFx0Ly8gd2hlbiB3ZSBlbmNvdW50ZXIgdW5kZWZpbmVkLlxuXHRcdFx0XHRcdHJldCA9ICcnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3VuZXhwZWN0ZWQgdHlwZSBpbiBBU1Q6ICcgKyB0eXBlb2Ygbm9kZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQYXJzaW5nIGhhcyBiZWVuIGFwcGxpZWQgZGVwdGgtZmlyc3Qgd2UgY2FuIGFzc3VtZSB0aGF0IGFsbCBub2Rlc1xuXHRcdCAqIGhlcmUgYXJlIHNpbmdsZSBub2RlcyBNdXN0IHJldHVybiBhIHNpbmdsZSBub2RlIHRvIHBhcmVudHMgLS0gYVxuXHRcdCAqIGpRdWVyeSB3aXRoIHN5bnRoZXRpYyBzcGFuIEhvd2V2ZXIsIHVud3JhcCBhbnkgb3RoZXIgc3ludGhldGljIHNwYW5zXG5cdFx0ICogaW4gb3VyIGNoaWxkcmVuIGFuZCBwYXNzIHRoZW0gdXB3YXJkc1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgTWl4ZWQsIHNvbWUgc2luZ2xlIG5vZGVzLCBzb21lIGFycmF5cyBvZiBub2Rlcy5cblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0Y29uY2F0OiBmdW5jdGlvbiAoIG5vZGVzICkge1xuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXG5cdFx0XHQkLmVhY2goIG5vZGVzLCBmdW5jdGlvbiAoIGksIG5vZGUgKSB7XG5cdFx0XHRcdC8vIHN0cmluZ3MsIGludGVnZXJzLCBhbnl0aGluZyBlbHNlXG5cdFx0XHRcdHJlc3VsdCArPSBub2RlO1xuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gZXNjYXBlZCByZXBsYWNlbWVudCBvZiBjb3JyZWN0IGluZGV4LCBvciBzdHJpbmcgaWZcblx0XHQgKiB1bmF2YWlsYWJsZS4gTm90ZSB0aGF0IHdlIGV4cGVjdCB0aGUgcGFyc2VkIHBhcmFtZXRlciB0byBiZVxuXHRcdCAqIHplcm8tYmFzZWQuIGkuZS4gJDEgc2hvdWxkIGhhdmUgYmVjb21lIFsgMCBdLiBpZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogcGFyYW1ldGVyIGlzIG5vdCBmb3VuZCByZXR1cm4gdGhlIHNhbWUgc3RyaW5nIChlLmcuIFwiJDk5XCIgLT5cblx0XHQgKiBwYXJhbWV0ZXIgOTggLT4gbm90IGZvdW5kIC0+IHJldHVybiBcIiQ5OVwiICkgVE9ETyB0aHJvdyBlcnJvciBpZlxuXHRcdCAqIG5vZGVzLmxlbmd0aCA+IDEgP1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgT25lIGVsZW1lbnQsIGludGVnZXIsIG4gPj0gMFxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHJlcGxhY2VtZW50cyBmb3IgJDEsICQyLCAuLi4gJG5cblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHJlcGxhY2VtZW50XG5cdFx0ICovXG5cdFx0cmVwbGFjZTogZnVuY3Rpb24gKCBub2RlcywgcmVwbGFjZW1lbnRzICkge1xuXHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIG5vZGVzWyAwIF0sIDEwICk7XG5cblx0XHRcdGlmICggaW5kZXggPCByZXBsYWNlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHQvLyByZXBsYWNlbWVudCBpcyBub3QgYSBzdHJpbmcsIGRvbid0IHRvdWNoIVxuXHRcdFx0XHRyZXR1cm4gcmVwbGFjZW1lbnRzWyBpbmRleCBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaW5kZXggbm90IGZvdW5kLCBmYWxsYmFjayB0byBkaXNwbGF5aW5nIHZhcmlhYmxlXG5cdFx0XHRcdHJldHVybiAnJCcgKyAoIGluZGV4ICsgMSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2Zvcm0gcGFyc2VkIHN0cnVjdHVyZSBpbnRvIHBsdXJhbGl6YXRpb24gbi5iLiBUaGUgZmlyc3Qgbm9kZSBtYXlcblx0XHQgKiBiZSBhIG5vbi1pbnRlZ2VyIChmb3IgaW5zdGFuY2UsIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBBcmFiaWNcblx0XHQgKiBudW1iZXIpLiBTbyBjb252ZXJ0IGl0IGJhY2sgd2l0aCB0aGUgY3VycmVudCBsYW5ndWFnZSdzXG5cdFx0ICogY29udmVydE51bWJlci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIExpc3QgWyB7U3RyaW5nfE51bWJlcn0sIHtTdHJpbmd9LCB7U3RyaW5nfSAuLi4gXVxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gc2VsZWN0ZWQgcGx1cmFsaXplZCBmb3JtIGFjY29yZGluZyB0byBjdXJyZW50XG5cdFx0ICogIGxhbmd1YWdlLlxuXHRcdCAqL1xuXHRcdHBsdXJhbDogZnVuY3Rpb24gKCBub2RlcyApIHtcblx0XHRcdHZhciBjb3VudCA9IHBhcnNlRmxvYXQoIHRoaXMubGFuZ3VhZ2UuY29udmVydE51bWJlciggbm9kZXNbIDAgXSwgMTAgKSApLFxuXHRcdFx0XHRmb3JtcyA9IG5vZGVzLnNsaWNlKCAxICk7XG5cblx0XHRcdHJldHVybiBmb3Jtcy5sZW5ndGggPyB0aGlzLmxhbmd1YWdlLmNvbnZlcnRQbHVyYWwoIGNvdW50LCBmb3JtcyApIDogJyc7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybSBwYXJzZWQgc3RydWN0dXJlIGludG8gZ2VuZGVyIFVzYWdlXG5cdFx0ICoge3tnZW5kZXI6Z2VuZGVyfG1hc2N1bGluZXxmZW1pbmluZXxuZXV0cmFsfX0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlcyBMaXN0IFsge1N0cmluZ30sIHtTdHJpbmd9LCB7U3RyaW5nfSAsIHtTdHJpbmd9IF1cblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHNlbGVjdGVkIGdlbmRlciBmb3JtIGFjY29yZGluZyB0byBjdXJyZW50IGxhbmd1YWdlXG5cdFx0ICovXG5cdFx0Z2VuZGVyOiBmdW5jdGlvbiAoIG5vZGVzICkge1xuXHRcdFx0dmFyIGdlbmRlciA9IG5vZGVzWyAwIF0sXG5cdFx0XHRcdGZvcm1zID0gbm9kZXMuc2xpY2UoIDEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMubGFuZ3VhZ2UuZ2VuZGVyKCBnZW5kZXIsIGZvcm1zICk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybSBwYXJzZWQgc3RydWN0dXJlIGludG8gZ3JhbW1hciBjb252ZXJzaW9uLiBJbnZva2VkIGJ5XG5cdFx0ICogcHV0dGluZyB7e2dyYW1tYXI6Zm9ybXx3b3JkfX0gaW4gYSBtZXNzYWdlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlcyBMaXN0IFt7R3JhbW1hciBjYXNlIGVnOiBnZW5pdGl2ZX0sIHtTdHJpbmcgd29yZH1dXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBzZWxlY3RlZCBncmFtbWF0aWNhbCBmb3JtIGFjY29yZGluZyB0byBjdXJyZW50XG5cdFx0ICogIGxhbmd1YWdlLlxuXHRcdCAqL1xuXHRcdGdyYW1tYXI6IGZ1bmN0aW9uICggbm9kZXMgKSB7XG5cdFx0XHR2YXIgZm9ybSA9IG5vZGVzWyAwIF0sXG5cdFx0XHRcdHdvcmQgPSBub2Rlc1sgMSBdO1xuXG5cdFx0XHRyZXR1cm4gd29yZCAmJiBmb3JtICYmIHRoaXMubGFuZ3VhZ2UuY29udmVydEdyYW1tYXIoIHdvcmQsIGZvcm0gKTtcblx0XHR9XG5cdH07XG5cblx0JC5leHRlbmQoICQuaTE4bi5wYXJzZXIuZW1pdHRlciwgbmV3IE1lc3NhZ2VQYXJzZXJFbWl0dGVyKCkgKTtcbn0oIGpRdWVyeSApICk7XG4iLCIvKiFcbiAqIGpRdWVyeSBJbnRlcm5hdGlvbmFsaXphdGlvbiBsaWJyYXJ5XG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEyIFNhbnRob3NoIFRob3R0aW5nYWxcbiAqXG4gKiBqcXVlcnkuaTE4biBpcyBkdWFsIGxpY2Vuc2VkIEdQTHYyIG9yIGxhdGVyIGFuZCBNSVQuIFlvdSBkb24ndCBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgdG9cbiAqIGNob29zZSBvbmUgbGljZW5zZSBvciB0aGUgb3RoZXIgYW5kIHlvdSBkb24ndCBoYXZlIHRvIG5vdGlmeSBhbnlvbmUgd2hpY2ggbGljZW5zZSB5b3UgYXJlIHVzaW5nLlxuICogWW91IGFyZSBmcmVlIHRvIHVzZSBVbml2ZXJzYWxMYW5ndWFnZVNlbGVjdG9yIGluIGNvbW1lcmNpYWwgcHJvamVjdHMgYXMgbG9uZyBhcyB0aGUgY29weXJpZ2h0XG4gKiBoZWFkZXIgaXMgbGVmdCBpbnRhY3QuIFNlZSBmaWxlcyBHUEwtTElDRU5TRSBhbmQgTUlULUxJQ0VOU0UgZm9yIGRldGFpbHMuXG4gKlxuICogQGxpY2VuY2UgR05VIEdlbmVyYWwgUHVibGljIExpY2VuY2UgMi4wIG9yIGxhdGVyXG4gKiBAbGljZW5jZSBNSVQgTGljZW5zZVxuICovXG4oIGZ1bmN0aW9uICggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdCQuaTE4biA9ICQuaTE4biB8fCB7fTtcblx0JC5leHRlbmQoICQuaTE4bi5mYWxsYmFja3MsIHtcblx0XHRhYjogWyAncnUnIF0sXG5cdFx0YWNlOiBbICdpZCcgXSxcblx0XHRhbG46IFsgJ3NxJyBdLFxuXHRcdC8vIE5vdCBzbyBzdGFuZGFyZCAtIGFscyBpcyBzdXBwb3NlZCB0byBiZSBUb3NrIEFsYmFuaWFuLFxuXHRcdC8vIGJ1dCBpbiBXaWtpcGVkaWEgaXQncyB1c2VkIGZvciBhIEdlcm1hbmljIGxhbmd1YWdlLlxuXHRcdGFsczogWyAnZ3N3JywgJ2RlJyBdLFxuXHRcdGFuOiBbICdlcycgXSxcblx0XHRhbnA6IFsgJ2hpJyBdLFxuXHRcdGFybjogWyAnZXMnIF0sXG5cdFx0YXJ6OiBbICdhcicgXSxcblx0XHRhdjogWyAncnUnIF0sXG5cdFx0YXk6IFsgJ2VzJyBdLFxuXHRcdGJhOiBbICdydScgXSxcblx0XHRiYXI6IFsgJ2RlJyBdLFxuXHRcdCdiYXQtc21nJzogWyAnc2dzJywgJ2x0JyBdLFxuXHRcdGJjYzogWyAnZmEnIF0sXG5cdFx0J2JlLXgtb2xkJzogWyAnYmUtdGFyYXNrJyBdLFxuXHRcdGJoOiBbICdiaG8nIF0sXG5cdFx0YmpuOiBbICdpZCcgXSxcblx0XHRibTogWyAnZnInIF0sXG5cdFx0YnB5OiBbICdibicgXSxcblx0XHRicWk6IFsgJ2ZhJyBdLFxuXHRcdGJ1ZzogWyAnaWQnIF0sXG5cdFx0J2Niay16YW0nOiBbICdlcycgXSxcblx0XHRjZTogWyAncnUnIF0sXG5cdFx0Y3JoOiBbICdjcmgtbGF0bicgXSxcblx0XHQnY3JoLWN5cmwnOiBbICdydScgXSxcblx0XHRjc2I6IFsgJ3BsJyBdLFxuXHRcdGN2OiBbICdydScgXSxcblx0XHQnZGUtYXQnOiBbICdkZScgXSxcblx0XHQnZGUtY2gnOiBbICdkZScgXSxcblx0XHQnZGUtZm9ybWFsJzogWyAnZGUnIF0sXG5cdFx0ZHNiOiBbICdkZScgXSxcblx0XHRkdHA6IFsgJ21zJyBdLFxuXHRcdGVnbDogWyAnaXQnIF0sXG5cdFx0ZW1sOiBbICdpdCcgXSxcblx0XHRmZjogWyAnZnInIF0sXG5cdFx0Zml0OiBbICdmaScgXSxcblx0XHQnZml1LXZybyc6IFsgJ3ZybycsICdldCcgXSxcblx0XHRmcmM6IFsgJ2ZyJyBdLFxuXHRcdGZycDogWyAnZnInIF0sXG5cdFx0ZnJyOiBbICdkZScgXSxcblx0XHRmdXI6IFsgJ2l0JyBdLFxuXHRcdGdhZzogWyAndHInIF0sXG5cdFx0Z2FuOiBbICdnYW4taGFudCcsICd6aC1oYW50JywgJ3poLWhhbnMnIF0sXG5cdFx0J2dhbi1oYW5zJzogWyAnemgtaGFucycgXSxcblx0XHQnZ2FuLWhhbnQnOiBbICd6aC1oYW50JywgJ3poLWhhbnMnIF0sXG5cdFx0Z2w6IFsgJ3B0JyBdLFxuXHRcdGdsazogWyAnZmEnIF0sXG5cdFx0Z246IFsgJ2VzJyBdLFxuXHRcdGdzdzogWyAnZGUnIF0sXG5cdFx0aGlmOiBbICdoaWYtbGF0bicgXSxcblx0XHRoc2I6IFsgJ2RlJyBdLFxuXHRcdGh0OiBbICdmcicgXSxcblx0XHRpaTogWyAnemgtY24nLCAnemgtaGFucycgXSxcblx0XHRpbmg6IFsgJ3J1JyBdLFxuXHRcdGl1OiBbICdpa2UtY2FucycgXSxcblx0XHRqdXQ6IFsgJ2RhJyBdLFxuXHRcdGp2OiBbICdpZCcgXSxcblx0XHRrYWE6IFsgJ2trLWxhdG4nLCAna2stY3lybCcgXSxcblx0XHRrYmQ6IFsgJ2tiZC1jeXJsJyBdLFxuXHRcdGtodzogWyAndXInIF0sXG5cdFx0a2l1OiBbICd0cicgXSxcblx0XHRrazogWyAna2stY3lybCcgXSxcblx0XHQna2stYXJhYic6IFsgJ2trLWN5cmwnIF0sXG5cdFx0J2trLWxhdG4nOiBbICdray1jeXJsJyBdLFxuXHRcdCdray1jbic6IFsgJ2trLWFyYWInLCAna2stY3lybCcgXSxcblx0XHQna2sta3onOiBbICdray1jeXJsJyBdLFxuXHRcdCdray10cic6IFsgJ2trLWxhdG4nLCAna2stY3lybCcgXSxcblx0XHRrbDogWyAnZGEnIF0sXG5cdFx0J2tvLWtwJzogWyAna28nIF0sXG5cdFx0a29pOiBbICdydScgXSxcblx0XHRrcmM6IFsgJ3J1JyBdLFxuXHRcdGtzOiBbICdrcy1hcmFiJyBdLFxuXHRcdGtzaDogWyAnZGUnIF0sXG5cdFx0a3U6IFsgJ2t1LWxhdG4nIF0sXG5cdFx0J2t1LWFyYWInOiBbICdja2InIF0sXG5cdFx0a3Y6IFsgJ3J1JyBdLFxuXHRcdGxhZDogWyAnZXMnIF0sXG5cdFx0bGI6IFsgJ2RlJyBdLFxuXHRcdGxiZTogWyAncnUnIF0sXG5cdFx0bGV6OiBbICdydScgXSxcblx0XHRsaTogWyAnbmwnIF0sXG5cdFx0bGlqOiBbICdpdCcgXSxcblx0XHRsaXY6IFsgJ2V0JyBdLFxuXHRcdGxtbzogWyAnaXQnIF0sXG5cdFx0bG46IFsgJ2ZyJyBdLFxuXHRcdGx0ZzogWyAnbHYnIF0sXG5cdFx0bHp6OiBbICd0cicgXSxcblx0XHRtYWk6IFsgJ2hpJyBdLFxuXHRcdCdtYXAtYm1zJzogWyAnanYnLCAnaWQnIF0sXG5cdFx0bWc6IFsgJ2ZyJyBdLFxuXHRcdG1ocjogWyAncnUnIF0sXG5cdFx0bWluOiBbICdpZCcgXSxcblx0XHRtbzogWyAncm8nIF0sXG5cdFx0bXJqOiBbICdydScgXSxcblx0XHRtd2w6IFsgJ3B0JyBdLFxuXHRcdG15djogWyAncnUnIF0sXG5cdFx0bXpuOiBbICdmYScgXSxcblx0XHRuYWg6IFsgJ2VzJyBdLFxuXHRcdG5hcDogWyAnaXQnIF0sXG5cdFx0bmRzOiBbICdkZScgXSxcblx0XHQnbmRzLW5sJzogWyAnbmwnIF0sXG5cdFx0J25sLWluZm9ybWFsJzogWyAnbmwnIF0sXG5cdFx0bm86IFsgJ25iJyBdLFxuXHRcdG9zOiBbICdydScgXSxcblx0XHRwY2Q6IFsgJ2ZyJyBdLFxuXHRcdHBkYzogWyAnZGUnIF0sXG5cdFx0cGR0OiBbICdkZScgXSxcblx0XHRwZmw6IFsgJ2RlJyBdLFxuXHRcdHBtczogWyAnaXQnIF0sXG5cdFx0cHQ6IFsgJ3B0LWJyJyBdLFxuXHRcdCdwdC1icic6IFsgJ3B0JyBdLFxuXHRcdHF1OiBbICdlcycgXSxcblx0XHRxdWc6IFsgJ3F1JywgJ2VzJyBdLFxuXHRcdHJnbjogWyAnaXQnIF0sXG5cdFx0cm15OiBbICdybycgXSxcblx0XHQncm9hLXJ1cCc6IFsgJ3J1cCcgXSxcblx0XHRydWU6IFsgJ3VrJywgJ3J1JyBdLFxuXHRcdHJ1cTogWyAncnVxLWxhdG4nLCAncm8nIF0sXG5cdFx0J3J1cS1jeXJsJzogWyAnbWsnIF0sXG5cdFx0J3J1cS1sYXRuJzogWyAncm8nIF0sXG5cdFx0c2E6IFsgJ2hpJyBdLFxuXHRcdHNhaDogWyAncnUnIF0sXG5cdFx0c2NuOiBbICdpdCcgXSxcblx0XHRzZzogWyAnZnInIF0sXG5cdFx0c2dzOiBbICdsdCcgXSxcblx0XHRzbGk6IFsgJ2RlJyBdLFxuXHRcdHNyOiBbICdzci1lYycgXSxcblx0XHRzcm46IFsgJ25sJyBdLFxuXHRcdHN0cTogWyAnZGUnIF0sXG5cdFx0c3U6IFsgJ2lkJyBdLFxuXHRcdHN6bDogWyAncGwnIF0sXG5cdFx0dGN5OiBbICdrbicgXSxcblx0XHR0ZzogWyAndGctY3lybCcgXSxcblx0XHR0dDogWyAndHQtY3lybCcsICdydScgXSxcblx0XHQndHQtY3lybCc6IFsgJ3J1JyBdLFxuXHRcdHR5OiBbICdmcicgXSxcblx0XHR1ZG06IFsgJ3J1JyBdLFxuXHRcdHVnOiBbICd1Zy1hcmFiJyBdLFxuXHRcdHVrOiBbICdydScgXSxcblx0XHR2ZWM6IFsgJ2l0JyBdLFxuXHRcdHZlcDogWyAnZXQnIF0sXG5cdFx0dmxzOiBbICdubCcgXSxcblx0XHR2bWY6IFsgJ2RlJyBdLFxuXHRcdHZvdDogWyAnZmknIF0sXG5cdFx0dnJvOiBbICdldCcgXSxcblx0XHR3YTogWyAnZnInIF0sXG5cdFx0d286IFsgJ2ZyJyBdLFxuXHRcdHd1dTogWyAnemgtaGFucycgXSxcblx0XHR4YWw6IFsgJ3J1JyBdLFxuXHRcdHhtZjogWyAna2EnIF0sXG5cdFx0eWk6IFsgJ2hlJyBdLFxuXHRcdHphOiBbICd6aC1oYW5zJyBdLFxuXHRcdHplYTogWyAnbmwnIF0sXG5cdFx0emg6IFsgJ3poLWhhbnMnIF0sXG5cdFx0J3poLWNsYXNzaWNhbCc6IFsgJ2x6aCcgXSxcblx0XHQnemgtY24nOiBbICd6aC1oYW5zJyBdLFxuXHRcdCd6aC1oYW50JzogWyAnemgtaGFucycgXSxcblx0XHQnemgtaGsnOiBbICd6aC1oYW50JywgJ3poLWhhbnMnIF0sXG5cdFx0J3poLW1pbi1uYW4nOiBbICduYW4nIF0sXG5cdFx0J3poLW1vJzogWyAnemgtaGsnLCAnemgtaGFudCcsICd6aC1oYW5zJyBdLFxuXHRcdCd6aC1teSc6IFsgJ3poLXNnJywgJ3poLWhhbnMnIF0sXG5cdFx0J3poLXNnJzogWyAnemgtaGFucycgXSxcblx0XHQnemgtdHcnOiBbICd6aC1oYW50JywgJ3poLWhhbnMnIF0sXG5cdFx0J3poLXl1ZSc6IFsgJ3l1ZScgXVxuXHR9ICk7XG59KCBqUXVlcnkgKSApO1xuIiwiLyohXG4gKiBqUXVlcnkgSW50ZXJuYXRpb25hbGl6YXRpb24gbGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMiBTYW50aG9zaCBUaG90dGluZ2FsXG4gKlxuICoganF1ZXJ5LmkxOG4gaXMgZHVhbCBsaWNlbnNlZCBHUEx2MiBvciBsYXRlciBhbmQgTUlULiBZb3UgZG9uJ3QgaGF2ZSB0byBkb1xuICogYW55dGhpbmcgc3BlY2lhbCB0byBjaG9vc2Ugb25lIGxpY2Vuc2Ugb3IgdGhlIG90aGVyIGFuZCB5b3UgZG9uJ3QgaGF2ZSB0b1xuICogbm90aWZ5IGFueW9uZSB3aGljaCBsaWNlbnNlIHlvdSBhcmUgdXNpbmcuIFlvdSBhcmUgZnJlZSB0byB1c2VcbiAqIFVuaXZlcnNhbExhbmd1YWdlU2VsZWN0b3IgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyBhcyBsb25nIGFzIHRoZSBjb3B5cmlnaHRcbiAqIGhlYWRlciBpcyBsZWZ0IGludGFjdC4gU2VlIGZpbGVzIEdQTC1MSUNFTlNFIGFuZCBNSVQtTElDRU5TRSBmb3IgZGV0YWlscy5cbiAqXG4gKiBAbGljZW5jZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5jZSAyLjAgb3IgbGF0ZXJcbiAqIEBsaWNlbmNlIE1JVCBMaWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbiAoICQgKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgSTE4Tixcblx0XHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0STE4TiA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblx0XHQvLyBMb2FkIGRlZmF1bHRzXG5cdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoIHt9LCBJMThOLmRlZmF1bHRzLCBvcHRpb25zICk7XG5cblx0XHR0aGlzLnBhcnNlciA9IHRoaXMub3B0aW9ucy5wYXJzZXI7XG5cdFx0dGhpcy5sb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlO1xuXHRcdHRoaXMubWVzc2FnZVN0b3JlID0gdGhpcy5vcHRpb25zLm1lc3NhZ2VTdG9yZTtcblx0XHR0aGlzLmxhbmd1YWdlcyA9IHt9O1xuXHR9O1xuXG5cdEkxOE4ucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIExvY2FsaXplIGEgZ2l2ZW4gbWVzc2FnZUtleSB0byBhIGxvY2FsZS5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZUtleVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gTG9jYWxpemVkIG1lc3NhZ2Vcblx0XHQgKi9cblx0XHRsb2NhbGl6ZTogZnVuY3Rpb24gKCBtZXNzYWdlS2V5ICkge1xuXHRcdFx0dmFyIGxvY2FsZVBhcnRzLCBsb2NhbGVQYXJ0SW5kZXgsIGxvY2FsZSwgZmFsbGJhY2tJbmRleCxcblx0XHRcdFx0dHJ5aW5nTG9jYWxlLCBtZXNzYWdlO1xuXG5cdFx0XHRsb2NhbGUgPSB0aGlzLmxvY2FsZTtcblx0XHRcdGZhbGxiYWNrSW5kZXggPSAwO1xuXG5cdFx0XHR3aGlsZSAoIGxvY2FsZSApIHtcblx0XHRcdFx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGxvY2FsZXMgc3RhcnRpbmcgYXQgbW9zdC1zcGVjaWZpYyB1bnRpbFxuXHRcdFx0XHQvLyBsb2NhbGl6YXRpb24gaXMgZm91bmQuIEFzIGluIGZpLUxhdG4tRkksIGZpLUxhdG4gYW5kIGZpLlxuXHRcdFx0XHRsb2NhbGVQYXJ0cyA9IGxvY2FsZS5zcGxpdCggJy0nICk7XG5cdFx0XHRcdGxvY2FsZVBhcnRJbmRleCA9IGxvY2FsZVBhcnRzLmxlbmd0aDtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0dHJ5aW5nTG9jYWxlID0gbG9jYWxlUGFydHMuc2xpY2UoIDAsIGxvY2FsZVBhcnRJbmRleCApLmpvaW4oICctJyApO1xuXHRcdFx0XHRcdG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VTdG9yZS5nZXQoIHRyeWluZ0xvY2FsZSwgbWVzc2FnZUtleSApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZXNzYWdlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bG9jYWxlUGFydEluZGV4LS07XG5cdFx0XHRcdH0gd2hpbGUgKCBsb2NhbGVQYXJ0SW5kZXggKTtcblxuXHRcdFx0XHRpZiAoIGxvY2FsZSA9PT0gJ2VuJyApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvY2FsZSA9ICggJC5pMThuLmZhbGxiYWNrc1sgdGhpcy5sb2NhbGUgXSAmJlxuXHRcdFx0XHRcdFx0JC5pMThuLmZhbGxiYWNrc1sgdGhpcy5sb2NhbGUgXVsgZmFsbGJhY2tJbmRleCBdICkgfHxcblx0XHRcdFx0XHRcdHRoaXMub3B0aW9ucy5mYWxsYmFja0xvY2FsZTtcblx0XHRcdFx0JC5pMThuLmxvZyggJ1RyeWluZyBmYWxsYmFjayBsb2NhbGUgZm9yICcgKyB0aGlzLmxvY2FsZSArICc6ICcgKyBsb2NhbGUgKyAnICgnICsgbWVzc2FnZUtleSArICcpJyApO1xuXG5cdFx0XHRcdGZhbGxiYWNrSW5kZXgrKztcblx0XHRcdH1cblxuXHRcdFx0Ly8ga2V5IG5vdCBmb3VuZFxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCAqIERlc3Ryb3kgdGhlIGkxOG4gaW5zdGFuY2UuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0JC5yZW1vdmVEYXRhKCBkb2N1bWVudCwgJ2kxOG4nICk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYWwgbWVzc2FnZSBsb2FkaW5nIEFQSSBUaGlzIGNhbiB0YWtlIGEgVVJMIHN0cmluZyBmb3Jcblx0XHQgKiB0aGUganNvbiBmb3JtYXR0ZWQgbWVzc2FnZXMuIEV4YW1wbGU6XG5cdFx0ICogPGNvZGU+bG9hZCgncGF0aC90by9hbGxfbG9jYWxpemF0aW9ucy5qc29uJyk7PC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogVG8gbG9hZCBhIGxvY2FsaXphdGlvbiBmaWxlIGZvciBhIGxvY2FsZTpcblx0XHQgKiA8Y29kZT5cblx0XHQgKiBsb2FkKCdwYXRoL3RvL2RlLW1lc3NhZ2VzLmpzb24nLCAnZGUnICk7XG5cdFx0ICogPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogVG8gbG9hZCBhIGxvY2FsaXphdGlvbiBmaWxlIGZyb20gYSBkaXJlY3Rvcnk6XG5cdFx0ICogPGNvZGU+XG5cdFx0ICogbG9hZCgncGF0aC90by9pMThuL2RpcmVjdG9yeScsICdkZScgKTtcblx0XHQgKiA8L2NvZGU+XG5cdFx0ICogVGhlIGFib3ZlIG1ldGhvZCBoYXMgdGhlIGFkdmFudGFnZSBvZiBmYWxsYmFjayByZXNvbHV0aW9uLlxuXHRcdCAqIGllLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgbG9hZCB0aGUgZmFsbGJhY2sgbG9jYWxlcyBmb3IgZGUuXG5cdFx0ICogRm9yIG1vc3QgdXNlY2FzZXMsIHRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZC5cblx0XHQgKiBJdCBpcyBvcHRpb25hbCB0byBoYXZlIHRyYWlsaW5nIHNsYXNoIGF0IGVuZC5cblx0XHQgKlxuXHRcdCAqIEEgZGF0YSBvYmplY3QgY29udGFpbmluZyBtZXNzYWdlIGtleS0gbWVzc2FnZSB0cmFuc2xhdGlvbiBtYXBwaW5nc1xuXHRcdCAqIGNhbiBhbHNvIGJlIHBhc3NlZC4gRXhhbXBsZTpcblx0XHQgKiA8Y29kZT5cblx0XHQgKiBsb2FkKCB7ICdoZWxsbycgOiAnSGVsbG8nIH0sIG9wdGlvbmFsTG9jYWxlICk7XG5cdFx0ICogPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogQSBzb3VyY2UgbWFwIGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXIgb2YgbGFuZ3VhZ2VuYW1lIGFuZCBsb2NhdGlvbnNcblx0XHQgKiBjYW4gYWxzbyBiZSBwYXNzZWQuIEV4YW1wbGU6XG5cdFx0ICogPGNvZGU+XG5cdFx0ICogbG9hZCgge1xuXHRcdCAqIGJuOiAnaTE4bi9ibi5qc29uJyxcblx0XHQgKiBoZTogJ2kxOG4vaGUuanNvbicsXG5cdFx0ICogZW46ICdpMThuL2VuLmpzb24nXG5cdFx0ICogfSApXG5cdFx0ICogPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogSWYgdGhlIGRhdGEgYXJndW1lbnQgaXMgbnVsbC91bmRlZmluZWQvZmFsc2UsXG5cdFx0ICogYWxsIGNhY2hlZCBtZXNzYWdlcyBmb3IgdGhlIGkxOG4gaW5zdGFuY2Ugd2lsbCBnZXQgcmVzZXQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHNvdXJjZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgTGFuZ3VhZ2UgdGFnXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9XG5cdFx0ICovXG5cdFx0bG9hZDogZnVuY3Rpb24gKCBzb3VyY2UsIGxvY2FsZSApIHtcblx0XHRcdHZhciBmYWxsYmFja0xvY2FsZXMsIGxvY0luZGV4LCBmYWxsYmFja0xvY2FsZSwgc291cmNlTWFwID0ge307XG5cdFx0XHRpZiAoICFzb3VyY2UgJiYgIWxvY2FsZSApIHtcblx0XHRcdFx0c291cmNlID0gJ2kxOG4vJyArICQuaTE4bigpLmxvY2FsZSArICcuanNvbic7XG5cdFx0XHRcdGxvY2FsZSA9ICQuaTE4bigpLmxvY2FsZTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiZcblx0XHRcdFx0Ly8gc291cmNlIGV4dGVuc2lvbiBzaG91bGQgYmUganNvbiwgYnV0IGNhbiBoYXZlIHF1ZXJ5IHBhcmFtcyBhZnRlciB0aGF0LlxuXHRcdFx0XHRzb3VyY2Uuc3BsaXQoICc/JyApWyAwIF0uc3BsaXQoICcuJyApLnBvcCgpICE9PSAnanNvbidcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBMb2FkIHNwZWNpZmllZCBsb2NhbGUgdGhlbiBjaGVjayBmb3IgZmFsbGJhY2tzIHdoZW4gZGlyZWN0b3J5IGlzXG5cdFx0XHRcdC8vIHNwZWNpZmllZCBpbiBsb2FkKClcblx0XHRcdFx0c291cmNlTWFwWyBsb2NhbGUgXSA9IHNvdXJjZSArICcvJyArIGxvY2FsZSArICcuanNvbic7XG5cdFx0XHRcdGZhbGxiYWNrTG9jYWxlcyA9ICggJC5pMThuLmZhbGxiYWNrc1sgbG9jYWxlIF0gfHwgW10gKVxuXHRcdFx0XHRcdC5jb25jYXQoIHRoaXMub3B0aW9ucy5mYWxsYmFja0xvY2FsZSApO1xuXHRcdFx0XHRmb3IgKCBsb2NJbmRleCA9IDA7IGxvY0luZGV4IDwgZmFsbGJhY2tMb2NhbGVzLmxlbmd0aDsgbG9jSW5kZXgrKyApIHtcblx0XHRcdFx0XHRmYWxsYmFja0xvY2FsZSA9IGZhbGxiYWNrTG9jYWxlc1sgbG9jSW5kZXggXTtcblx0XHRcdFx0XHRzb3VyY2VNYXBbIGZhbGxiYWNrTG9jYWxlIF0gPSBzb3VyY2UgKyAnLycgKyBmYWxsYmFja0xvY2FsZSArICcuanNvbic7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZCggc291cmNlTWFwICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlU3RvcmUubG9hZCggc291cmNlLCBsb2NhbGUgKTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEb2VzIHBhcmFtZXRlciBhbmQgbWFnaWMgd29yZCBzdWJzdGl0dXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IE1lc3NhZ2Uga2V5XG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVycyBNZXNzYWdlIHBhcmFtZXRlcnNcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgga2V5LCBwYXJhbWV0ZXJzICkge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSB0aGlzLmxvY2FsaXplKCBrZXkgKTtcblx0XHRcdC8vIEZJWE1FOiBUaGlzIGNoYW5nZXMgdGhlIHN0YXRlIG9mIHRoZSBJMThOIG9iamVjdCxcblx0XHRcdC8vIHNob3VsZCBwcm9iYWJseSBub3QgY2hhbmdlIHRoZSAndGhpcy5wYXJzZXInIGJ1dCBqdXN0XG5cdFx0XHQvLyBwYXNzIGl0IHRvIHRoZSBwYXJzZXIuXG5cdFx0XHR0aGlzLnBhcnNlci5sYW5ndWFnZSA9ICQuaTE4bi5sYW5ndWFnZXNbICQuaTE4bigpLmxvY2FsZSBdIHx8ICQuaTE4bi5sYW5ndWFnZXNbICdkZWZhdWx0JyBdO1xuXHRcdFx0aWYgKCBtZXNzYWdlID09PSAnJyApIHtcblx0XHRcdFx0bWVzc2FnZSA9IGtleTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlci5wYXJzZSggbWVzc2FnZSwgcGFyYW1ldGVycyApO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvY2VzcyBhIG1lc3NhZ2UgZnJvbSB0aGUgJC5JMThOIGluc3RhbmNlXG5cdCAqIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCwgc3RvcmVkIGluIGpRdWVyeS5kYXRhKGRvY3VtZW50KS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgb2YgdGhlIG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbTEgW3BhcmFtLi4uXSBWYXJpYWRpYyBsaXN0IG9mIHBhcmFtZXRlcnMgZm9yIHtrZXl9LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd8JC5JMThOfSBQYXJzZWQgbWVzc2FnZSwgb3IgaWYgbm8ga2V5IHdhcyBnaXZlblxuXHQgKiB0aGUgaW5zdGFuY2Ugb2YgJC5JMThOIGlzIHJldHVybmVkLlxuXHQgKi9cblx0JC5pMThuID0gZnVuY3Rpb24gKCBrZXksIHBhcmFtMSApIHtcblx0XHR2YXIgcGFyYW1ldGVycyxcblx0XHRcdGkxOG4gPSAkLmRhdGEoIGRvY3VtZW50LCAnaTE4bicgKSxcblx0XHRcdG9wdGlvbnMgPSB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXk7XG5cblx0XHQvLyBJZiB0aGUgbG9jYWxlIG9wdGlvbiBmb3IgdGhpcyBjYWxsIGlzIGRpZmZlcmVudCB0aGVuIHRoZSBzZXR1cCBzbyBmYXIsXG5cdFx0Ly8gdXBkYXRlIGl0IGF1dG9tYXRpY2FsbHkuIFRoaXMgZG9lc24ndCBqdXN0IGNoYW5nZSB0aGUgY29udGV4dCBmb3IgdGhpc1xuXHRcdC8vIGNhbGwgYnV0IGZvciBhbGwgZnV0dXJlIGNhbGwgYXMgd2VsbC5cblx0XHQvLyBJZiB0aGVyZSBpcyBubyBpMThuIHNldHVwIHlldCwgZG9uJ3QgZG8gdGhpcy4gSXQgd2lsbCBiZSB0YWtlbiBjYXJlIG9mXG5cdFx0Ly8gYnkgdGhlIGBuZXcgSTE4TmAgY29uc3RydWN0aW9uIGJlbG93LlxuXHRcdC8vIE5PVEU6IEl0IHNob3VsZCBvbmx5IGNoYW5nZSBsYW5ndWFnZSBmb3IgdGhpcyBvbmUgY2FsbC5cblx0XHQvLyBUaGVuIGNhY2hlIGluc3RhbmNlcyBvZiBJMThOIHNvbWV3aGVyZS5cblx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5sb2NhbGUgJiYgaTE4biAmJiBpMThuLmxvY2FsZSAhPT0gb3B0aW9ucy5sb2NhbGUgKSB7XG5cdFx0XHRpMThuLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuXHRcdH1cblxuXHRcdGlmICggIWkxOG4gKSB7XG5cdFx0XHRpMThuID0gbmV3IEkxOE4oIG9wdGlvbnMgKTtcblx0XHRcdCQuZGF0YSggZG9jdW1lbnQsICdpMThuJywgaTE4biApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRpZiAoIHBhcmFtMSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRwYXJhbWV0ZXJzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJhbWV0ZXJzID0gW107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpMThuLnBhcnNlKCBrZXksIHBhcmFtZXRlcnMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRklYTUU6IHJlbW92ZSB0aGlzIGZlYXR1cmUvYnVnLlxuXHRcdFx0cmV0dXJuIGkxOG47XG5cdFx0fVxuXHR9O1xuXG5cdCQuZm4uaTE4biA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaTE4biA9ICQuZGF0YSggZG9jdW1lbnQsICdpMThuJyApO1xuXG5cdFx0aWYgKCAhaTE4biApIHtcblx0XHRcdGkxOG4gPSBuZXcgSTE4TigpO1xuXHRcdFx0JC5kYXRhKCBkb2N1bWVudCwgJ2kxOG4nLCBpMThuICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCggdGhpcyApLFxuXHRcdFx0XHRtZXNzYWdlS2V5ID0gJHRoaXMuZGF0YSggJ2kxOG4nICksXG5cdFx0XHRcdGxCcmFja2V0LCByQnJhY2tldCwgdHlwZSwga2V5O1xuXG5cdFx0XHRpZiAoIG1lc3NhZ2VLZXkgKSB7XG5cdFx0XHRcdGxCcmFja2V0ID0gbWVzc2FnZUtleS5pbmRleE9mKCAnWycgKTtcblx0XHRcdFx0ckJyYWNrZXQgPSBtZXNzYWdlS2V5LmluZGV4T2YoICddJyApO1xuXHRcdFx0XHRpZiAoIGxCcmFja2V0ICE9PSAtMSAmJiByQnJhY2tldCAhPT0gLTEgJiYgbEJyYWNrZXQgPCByQnJhY2tldCApIHtcblx0XHRcdFx0XHR0eXBlID0gbWVzc2FnZUtleS5zbGljZSggbEJyYWNrZXQgKyAxLCByQnJhY2tldCApO1xuXHRcdFx0XHRcdGtleSA9IG1lc3NhZ2VLZXkuc2xpY2UoIHJCcmFja2V0ICsgMSApO1xuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2h0bWwnICkge1xuXHRcdFx0XHRcdFx0JHRoaXMuaHRtbCggaTE4bi5wYXJzZSgga2V5ICkgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JHRoaXMuYXR0ciggdHlwZSwgaTE4bi5wYXJzZSgga2V5ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JHRoaXMudGV4dCggaTE4bi5wYXJzZSggbWVzc2FnZUtleSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCR0aGlzLmZpbmQoICdbZGF0YS1pMThuXScgKS5pMThuKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldERlZmF1bHRMb2NhbGUoKSB7XG5cdFx0dmFyIG5hdiwgbG9jYWxlID0gJCggJ2h0bWwnICkuYXR0ciggJ2xhbmcnICk7XG5cblx0XHRpZiAoICFsb2NhbGUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cdFx0XHRcdGxvY2FsZSA9IG5hdi5sYW5ndWFnZSB8fCBuYXYudXNlckxhbmd1YWdlIHx8ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9jYWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhbGU7XG5cdH1cblxuXHQkLmkxOG4ubGFuZ3VhZ2VzID0ge307XG5cdCQuaTE4bi5tZXNzYWdlU3RvcmUgPSAkLmkxOG4ubWVzc2FnZVN0b3JlIHx8IHt9O1xuXHQkLmkxOG4ucGFyc2VyID0ge1xuXHRcdC8vIFRoZSBkZWZhdWx0IHBhcnNlciBvbmx5IGhhbmRsZXMgdmFyaWFibGUgc3Vic3RpdHV0aW9uXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggbWVzc2FnZSwgcGFyYW1ldGVycyApIHtcblx0XHRcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoIC9cXCQoXFxkKykvZywgZnVuY3Rpb24gKCBzdHIsIG1hdGNoICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggbWF0Y2gsIDEwICkgLSAxO1xuXHRcdFx0XHRyZXR1cm4gcGFyYW1ldGVyc1sgaW5kZXggXSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVyc1sgaW5kZXggXSA6ICckJyArIG1hdGNoO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFx0ZW1pdHRlcjoge31cblx0fTtcblx0JC5pMThuLmZhbGxiYWNrcyA9IHt9O1xuXHQkLmkxOG4uZGVidWcgPSBmYWxzZTtcblx0JC5pMThuLmxvZyA9IGZ1bmN0aW9uICggLyogYXJndW1lbnRzICovICkge1xuXHRcdGlmICggd2luZG93LmNvbnNvbGUgJiYgJC5pMThuLmRlYnVnICkge1xuXHRcdFx0d2luZG93LmNvbnNvbGUubG9nLmFwcGx5KCB3aW5kb3cuY29uc29sZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xuXHQvKiBTdGF0aWMgbWVtYmVycyAqL1xuXHRJMThOLmRlZmF1bHRzID0ge1xuXHRcdGxvY2FsZTogZ2V0RGVmYXVsdExvY2FsZSgpLFxuXHRcdGZhbGxiYWNrTG9jYWxlOiAnZW4nLFxuXHRcdHBhcnNlcjogJC5pMThuLnBhcnNlcixcblx0XHRtZXNzYWdlU3RvcmU6ICQuaTE4bi5tZXNzYWdlU3RvcmVcblx0fTtcblxuXHQvLyBFeHBvc2UgY29uc3RydWN0b3Jcblx0JC5pMThuLmNvbnN0cnVjdG9yID0gSTE4Tjtcbn0oIGpRdWVyeSApICk7XG4iLCIvKiBnbG9iYWwgcGx1cmFsUnVsZVBhcnNlciAqL1xuKCBmdW5jdGlvbiAoICQgKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBqc2NzOmRpc2FibGVcblx0dmFyIGxhbmd1YWdlID0ge1xuXHRcdC8vIENMRFIgcGx1cmFsIHJ1bGVzIGdlbmVyYXRlZCB1c2luZ1xuXHRcdC8vIGxpYnMvQ0xEUlBsdXJhbFJ1bGVQYXJzZXIvdG9vbHMvUGx1cmFsWE1MMkpTT04uaHRtbFxuXHRcdHBsdXJhbFJ1bGVzOiB7XG5cdFx0XHRhazoge1xuXHRcdFx0XHRvbmU6ICduID0gMC4uMSdcblx0XHRcdH0sXG5cdFx0XHRhbToge1xuXHRcdFx0XHRvbmU6ICdpID0gMCBvciBuID0gMSdcblx0XHRcdH0sXG5cdFx0XHRhcjoge1xuXHRcdFx0XHR6ZXJvOiAnbiA9IDAnLFxuXHRcdFx0XHRvbmU6ICduID0gMScsXG5cdFx0XHRcdHR3bzogJ24gPSAyJyxcblx0XHRcdFx0ZmV3OiAnbiAlIDEwMCA9IDMuLjEwJyxcblx0XHRcdFx0bWFueTogJ24gJSAxMDAgPSAxMS4uOTknXG5cdFx0XHR9LFxuXHRcdFx0YXJzOiB7XG5cdFx0XHRcdHplcm86ICduID0gMCcsXG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInLFxuXHRcdFx0XHRmZXc6ICduICUgMTAwID0gMy4uMTAnLFxuXHRcdFx0XHRtYW55OiAnbiAlIDEwMCA9IDExLi45OSdcblx0XHRcdH0sXG5cdFx0XHRhczoge1xuXHRcdFx0XHRvbmU6ICdpID0gMCBvciBuID0gMSdcblx0XHRcdH0sXG5cdFx0XHRiZToge1xuXHRcdFx0XHRvbmU6ICduICUgMTAgPSAxIGFuZCBuICUgMTAwICE9IDExJyxcblx0XHRcdFx0ZmV3OiAnbiAlIDEwID0gMi4uNCBhbmQgbiAlIDEwMCAhPSAxMi4uMTQnLFxuXHRcdFx0XHRtYW55OiAnbiAlIDEwID0gMCBvciBuICUgMTAgPSA1Li45IG9yIG4gJSAxMDAgPSAxMS4uMTQnXG5cdFx0XHR9LFxuXHRcdFx0Ymg6IHtcblx0XHRcdFx0b25lOiAnbiA9IDAuLjEnXG5cdFx0XHR9LFxuXHRcdFx0Ym46IHtcblx0XHRcdFx0b25lOiAnaSA9IDAgb3IgbiA9IDEnXG5cdFx0XHR9LFxuXHRcdFx0YnI6IHtcblx0XHRcdFx0b25lOiAnbiAlIDEwID0gMSBhbmQgbiAlIDEwMCAhPSAxMSw3MSw5MScsXG5cdFx0XHRcdHR3bzogJ24gJSAxMCA9IDIgYW5kIG4gJSAxMDAgIT0gMTIsNzIsOTInLFxuXHRcdFx0XHRmZXc6ICduICUgMTAgPSAzLi40LDkgYW5kIG4gJSAxMDAgIT0gMTAuLjE5LDcwLi43OSw5MC4uOTknLFxuXHRcdFx0XHRtYW55OiAnbiAhPSAwIGFuZCBuICUgMTAwMDAwMCA9IDAnXG5cdFx0XHR9LFxuXHRcdFx0YnM6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEgb3IgZiAlIDEwID0gMSBhbmQgZiAlIDEwMCAhPSAxMScsXG5cdFx0XHRcdGZldzogJ3YgPSAwIGFuZCBpICUgMTAgPSAyLi40IGFuZCBpICUgMTAwICE9IDEyLi4xNCBvciBmICUgMTAgPSAyLi40IGFuZCBmICUgMTAwICE9IDEyLi4xNCdcblx0XHRcdH0sXG5cdFx0XHRjczoge1xuXHRcdFx0XHRvbmU6ICdpID0gMSBhbmQgdiA9IDAnLFxuXHRcdFx0XHRmZXc6ICdpID0gMi4uNCBhbmQgdiA9IDAnLFxuXHRcdFx0XHRtYW55OiAndiAhPSAwJ1xuXHRcdFx0fSxcblx0XHRcdGN5OiB7XG5cdFx0XHRcdHplcm86ICduID0gMCcsXG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInLFxuXHRcdFx0XHRmZXc6ICduID0gMycsXG5cdFx0XHRcdG1hbnk6ICduID0gNidcblx0XHRcdH0sXG5cdFx0XHRkYToge1xuXHRcdFx0XHRvbmU6ICduID0gMSBvciB0ICE9IDAgYW5kIGkgPSAwLDEnXG5cdFx0XHR9LFxuXHRcdFx0ZHNiOiB7XG5cdFx0XHRcdG9uZTogJ3YgPSAwIGFuZCBpICUgMTAwID0gMSBvciBmICUgMTAwID0gMScsXG5cdFx0XHRcdHR3bzogJ3YgPSAwIGFuZCBpICUgMTAwID0gMiBvciBmICUgMTAwID0gMicsXG5cdFx0XHRcdGZldzogJ3YgPSAwIGFuZCBpICUgMTAwID0gMy4uNCBvciBmICUgMTAwID0gMy4uNCdcblx0XHRcdH0sXG5cdFx0XHRmYToge1xuXHRcdFx0XHRvbmU6ICdpID0gMCBvciBuID0gMSdcblx0XHRcdH0sXG5cdFx0XHRmZjoge1xuXHRcdFx0XHRvbmU6ICdpID0gMCwxJ1xuXHRcdFx0fSxcblx0XHRcdGZpbDoge1xuXHRcdFx0XHRvbmU6ICd2ID0gMCBhbmQgaSA9IDEsMiwzIG9yIHYgPSAwIGFuZCBpICUgMTAgIT0gNCw2LDkgb3IgdiAhPSAwIGFuZCBmICUgMTAgIT0gNCw2LDknXG5cdFx0XHR9LFxuXHRcdFx0ZnI6IHtcblx0XHRcdFx0b25lOiAnaSA9IDAsMSdcblx0XHRcdH0sXG5cdFx0XHRnYToge1xuXHRcdFx0XHRvbmU6ICduID0gMScsXG5cdFx0XHRcdHR3bzogJ24gPSAyJyxcblx0XHRcdFx0ZmV3OiAnbiA9IDMuLjYnLFxuXHRcdFx0XHRtYW55OiAnbiA9IDcuLjEwJ1xuXHRcdFx0fSxcblx0XHRcdGdkOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxLDExJyxcblx0XHRcdFx0dHdvOiAnbiA9IDIsMTInLFxuXHRcdFx0XHRmZXc6ICduID0gMy4uMTAsMTMuLjE5J1xuXHRcdFx0fSxcblx0XHRcdGd1OiB7XG5cdFx0XHRcdG9uZTogJ2kgPSAwIG9yIG4gPSAxJ1xuXHRcdFx0fSxcblx0XHRcdGd1dzoge1xuXHRcdFx0XHRvbmU6ICduID0gMC4uMSdcblx0XHRcdH0sXG5cdFx0XHRndjoge1xuXHRcdFx0XHRvbmU6ICd2ID0gMCBhbmQgaSAlIDEwID0gMScsXG5cdFx0XHRcdHR3bzogJ3YgPSAwIGFuZCBpICUgMTAgPSAyJyxcblx0XHRcdFx0ZmV3OiAndiA9IDAgYW5kIGkgJSAxMDAgPSAwLDIwLDQwLDYwLDgwJyxcblx0XHRcdFx0bWFueTogJ3YgIT0gMCdcblx0XHRcdH0sXG5cdFx0XHRoZToge1xuXHRcdFx0XHRvbmU6ICdpID0gMSBhbmQgdiA9IDAnLFxuXHRcdFx0XHR0d286ICdpID0gMiBhbmQgdiA9IDAnLFxuXHRcdFx0XHRtYW55OiAndiA9IDAgYW5kIG4gIT0gMC4uMTAgYW5kIG4gJSAxMCA9IDAnXG5cdFx0XHR9LFxuXHRcdFx0aGk6IHtcblx0XHRcdFx0b25lOiAnaSA9IDAgb3IgbiA9IDEnXG5cdFx0XHR9LFxuXHRcdFx0aHI6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEgb3IgZiAlIDEwID0gMSBhbmQgZiAlIDEwMCAhPSAxMScsXG5cdFx0XHRcdGZldzogJ3YgPSAwIGFuZCBpICUgMTAgPSAyLi40IGFuZCBpICUgMTAwICE9IDEyLi4xNCBvciBmICUgMTAgPSAyLi40IGFuZCBmICUgMTAwICE9IDEyLi4xNCdcblx0XHRcdH0sXG5cdFx0XHRoc2I6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMDAgPSAxIG9yIGYgJSAxMDAgPSAxJyxcblx0XHRcdFx0dHdvOiAndiA9IDAgYW5kIGkgJSAxMDAgPSAyIG9yIGYgJSAxMDAgPSAyJyxcblx0XHRcdFx0ZmV3OiAndiA9IDAgYW5kIGkgJSAxMDAgPSAzLi40IG9yIGYgJSAxMDAgPSAzLi40J1xuXHRcdFx0fSxcblx0XHRcdGh5OiB7XG5cdFx0XHRcdG9uZTogJ2kgPSAwLDEnXG5cdFx0XHR9LFxuXHRcdFx0aXM6IHtcblx0XHRcdFx0b25lOiAndCA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEgb3IgdCAhPSAwJ1xuXHRcdFx0fSxcblx0XHRcdGl1OiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0aXc6IHtcblx0XHRcdFx0b25lOiAnaSA9IDEgYW5kIHYgPSAwJyxcblx0XHRcdFx0dHdvOiAnaSA9IDIgYW5kIHYgPSAwJyxcblx0XHRcdFx0bWFueTogJ3YgPSAwIGFuZCBuICE9IDAuLjEwIGFuZCBuICUgMTAgPSAwJ1xuXHRcdFx0fSxcblx0XHRcdGthYjoge1xuXHRcdFx0XHRvbmU6ICdpID0gMCwxJ1xuXHRcdFx0fSxcblx0XHRcdGtuOiB7XG5cdFx0XHRcdG9uZTogJ2kgPSAwIG9yIG4gPSAxJ1xuXHRcdFx0fSxcblx0XHRcdGt3OiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0bGFnOiB7XG5cdFx0XHRcdHplcm86ICduID0gMCcsXG5cdFx0XHRcdG9uZTogJ2kgPSAwLDEgYW5kIG4gIT0gMCdcblx0XHRcdH0sXG5cdFx0XHRsbjoge1xuXHRcdFx0XHRvbmU6ICduID0gMC4uMSdcblx0XHRcdH0sXG5cdFx0XHRsdDoge1xuXHRcdFx0XHRvbmU6ICduICUgMTAgPSAxIGFuZCBuICUgMTAwICE9IDExLi4xOScsXG5cdFx0XHRcdGZldzogJ24gJSAxMCA9IDIuLjkgYW5kIG4gJSAxMDAgIT0gMTEuLjE5Jyxcblx0XHRcdFx0bWFueTogJ2YgIT0gMCdcblx0XHRcdH0sXG5cdFx0XHRsdjoge1xuXHRcdFx0XHR6ZXJvOiAnbiAlIDEwID0gMCBvciBuICUgMTAwID0gMTEuLjE5IG9yIHYgPSAyIGFuZCBmICUgMTAwID0gMTEuLjE5Jyxcblx0XHRcdFx0b25lOiAnbiAlIDEwID0gMSBhbmQgbiAlIDEwMCAhPSAxMSBvciB2ID0gMiBhbmQgZiAlIDEwID0gMSBhbmQgZiAlIDEwMCAhPSAxMSBvciB2ICE9IDIgYW5kIGYgJSAxMCA9IDEnXG5cdFx0XHR9LFxuXHRcdFx0bWc6IHtcblx0XHRcdFx0b25lOiAnbiA9IDAuLjEnXG5cdFx0XHR9LFxuXHRcdFx0bWs6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgb3IgZiAlIDEwID0gMSdcblx0XHRcdH0sXG5cdFx0XHRtbzoge1xuXHRcdFx0XHRvbmU6ICdpID0gMSBhbmQgdiA9IDAnLFxuXHRcdFx0XHRmZXc6ICd2ICE9IDAgb3IgbiA9IDAgb3IgbiAhPSAxIGFuZCBuICUgMTAwID0gMS4uMTknXG5cdFx0XHR9LFxuXHRcdFx0bXI6IHtcblx0XHRcdFx0b25lOiAnaSA9IDAgb3IgbiA9IDEnXG5cdFx0XHR9LFxuXHRcdFx0bXQ6IHtcblx0XHRcdFx0b25lOiAnbiA9IDEnLFxuXHRcdFx0XHRmZXc6ICduID0gMCBvciBuICUgMTAwID0gMi4uMTAnLFxuXHRcdFx0XHRtYW55OiAnbiAlIDEwMCA9IDExLi4xOSdcblx0XHRcdH0sXG5cdFx0XHRuYXE6IHtcblx0XHRcdFx0b25lOiAnbiA9IDEnLFxuXHRcdFx0XHR0d286ICduID0gMidcblx0XHRcdH0sXG5cdFx0XHRuc286IHtcblx0XHRcdFx0b25lOiAnbiA9IDAuLjEnXG5cdFx0XHR9LFxuXHRcdFx0cGE6IHtcblx0XHRcdFx0b25lOiAnbiA9IDAuLjEnXG5cdFx0XHR9LFxuXHRcdFx0cGw6IHtcblx0XHRcdFx0b25lOiAnaSA9IDEgYW5kIHYgPSAwJyxcblx0XHRcdFx0ZmV3OiAndiA9IDAgYW5kIGkgJSAxMCA9IDIuLjQgYW5kIGkgJSAxMDAgIT0gMTIuLjE0Jyxcblx0XHRcdFx0bWFueTogJ3YgPSAwIGFuZCBpICE9IDEgYW5kIGkgJSAxMCA9IDAuLjEgb3IgdiA9IDAgYW5kIGkgJSAxMCA9IDUuLjkgb3IgdiA9IDAgYW5kIGkgJSAxMDAgPSAxMi4uMTQnXG5cdFx0XHR9LFxuXHRcdFx0cHJnOiB7XG5cdFx0XHRcdHplcm86ICduICUgMTAgPSAwIG9yIG4gJSAxMDAgPSAxMS4uMTkgb3IgdiA9IDIgYW5kIGYgJSAxMDAgPSAxMS4uMTknLFxuXHRcdFx0XHRvbmU6ICduICUgMTAgPSAxIGFuZCBuICUgMTAwICE9IDExIG9yIHYgPSAyIGFuZCBmICUgMTAgPSAxIGFuZCBmICUgMTAwICE9IDExIG9yIHYgIT0gMiBhbmQgZiAlIDEwID0gMSdcblx0XHRcdH0sXG5cdFx0XHRwdDoge1xuXHRcdFx0XHRvbmU6ICdpID0gMC4uMSdcblx0XHRcdH0sXG5cdFx0XHRybzoge1xuXHRcdFx0XHRvbmU6ICdpID0gMSBhbmQgdiA9IDAnLFxuXHRcdFx0XHRmZXc6ICd2ICE9IDAgb3IgbiA9IDAgb3IgbiAhPSAxIGFuZCBuICUgMTAwID0gMS4uMTknXG5cdFx0XHR9LFxuXHRcdFx0cnU6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEnLFxuXHRcdFx0XHRmZXc6ICd2ID0gMCBhbmQgaSAlIDEwID0gMi4uNCBhbmQgaSAlIDEwMCAhPSAxMi4uMTQnLFxuXHRcdFx0XHRtYW55OiAndiA9IDAgYW5kIGkgJSAxMCA9IDAgb3IgdiA9IDAgYW5kIGkgJSAxMCA9IDUuLjkgb3IgdiA9IDAgYW5kIGkgJSAxMDAgPSAxMS4uMTQnXG5cdFx0XHR9LFxuXHRcdFx0c2U6IHtcblx0XHRcdFx0b25lOiAnbiA9IDEnLFxuXHRcdFx0XHR0d286ICduID0gMidcblx0XHRcdH0sXG5cdFx0XHRzaDoge1xuXHRcdFx0XHRvbmU6ICd2ID0gMCBhbmQgaSAlIDEwID0gMSBhbmQgaSAlIDEwMCAhPSAxMSBvciBmICUgMTAgPSAxIGFuZCBmICUgMTAwICE9IDExJyxcblx0XHRcdFx0ZmV3OiAndiA9IDAgYW5kIGkgJSAxMCA9IDIuLjQgYW5kIGkgJSAxMDAgIT0gMTIuLjE0IG9yIGYgJSAxMCA9IDIuLjQgYW5kIGYgJSAxMDAgIT0gMTIuLjE0J1xuXHRcdFx0fSxcblx0XHRcdHNoaToge1xuXHRcdFx0XHRvbmU6ICdpID0gMCBvciBuID0gMScsXG5cdFx0XHRcdGZldzogJ24gPSAyLi4xMCdcblx0XHRcdH0sXG5cdFx0XHRzaToge1xuXHRcdFx0XHRvbmU6ICduID0gMCwxIG9yIGkgPSAwIGFuZCBmID0gMSdcblx0XHRcdH0sXG5cdFx0XHRzazoge1xuXHRcdFx0XHRvbmU6ICdpID0gMSBhbmQgdiA9IDAnLFxuXHRcdFx0XHRmZXc6ICdpID0gMi4uNCBhbmQgdiA9IDAnLFxuXHRcdFx0XHRtYW55OiAndiAhPSAwJ1xuXHRcdFx0fSxcblx0XHRcdHNsOiB7XG5cdFx0XHRcdG9uZTogJ3YgPSAwIGFuZCBpICUgMTAwID0gMScsXG5cdFx0XHRcdHR3bzogJ3YgPSAwIGFuZCBpICUgMTAwID0gMicsXG5cdFx0XHRcdGZldzogJ3YgPSAwIGFuZCBpICUgMTAwID0gMy4uNCBvciB2ICE9IDAnXG5cdFx0XHR9LFxuXHRcdFx0c21hOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0c21pOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0c21qOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0c21uOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0c21zOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAxJyxcblx0XHRcdFx0dHdvOiAnbiA9IDInXG5cdFx0XHR9LFxuXHRcdFx0c3I6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEgb3IgZiAlIDEwID0gMSBhbmQgZiAlIDEwMCAhPSAxMScsXG5cdFx0XHRcdGZldzogJ3YgPSAwIGFuZCBpICUgMTAgPSAyLi40IGFuZCBpICUgMTAwICE9IDEyLi4xNCBvciBmICUgMTAgPSAyLi40IGFuZCBmICUgMTAwICE9IDEyLi4xNCdcblx0XHRcdH0sXG5cdFx0XHR0aToge1xuXHRcdFx0XHRvbmU6ICduID0gMC4uMSdcblx0XHRcdH0sXG5cdFx0XHR0bDoge1xuXHRcdFx0XHRvbmU6ICd2ID0gMCBhbmQgaSA9IDEsMiwzIG9yIHYgPSAwIGFuZCBpICUgMTAgIT0gNCw2LDkgb3IgdiAhPSAwIGFuZCBmICUgMTAgIT0gNCw2LDknXG5cdFx0XHR9LFxuXHRcdFx0dHptOiB7XG5cdFx0XHRcdG9uZTogJ24gPSAwLi4xIG9yIG4gPSAxMS4uOTknXG5cdFx0XHR9LFxuXHRcdFx0dWs6IHtcblx0XHRcdFx0b25lOiAndiA9IDAgYW5kIGkgJSAxMCA9IDEgYW5kIGkgJSAxMDAgIT0gMTEnLFxuXHRcdFx0XHRmZXc6ICd2ID0gMCBhbmQgaSAlIDEwID0gMi4uNCBhbmQgaSAlIDEwMCAhPSAxMi4uMTQnLFxuXHRcdFx0XHRtYW55OiAndiA9IDAgYW5kIGkgJSAxMCA9IDAgb3IgdiA9IDAgYW5kIGkgJSAxMCA9IDUuLjkgb3IgdiA9IDAgYW5kIGkgJSAxMDAgPSAxMS4uMTQnXG5cdFx0XHR9LFxuXHRcdFx0d2E6IHtcblx0XHRcdFx0b25lOiAnbiA9IDAuLjEnXG5cdFx0XHR9LFxuXHRcdFx0enU6IHtcblx0XHRcdFx0b25lOiAnaSA9IDAgb3IgbiA9IDEnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBqc2NzOmVuYWJsZVxuXG5cdFx0LyoqXG5cdFx0ICogUGx1cmFsIGZvcm0gdHJhbnNmb3JtYXRpb25zLCBuZWVkZWQgZm9yIHNvbWUgbGFuZ3VhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBjb3VudFxuXHRcdCAqICAgICAgICAgICAgTm9uLWxvY2FsaXplZCBxdWFudGlmaWVyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gZm9ybXNcblx0XHQgKiAgICAgICAgICAgIExpc3Qgb2YgcGx1cmFsIGZvcm1zXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBDb3JyZWN0IGZvcm0gZm9yIHF1YW50aWZpZXIgaW4gdGhpcyBsYW5ndWFnZVxuXHRcdCAqL1xuXHRcdGNvbnZlcnRQbHVyYWw6IGZ1bmN0aW9uICggY291bnQsIGZvcm1zICkge1xuXHRcdFx0dmFyIHBsdXJhbFJ1bGVzLFxuXHRcdFx0XHRwbHVyYWxGb3JtSW5kZXgsXG5cdFx0XHRcdGluZGV4LFxuXHRcdFx0XHRleHBsaWNpdFBsdXJhbFBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXFxcXGQrPScsICdpJyApLFxuXHRcdFx0XHRmb3JtQ291bnQsXG5cdFx0XHRcdGZvcm07XG5cblx0XHRcdGlmICggIWZvcm1zIHx8IGZvcm1zLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgZm9yIEV4cGxpY2l0IDA9ICYgMT0gdmFsdWVzXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgZm9ybXMubGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRmb3JtID0gZm9ybXNbIGluZGV4IF07XG5cdFx0XHRcdGlmICggZXhwbGljaXRQbHVyYWxQYXR0ZXJuLnRlc3QoIGZvcm0gKSApIHtcblx0XHRcdFx0XHRmb3JtQ291bnQgPSBwYXJzZUludCggZm9ybS5zbGljZSggMCwgZm9ybS5pbmRleE9mKCAnPScgKSApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggZm9ybUNvdW50ID09PSBjb3VudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiAoIGZvcm0uc2xpY2UoIGZvcm0uaW5kZXhPZiggJz0nICkgKyAxICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9ybXNbIGluZGV4IF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9ybXMgPSAkLm1hcCggZm9ybXMsIGZ1bmN0aW9uICggZm9ybSApIHtcblx0XHRcdFx0aWYgKCBmb3JtICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZvcm07XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdFx0cGx1cmFsUnVsZXMgPSB0aGlzLnBsdXJhbFJ1bGVzWyAkLmkxOG4oKS5sb2NhbGUgXTtcblxuXHRcdFx0aWYgKCAhcGx1cmFsUnVsZXMgKSB7XG5cdFx0XHRcdC8vIGRlZmF1bHQgZmFsbGJhY2suXG5cdFx0XHRcdHJldHVybiAoIGNvdW50ID09PSAxICkgPyBmb3Jtc1sgMCBdIDogZm9ybXNbIDEgXTtcblx0XHRcdH1cblxuXHRcdFx0cGx1cmFsRm9ybUluZGV4ID0gdGhpcy5nZXRQbHVyYWxGb3JtKCBjb3VudCwgcGx1cmFsUnVsZXMgKTtcblx0XHRcdHBsdXJhbEZvcm1JbmRleCA9IE1hdGgubWluKCBwbHVyYWxGb3JtSW5kZXgsIGZvcm1zLmxlbmd0aCAtIDEgKTtcblxuXHRcdFx0cmV0dXJuIGZvcm1zWyBwbHVyYWxGb3JtSW5kZXggXTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9yIHRoZSBudW1iZXIsIGdldCB0aGUgcGx1cmFsIGZvciBpbmRleFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBudW1iZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGx1cmFsUnVsZXNcblx0XHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBwbHVyYWwgZm9ybSBpbmRleFxuXHRcdCAqL1xuXHRcdGdldFBsdXJhbEZvcm06IGZ1bmN0aW9uICggbnVtYmVyLCBwbHVyYWxSdWxlcyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRwbHVyYWxGb3JtcyA9IFsgJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlcicgXSxcblx0XHRcdFx0cGx1cmFsRm9ybUluZGV4ID0gMDtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwbHVyYWxGb3Jtcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBwbHVyYWxSdWxlc1sgcGx1cmFsRm9ybXNbIGkgXSBdICkge1xuXHRcdFx0XHRcdGlmICggcGx1cmFsUnVsZVBhcnNlciggcGx1cmFsUnVsZXNbIHBsdXJhbEZvcm1zWyBpIF0gXSwgbnVtYmVyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGx1cmFsRm9ybUluZGV4O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBsdXJhbEZvcm1JbmRleCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwbHVyYWxGb3JtSW5kZXg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIGEgbnVtYmVyIHVzaW5nIGRpZ2l0VHJhbnNmb3JtVGFibGUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gbnVtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZWdlciBDb252ZXJ0IHRoZSByZXR1cm4gdmFsdWUgdG8gYW4gaW50ZWdlclxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG51bWJlciBjb252ZXJ0ZWQgaW50byBhIFN0cmluZy5cblx0XHQgKi9cblx0XHRjb252ZXJ0TnVtYmVyOiBmdW5jdGlvbiAoIG51bSwgaW50ZWdlciApIHtcblx0XHRcdHZhciB0bXAsIGl0ZW0sIGksXG5cdFx0XHRcdHRyYW5zZm9ybVRhYmxlLCBudW1iZXJTdHJpbmcsIGNvbnZlcnRlZE51bWJlcjtcblxuXHRcdFx0Ly8gU2V0IHRoZSB0YXJnZXQgVHJhbnNmb3JtIHRhYmxlOlxuXHRcdFx0dHJhbnNmb3JtVGFibGUgPSB0aGlzLmRpZ2l0VHJhbnNmb3JtVGFibGUoICQuaTE4bigpLmxvY2FsZSApO1xuXHRcdFx0bnVtYmVyU3RyaW5nID0gU3RyaW5nKCBudW0gKTtcblx0XHRcdGNvbnZlcnRlZE51bWJlciA9ICcnO1xuXG5cdFx0XHRpZiAoICF0cmFuc2Zvcm1UYWJsZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHJlc3RvcmUgdG8gTGF0aW4gbnVtYmVyIGZsYWcgaXMgc2V0OlxuXHRcdFx0aWYgKCBpbnRlZ2VyICkge1xuXHRcdFx0XHRpZiAoIHBhcnNlRmxvYXQoIG51bSwgMTAgKSA9PT0gbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0bXAgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBpdGVtIGluIHRyYW5zZm9ybVRhYmxlICkge1xuXHRcdFx0XHRcdHRtcFsgdHJhbnNmb3JtVGFibGVbIGl0ZW0gXSBdID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyYW5zZm9ybVRhYmxlID0gdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG51bWJlclN0cmluZy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCB0cmFuc2Zvcm1UYWJsZVsgbnVtYmVyU3RyaW5nWyBpIF0gXSApIHtcblx0XHRcdFx0XHRjb252ZXJ0ZWROdW1iZXIgKz0gdHJhbnNmb3JtVGFibGVbIG51bWJlclN0cmluZ1sgaSBdIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udmVydGVkTnVtYmVyICs9IG51bWJlclN0cmluZ1sgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlZ2VyID8gcGFyc2VGbG9hdCggY29udmVydGVkTnVtYmVyLCAxMCApIDogY29udmVydGVkTnVtYmVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHcmFtbWF0aWNhbCB0cmFuc2Zvcm1hdGlvbnMsIG5lZWRlZCBmb3IgaW5mbGVjdGVkIGxhbmd1YWdlcy5cblx0XHQgKiBJbnZva2VkIGJ5IHB1dHRpbmcge3tncmFtbWFyOmZvcm18d29yZH19IGluIGEgbWVzc2FnZS5cblx0XHQgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgbGFuZ3VhZ2VzIHRoYXQgbmVlZCBzcGVjaWFsIGdyYW1tYXIgcnVsZXNcblx0XHQgKiBhcHBsaWVkIGR5bmFtaWNhbGx5LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHdvcmRcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZm9ybVxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRjb252ZXJ0R3JhbW1hcjogZnVuY3Rpb24gKCB3b3JkLCBmb3JtICkge1xuXHRcdFx0cmV0dXJuIHdvcmQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVzIGFuIGFsdGVybmF0aXZlIHRleHQgZGVwZW5kaW5nIG9uIHNwZWNpZmllZCBnZW5kZXIuIFVzYWdlXG5cdFx0ICoge3tnZW5kZXI6W2dlbmRlcnx1c2VyIG9iamVjdF18bWFzY3VsaW5lfGZlbWluaW5lfG5ldXRyYWx9fS4gSWYgc2Vjb25kXG5cdFx0ICogb3IgdGhpcmQgcGFyYW1ldGVyIGFyZSBub3Qgc3BlY2lmaWVkLCBtYXNjdWxpbmUgaXMgdXNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZXNlIGRldGFpbHMgbWF5IGJlIG92ZXJyaWRlbiBwZXIgbGFuZ3VhZ2UuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZ2VuZGVyXG5cdFx0ICogICAgICBtYWxlLCBmZW1hbGUsIG9yIGFueXRoaW5nIGVsc2UgZm9yIG5ldXRyYWwuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gZm9ybXNcblx0XHQgKiAgICAgIExpc3Qgb2YgZ2VuZGVyIGZvcm1zXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2VuZGVyOiBmdW5jdGlvbiAoIGdlbmRlciwgZm9ybXMgKSB7XG5cdFx0XHRpZiAoICFmb3JtcyB8fCBmb3Jtcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKCBmb3Jtcy5sZW5ndGggPCAyICkge1xuXHRcdFx0XHRmb3Jtcy5wdXNoKCBmb3Jtc1sgZm9ybXMubGVuZ3RoIC0gMSBdICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VuZGVyID09PSAnbWFsZScgKSB7XG5cdFx0XHRcdHJldHVybiBmb3Jtc1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlbmRlciA9PT0gJ2ZlbWFsZScgKSB7XG5cdFx0XHRcdHJldHVybiBmb3Jtc1sgMSBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBmb3Jtcy5sZW5ndGggPT09IDMgKSA/IGZvcm1zWyAyIF0gOiBmb3Jtc1sgMCBdO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRpZ2l0IHRyYW5zZm9ybSB0YWJsZSBmb3IgdGhlIGdpdmVuIGxhbmd1YWdlXG5cdFx0ICogU2VlIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL251bWJlcmluZy1zeXN0ZW1zXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2Vcblx0XHQgKiBAcmV0dXJuIHtBcnJheXxib29sZWFufSBMaXN0IG9mIGRpZ2l0cyBpbiB0aGUgcGFzc2VkIGxhbmd1YWdlIG9yIGZhbHNlXG5cdFx0ICogcmVwcmVzZW50YXRpb24sIG9yIGJvb2xlYW4gZmFsc2UgaWYgdGhlcmUgaXMgbm8gaW5mb3JtYXRpb24uXG5cdFx0ICovXG5cdFx0ZGlnaXRUcmFuc2Zvcm1UYWJsZTogZnVuY3Rpb24gKCBsYW5ndWFnZSApIHtcblx0XHRcdHZhciB0YWJsZXMgPSB7XG5cdFx0XHRcdGFyOiAn2aDZodmi2aPZpNml2abZp9mo2aknLFxuXHRcdFx0XHRmYTogJ9uw27Hbstuz27Tbtdu227fbuNu5Jyxcblx0XHRcdFx0bWw6ICfgtabgtafgtajgtangtargtavgtazgta3gta7gta8nLFxuXHRcdFx0XHRrbjogJ+CzpuCzp+CzqOCzqeCzquCzq+CzrOCzreCzruCzrycsXG5cdFx0XHRcdGxvOiAn4LuQ4LuR4LuS4LuT4LuU4LuV4LuW4LuX4LuY4LuZJyxcblx0XHRcdFx0b3I6ICfgrabgrafgrajgrangrargravgrazgra3gra7gra8nLFxuXHRcdFx0XHRraDogJ+GfoOGfoeGfouGfo+GfpOGfpeGfpuGfp+GfqOGfqScsXG5cdFx0XHRcdHBhOiAn4Kmm4Kmn4Kmo4Kmp4Kmq4Kmr4Kms4Kmt4Kmu4KmvJyxcblx0XHRcdFx0Z3U6ICfgq6bgq6fgq6jgq6ngq6rgq6vgq6zgq63gq67gq68nLFxuXHRcdFx0XHRoaTogJ+ClpuClp+ClqOClqeClquClq+ClrOClreClruClrycsXG5cdFx0XHRcdG15OiAn4YGA4YGB4YGC4YGD4YGE4YGF4YGG4YGH4YGI4YGJJyxcblx0XHRcdFx0dGE6ICfgr6bgr6fgr6jgr6ngr6rgr6vgr6zgr63gr67gr68nLFxuXHRcdFx0XHR0ZTogJ+CxpuCxp+CxqOCxqeCxquCxq+CxrOCxreCxruCxrycsXG5cdFx0XHRcdHRoOiAn4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZJywgLy8gRklYTUUgdXNlIGlzbyA2MzkgY29kZXNcblx0XHRcdFx0Ym86ICfgvKDgvKHgvKLgvKPgvKTgvKXgvKbgvKfgvKjgvKknIC8vIEZJWE1FIHVzZSBpc28gNjM5IGNvZGVzXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoICF0YWJsZXNbIGxhbmd1YWdlIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhYmxlc1sgbGFuZ3VhZ2UgXS5zcGxpdCggJycgKTtcblx0XHR9XG5cdH07XG5cblx0JC5leHRlbmQoICQuaTE4bi5sYW5ndWFnZXMsIHtcblx0XHQnZGVmYXVsdCc6IGxhbmd1YWdlXG5cdH0gKTtcbn0oIGpRdWVyeSApICk7XG4iLCIvKiFcbiAqIGpRdWVyeSBJbnRlcm5hdGlvbmFsaXphdGlvbiBsaWJyYXJ5IC0gTWVzc2FnZSBTdG9yZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMiBTYW50aG9zaCBUaG90dGluZ2FsXG4gKlxuICoganF1ZXJ5LmkxOG4gaXMgZHVhbCBsaWNlbnNlZCBHUEx2MiBvciBsYXRlciBhbmQgTUlULiBZb3UgZG9uJ3QgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsIHRvXG4gKiBjaG9vc2Ugb25lIGxpY2Vuc2Ugb3IgdGhlIG90aGVyIGFuZCB5b3UgZG9uJ3QgaGF2ZSB0byBub3RpZnkgYW55b25lIHdoaWNoIGxpY2Vuc2UgeW91IGFyZSB1c2luZy5cbiAqIFlvdSBhcmUgZnJlZSB0byB1c2UgVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpbiBjb21tZXJjaWFsIHByb2plY3RzIGFzIGxvbmcgYXMgdGhlIGNvcHlyaWdodFxuICogaGVhZGVyIGlzIGxlZnQgaW50YWN0LiBTZWUgZmlsZXMgR1BMLUxJQ0VOU0UgYW5kIE1JVC1MSUNFTlNFIGZvciBkZXRhaWxzLlxuICpcbiAqIEBsaWNlbmNlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbmNlIDIuMCBvciBsYXRlclxuICogQGxpY2VuY2UgTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uICggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBNZXNzYWdlU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IHt9O1xuXHRcdHRoaXMuc291cmNlcyA9IHt9O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGpzb25NZXNzYWdlTG9hZGVyKCB1cmwgKSB7XG5cdFx0dmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG5cdFx0JC5nZXRKU09OKCB1cmwgKVxuXHRcdFx0LmRvbmUoIGRlZmVycmVkLnJlc29sdmUgKVxuXHRcdFx0LmZhaWwoIGZ1bmN0aW9uICgganF4aHIsIHNldHRpbmdzLCBleGNlcHRpb24gKSB7XG5cdFx0XHRcdCQuaTE4bi5sb2coICdFcnJvciBpbiBsb2FkaW5nIG1lc3NhZ2VzIGZyb20gJyArIHVybCArICcgRXhjZXB0aW9uOiAnICsgZXhjZXB0aW9uICk7XG5cdFx0XHRcdC8vIElnbm9yZSA0MDQgZXhjZXB0aW9uLCBiZWNhdXNlIHdlIGFyZSBoYW5kbGluZyBmYWxsYWJhY2tzIGV4cGxpY2l0bHlcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZSgpO1xuXHRcdFx0fSApO1xuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dpa2ltZWRpYS9qcXVlcnkuaTE4bi93aWtpL1NwZWNpZmljYXRpb24jd2lraS1NZXNzYWdlX0ZpbGVfTG9hZGluZ1xuXHQgKi9cblx0TWVzc2FnZVN0b3JlLnByb3RvdHlwZSA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYWwgbWVzc2FnZSBsb2FkaW5nIEFQSSBUaGlzIGNhbiB0YWtlIGEgVVJMIHN0cmluZyBmb3Jcblx0XHQgKiB0aGUganNvbiBmb3JtYXR0ZWQgbWVzc2FnZXMuXG5cdFx0ICogPGNvZGU+bG9hZCgncGF0aC90by9hbGxfbG9jYWxpemF0aW9ucy5qc29uJyk7PC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogVGhpcyBjYW4gYWxzbyBsb2FkIGEgbG9jYWxpemF0aW9uIGZpbGUgZm9yIGEgbG9jYWxlIDxjb2RlPlxuXHRcdCAqIGxvYWQoICdwYXRoL3RvL2RlLW1lc3NhZ2VzLmpzb24nLCAnZGUnICk7XG5cdFx0ICogPC9jb2RlPlxuXHRcdCAqIEEgZGF0YSBvYmplY3QgY29udGFpbmluZyBtZXNzYWdlIGtleS0gbWVzc2FnZSB0cmFuc2xhdGlvbiBtYXBwaW5nc1xuXHRcdCAqIGNhbiBhbHNvIGJlIHBhc3NlZCBFZzpcblx0XHQgKiA8Y29kZT5cblx0XHQgKiBsb2FkKCB7ICdoZWxsbycgOiAnSGVsbG8nIH0sIG9wdGlvbmFsTG9jYWxlICk7XG5cdFx0ICogPC9jb2RlPiBJZiB0aGUgZGF0YSBhcmd1bWVudCBpc1xuXHRcdCAqIG51bGwvdW5kZWZpbmVkL2ZhbHNlLFxuXHRcdCAqIGFsbCBjYWNoZWQgbWVzc2FnZXMgZm9yIHRoZSBpMThuIGluc3RhbmNlIHdpbGwgZ2V0IHJlc2V0LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBzb3VyY2Vcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIExhbmd1YWdlIHRhZ1xuXHRcdCAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfVxuXHRcdCAqL1xuXHRcdGxvYWQ6IGZ1bmN0aW9uICggc291cmNlLCBsb2NhbGUgKSB7XG5cdFx0XHR2YXIga2V5ID0gbnVsbCxcblx0XHRcdFx0ZGVmZXJyZWQgPSBudWxsLFxuXHRcdFx0XHRkZWZlcnJlZHMgPSBbXSxcblx0XHRcdFx0bWVzc2FnZVN0b3JlID0gdGhpcztcblxuXHRcdFx0aWYgKCB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIFVSTCB0byB0aGUgbWVzc2FnZXMgZmlsZS5cblx0XHRcdFx0JC5pMThuLmxvZyggJ0xvYWRpbmcgbWVzc2FnZXMgZnJvbTogJyArIHNvdXJjZSApO1xuXHRcdFx0XHRkZWZlcnJlZCA9IGpzb25NZXNzYWdlTG9hZGVyKCBzb3VyY2UgKVxuXHRcdFx0XHRcdC5kb25lKCBmdW5jdGlvbiAoIGxvY2FsaXphdGlvbiApIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2VTdG9yZS5zZXQoIGxvY2FsZSwgbG9jYWxpemF0aW9uICk7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbG9jYWxlICkge1xuXHRcdFx0XHQvLyBzb3VyY2UgaXMgYW4ga2V5LXZhbHVlIHBhaXIgb2YgbWVzc2FnZXMgZm9yIGdpdmVuIGxvY2FsZVxuXHRcdFx0XHRtZXNzYWdlU3RvcmUuc2V0KCBsb2NhbGUsIHNvdXJjZSApO1xuXG5cdFx0XHRcdHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc291cmNlIGlzIGEga2V5LXZhbHVlIHBhaXIgb2YgbG9jYWxlcyBhbmQgdGhlaXIgc291cmNlXG5cdFx0XHRcdGZvciAoIGtleSBpbiBzb3VyY2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRsb2NhbGUgPSBrZXk7XG5cdFx0XHRcdFx0XHQvLyBObyB7bG9jYWxlfSBnaXZlbiwgYXNzdW1lIGRhdGEgaXMgYSBncm91cCBvZiBsYW5ndWFnZXMsXG5cdFx0XHRcdFx0XHQvLyBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4gZm9yIGVhY2ggbGFuZ3VhZ2UuXG5cdFx0XHRcdFx0XHRkZWZlcnJlZHMucHVzaCggbWVzc2FnZVN0b3JlLmxvYWQoIHNvdXJjZVsga2V5IF0sIGxvY2FsZSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAkLndoZW4uYXBwbHkoICQsIGRlZmVycmVkcyApO1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBtZXNzYWdlcyB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuXHRcdCAqIElmIGxvY2FsZSBleGlzdHMsIGFkZCBtZXNzYWdlcyB0byB0aGUgbG9jYWxlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlc1xuXHRcdCAqL1xuXHRcdHNldDogZnVuY3Rpb24gKCBsb2NhbGUsIG1lc3NhZ2VzICkge1xuXHRcdFx0aWYgKCAhdGhpcy5tZXNzYWdlc1sgbG9jYWxlIF0gKSB7XG5cdFx0XHRcdHRoaXMubWVzc2FnZXNbIGxvY2FsZSBdID0gbWVzc2FnZXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2VzWyBsb2NhbGUgXSA9ICQuZXh0ZW5kKCB0aGlzLm1lc3NhZ2VzWyBsb2NhbGUgXSwgbWVzc2FnZXMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VLZXlcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24gKCBsb2NhbGUsIG1lc3NhZ2VLZXkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlc1sgbG9jYWxlIF0gJiYgdGhpcy5tZXNzYWdlc1sgbG9jYWxlIF1bIG1lc3NhZ2VLZXkgXTtcblx0XHR9XG5cdH07XG5cblx0JC5leHRlbmQoICQuaTE4bi5tZXNzYWdlU3RvcmUsIG5ldyBNZXNzYWdlU3RvcmUoKSApO1xufSggalF1ZXJ5ICkgKTtcbiIsIi8qIVxuICogalF1ZXJ5IEludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnlcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEtMjAxMyBTYW50aG9zaCBUaG90dGluZ2FsLCBOZWlsIEthbmRhbGdhb25rYXJcbiAqXG4gKiBqcXVlcnkuaTE4biBpcyBkdWFsIGxpY2Vuc2VkIEdQTHYyIG9yIGxhdGVyIGFuZCBNSVQuIFlvdSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIHRvIGNob29zZSBvbmUgbGljZW5zZSBvciB0aGUgb3RoZXIgYW5kIHlvdSBkb24ndCBoYXZlIHRvXG4gKiBub3RpZnkgYW55b25lIHdoaWNoIGxpY2Vuc2UgeW91IGFyZSB1c2luZy4gWW91IGFyZSBmcmVlIHRvIHVzZVxuICogVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpbiBjb21tZXJjaWFsIHByb2plY3RzIGFzIGxvbmcgYXMgdGhlIGNvcHlyaWdodFxuICogaGVhZGVyIGlzIGxlZnQgaW50YWN0LiBTZWUgZmlsZXMgR1BMLUxJQ0VOU0UgYW5kIE1JVC1MSUNFTlNFIGZvciBkZXRhaWxzLlxuICpcbiAqIEBsaWNlbmNlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbmNlIDIuMCBvciBsYXRlclxuICogQGxpY2VuY2UgTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uICggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBNZXNzYWdlUGFyc2VyID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgJC5pMThuLnBhcnNlci5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHRcdHRoaXMubGFuZ3VhZ2UgPSAkLmkxOG4ubGFuZ3VhZ2VzWyBTdHJpbmcubG9jYWxlIF0gfHwgJC5pMThuLmxhbmd1YWdlc1sgJ2RlZmF1bHQnIF07XG5cdFx0dGhpcy5lbWl0dGVyID0gJC5pMThuLnBhcnNlci5lbWl0dGVyO1xuXHR9O1xuXG5cdE1lc3NhZ2VQYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IE1lc3NhZ2VQYXJzZXIsXG5cblx0XHRzaW1wbGVQYXJzZTogZnVuY3Rpb24gKCBtZXNzYWdlLCBwYXJhbWV0ZXJzICkge1xuXHRcdFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSggL1xcJChcXGQrKS9nLCBmdW5jdGlvbiAoIHN0ciwgbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCBtYXRjaCwgMTAgKSAtIDE7XG5cblx0XHRcdFx0cmV0dXJuIHBhcmFtZXRlcnNbIGluZGV4IF0gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnNbIGluZGV4IF0gOiAnJCcgKyBtYXRjaDtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggbWVzc2FnZSwgcmVwbGFjZW1lbnRzICkge1xuXHRcdFx0aWYgKCBtZXNzYWdlLmluZGV4T2YoICd7eycgKSA8IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNpbXBsZVBhcnNlKCBtZXNzYWdlLCByZXBsYWNlbWVudHMgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbWl0dGVyLmxhbmd1YWdlID0gJC5pMThuLmxhbmd1YWdlc1sgJC5pMThuKCkubG9jYWxlIF0gfHxcblx0XHRcdFx0JC5pMThuLmxhbmd1YWdlc1sgJ2RlZmF1bHQnIF07XG5cblx0XHRcdHJldHVybiB0aGlzLmVtaXR0ZXIuZW1pdCggdGhpcy5hc3QoIG1lc3NhZ2UgKSwgcmVwbGFjZW1lbnRzICk7XG5cdFx0fSxcblxuXHRcdGFzdDogZnVuY3Rpb24gKCBtZXNzYWdlICkge1xuXHRcdFx0dmFyIHBpcGUsIGNvbG9uLCBiYWNrc2xhc2gsIGFueUNoYXJhY3RlciwgZG9sbGFyLCBkaWdpdHMsIHJlZ3VsYXJMaXRlcmFsLFxuXHRcdFx0XHRyZWd1bGFyTGl0ZXJhbFdpdGhvdXRCYXIsIHJlZ3VsYXJMaXRlcmFsV2l0aG91dFNwYWNlLCBlc2NhcGVkT3JMaXRlcmFsV2l0aG91dEJhcixcblx0XHRcdFx0ZXNjYXBlZE9yUmVndWxhckxpdGVyYWwsIHRlbXBsYXRlQ29udGVudHMsIHRlbXBsYXRlTmFtZSwgb3BlblRlbXBsYXRlLFxuXHRcdFx0XHRjbG9zZVRlbXBsYXRlLCBleHByZXNzaW9uLCBwYXJhbUV4cHJlc3Npb24sIHJlc3VsdCxcblx0XHRcdFx0cG9zID0gMDtcblxuXHRcdFx0Ly8gVHJ5IHBhcnNlcnMgdW50aWwgb25lIHdvcmtzLCBpZiBub25lIHdvcmsgcmV0dXJuIG51bGxcblx0XHRcdGZ1bmN0aW9uIGNob2ljZSggcGFyc2VyU3ludGF4ICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBpLCByZXN1bHQ7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnNlclN5bnRheC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHBhcnNlclN5bnRheFsgaSBdKCk7XG5cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcnkgc2V2ZXJhbCBwYXJzZXJTeW50YXgtZXMgaW4gYSByb3cuXG5cdFx0XHQvLyBBbGwgbXVzdCBzdWNjZWVkOyBvdGhlcndpc2UsIHJldHVybiBudWxsLlxuXHRcdFx0Ly8gVGhpcyBpcyB0aGUgb25seSBlYWdlciBvbmUuXG5cdFx0XHRmdW5jdGlvbiBzZXF1ZW5jZSggcGFyc2VyU3ludGF4ICkge1xuXHRcdFx0XHR2YXIgaSwgcmVzLFxuXHRcdFx0XHRcdG9yaWdpbmFsUG9zID0gcG9zLFxuXHRcdFx0XHRcdHJlc3VsdCA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFyc2VyU3ludGF4Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHJlcyA9IHBhcnNlclN5bnRheFsgaSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIHJlcyA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHBvcyA9IG9yaWdpbmFsUG9zO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXN1bHQucHVzaCggcmVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSdW4gdGhlIHNhbWUgcGFyc2VyIG92ZXIgYW5kIG92ZXIgdW50aWwgaXQgZmFpbHMuXG5cdFx0XHQvLyBNdXN0IHN1Y2NlZWQgYSBtaW5pbXVtIG9mIG4gdGltZXM7IG90aGVyd2lzZSwgcmV0dXJuIG51bGwuXG5cdFx0XHRmdW5jdGlvbiBuT3JNb3JlKCBuLCBwICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBvcmlnaW5hbFBvcyA9IHBvcyxcblx0XHRcdFx0XHRcdHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdFx0cGFyc2VkID0gcCgpO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCBwYXJzZWQgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggcGFyc2VkICk7XG5cdFx0XHRcdFx0XHRwYXJzZWQgPSBwKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCByZXN1bHQubGVuZ3RoIDwgbiApIHtcblx0XHRcdFx0XHRcdHBvcyA9IG9yaWdpbmFsUG9zO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIZWxwZXJzIC0tIGp1c3QgbWFrZSBwYXJzZXJTeW50YXggb3V0IG9mIHNpbXBsZXIgSlMgYnVpbHRpbiB0eXBlc1xuXG5cdFx0XHRmdW5jdGlvbiBtYWtlU3RyaW5nUGFyc2VyKCBzICkge1xuXHRcdFx0XHR2YXIgbGVuID0gcy5sZW5ndGg7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0XHRcdGlmICggbWVzc2FnZS5zbGljZSggcG9zLCBwb3MgKyBsZW4gKSA9PT0gcyApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHM7XG5cdFx0XHRcdFx0XHRwb3MgKz0gbGVuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG1ha2VSZWdleFBhcnNlciggcmVnZXggKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoZXMgPSBtZXNzYWdlLnNsaWNlKCBwb3MgKS5tYXRjaCggcmVnZXggKTtcblxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcyA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBvcyArPSBtYXRjaGVzWyAwIF0ubGVuZ3RoO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXNbIDAgXTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cGlwZSA9IG1ha2VTdHJpbmdQYXJzZXIoICd8JyApO1xuXHRcdFx0Y29sb24gPSBtYWtlU3RyaW5nUGFyc2VyKCAnOicgKTtcblx0XHRcdGJhY2tzbGFzaCA9IG1ha2VTdHJpbmdQYXJzZXIoICdcXFxcJyApO1xuXHRcdFx0YW55Q2hhcmFjdGVyID0gbWFrZVJlZ2V4UGFyc2VyKCAvXi4vICk7XG5cdFx0XHRkb2xsYXIgPSBtYWtlU3RyaW5nUGFyc2VyKCAnJCcgKTtcblx0XHRcdGRpZ2l0cyA9IG1ha2VSZWdleFBhcnNlciggL15cXGQrLyApO1xuXHRcdFx0cmVndWxhckxpdGVyYWwgPSBtYWtlUmVnZXhQYXJzZXIoIC9eW157fVtcXF0kXFxcXF0vICk7XG5cdFx0XHRyZWd1bGFyTGl0ZXJhbFdpdGhvdXRCYXIgPSBtYWtlUmVnZXhQYXJzZXIoIC9eW157fVtcXF0kXFxcXHxdLyApO1xuXHRcdFx0cmVndWxhckxpdGVyYWxXaXRob3V0U3BhY2UgPSBtYWtlUmVnZXhQYXJzZXIoIC9eW157fVtcXF0kXFxzXS8gKTtcblxuXHRcdFx0Ly8gVGhlcmUgaXMgYSBnZW5lcmFsIHBhdHRlcm46XG5cdFx0XHQvLyBwYXJzZSBhIHRoaW5nO1xuXHRcdFx0Ly8gaWYgaXQgd29ya2VkLCBhcHBseSB0cmFuc2Zvcm0sXG5cdFx0XHQvLyBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cdFx0XHQvLyBCdXQgdXNpbmcgdGhpcyBhcyBhIGNvbWJpbmF0b3Igc2VlbXMgdG8gY2F1c2UgcHJvYmxlbXNcblx0XHRcdC8vIHdoZW4gY29tYmluZWQgd2l0aCBuT3JNb3JlKCkuXG5cdFx0XHQvLyBNYXkgYmUgc29tZSBzY29waW5nIGlzc3VlLlxuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmb3JtKCBwLCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gcCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG51bGwgOiBmbiggcmVzdWx0ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZWQgdG8gZGVmaW5lIFwibGl0ZXJhbHNcIiB3aXRoaW4gdGVtcGxhdGUgcGFyYW1ldGVycy4gVGhlIHBpcGVcblx0XHRcdC8vIGNoYXJhY3RlciBpcyB0aGUgcGFyYW1ldGVyIGRlbGltZXRlciwgc28gYnkgZGVmYXVsdFxuXHRcdFx0Ly8gaXQgaXMgbm90IGEgbGl0ZXJhbCBpbiB0aGUgcGFyYW1ldGVyXG5cdFx0XHRmdW5jdGlvbiBsaXRlcmFsV2l0aG91dEJhcigpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG5Pck1vcmUoIDEsIGVzY2FwZWRPckxpdGVyYWxXaXRob3V0QmFyICkoKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBudWxsID8gbnVsbCA6IHJlc3VsdC5qb2luKCAnJyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBsaXRlcmFsKCkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gbk9yTW9yZSggMSwgZXNjYXBlZE9yUmVndWxhckxpdGVyYWwgKSgpO1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQgPT09IG51bGwgPyBudWxsIDogcmVzdWx0LmpvaW4oICcnICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGVzY2FwZWRMaXRlcmFsKCkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gc2VxdWVuY2UoIFsgYmFja3NsYXNoLCBhbnlDaGFyYWN0ZXIgXSApO1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQgPT09IG51bGwgPyBudWxsIDogcmVzdWx0WyAxIF07XG5cdFx0XHR9XG5cblx0XHRcdGNob2ljZSggWyBlc2NhcGVkTGl0ZXJhbCwgcmVndWxhckxpdGVyYWxXaXRob3V0U3BhY2UgXSApO1xuXHRcdFx0ZXNjYXBlZE9yTGl0ZXJhbFdpdGhvdXRCYXIgPSBjaG9pY2UoIFsgZXNjYXBlZExpdGVyYWwsIHJlZ3VsYXJMaXRlcmFsV2l0aG91dEJhciBdICk7XG5cdFx0XHRlc2NhcGVkT3JSZWd1bGFyTGl0ZXJhbCA9IGNob2ljZSggWyBlc2NhcGVkTGl0ZXJhbCwgcmVndWxhckxpdGVyYWwgXSApO1xuXG5cdFx0XHRmdW5jdGlvbiByZXBsYWNlbWVudCgpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlcXVlbmNlKCBbIGRvbGxhciwgZGlnaXRzIF0gKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbICdSRVBMQUNFJywgcGFyc2VJbnQoIHJlc3VsdFsgMSBdLCAxMCApIC0gMSBdO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZW1wbGF0ZU5hbWUgPSB0cmFuc2Zvcm0oXG5cdFx0XHRcdC8vIHNlZSAkd2dMZWdhbFRpdGxlQ2hhcnNcblx0XHRcdFx0Ly8gbm90IGFsbG93aW5nIDogZHVlIHRvIHRoZSBuZWVkIHRvIGNhdGNoIFwiUExVUkFMOiQxXCJcblx0XHRcdFx0bWFrZVJlZ2V4UGFyc2VyKCAvXlsgIVwiJCYnKCkqLC4vMC05Oz0/QEEtWl5fYGEten5cXHg4MC1cXHhGRistXSsvICksXG5cblx0XHRcdFx0ZnVuY3Rpb24gKCByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHRmdW5jdGlvbiB0ZW1wbGF0ZVBhcmFtKCkge1xuXHRcdFx0XHR2YXIgZXhwcixcblx0XHRcdFx0XHRyZXN1bHQgPSBzZXF1ZW5jZSggWyBwaXBlLCBuT3JNb3JlKCAwLCBwYXJhbUV4cHJlc3Npb24gKSBdICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRleHByID0gcmVzdWx0WyAxIF07XG5cblx0XHRcdFx0Ly8gdXNlIGEgXCJDT05DQVRcIiBvcGVyYXRvciBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbm9kZXMsXG5cdFx0XHRcdC8vIG90aGVyd2lzZSByZXR1cm4gdGhlIGZpcnN0IG5vZGUsIHJhdy5cblx0XHRcdFx0cmV0dXJuIGV4cHIubGVuZ3RoID4gMSA/IFsgJ0NPTkNBVCcgXS5jb25jYXQoIGV4cHIgKSA6IGV4cHJbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdGVtcGxhdGVXaXRoUmVwbGFjZW1lbnQoKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBzZXF1ZW5jZSggWyB0ZW1wbGF0ZU5hbWUsIGNvbG9uLCByZXBsYWNlbWVudCBdICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG51bGwgOiBbIHJlc3VsdFsgMCBdLCByZXN1bHRbIDIgXSBdO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0ZW1wbGF0ZVdpdGhPdXRSZXBsYWNlbWVudCgpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlcXVlbmNlKCBbIHRlbXBsYXRlTmFtZSwgY29sb24sIHBhcmFtRXhwcmVzc2lvbiBdICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG51bGwgOiBbIHJlc3VsdFsgMCBdLCByZXN1bHRbIDIgXSBdO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZW1wbGF0ZUNvbnRlbnRzID0gY2hvaWNlKCBbXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcmVzID0gc2VxdWVuY2UoIFtcblx0XHRcdFx0XHRcdC8vIHRlbXBsYXRlcyBjYW4gaGF2ZSBwbGFjZWhvbGRlcnMgZm9yIGR5bmFtaWNcblx0XHRcdFx0XHRcdC8vIHJlcGxhY2VtZW50IGVnOiB7e1BMVVJBTDokMXxvbmUgY2FyfCQxIGNhcnN9fVxuXHRcdFx0XHRcdFx0Ly8gb3Igbm8gcGxhY2Vob2xkZXJzIGVnOlxuXHRcdFx0XHRcdFx0Ly8ge3tHUkFNTUFSOmdlbml0aXZlfHt7U0lURU5BTUV9fX1cblx0XHRcdFx0XHRcdGNob2ljZSggWyB0ZW1wbGF0ZVdpdGhSZXBsYWNlbWVudCwgdGVtcGxhdGVXaXRoT3V0UmVwbGFjZW1lbnQgXSApLFxuXHRcdFx0XHRcdFx0bk9yTW9yZSggMCwgdGVtcGxhdGVQYXJhbSApXG5cdFx0XHRcdFx0XSApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlcyA9PT0gbnVsbCA/IG51bGwgOiByZXNbIDAgXS5jb25jYXQoIHJlc1sgMSBdICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcmVzID0gc2VxdWVuY2UoIFsgdGVtcGxhdGVOYW1lLCBuT3JNb3JlKCAwLCB0ZW1wbGF0ZVBhcmFtICkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXMgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gWyByZXNbIDAgXSBdLmNvbmNhdCggcmVzWyAxIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XSApO1xuXG5cdFx0XHRvcGVuVGVtcGxhdGUgPSBtYWtlU3RyaW5nUGFyc2VyKCAne3snICk7XG5cdFx0XHRjbG9zZVRlbXBsYXRlID0gbWFrZVN0cmluZ1BhcnNlciggJ319JyApO1xuXG5cdFx0XHRmdW5jdGlvbiB0ZW1wbGF0ZSgpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlcXVlbmNlKCBbIG9wZW5UZW1wbGF0ZSwgdGVtcGxhdGVDb250ZW50cywgY2xvc2VUZW1wbGF0ZSBdICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG51bGwgOiByZXN1bHRbIDEgXTtcblx0XHRcdH1cblxuXHRcdFx0ZXhwcmVzc2lvbiA9IGNob2ljZSggWyB0ZW1wbGF0ZSwgcmVwbGFjZW1lbnQsIGxpdGVyYWwgXSApO1xuXHRcdFx0cGFyYW1FeHByZXNzaW9uID0gY2hvaWNlKCBbIHRlbXBsYXRlLCByZXBsYWNlbWVudCwgbGl0ZXJhbFdpdGhvdXRCYXIgXSApO1xuXG5cdFx0XHRmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG5Pck1vcmUoIDAsIGV4cHJlc3Npb24gKSgpO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFsgJ0NPTkNBVCcgXS5jb25jYXQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSBzdGFydCgpO1xuXG5cdFx0XHQvKlxuXHRcdFx0ICogRm9yIHN1Y2Nlc3MsIHRoZSBwb3MgbXVzdCBoYXZlIGdvdHRlbiB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuXHRcdFx0ICogYW5kIHJldHVybmVkIGEgbm9uLW51bGwuXG5cdFx0XHQgKiBuLmIuIFRoaXMgaXMgcGFydCBvZiBsYW5ndWFnZSBpbmZyYXN0cnVjdHVyZSwgc28gd2UgZG8gbm90IHRocm93IGFuXG5cdFx0XHQgKiBpbnRlcm5hdGlvbmFsaXphYmxlIG1lc3NhZ2UuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggcmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gbWVzc2FnZS5sZW5ndGggKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1BhcnNlIGVycm9yIGF0IHBvc2l0aW9uICcgKyBwb3MudG9TdHJpbmcoKSArICcgaW4gaW5wdXQ6ICcgKyBtZXNzYWdlICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdH07XG5cblx0JC5leHRlbmQoICQuaTE4bi5wYXJzZXIsIG5ldyBNZXNzYWdlUGFyc2VyKCkgKTtcbn0oIGpRdWVyeSApICk7XG4iLCIvKipcbiAqIEZpbm5pc2ggKFN1b21pKSBsYW5ndWFnZSBmdW5jdGlvbnNcbiAqXG4gKiBAYXV0aG9yIFNhbnRob3NoIFRob3R0aW5nYWxcbiAqL1xuXG4oIGZ1bmN0aW9uICggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdCQuaTE4bi5sYW5ndWFnZXMuZmkgPSAkLmV4dGVuZCgge30sICQuaTE4bi5sYW5ndWFnZXNbICdkZWZhdWx0JyBdLCB7XG5cdFx0Y29udmVydEdyYW1tYXI6IGZ1bmN0aW9uICggd29yZCwgZm9ybSApIHtcblx0XHRcdC8vIHZvd2VsIGhhcm1vbnkgZmxhZ1xuXHRcdFx0dmFyIGFvdSA9IHdvcmQubWF0Y2goIC9bYW91XVtew6TDtnldKiQvaSApLFxuXHRcdFx0XHRvcmlnV29yZCA9IHdvcmQ7XG5cdFx0XHRpZiAoIHdvcmQubWF0Y2goIC93aWtpJC9pICkgKSB7XG5cdFx0XHRcdGFvdSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBlbmQgaSBhZnRlciBmaW5hbCBjb25zb25hbnRcblx0XHRcdGlmICggd29yZC5tYXRjaCggL1tiY2RmZ2hqa2xtbnBxcnN0dnd4el0kL2kgKSApIHtcblx0XHRcdFx0d29yZCArPSAnaSc7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIGZvcm0gKSB7XG5cdFx0XHRcdGNhc2UgJ2dlbml0aXZlJzpcblx0XHRcdFx0XHR3b3JkICs9ICduJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZWxhdGl2ZSc6XG5cdFx0XHRcdFx0d29yZCArPSAoIGFvdSA/ICdzdGEnIDogJ3N0w6QnICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3BhcnRpdGl2ZSc6XG5cdFx0XHRcdFx0d29yZCArPSAoIGFvdSA/ICdhJyA6ICfDpCcgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaWxsYXRpdmUnOlxuXHRcdFx0XHQvLyBEb3VibGUgdGhlIGxhc3QgbGV0dGVyIGFuZCBhZGQgJ24nXG5cdFx0XHRcdFx0d29yZCArPSB3b3JkLnNsaWNlKCAtMSApICsgJ24nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdpbmVzc2l2ZSc6XG5cdFx0XHRcdFx0d29yZCArPSAoIGFvdSA/ICdzc2EnIDogJ3Nzw6QnICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0d29yZCA9IG9yaWdXb3JkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gd29yZDtcblx0XHR9XG5cdH0gKTtcbn0oIGpRdWVyeSApICk7XG4iLCIvKipcbiAqIEhlYnJldyAo16LXkdeo15nXqikgbGFuZ3VhZ2UgZnVuY3Rpb25zXG4gKi9cbiggZnVuY3Rpb24gKCAkICkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0JC5pMThuLmxhbmd1YWdlcy5oZSA9ICQuZXh0ZW5kKCB7fSwgJC5pMThuLmxhbmd1YWdlc1sgJ2RlZmF1bHQnIF0sIHtcblx0XHRjb252ZXJ0R3JhbW1hcjogZnVuY3Rpb24gKCB3b3JkLCBmb3JtICkge1xuXHRcdFx0c3dpdGNoICggZm9ybSApIHtcblx0XHRcdFx0Y2FzZSAncHJlZml4ZWQnOlxuXHRcdFx0XHRjYXNlICfXqteX15nXnNeZ16onOiAvLyB0aGUgc2FtZSB3b3JkIGluIEhlYnJld1xuXHRcdFx0XHRcdC8vIER1cGxpY2F0ZSBwcmVmaXhlZCBcIldhd1wiLCBidXQgb25seSBpZiBpdCdzIG5vdCBhbHJlYWR5IGRvdWJsZVxuXHRcdFx0XHRcdGlmICggd29yZC5zbGljZSggMCwgMSApID09PSAn15UnICYmIHdvcmQuc2xpY2UoIDAsIDIgKSAhPT0gJ9eV15UnICkge1xuXHRcdFx0XHRcdFx0d29yZCA9ICfXlScgKyB3b3JkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbW92ZSB0aGUgXCJIZVwiIGlmIHByZWZpeGVkXG5cdFx0XHRcdFx0aWYgKCB3b3JkLnNsaWNlKCAwLCAxICkgPT09ICfXlCcgKSB7XG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkZCBhIGh5cGhlbiAobWFxYWYpIGJlZm9yZSBudW1iZXJzIGFuZCBub24tSGVicmV3IGxldHRlcnNcblx0XHRcdFx0XHRpZiAoIHdvcmQuc2xpY2UoIDAsIDEgKSA8ICfXkCcgfHwgd29yZC5zbGljZSggMCwgMSApID4gJ9eqJyApIHtcblx0XHRcdFx0XHRcdHdvcmQgPSAn1r4nICsgd29yZDtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3b3JkO1xuXHRcdH1cblx0fSApO1xufSggalF1ZXJ5ICkgKTtcbiIsIi8qKlxuICogTWFsYXlhbGFtIGxhbmd1YWdlIGZ1bmN0aW9uc1xuICpcbiAqIEBhdXRob3IgU2FudGhvc2ggVGhvdHRpbmdhbFxuICovXG5cbiggZnVuY3Rpb24gKCAkICkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0JC5pMThuLmxhbmd1YWdlcy5tbCA9ICQuZXh0ZW5kKCB7fSwgJC5pMThuLmxhbmd1YWdlc1sgJ2RlZmF1bHQnIF0sIHtcblx0XHRjb252ZXJ0R3JhbW1hcjogZnVuY3Rpb24gKCB3b3JkLCBmb3JtICkge1xuXHRcdFx0Zm9ybSA9IGZvcm0udG9Mb3dlckNhc2UoKTtcblx0XHRcdHN3aXRjaCAoIGZvcm0gKSB7XG5cdFx0XHRcdGNhc2UgJ+C0ieC0puC1jeC0puC1h+C0tuC0v+C0lSc6XG5cdFx0XHRcdGNhc2UgJ2RhdGl2ZSc6XG5cdFx0XHRcdFx0aWYgKCB3b3JkLnNsaWNlKCAtMSApID09PSAn4LWBJyB8fFxuXHRcdFx0XHRcdFx0d29yZC5zbGljZSggLTEgKSA9PT0gJ+C1gicgfHxcblx0XHRcdFx0XHRcdHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtZcnIHx8XG5cdFx0XHRcdFx0XHR3b3JkLnNsaWNlKCAtMSApID09PSAn4LWMJ1xuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0d29yZCArPSAn4LS14LS/4LSo4LWNJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMSApID09PSAn4LSCJyApIHtcblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMSApICsgJ+C0pOC1jeC0pOC0v+C0qOC1jSc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggd29yZC5zbGljZSggLTEgKSA9PT0gJ+C1uycgKSB7XG5cdFx0XHRcdFx0XHQvLyBBdG9taWMgY2hpbGx1IG4uIOC0heC0teC1uyAtPiDgtIXgtLXgtKjgtY1cblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMSApICsgJ+C0qOC1jSc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggd29yZC5zbGljZSggLTMgKSA9PT0gJ+C0qOC1jVxcdTIwMGQnICkge1xuXHRcdFx0XHRcdFx0Ly8gY2hpbGx1IG4uIOC0heC0teC1uyAtPiDgtIXgtLXgtKjgtY1cblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtb4nIHx8IHdvcmQuc2xpY2UoIC0zICkgPT09ICfgtLPgtY1cXHUyMDBkJyApIHtcblx0XHRcdFx0XHRcdHdvcmQgKz0gJ+C0leC1jeC0leC1jSc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggd29yZC5zbGljZSggLTEgKSA9PT0gJ+C1vCcgfHwgd29yZC5zbGljZSggLTMgKSA9PT0gJ+C0sOC1jVxcdTIwMGQnICkge1xuXHRcdFx0XHRcdFx0d29yZCArPSAn4LSV4LWN4LSV4LWNJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMSApID09PSAn4LW9JyApIHtcblx0XHRcdFx0XHRcdC8vIEF0b21pYyBjaGlsbHUg4LW9ICwg4LSr4LSv4LW9IC0+IOC0q+C0r+C0suC0v+C0qOC1jVxuXHRcdFx0XHRcdFx0d29yZCA9IHdvcmQuc2xpY2UoIDAsIC0xICkgKyAn4LSy4LS/4LSo4LWNJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMyApID09PSAn4LSy4LWNXFx1MjAwZCcgKSB7XG5cdFx0XHRcdFx0XHQvLyBjaGlsbHUg4LSy4LWNXFx1MjAwZCAsIOC0q+C0r+C0suC1jVxcdTIwMGQgLT4g4LSr4LSv4LSy4LS/4LSo4LWNXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTIgKSArICfgtL/gtKjgtY0nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0yICkgPT09ICfgtYHgtY0nICkge1xuXHRcdFx0XHRcdFx0d29yZCA9IHdvcmQuc2xpY2UoIDAsIC0yICkgKyAn4LS/4LSo4LWNJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMSApID09PSAn4LWNJyApIHtcblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMSApICsgJ+C0v+C0qOC1jSc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIOC0leC0vuC0teC1jeC0ryAtPiDgtJXgtL7gtLXgtY3gtK/gtK/gtY3gtJXgtY3gtJXgtY0sIOC0ueC0sOC0vyAtPiDgtLngtLDgtL/gtK/gtY3gtJXgtY3gtJXgtY0sIOC0ruC0siAtPiDgtK7gtLLgtK/gtY3gtJXgtY3gtJXgtY1cblx0XHRcdFx0XHRcdHdvcmQgKz0gJ+C0r+C1jeC0leC1jeC0leC1jSc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ+C0uOC0guC0rOC0qOC1jeC0p+C0v+C0lSc6XG5cdFx0XHRcdGNhc2UgJ2dlbml0aXZlJzpcblx0XHRcdFx0XHRpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtIInICkge1xuXHRcdFx0XHRcdFx0d29yZCA9IHdvcmQuc2xpY2UoIDAsIC0xICkgKyAn4LSk4LWN4LSk4LS/4LSo4LWN4LSx4LWGJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMiApID09PSAn4LWB4LWNJyApIHtcblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMiApICsgJ+C0v+C0qOC1jeC0seC1hic7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggd29yZC5zbGljZSggLTEgKSA9PT0gJ+C1jScgKSB7XG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTEgKSArICfgtL/gtKjgtY3gtLHgtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtYEnIHx8XG5cdFx0XHRcdFx0XHR3b3JkLnNsaWNlKCAtMSApID09PSAn4LWCJyB8fFxuXHRcdFx0XHRcdFx0d29yZC5zbGljZSggLTEgKSA9PT0gJ+C1lycgfHxcblx0XHRcdFx0XHRcdHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtYwnXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR3b3JkICs9ICfgtLXgtL/gtKjgtY3gtLHgtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtbsnICkge1xuXHRcdFx0XHRcdFx0Ly8gQXRvbWljIGNoaWxsdSBuLiDgtIXgtLXgtbsgLT4g4LSF4LS14LSo4LWN4LSx4LWGXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTEgKSArICfgtKjgtY3gtLHgtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0zICkgPT09ICfgtKjgtY1cXHUyMDBkJyApIHtcblx0XHRcdFx0XHRcdC8vIGNoaWxsdSBuLiDgtIXgtLXgtbsgLT4g4LSF4LS14LSo4LWN4LSx4LWGXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTEgKSArICfgtLHgtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0zICkgPT09ICfgtLPgtY1cXHUyMDBkJyApIHtcblx0XHRcdFx0XHRcdC8vIGNoaWxsdSBuLiDgtIXgtLXgtb4gLT4g4LSF4LS14LSz4LWB4LSf4LWGXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTIgKSArICfgtYHgtJ/gtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtb4nICkge1xuXHRcdFx0XHRcdFx0Ly8gQXRvbWljIGNoaWxsdSBuLiDgtIXgtLXgtLPgtY1cXHUyMDBkIC0+IOC0heC0teC0s+C1geC0n+C1hlxuXHRcdFx0XHRcdFx0d29yZCA9IHdvcmQuc2xpY2UoIDAsIC0xICkgKyAn4LSz4LWB4LSf4LWGJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMSApID09PSAn4LW9JyApIHtcblx0XHRcdFx0XHRcdC8vIEF0b21pYyBsLiDgtK7gtYHgtK/gtLLgtY1cXHUyMDBkIC0+IOC0ruC1geC0r+C0suC0v+C0qOC1jeC0seC1hlxuXHRcdFx0XHRcdFx0d29yZCA9IHdvcmQuc2xpY2UoIDAsIC0xICkgKyAn4LSy4LS/4LSo4LWN4LSx4LWGJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB3b3JkLnNsaWNlKCAtMyApID09PSAn4LSy4LWNXFx1MjAwZCcgKSB7XG5cdFx0XHRcdFx0XHQvLyBjaGlsbHUgbC4g4LSu4LWB4LSv4LSy4LWNXFx1MjAwZCAtPiDgtIXgtLXgtLPgtYHgtJ/gtYZcblx0XHRcdFx0XHRcdHdvcmQgPSB3b3JkLnNsaWNlKCAwLCAtMiApICsgJ+C0v+C0qOC1jeC0seC1hic7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggd29yZC5zbGljZSggLTMgKSA9PT0gJ+C0sOC1jVxcdTIwMGQnICkge1xuXHRcdFx0XHRcdFx0Ly8gY2hpbGx1IHIuIOC0heC0teC0sOC1jVxcdTIwMGQgLT4g4LSF4LS14LSw4LWB4LSf4LWGXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTIgKSArICfgtYHgtJ/gtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHdvcmQuc2xpY2UoIC0xICkgPT09ICfgtbwnICkge1xuXHRcdFx0XHRcdFx0Ly8gQXRvbWljIGNoaWxsdSByLiDgtIXgtLXgtbwgLT4g4LSF4LS14LSw4LWB4LSf4LWGXG5cdFx0XHRcdFx0XHR3b3JkID0gd29yZC5zbGljZSggMCwgLTEgKSArICfgtLDgtYHgtJ/gtYYnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR3b3JkICs9ICfgtK/gtYHgtJ/gtYYnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gd29yZDtcblx0XHR9XG5cdH0gKTtcbn0oIGpRdWVyeSApICk7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvKipcbiAqIFVuaXZlcnNhbCBMYW5ndWFnZSBTZWxlY3RvclxuICogVUxTIGNvcmUgY29tcG9uZW50LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMiBBbG9saXRhIFNoYXJtYSwgQW1pciBBaGFyb25pLCBBcnVuIEdhbmVzaCwgQnJhbmRvbiBIYXJyaXMsXG4gKiBOaWtsYXMgTGF4c3Ryw7ZtLCBQYXUgR2luZXIsIFNhbnRob3NoIFRob3R0aW5nYWwsIFNpZWJyYW5kIE1hemVsYW5kIGFuZCBvdGhlclxuICogY29udHJpYnV0b3JzLiBTZWUgQ1JFRElUUyBmb3IgYSBsaXN0LlxuICpcbiAqIFVuaXZlcnNhbExhbmd1YWdlU2VsZWN0b3IgaXMgZHVhbCBsaWNlbnNlZCBHUEx2MiBvciBsYXRlciBhbmQgTUlULiBZb3UgZG9uJ3RcbiAqIGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCB0byBjaG9vc2Ugb25lIGxpY2Vuc2Ugb3IgdGhlIG90aGVyIGFuZCB5b3UgZG9uJ3RcbiAqIGhhdmUgdG8gbm90aWZ5IGFueW9uZSB3aGljaCBsaWNlbnNlIHlvdSBhcmUgdXNpbmcuIFlvdSBhcmUgZnJlZSB0byB1c2VcbiAqIFVuaXZlcnNhbExhbmd1YWdlU2VsZWN0b3IgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyBhcyBsb25nIGFzIHRoZSBjb3B5cmlnaHRcbiAqIGhlYWRlciBpcyBsZWZ0IGludGFjdC4gU2VlIGZpbGVzIEdQTC1MSUNFTlNFIGFuZCBNSVQtTElDRU5TRSBmb3IgZGV0YWlscy5cbiAqXG4gKiBAZmlsZVxuICogQGluZ3JvdXAgRXh0ZW5zaW9uc1xuICogQGxpY2VuY2UgR05VIEdlbmVyYWwgUHVibGljIExpY2VuY2UgMi4wIG9yIGxhdGVyXG4gKiBAbGljZW5jZSBNSVQgTGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24gKCAkICkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHRlbXBsYXRlLCBVTFM7XG5cblx0Ly8gUmVnaW9uIG51bWJlcnMgaW4gaWQgYXR0cmlidXRlcyBhbHNvIGFwcGVhciBpbiB0aGUgbGFuZ2RiLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktc3RyXG5cdHRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJncmlkIHVscy1tZW51XCI+IFxcXG5cdFx0XHQ8ZGl2IGlkPVwic2VhcmNoXCIgY2xhc3M9XCJyb3cgdWxzLXNlYXJjaFwiPiBcXFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidWxzLXNlYXJjaC13cmFwcGVyXCI+IFxcXG5cdFx0XHRcdFx0PGxhYmVsIGNsYXNzPVwidWxzLXNlYXJjaC1sYWJlbFwiIGZvcj1cInVscy1sYW5ndWFnZWZpbHRlclwiPjwvbGFiZWw+XFxcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidWxzLXNlYXJjaC1pbnB1dC13cmFwcGVyXCI+XFxcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidWxzLWxhbmd1YWdlZmlsdGVyLWNsZWFyXCI+PC9zcGFuPlxcXG5cdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInVscy1maWx0ZXJpbnB1dCB1bHMtZmlsdGVyc3VnZ2VzdGlvblwiXFxcblx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9XCJ0cnVlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCI+XFxcblx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwidWxzLWZpbHRlcmlucHV0IHVscy1sYW5ndWFnZWZpbHRlclwiXFxcblx0XHRcdFx0XHRcdFx0bWF4bGVuZ3RoPVwiNDBcIlxcXG5cdFx0XHRcdFx0XHRcdGRhdGEtY2xlYXI9XCJ1bHMtbGFuZ3VhZ2VmaWx0ZXItY2xlYXJcIlxcXG5cdFx0XHRcdFx0XHRcdGRhdGEtc3VnZ2VzdGlvbj1cInVscy1maWx0ZXJzdWdnZXN0aW9uXCJcXFxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIlNlYXJjaCBmb3IgYSBsYW5ndWFnZVwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiPlxcXG5cdFx0XHRcdFx0PC9kaXY+XFxcblx0XHRcdFx0PC9kaXY+XFxcblx0XHRcdDwvZGl2PlxcXG5cdFx0XHQ8ZGl2IGNsYXNzPVwicm93IHVscy1sYW5ndWFnZS1saXN0XCI+PC9kaXY+XFxcblx0XHRcdDxkaXYgY2xhc3M9XCJyb3dcIiBpZD1cInVscy1zZXR0aW5ncy1ibG9ja1wiPjwvZGl2PlxcXG5cdFx0PC9kaXY+JztcblxuXHQvKipcblx0ICogVUxTIFB1YmxpYyBjbGFzcyBkZWZpbml0aW9uXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0VUxTID0gZnVuY3Rpb24gKCBlbGVtZW50LCBvcHRpb25zICkge1xuXHRcdHZhciBjb2RlO1xuXHRcdHRoaXMuJGVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoIHt9LCAkLmZuLnVscy5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHRcdHRoaXMuJG1lbnUgPSAkKCB0ZW1wbGF0ZSApO1xuXHRcdHRoaXMubGFuZ3VhZ2VzID0gdGhpcy5vcHRpb25zLmxhbmd1YWdlcztcblxuXHRcdGZvciAoIGNvZGUgaW4gdGhpcy5sYW5ndWFnZXMgKSB7XG5cdFx0XHRpZiAoICQudWxzLmRhdGEubGFuZ3VhZ2VzWyBjb2RlIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gTGFuZ3VhZ2UgaXMgdW5rbm93biB0byBVTFMuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmxhbmd1YWdlc1sgY29kZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMubGVmdCA9IHRoaXMub3B0aW9ucy5sZWZ0O1xuXHRcdHRoaXMudG9wID0gdGhpcy5vcHRpb25zLnRvcDtcblx0XHR0aGlzLnNob3duID0gZmFsc2U7XG5cdFx0dGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdHRoaXMuc2hvdWxkUmVjcmVhdGUgPSBmYWxzZTtcblx0XHR0aGlzLm1lbnVXaWR0aCA9IHRoaXMuZ2V0TWVudVdpZHRoKCk7XG5cblx0XHR0aGlzLiRsYW5ndWFnZUZpbHRlciA9IHRoaXMuJG1lbnUuZmluZCggJy51bHMtbGFuZ3VhZ2VmaWx0ZXInICk7XG5cdFx0dGhpcy4kcmVzdWx0c1ZpZXcgPSB0aGlzLiRtZW51LmZpbmQoICcudWxzLWxhbmd1YWdlLWxpc3QnICk7XG5cblx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdHRoaXMubGlzdGVuKCk7XG5cdFx0dGhpcy5yZWFkeSgpO1xuXHR9O1xuXG5cdFVMUy5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IFVMUyxcblxuXHRcdC8qKlxuXHRcdCAqIEEgXCJob29rXCIgdGhhdCBydW5zIGFmdGVyIHRoZSBVTFMgY29uc3RydWN0b3IuXG5cdFx0ICogQXQgdGhpcyBwb2ludCBpdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZSBVTFMgaGFzIGl0cyBkaW1lbnNpb25zXG5cdFx0ICogYW5kIHRoYXQgdGhlIGxhbmd1YWdlcyBsaXN0cyBhcmUgaW5pdGlhbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBUbyB1c2UgaXQsIHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgb25SZWFkeSBwYXJhbWV0ZXJcblx0XHQgKiBpbiB0aGUgb3B0aW9ucyB3aGVuIGluaXRpYWxpemluZyBVTFMuXG5cdFx0ICovXG5cdFx0cmVhZHk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLm9uUmVhZHkgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5vblJlYWR5LmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQSBcImhvb2tcIiB0aGF0IHJ1bnMgYWZ0ZXIgdGhlIFVMUyBwYW5lbCBiZWNvbWVzIHZpc2libGVcblx0XHQgKiBieSB1c2luZyB0aGUgc2hvdyBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBUbyB1c2UgaXQsIHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgb25WaXNpYmxlIHBhcmFtZXRlclxuXHRcdCAqIGluIHRoZSBvcHRpb25zIHdoZW4gaW5pdGlhbGl6aW5nIFVMUy5cblx0XHQgKi9cblx0XHR2aXNpYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5vblZpc2libGUgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5vblZpc2libGUuY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIFVMU1xuXHRcdCAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXMuXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9zLFxuXHRcdFx0XHR0b3AgPSB0aGlzLnRvcCxcblx0XHRcdFx0bGVmdCA9IHRoaXMubGVmdDtcblxuXHRcdFx0aWYgKCB0b3AgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cG9zID0gJC5leHRlbmQoIHt9LCB0aGlzLiRlbGVtZW50Lm9mZnNldCgpLCB7XG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLiRlbGVtZW50WyAwIF0ub2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dG9wID0gcG9zLnRvcCArIHBvcy5oZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGVmdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRsZWZ0ID0gJCggd2luZG93ICkud2lkdGgoKSAvIDIgLSB0aGlzLiRtZW51Lm91dGVyV2lkdGgoKSAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogdG9wLFxuXHRcdFx0XHRsZWZ0OiBsZWZ0XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaG93IHRoZSBVTFMgd2luZG93XG5cdFx0ICovXG5cdFx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdpZHRoQ2xhc3NlcyA9IHtcblx0XHRcdFx0d2lkZTogJ3Vscy13aWRlJyxcblx0XHRcdFx0bWVkaXVtOiAndWxzLW1lZGl1bScsXG5cdFx0XHRcdG5hcnJvdzogJ3Vscy1uYXJyb3cnXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLiRtZW51LmFkZENsYXNzKCB3aWR0aENsYXNzZXNbIHRoaXMubWVudVdpZHRoIF0gKTtcblxuXHRcdFx0aWYgKCAhdGhpcy5pbml0aWFsaXplZCApIHtcblx0XHRcdFx0JCggJ2JvZHknICkucHJlcGVuZCggdGhpcy4kbWVudSApO1xuXHRcdFx0XHR0aGlzLmkxOG4oKTtcblx0XHRcdFx0dGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuJG1lbnUuY3NzKCB0aGlzLnBvc2l0aW9uKCkgKTtcblx0XHRcdHRoaXMuJG1lbnUuc2hvdygpO1xuXHRcdFx0dGhpcy4kbWVudS5zY3JvbGxJbnRvVmlldygpO1xuXHRcdFx0dGhpcy5zaG93biA9IHRydWU7XG5cblx0XHRcdGlmICggIXRoaXMuaXNNb2JpbGUoKSApIHtcblx0XHRcdFx0dGhpcy4kbGFuZ3VhZ2VGaWx0ZXIuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aXNpYmxlKCk7XG5cdFx0fSxcblxuXHRcdGkxOG46IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICggJC5pMThuICkge1xuXHRcdFx0XHR0aGlzLiRtZW51LmZpbmQoICdbZGF0YS1pMThuXScgKS5pMThuKCk7XG5cdFx0XHRcdHRoaXMuJGxhbmd1YWdlRmlsdGVyLnByb3AoICdwbGFjZWhvbGRlcicsICQuaTE4biggJ3Vscy1zZWFyY2gtcGxhY2Vob2xkZXInICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlkZSB0aGUgVUxTIHdpbmRvd1xuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuJG1lbnUuaGlkZSgpO1xuXHRcdFx0dGhpcy5zaG93biA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLiRtZW51LnJlbW92ZUNsYXNzKCAndWxzLXdpZGUgdWxzLW1lZGl1bSB1bHMtbmFycm93JyApO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2hvdWxkUmVjcmVhdGUgKSB7XG5cdFx0XHRcdHRoaXMucmVjcmVhdGVMYW5ndWFnZUZpbHRlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5vbkNhbmNlbCApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLm9uQ2FuY2VsLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSBVSSBlbGVtZW50cy5cblx0XHQgKiBEb2VzIG5vdGhpbmcgYnkgZGVmYXVsdC4gQ2FuIGJlIHVzZWQgZm9yIGN1c3RvbWl6YXRpb24uXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBSZW5kZXJpbmcgc3R1ZmYgaGVyZVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmb3IgcmVzdWx0cyBmb3VuZCBjb250ZXh0LlxuXHRcdCAqL1xuXHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuJHJlc3VsdHNWaWV3LnNob3coKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlTGFuZ3VhZ2VGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsY2QsIGxhbmd1YWdlc0NvdW50LFxuXHRcdFx0XHRjb2x1bW5zT3B0aW9ucyA9IHtcblx0XHRcdFx0XHR3aWRlOiA0LFxuXHRcdFx0XHRcdG1lZGl1bTogMixcblx0XHRcdFx0XHRuYXJyb3c6IDFcblx0XHRcdFx0fTtcblxuXHRcdFx0bGFuZ3VhZ2VzQ291bnQgPSBPYmplY3Qua2V5cyggdGhpcy5vcHRpb25zLmxhbmd1YWdlcyApLmxlbmd0aDtcblx0XHRcdGxjZCA9IHRoaXMuJHJlc3VsdHNWaWV3LmxjZCgge1xuXHRcdFx0XHRsYW5ndWFnZXM6IHRoaXMubGFuZ3VhZ2VzLFxuXHRcdFx0XHRjb2x1bW5zOiBjb2x1bW5zT3B0aW9uc1sgdGhpcy5tZW51V2lkdGggXSxcblxuXHRcdFx0XHRxdWlja0xpc3Q6IGxhbmd1YWdlc0NvdW50ID4gMTIgPyB0aGlzLm9wdGlvbnMucXVpY2tMaXN0IDogW10sXG5cdFx0XHRcdGNsaWNraGFuZGxlcjogdGhpcy5zZWxlY3QuYmluZCggdGhpcyApLFxuXHRcdFx0XHRzaG93UmVnaW9uczogdGhpcy5vcHRpb25zLnNob3dSZWdpb25zLFxuXHRcdFx0XHRsYW5ndWFnZURlY29yYXRvcjogdGhpcy5vcHRpb25zLmxhbmd1YWdlRGVjb3JhdG9yLFxuXHRcdFx0XHRub1Jlc3VsdHNUZW1wbGF0ZTogdGhpcy5vcHRpb25zLm5vUmVzdWx0c1RlbXBsYXRlLFxuXHRcdFx0XHRpdGVtc1BlckNvbHVtbjogdGhpcy5vcHRpb25zLml0ZW1zUGVyQ29sdW1uLFxuXHRcdFx0XHRncm91cEJ5UmVnaW9uOiB0aGlzLm9wdGlvbnMuZ3JvdXBCeVJlZ2lvblxuXHRcdFx0fSApLmRhdGEoICdsY2QnICk7XG5cblx0XHRcdHRoaXMuJGxhbmd1YWdlRmlsdGVyLmxhbmd1YWdlZmlsdGVyKCB7XG5cdFx0XHRcdGxjZDogbGNkLFxuXHRcdFx0XHRsYW5ndWFnZXM6IHRoaXMubGFuZ3VhZ2VzLFxuXHRcdFx0XHR1bHNQdXJwb3NlOiB0aGlzLm9wdGlvbnMudWxzUHVycG9zZSxcblx0XHRcdFx0c2VhcmNoQVBJOiB0aGlzLm9wdGlvbnMuc2VhcmNoQVBJLFxuXHRcdFx0XHRvblNlbGVjdDogdGhpcy5zZWxlY3QuYmluZCggdGhpcyApXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuJGxhbmd1YWdlRmlsdGVyLm9uKCAnbm9yZXN1bHRzLnVscycsIGxjZC5ub1Jlc3VsdHMuYmluZCggbGNkICkgKTtcblx0XHR9LFxuXG5cdFx0cmVjcmVhdGVMYW5ndWFnZUZpbHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy4kcmVzdWx0c1ZpZXcucmVtb3ZlRGF0YSggJ2xjZCcgKTtcblx0XHRcdHRoaXMuJHJlc3VsdHNWaWV3LmVtcHR5KCk7XG5cdFx0XHR0aGlzLiRsYW5ndWFnZUZpbHRlci5yZW1vdmVEYXRhKCAnbGFuZ3VhZ2VmaWx0ZXInICk7XG5cdFx0XHR0aGlzLmNyZWF0ZUxhbmd1YWdlRmlsdGVyKCk7XG5cblx0XHRcdHRoaXMuc2hvdWxkUmVjcmVhdGUgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQmluZCB0aGUgVUkgZWxlbWVudHMgd2l0aCB0aGVpciBldmVudCBsaXN0ZW5lcnNcblx0XHQgKi9cblx0XHRsaXN0ZW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFJlZ2lzdGVyIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIFVMUyBoZXJlLlxuXHRcdFx0dGhpcy4kZWxlbWVudC5vbiggJ2NsaWNrJywgdGhpcy5jbGljay5iaW5kKCB0aGlzICkgKTtcblxuXHRcdFx0Ly8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgcHJlc3Npbmcgb24gZW1wdHkgc3BhY2UgaW4gdGhlIFVMU1xuXHRcdFx0dGhpcy4kbWVudS5vbiggJ2NsaWNrJywgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBIYW5kbGUga2V5IHByZXNzIGV2ZW50cyBvbiB0aGUgbWVudVxuXHRcdFx0dGhpcy4kbWVudS5vbiggJ2tleWRvd24nLCB0aGlzLmtleXByZXNzLmJpbmQoIHRoaXMgKSApO1xuXG5cdFx0XHR0aGlzLmNyZWF0ZUxhbmd1YWdlRmlsdGVyKCk7XG5cblx0XHRcdHRoaXMuJGxhbmd1YWdlRmlsdGVyLm9uKCAncmVzdWx0c2ZvdW5kLnVscycsIHRoaXMuc3VjY2Vzcy5iaW5kKCB0aGlzICkgKTtcblxuXHRcdFx0JCggJ2h0bWwnICkuY2xpY2soIHRoaXMuY2FuY2VsLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0JCggd2luZG93ICkucmVzaXplKCAkLmZuLnVscy5kZWJvdW5jZSggdGhpcy5yZXNpemUuYmluZCggdGhpcyApLCAyNTAgKSApO1xuXHRcdH0sXG5cblx0XHRyZXNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtZW51V2lkdGggPSB0aGlzLmdldE1lbnVXaWR0aCgpO1xuXG5cdFx0XHRpZiAoIHRoaXMubWVudVdpZHRoID09PSBtZW51V2lkdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tZW51V2lkdGggPSBtZW51V2lkdGg7XG5cdFx0XHR0aGlzLnNob3VsZFJlY3JlYXRlID0gdHJ1ZTtcblx0XHRcdGlmICggIXRoaXMuc2hvd24gKSB7XG5cdFx0XHRcdHRoaXMucmVjcmVhdGVMYW5ndWFnZUZpbHRlcigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBPbiBzZWxlY3QgaGFuZGxlciBmb3Igc2VhcmNoIHJlc3VsdHNcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ0NvZGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGpRdWVyeSBjbGljayBldmVudFxuXHRcdCAqL1xuXHRcdHNlbGVjdDogZnVuY3Rpb24gKCBsYW5nQ29kZSwgZXZlbnQgKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLm9uU2VsZWN0ICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMub25TZWxlY3QuY2FsbCggdGhpcywgbGFuZ0NvZGUsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE9uIGNhbmNlbCBoYW5kbGVyIGZvciB0aGUgdWxzIG1lbnVcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdFx0ICovXG5cdFx0Y2FuY2VsOiBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRpZiAoIGUgJiYgKCB0aGlzLiRlbGVtZW50LmlzKCBlLnRhcmdldCApIHx8XG5cdFx0XHRcdCQuY29udGFpbnMoIHRoaXMuJGVsZW1lbnRbIDAgXSwgZS50YXJnZXQgKSApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdH0sXG5cblx0XHRrZXlwcmVzczogZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0aWYgKCAhdGhpcy5zaG93biApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMjcgKSB7IC8vIGVzY2FwZVxuXHRcdFx0XHR0aGlzLmNhbmNlbCgpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIHRoaXMuc2hvd24gKSB7XG5cdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgcGFuZWwgbWVudSB3aWR0aCBwYXJhbWV0ZXJcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0TWVudVdpZHRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbGFuZ3VhZ2VzQ291bnQsXG5cdFx0XHRcdHNjcmVlbldpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5tZW51V2lkdGggKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWVudVdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRsYW5ndWFnZXNDb3VudCA9IE9iamVjdC5rZXlzKCB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VzICkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHNjcmVlbldpZHRoID4gOTAwICYmIGxhbmd1YWdlc0NvdW50ID49IDQ4ICkge1xuXHRcdFx0XHRyZXR1cm4gJ3dpZGUnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNjcmVlbldpZHRoID4gNTAwICYmIGxhbmd1YWdlc0NvdW50ID49IDI0ICkge1xuXHRcdFx0XHRyZXR1cm4gJ21lZGl1bSc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAnbmFycm93Jztcblx0XHR9LFxuXG5cdFx0aXNNb2JpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCAvKGlQaG9uZXxpUG9kfGlQYWR8QW5kcm9pZHxCbGFja0JlcnJ5KS8gKTtcblx0XHR9XG5cdH07XG5cblx0LyogVUxTIFBMVUdJTiBERUZJTklUSU9OXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdCQuZm4udWxzID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCggdGhpcyApLFxuXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSggJ3VscycgKSxcblx0XHRcdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjtcblxuXHRcdFx0aWYgKCAhZGF0YSApIHtcblx0XHRcdFx0JHRoaXMuZGF0YSggJ3VscycsICggZGF0YSA9IG5ldyBVTFMoIHRoaXMsIG9wdGlvbnMgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGRhdGFbIG9wdGlvbiBdKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9O1xuXG5cdCQuZm4udWxzLmRlZmF1bHRzID0ge1xuXHRcdC8vIENTUyB0b3AgcG9zaXRpb24gZm9yIHRoZSBkaWFsb2dcblx0XHR0b3A6IHVuZGVmaW5lZCxcblx0XHQvLyBDU1MgbGVmdCBwb3NpdGlvbiBmb3IgdGhlIGRpYWxvZ1xuXHRcdGxlZnQ6IHVuZGVmaW5lZCxcblx0XHQvLyBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVzZXIgc2VsZWN0cyBhIGxhbmd1YWdlXG5cdFx0b25TZWxlY3Q6IHVuZGVmaW5lZCxcblx0XHQvLyBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkIHdpdGhvdXQgc2VsZWN0aW5nIGEgbGFuZ3VhZ2Vcblx0XHRvbkNhbmNlbDogdW5kZWZpbmVkLFxuXHRcdC8vIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gVUxTIGhhcyBpbml0aWFsaXplZFxuXHRcdG9uUmVhZHk6IHVuZGVmaW5lZCxcblx0XHQvLyBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIFVMUyBkaWFsb2cgaXMgc2hvd25cblx0XHRvblZpc2libGU6IHVuZGVmaW5lZCxcblx0XHQvLyBMYW5ndWFnZXMgdG8gYmUgdXNlZCBmb3IgVUxTLCBkZWZhdWx0IGlzIGFsbCBsYW5ndWFnZXNcblx0XHRsYW5ndWFnZXM6ICQudWxzLmRhdGEuZ2V0QXV0b255bXMoKSxcblx0XHQvLyBUaGUgb3B0aW9ucyBhcmUgd2lkZSAoNCBjb2x1bW5zKSwgbWVkaXVtICgyIGNvbHVtbnMpLCBhbmQgbmFycm93ICgxIGNvbHVtbikuXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgYXV0b21hdGljYWxseS5cblx0XHRtZW51V2lkdGg6IHVuZGVmaW5lZCxcblx0XHQvLyBXaGF0IGlzIHRoaXMgVUxTIHVzZWQgZm9yLlxuXHRcdC8vIFNob3VsZCBiZSBzZXQgZm9yIGRpc3Rpbmd1aXNoaW5nIGJldHdlZW4gZGlmZmVyZW50IGluc3RhbmNlcyBvZiBVTFNcblx0XHQvLyBpbiB0aGUgc2FtZSBhcHBsaWNhdGlvbi5cblx0XHR1bHNQdXJwb3NlOiAnJyxcblx0XHQvLyBVc2VkIGJ5IExDRFxuXHRcdHF1aWNrTGlzdDogW10sXG5cdFx0Ly8gVXNlZCBieSBMQ0Rcblx0XHRzaG93UmVnaW9uczogdW5kZWZpbmVkLFxuXHRcdC8vIFVzZWQgYnkgTENEXG5cdFx0bGFuZ3VhZ2VEZWNvcmF0b3I6IHVuZGVmaW5lZCxcblx0XHQvLyBVc2VkIGJ5IExDRFxuXHRcdG5vUmVzdWx0c1RlbXBsYXRlOiB1bmRlZmluZWQsXG5cdFx0Ly8gVXNlZCBieSBMQ0Rcblx0XHRpdGVtc1BlckNvbHVtbjogdW5kZWZpbmVkLFxuXHRcdC8vIFVzZWQgYnkgTENEXG5cdFx0Z3JvdXBCeVJlZ2lvbjogdW5kZWZpbmVkLFxuXHRcdC8vIFVzZWQgYnkgTGFuZ3VhZ2VGaWx0ZXJcblx0XHRzZWFyY2hBUEk6IHVuZGVmaW5lZFxuXHR9O1xuXG5cdC8vIERlZmluZSBhIGR1bW15IGkxOG4gZnVuY3Rpb24sIGlmIGpxdWVyeS5pMThuIG5vdCBpbnRlZ3JhdGVkLlxuXHRpZiAoICEkLmZuLmkxOG4gKSB7XG5cdFx0JC5mbi5pMThuID0gZnVuY3Rpb24gKCkge307XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBkZWJvdW5jZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9uLFxuXHQgKiB3aGljaCB3aWxsIHBvc3Rwb25lIGl0cyBleGVjdXRpb24sIHVudGlsIGFmdGVyIHdhaXQgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuXHQgKiBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBkZWJvdW5jZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFdhaXQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW1lZGlhdGVdIFRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHdhaXQgaW50ZXJ2YWwsXG5cdCAqIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nIGVkZ2UuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBEZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAqL1xuXHQkLmZuLnVscy5kZWJvdW5jZSA9IGZ1bmN0aW9uICggZm4sIHdhaXQsIGltbWVkaWF0ZSApIHtcblx0XHR2YXIgdGltZW91dDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2FsbE5vdywgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRpbWVvdXQgPSBudWxsO1xuXHRcdFx0XHRcdGlmICggIWltbWVkaWF0ZSApIHtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KCBzZWxmLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBsYXRlciwgd2FpdCB8fCAxMDAgKTtcblxuXHRcdFx0aWYgKCBjYWxsTm93ICkge1xuXHRcdFx0XHRmbi5hcHBseSggc2VsZiwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHQvKlxuXHQgKiBTaW1wbGUgc2Nyb2xsSW50b1ZpZXcgcGx1Z2luLlxuXHQgKiBTY3JvbGxzIHRoZSBlbGVtZW50IHRvIHRoZSB2aWV3cG9ydCBzbW9vdGhseSBpZiBpdCBpcyBub3QgYWxyZWFkeS5cblx0ICovXG5cdCQuZm4uc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNjcm9sbFBvc2l0aW9uLFxuXHRcdFx0XHQkd2luZG93ID0gJCggd2luZG93ICksXG5cdFx0XHRcdHdpbmRvd0hlaWdodCA9ICR3aW5kb3cuaGVpZ2h0KCksXG5cdFx0XHRcdHdpbmRvd1RvcCA9ICR3aW5kb3cuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdHdpbmRvd0JvdHRvbSA9IHdpbmRvd1RvcCArIHdpbmRvd0hlaWdodCxcblx0XHRcdFx0JGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0XHRcdHBhbmVsSGVpZ2h0ID0gJGVsZW1lbnQuaGVpZ2h0KCksXG5cdFx0XHRcdHBhbmVsVG9wID0gJGVsZW1lbnQub2Zmc2V0KCkudG9wLFxuXHRcdFx0XHRwYW5lbEJvdHRvbSA9IHBhbmVsVG9wICsgcGFuZWxIZWlnaHQ7XG5cblx0XHRcdGlmICggKCBwYW5lbFRvcCA8IHdpbmRvd1RvcCApIHx8ICggcGFuZWxCb3R0b20gPiB3aW5kb3dCb3R0b20gKSApIHtcblx0XHRcdFx0aWYgKCB3aW5kb3dUb3AgPiBwYW5lbFRvcCApIHtcblx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbiA9IHBhbmVsVG9wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uID0gcGFuZWxCb3R0b20gLSB3aW5kb3dIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0JCggJ2h0bWwsIGJvZHknICkuc3RvcCgpLmFuaW1hdGUoIHtcblx0XHRcdFx0XHRzY3JvbGxUb3A6IHNjcm9sbFBvc2l0aW9uXG5cdFx0XHRcdH0sIDUwMCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fTtcblxuXHQkLmZuLnVscy5Db25zdHJ1Y3RvciA9IFVMUztcbn0oIGpRdWVyeSApICk7XG4iLCIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPSggZnVuY3Rpb24gKCAkICkge1xuXHQkLnVscyA9ICQudWxzIHx8IHt9O1xuXHQkLnVscy5kYXRhID0ge1xuICAgIFwibGFuZ3VhZ2VzXCI6IHtcbiAgICAgICAgXCJhYVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlFhZsOhciBhZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWJcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQkNKn0YHRiNOZ0LBcIlxuICAgICAgICBdLFxuICAgICAgICBcImFiZVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlfDtGJhbmFracO0ZHdhd8O0Z2FuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhYnNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJCYWhhc2EgQW1ib25cIlxuICAgICAgICBdLFxuICAgICAgICBcImFjZVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBY8OoaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWNmXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwia3fDqXnDsmxcIlxuICAgICAgICBdLFxuICAgICAgICBcImFkeVwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQkNC00YvQs9Cw0LHQt9GNXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhZHktY3lybFwiOiBbXG4gICAgICAgICAgICBcImFkeVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWR5LWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQWR5Z2FiemVcIlxuICAgICAgICBdLFxuICAgICAgICBcImFlYlwiOiBbXG4gICAgICAgICAgICBcImFlYi1hcmFiXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhZWItYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItiq2YjZhtiz2YpcIlxuICAgICAgICBdLFxuICAgICAgICBcImFlYi1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVMO7bnPDrlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBZnJpa2FhbnNcIlxuICAgICAgICBdLFxuICAgICAgICBcImFoclwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCkheCkueCkv+CksOCkvuCko+ClgFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWlzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU2FraXpheWFcIlxuICAgICAgICBdLFxuICAgICAgICBcImFrXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQWthblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYWt6XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQWxiYWFtbyBpbm5hYcmsaWlsa2FcIlxuICAgICAgICBdLFxuICAgICAgICBcImFsblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkdlZ8OrXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhbVwiOiBbXG4gICAgICAgICAgICBcIkV0aGlcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGKoOGIm+GIreGKm1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYW1pXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGFuZ2NhaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYW5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJhcmFnb27DqXNcIlxuICAgICAgICBdLFxuICAgICAgICBcImFuZ1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIsOGbmdsaXNjXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhbnBcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpIXgpJngpY3gpJfgpL/gpJXgpL5cIlxuICAgICAgICBdLFxuICAgICAgICBcImFyXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2KfZhNi52LHYqNmK2KlcIlxuICAgICAgICBdLFxuICAgICAgICBcImFyY1wiOiBbXG4gICAgICAgICAgICBcIlN5cmNcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItyQ3Krcodyd3JBcIlxuICAgICAgICBdLFxuICAgICAgICBcImFyblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1hcHVkdW5ndW5cIlxuICAgICAgICBdLFxuICAgICAgICBcImFyb1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkFyYW9uYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXJxXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2KzYp9iy2KfZitix2YrYqVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXJ5XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTWHEoXJpYmlcIlxuICAgICAgICBdLFxuICAgICAgICBcImFyelwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmF2LXYsdmJXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhc1wiOiBbXG4gICAgICAgICAgICBcIkJlbmdcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCmheCmuOCmruCngOCmr+CmvOCmvlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXNlXCI6IFtcbiAgICAgICAgICAgIFwiU2dud1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQW1lcmljYW4gc2lnbiBsYW5ndWFnZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXN0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiYXN0dXJpYW51XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJhdGpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJhdGlrYW1la3dcIlxuICAgICAgICBdLFxuICAgICAgICBcImF2XCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LDQstCw0YBcIlxuICAgICAgICBdLFxuICAgICAgICBcImF2a1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIktvdGF2YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXlcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBeW1hciBhcnVcIlxuICAgICAgICBdLFxuICAgICAgICBcImF6XCI6IFtcbiAgICAgICAgICAgIFwiYXotbGF0blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXotYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYqtuG2LHaqdis2YdcIlxuICAgICAgICBdLFxuICAgICAgICBcImF6LWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiYXrJmXJiYXljYW5jYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYXotY3lybFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQsNC305nRgNCx0LDRmNK50LDQvdK50LBcIlxuICAgICAgICBdLFxuICAgICAgICBcImF6YlwiOiBbXG4gICAgICAgICAgICBcImF6LWFyYWJcIlxuICAgICAgICBdLFxuICAgICAgICBcImF6alwiOiBbXG4gICAgICAgICAgICBcImF6LWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcImJhXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LHQsNGI0qHQvtGA0YLRgdCwXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiYW5cIjogW1xuICAgICAgICAgICAgXCJCYWxpXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhrKnhrLLhrKnhrK7hrLZcIlxuICAgICAgICBdLFxuICAgICAgICBcImJhclwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJvYXJpc2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiYXQtc21nXCI6IFtcbiAgICAgICAgICAgIFwic2dzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiYmMtbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJhdGFrIFRvYmFcIlxuICAgICAgICBdLFxuICAgICAgICBcImJiYy1iYXRrXCI6IFtcbiAgICAgICAgICAgIFwiQmF0a1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4a+F4a+W4a+C4a+yIOGvluGvrOGvhVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmJjXCI6IFtcbiAgICAgICAgICAgIFwiYmJjLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcImJjY1wiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYrNmH2YTYs9ix24wg2KjZhNmI2obbjFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmNsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmlrb2wgQ2VudHJhbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmUtdGFyYXNrXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LHQtdC70LDRgNGD0YHQutCw0Y8gKNGC0LDRgNCw0YjQutC10LLRltGG0LApXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiZS14LW9sZFwiOiBbXG4gICAgICAgICAgICBcImJlLXRhcmFza1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmVcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQsdC10LvQsNGA0YPRgdC60LDRj1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmV3XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFoYXNhIEJldGF3aVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmZhXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFyaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmZ0XCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2KjZhNiq24xcIlxuICAgICAgICBdLFxuICAgICAgICBcImJmcVwiOiBbXG4gICAgICAgICAgICBcIlRhbWxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCuquCun+CuleCuvlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmdcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQsdGK0LvQs9Cw0YDRgdC60LhcIlxuICAgICAgICBdLFxuICAgICAgICBcImJnblwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYsdmI2oYg2qnZvtiq24zZhiDYqNmE2YjahtuMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiaFwiOiBbXG4gICAgICAgICAgICBcImJob1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYmhvXCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KSt4KWL4KSc4KSq4KWB4KSw4KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiaVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJpc2xhbWFcIlxuICAgICAgICBdLFxuICAgICAgICBcImJqblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJhaGFzYSBCYW5qYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImJtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiYmFtYW5hbmthblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYm5cIjogW1xuICAgICAgICAgICAgXCJCZW5nXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpqzgpr7gpoLgprLgpr5cIlxuICAgICAgICBdLFxuICAgICAgICBcImJublwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJ1bnVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJib1wiOiBbXG4gICAgICAgICAgICBcIlRpYnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuC9luC9vOC9keC8i+C9oeC9suC9glwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYnB5XCI6IFtcbiAgICAgICAgICAgIFwiQmVuZ1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4Kas4Ka/4Ka34KeN4Kaj4KeB4Kaq4KeN4Kaw4Ka/4Kav4Ka84Ka+IOCmruCmo+Cmv+CmquCngeCmsOCngFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYnFpXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItio2K7YqtuM2KfYsduMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJiclwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImJyZXpob25lZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYnJoXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIixcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJyw6FodcOtXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJicnhcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpKzgpLAnXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJic1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImJvc2Fuc2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJidG1cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNYW5kYWlsaW5nXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJidG9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJJcmlnYSBCaWNvbGFub1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYnVnXCI6IFtcbiAgICAgICAgICAgIFwiQnVnaVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4aiF4aiUIOGoleGomOGogeGol1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiYnhyXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LHRg9GA0Y/QsNC0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJieW5cIjogW1xuICAgICAgICAgICAgXCJFdGhpXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhiaXhiIrhipVcIlxuICAgICAgICBdLFxuICAgICAgICBcImNhXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiY2F0YWzDoFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2FrXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS2FxY2hpa2VsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjYmstemFtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQ2hhdmFjYW5vIGRlIFphbWJvYW5nYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2RvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTcOsbmctZMSVzKRuZy1uZ+G5s8yEXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjZVwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC90L7RhdGH0LjQudC9XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjZWJcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJDZWJ1YW5vXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjaFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkNoYW1vcnVcIlxuICAgICAgICBdLFxuICAgICAgICBcImNobVwiOiBbXG4gICAgICAgICAgICBcIm1oclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2huXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiY2hpbnVrIHdhd2FcIlxuICAgICAgICBdLFxuICAgICAgICBcImNob1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkNob2N0YXdcIlxuICAgICAgICBdLFxuICAgICAgICBcImNoclwiOiBbXG4gICAgICAgICAgICBcIkNoZXJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGPo+GOs+GOqVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2h5XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVHNldHPDqmhlc3TDomhlc2VcIlxuICAgICAgICBdLFxuICAgICAgICBcImNpd1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk9qaWJ3ZW1vd2luXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjanlcIjogW1xuICAgICAgICAgICAgXCJjanktaGFudFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2p5LWhhbnNcIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLmmYvor63vvIjnroDljJblrZcpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjanktaGFudFwiOiBbXG4gICAgICAgICAgICBcIkhhbnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuaZieiqnlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY2tiXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2qnZiNix2K/bjFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY25oXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTGFpIGhvbGhcIlxuICAgICAgICBdLFxuICAgICAgICBcImNuclwiOiBbXG4gICAgICAgICAgICBcImNuci1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjbnItY3lybFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGG0YDQvdC+0LPQvtGA0YHQutC4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjbnItbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImNybm9nb3Jza2lcIlxuICAgICAgICBdLFxuICAgICAgICBcImNvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiY29yc3VcIlxuICAgICAgICBdLFxuICAgICAgICBcImNvcFwiOiBbXG4gICAgICAgICAgICBcIkNvcHRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLPr+KymeKyieKyp+Kyo+KyieKymeKym8yA4rKt4rKP4rKZ4rKTXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjcHNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJDYXBpY2XDsW9cIlxuICAgICAgICBdLFxuICAgICAgICBcImNyXCI6IFtcbiAgICAgICAgICAgIFwiQ2Fuc1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4ZOA4ZCm4ZCD4ZSt4ZCN4ZCP4ZCjXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjci1jYW5zXCI6IFtcbiAgICAgICAgICAgIFwiY3JcIlxuICAgICAgICBdLFxuICAgICAgICBcImNyLWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJOxJNoaXlhd8STd2luXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjcmhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJxxLFyxLFtdGF0YXJjYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY3JoLWN5cmxcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQutGK0YvRgNGL0LzRgtCw0YLQsNGA0LTQttCwXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjcmgtbGF0blwiOiBbXG4gICAgICAgICAgICBcImNyaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiY3NcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLEjWXFoXRpbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcImNzYlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImthc3rDq2JzY3ppXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJjdVwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGB0LvQvtCy0aPQvdGM0YHQutGKIFxcLyDisJTisI7isJHisILisKHisJDisKDisJTisI3isJ9cIlxuICAgICAgICBdLFxuICAgICAgICBcImN2XCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0KfTkdCy0LDRiNC70LBcIlxuICAgICAgICBdLFxuICAgICAgICBcImN5XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQ3ltcmFlZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkYW5za1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGFnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZGFnYmFubGlcIlxuICAgICAgICBdLFxuICAgICAgICBcImRlLWF0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiw5ZzdGVycmVpY2hpc2NoZXMgRGV1dHNjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGUtY2hcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTY2h3ZWl6ZXIgSG9jaGRldXRzY2hcIlxuICAgICAgICBdLFxuICAgICAgICBcImRlLWZvcm1hbFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkRldXRzY2ggKFNpZS1Gb3JtKVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJEZXV0c2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkaW5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUaHXJlMWLasOkxYtcIlxuICAgICAgICBdLFxuICAgICAgICBcImRpcVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJaYXpha2lcIlxuICAgICAgICBdLFxuICAgICAgICBcImRvaVwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCkoeCli+Ckl+CksOClgFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZHNiXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZG9sbm9zZXJic2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkdHBcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJEdXN1biBCdW5kdS1saXdhblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZHR5XCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KSh4KWL4KSf4KWH4KSy4KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkdlwiOiBbXG4gICAgICAgICAgICBcIlRoYWFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIt6L3qjeiN6s3oDeqN6E3qbekN6wXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkelwiOiBbXG4gICAgICAgICAgICBcIlRpYnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuC9h+C9vOC9hOC8i+C9gVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZWVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJlyotlZ2JlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlZ2xcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJFbWlsacOgblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZWxcIjogW1xuICAgICAgICAgICAgXCJHcmVrXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLOlc67zrvOt869zrnOus6sXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlbWxcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJlbWlsacOgbiBlIHJ1bWFnbsOybFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZW4tY2FcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJDYW5hZGlhbiBFbmdsaXNoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlbi1nYlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiLFxuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQnJpdGlzaCBFbmdsaXNoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiQUZcIixcbiAgICAgICAgICAgICAgICBcIk1FXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiLFxuICAgICAgICAgICAgICAgIFwiUEFcIixcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkVuZ2xpc2hcIlxuICAgICAgICBdLFxuICAgICAgICBcImVvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiV1dcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRXNwZXJhbnRvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlcy00MTlcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJlc3Bhw7FvbCBkZSBBbcOpcmljYSBMYXRpbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcImVzLWZvcm1hbFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiQUZcIixcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImVzcGHDsW9sIChmb3JtYWwpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlc1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiQUZcIixcbiAgICAgICAgICAgICAgICBcIldXXCIsXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJlc3Bhw7FvbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXMtbmlcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJlc3Bhw7FvbCBuaWNhcmFnw7xlbnNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJlc3VcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJZdXAnaWtcIlxuICAgICAgICBdLFxuICAgICAgICBcImV0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZWVzdGlcIlxuICAgICAgICBdLFxuICAgICAgICBcImV1XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZXVza2FyYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXh0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZXN0cmVtZcOxdVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXlhXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiScK3eWHCt3FcIlxuICAgICAgICBdLFxuICAgICAgICBcImZhXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmB2KfYsdiz24xcIlxuICAgICAgICBdLFxuICAgICAgICBcImZhblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkZhxYtcIlxuICAgICAgICBdLFxuICAgICAgICBcImZheFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkZhbGFcIlxuICAgICAgICBdLFxuICAgICAgICBcImZmXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRnVsZnVsZGVcIlxuICAgICAgICBdLFxuICAgICAgICBcImZpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic3VvbWlcIlxuICAgICAgICBdLFxuICAgICAgICBcImZpbFwiOiBbXG4gICAgICAgICAgICBcInRsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmaXRcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZcOkbmtpZWxpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmaXUtdnJvXCI6IFtcbiAgICAgICAgICAgIFwidnJvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmalwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk5hIFZvc2EgVmFrYXZpdGlcIlxuICAgICAgICBdLFxuICAgICAgICBcImZrdlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImt2w6TDpG5pXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJmb1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImbDuHJveXNrdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZm9uXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZsmUzIBuZ2LDqFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIixcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImZyYW7Dp2Fpc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJjXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZnJhbsOnYWlzIGNhZGllblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJwXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiYXJwZXRhblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnJyXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTm9yZGZyaWlza1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnVmXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRnV1dGEgSmFsb25cIlxuICAgICAgICBdLFxuICAgICAgICBcImZ1clwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImZ1cmxhblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZnlcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJGcnlza1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2FcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJHYWVpbGdlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnYWFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJHYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2FnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiR2FnYXV6XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnYWhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBbGVrYW5vXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnYW4taGFuc1wiOiBbXG4gICAgICAgICAgICBcIkhhbnNcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIui1o+ivre+8iOeugOS9k++8iVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2FuLWhhbnRcIjogW1xuICAgICAgICAgICAgXCJnYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcImdhblwiOiBbXG4gICAgICAgICAgICBcIkhhbnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIui0m+iqnlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2JtXCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KSX4KSi4KS84KS14KSz4KS/XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnYnpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJEYXJpLWUgTWF6ZGV5YXNuxIFcIlxuICAgICAgICBdLFxuICAgICAgICBcImdjZlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkd1YWRlbG91cGVhbiBDcmVvbGUgRnJlbmNoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnY3JcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJrcsOpecOybCBnd2l5YW7DqFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2RcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJHw6BpZGhsaWdcIlxuICAgICAgICBdLFxuICAgICAgICBcImdlelwiOiBbXG4gICAgICAgICAgICBcIkV0aGlcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGMjeGLleGLnVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ2xcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJnYWxlZ29cIlxuICAgICAgICBdLFxuICAgICAgICBcImdsa1wiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLar9uM2YTaqduMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkF2YcOxZSfhur1cIlxuICAgICAgICBdLFxuICAgICAgICBcImdvbVwiOiBbXG4gICAgICAgICAgICBcImdvbS1kZXZhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnb20tZGV2YVwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCkl+Cli+CkguCkr+CkmuClgCDgpJXgpYvgpILgpJXgpKPgpYBcIlxuICAgICAgICBdLFxuICAgICAgICBcImdvbS1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiR8O1eWNoaSBLb25rbm5pXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnb3JcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJCYWhhc2EgSHVsb250YWxvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnb3RcIjogW1xuICAgICAgICAgICAgXCJHb3RoXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLwkIyy8JCMv/CQjYTwkIy58JCNg/CQjLpcIlxuICAgICAgICBdLFxuICAgICAgICBcImdyY1wiOiBbXG4gICAgICAgICAgICBcIkdyZWtcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuG8iM+Bz4fOsc6vzrEg4byRzrvOu863zr3Ouc664b20XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJnc3dcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBbGVtYW5uaXNjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3VcIjogW1xuICAgICAgICAgICAgXCJHdWpyXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgqpfgq4HgqpzgqrDgqr7gqqTgq4BcIlxuICAgICAgICBdLFxuICAgICAgICBcImd1Y1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIldhecO6dVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3VtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmFtdHJpa1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3VyXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiR3VyZW7Jm1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZ3ZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJHYWVsZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGEtYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmH2Y7ZiNmP2LPZjlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGEtbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkhhdXNhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoYVwiOiBbXG4gICAgICAgICAgICBcImhhLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcImhhaVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIljMsWFhdCBLw61sXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoYWtcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJIYWsta8OiLWZhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoYXdcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiSGF3YWlgaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGVcIjogW1xuICAgICAgICAgICAgXCJIZWJyXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLXoteR16jXmdeqXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoYWstaGFuc1wiOiBbXG4gICAgICAgICAgICBcIkhhbnNcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuWuouWutuivre+8iOeugOS9k++8iVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGFrLWhhbnRcIjogW1xuICAgICAgICAgICAgXCJIYW50XCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLlrqLlrrboqp7vvIjnuYHpq5TvvIlcIlxuICAgICAgICBdLFxuICAgICAgICBcImhpXCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KS54KS/4KSo4KWN4KSm4KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoaWZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJQQVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRmlqaSBIaW5kaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGlmLWRldmFcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpKvgpLzgpYDgpJzgpYAg4KS54KS/4KSo4KWN4KSm4KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoaWYtbGF0blwiOiBbXG4gICAgICAgICAgICBcImhpZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaGlsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiSWxvbmdnb1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG5lXCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KSb4KSk4KWN4KSk4KWA4KS44KSX4KSi4KS84KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJob1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkhpcmkgTW90dVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9jXCI6IFtcbiAgICAgICAgICAgIFwiV2FyYVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi8JGiufCRo4nwkaOJXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoclwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImhydmF0c2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJocnhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJIdW5zcmlrXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoc2JcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJob3Juam9zZXJic2NlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoc25cIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLmuZjor61cIlxuICAgICAgICBdLFxuICAgICAgICBcImh0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS3JlecOybCBheWlzeWVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJodS1mb3JtYWxcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNYWd5YXIgKG1hZ8OhesOzKVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaHVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtYWd5YXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImh5XCI6IFtcbiAgICAgICAgICAgIFwiQXJtblwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItWw1aHVtdWl1oDVpdW2XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJoeXdcIjogW1xuICAgICAgICAgICAgXCJBcm1uXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi1aHWgNWl1oLVtNW/1aHVsNWh1bXVpdaA1afVtlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaHpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJPdHNpaGVyZXJvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpYVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImludGVybGluZ3VhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpZFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJhaGFzYSBJbmRvbmVzaWFcIlxuICAgICAgICBdLFxuICAgICAgICBcImllXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiV1dcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiSW50ZXJsaW5ndWVcIlxuICAgICAgICBdLFxuICAgICAgICBcImlnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiSWdib1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaWlcIjogW1xuICAgICAgICAgICAgXCJZaWlpXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLqhofqiZlcIlxuICAgICAgICBdLFxuICAgICAgICBcImlrXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiScOxdXBpYWtcIlxuICAgICAgICBdLFxuICAgICAgICBcImlrZS1jYW5zXCI6IFtcbiAgICAgICAgICAgIFwiQ2Fuc1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4ZCD4ZOE4ZKD4ZGO4ZGQ4ZGmXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpa2UtbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImludWt0aXR1dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaWxvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiSWxva2Fub1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5oXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0JPTgNCw0LvQs9OA0LDQuVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJXV1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJJZG9cIlxuICAgICAgICBdLFxuICAgICAgICBcImlzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiw61zbGVuc2thXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpdFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIml0YWxpYW5vXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpdVwiOiBbXG4gICAgICAgICAgICBcImlrZS1jYW5zXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJqYVwiOiBbXG4gICAgICAgICAgICBcIkpwYW5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuaXpeacrOiqnlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiamFtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGF0b2lzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJqYm9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJXV1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJsb2piYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcImpkdFwiOiBbXG4gICAgICAgICAgICBcImpkdC1jeXJsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJqZHQtY3lybFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQttGD0LPRjNGD0YDQuFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwianV0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwianlza1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwianZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiLFxuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFzYSBKYXdhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJqdi1qYXZhXCI6IFtcbiAgICAgICAgICAgIFwiSmF2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuqmp+qmseqml+qmrlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2FcIjogW1xuICAgICAgICAgICAgXCJHZW9yXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhg6Xhg5Dhg6Dhg5fhg6Phg5rhg5hcIlxuICAgICAgICBdLFxuICAgICAgICBcImthYVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlFhcmFxYWxwYXFzaGFcIlxuICAgICAgICBdLFxuICAgICAgICBcImthYlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCIsXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUYXFiYXlsaXRcIlxuICAgICAgICBdLFxuICAgICAgICBcImthY1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkppbmdocGF3XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrYmQtY3lybFwiOiBbXG4gICAgICAgICAgICBcImtiZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2JkLWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJRYWJhcmRqYWrJmWJ6YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2JkXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItCQ0LTRi9Cz0Y3QsdC30Y1cIlxuICAgICAgICBdLFxuICAgICAgICBcImticFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkthYsmpecmbXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrZWFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLYWJ1dmVyZGlhbnVcIlxuICAgICAgICBdLFxuICAgICAgICBcImtnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS29uZ29cIlxuICAgICAgICBdLFxuICAgICAgICBcImtncFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkthaW5nw6FuZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2h3XCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIixcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItqp2r7ZiNin2LFcIlxuICAgICAgICBdLFxuICAgICAgICBcImtpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiR8Spa8WpecWpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJraXVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS8Sxcm1hbmNraVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2pcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLd2FueWFtYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2poXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0YXQsNC60LDRgVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2pwXCI6IFtcbiAgICAgICAgICAgIFwiTXltclwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4YCW4YGg4YCv4YC24YCc4YCt4YCA4YC6XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJra1wiOiBbXG4gICAgICAgICAgICBcImtrLWN5cmxcIlxuICAgICAgICBdLFxuICAgICAgICBcImtrLWFyYWJcIjogW1xuICAgICAgICAgICAgXCJBcmFiXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2YLYp9iy2KfZgti02KcgKNiq2bbYqtuVKVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia2stY25cIjogW1xuICAgICAgICAgICAgXCJray1hcmFiXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJray1jeXJsXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItKb0LDQt9Cw0pvRiNCwXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJray1relwiOiBbXG4gICAgICAgICAgICBcImtrLWN5cmxcIlxuICAgICAgICBdLFxuICAgICAgICBcImtrLWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInFhemFxxZ9hXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJray10clwiOiBbXG4gICAgICAgICAgICBcImtrLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcImtsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIixcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImthbGFhbGxpc3V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrbVwiOiBbXG4gICAgICAgICAgICBcIktobXJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGel+GetuGen+GetuGegeGfkuGemOGfguGemlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia25cIjogW1xuICAgICAgICAgICAgXCJLbmRhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgspXgsqjgs43gsqjgsqFcIlxuICAgICAgICBdLFxuICAgICAgICBcImtublwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCkruCkueCkvuCksOCkvuCkt+CljeCkn+CljeCksOClgOCkryDgpJXgpYvgpILgpJXgpKPgpYBcIlxuICAgICAgICBdLFxuICAgICAgICBcImtvLWtwXCI6IFtcbiAgICAgICAgICAgIFwiS29yZVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi7KGw7ISg66eQXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrb1wiOiBbXG4gICAgICAgICAgICBcIktvcmVcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIu2VnOq1reyWtFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia29pXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0J/QtdGA0LXQvCDQmtC+0LzQuFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia295XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRGVuYWFra2VuYWFnZcq8XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrclwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkthbnVyaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3JjXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LrRitCw0YDQsNGH0LDQuS3QvNCw0LvQutGK0LDRgFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3JpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS3Jpb1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3JqXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIixcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIktpbmFyYXktYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3JsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS2FyamFsYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3MtYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItqp2bLYtNmP2LFcIlxuICAgICAgICBdLFxuICAgICAgICBcImtzLWRldmFcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpJXgpYngpLbgpYHgpLBcIlxuICAgICAgICBdLFxuICAgICAgICBcImtzXCI6IFtcbiAgICAgICAgICAgIFwia3MtYXJhYlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3NmXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFmaWFcIlxuICAgICAgICBdLFxuICAgICAgICBcImtzaFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlJpcG9hcmlzY2hcIlxuICAgICAgICBdLFxuICAgICAgICBcImt1XCI6IFtcbiAgICAgICAgICAgIFwia3UtbGF0blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3UtYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLZg9mI2LHYr9mKXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJrdS1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImt1cmTDrlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwia3VtXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LrRitGD0LzRg9C60YpcIlxuICAgICAgICBdLFxuICAgICAgICBcImt2XCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LrQvtC80LhcIlxuICAgICAgICBdLFxuICAgICAgICBcImt3XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwia2Vybm93ZWtcIlxuICAgICAgICBdLFxuICAgICAgICBcImt5XCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0JrRi9GA0LPRi9C30YfQsFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibGFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMYXRpbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcImxhZFwiOiBbXG4gICAgICAgICAgICBcImxhZC1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsYWQtbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCIsXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTGFkaW5vXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsYWQtaGViclwiOiBbXG4gICAgICAgICAgICBcIkhlYnJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCIsXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi15zXkNeT15nXoNeVXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsYWdcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLaWxhYW5naVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibGJcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMw6t0emVidWVyZ2VzY2hcIlxuICAgICAgICBdLFxuICAgICAgICBcImxiZVwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC70LDQutC60YNcIlxuICAgICAgICBdLFxuICAgICAgICBcImxlelwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC70LXQt9Cz0LhcIlxuICAgICAgICBdLFxuICAgICAgICBcImxmblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkxpbmd1YSBGcmFuY2EgTm92YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibGdcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMdWdhbmRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsaVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkxpbWJ1cmdzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsaWpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMaWd1cmVcIlxuICAgICAgICBdLFxuICAgICAgICBcImxpdlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkzEq3bDtSBrxJPEvFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibGtpXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmE25XaqduMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsa3RcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMYWvIn8OzdGl5YXBpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsbGRcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJMYWRpblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibG1vXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibHVtYmFhcnRcIlxuICAgICAgICBdLFxuICAgICAgICBcImxuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibGluZ8OhbGFcIlxuICAgICAgICBdLFxuICAgICAgICBcImxvXCI6IFtcbiAgICAgICAgICAgIFwiTGFvb1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4Lql4Lqy4LqnXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsb3pcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTaWxvemlcIlxuICAgICAgICBdLFxuICAgICAgICBcImx0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibGlldHV2acWzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJscmNcIjogW1xuICAgICAgICAgICAgXCJBcmFiXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2YTbitix24wg2LTZiNmF2KfZhNuMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsdGdcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJsYXRnYcS8dVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibHVkXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibMO8w7xkaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibHVzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTWl6byDFo2F3bmdcIlxuICAgICAgICBdLFxuICAgICAgICBcImx1dFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImR4yrdsyZnFoXVjaWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImx1elwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmE2KbYsduMINiv2YjZmdmF24zZhtuMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsdlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImxhdHZpZcWhdVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibHpoXCI6IFtcbiAgICAgICAgICAgIFwiSGFudFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi5paH6KiAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJsenpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTGF6dXJpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtYWlcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpK7gpYjgpKXgpL/gpLLgpYBcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1hcC1ibXNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJCYXNhIEJhbnl1bWFzYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1kZlwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC80L7QutGI0LXQvdGMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZmVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNb3Jpc3llblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWdcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNYWxhZ2FzeVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJFYm9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtaHJcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQvtC70YvQuiDQvNCw0YDQuNC5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtaVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk3EgW9yaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWljXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTWkna21hcVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWluXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFzbyBNaW5hbmdrYWJhdVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWlxXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTcOtc2tpdHVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1rXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LzQsNC60LXQtNC+0L3RgdC60LhcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1sXCI6IFtcbiAgICAgICAgICAgIFwiTWx5bVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuC0ruC0suC0r+C0vuC0s+C0glwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibW5cIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQvNC+0L3Qs9C+0LtcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1uY1wiOiBbXG4gICAgICAgICAgICBcIk1vbmdcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGgruGgoOGgqOGgteGhoCDhoaThobPhoLDhoaDhoKhcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1uaVwiOiBbXG4gICAgICAgICAgICBcIkJlbmdcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCmruCnh+Cmh+CmpOCnh+CmhyDgprLgp4vgpqjgp41cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1ud1wiOiBbXG4gICAgICAgICAgICBcIk15bXJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuGAmOGArOGAnuGArCDhgJnhgJThgLpcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1vXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0LzQvtC70LTQvtCy0LXQvdGP0YHQutGNXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtb2VcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJJbm51LWFpbXVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtclwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpK7gpLDgpL7gpKDgpYBcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1yalwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC60YvRgNGL0Log0LzQsNGA0YtcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1zXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQmFoYXNhIE1lbGF5dVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibXRcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNYWx0aVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibXVpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTXVzaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibXVzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTXZza29rZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibXdsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTWlyYW5kw6lzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtd3ZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJCZWhhc2UgTWVudGF3ZWlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm13d1wiOiBbXG4gICAgICAgICAgICBcIm13dy1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtd3ctbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkhtb29iIERhd2JcIlxuICAgICAgICBdLFxuICAgICAgICBcIm15XCI6IFtcbiAgICAgICAgICAgIFwiTXltclwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4YCZ4YC84YCU4YC64YCZ4YCs4YCY4YCs4YCe4YCsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJteXZcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLRjdGA0LfRj9C90YxcIlxuICAgICAgICBdLFxuICAgICAgICBcIm16blwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk1FXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLZhdin2LLZkNix2YjZhtuMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuYVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkRvcmVyaW4gTmFvZXJvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuYWhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJOxIFodWF0bFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmFuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQsOibi1sw6JtLWfDulwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmFwXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmFwdWxpdGFub1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmJcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJub3JzayAoYm9rbcOlbClcIlxuICAgICAgICBdLFxuICAgICAgICBcIm5kXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2lOZGViZWxlIHNhc2VOeWFrYXRob1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmRzLW5sXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmVkZXJzYWtzaXNjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmRzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGxhdHRkw7zDvHRzY2hcIlxuICAgICAgICBdLFxuICAgICAgICBcIm5lXCI6IFtcbiAgICAgICAgICAgIFwiRGV2YVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4KSo4KWH4KSq4KS+4KSy4KWAXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuZXdcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpKjgpYfgpKrgpL7gpLIg4KSt4KS+4KS34KS+XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuZ1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk9zaGl3YW1ib1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibml1XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwia28gZSB2YWdhaGF1IE5pdcSTXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuam9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJBb1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmwtaW5mb3JtYWxcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmVkZXJsYW5kcyAoaW5mb3JtZWVsKVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibmxcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmVkZXJsYW5kc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibm5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJub3JzayAobnlub3JzaylcIlxuICAgICAgICBdLFxuICAgICAgICBcIm5vXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibm9yc2tcIlxuICAgICAgICBdLFxuICAgICAgICBcIm5vZFwiOiBbXG4gICAgICAgICAgICBcIlRoYWlcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuC4hOC4s+C5gOC4oeC4t+C4reC4h1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibm92XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiV1dcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTm92aWFsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJucW9cIjogW1xuICAgICAgICAgICAgXCJOa29vXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLfkt+e349cIlxuICAgICAgICBdLFxuICAgICAgICBcIm5yXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiaXNpTmRlYmVsZSBzZVNld3VsYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibnJtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTm91b3JtYW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJuc29cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTZXNvdGhvIHNhIExlYm9hXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJudlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkRpbsOpIGJpemFhZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibnlcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJDaGktQ2hld2FcIlxuICAgICAgICBdLFxuICAgICAgICBcIm55c1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk55dW5nYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIm9jXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwib2NjaXRhblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwib2thXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibsyTc8mZbMyTeGNpbsyTXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJvbG9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiLFxuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTGl2dmlua2FyamFsYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwib21cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJPcm9tb29cIlxuICAgICAgICBdLFxuICAgICAgICBcIm9vZFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIsq8T8q8b2RoYW0gaGEtw7Flyrxva8StXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJvclwiOiBbXG4gICAgICAgICAgICBcIk9yeWFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCsk+CsoeCsvOCsv+CshlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwib3NcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQmNGA0L7QvVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwib3RhXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItmE2LPYp9mGINi52KvZhdin2YbZiVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwib3ZkXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiw7Z2ZGFsc2tcIlxuICAgICAgICBdLFxuICAgICAgICBcInBhXCI6IFtcbiAgICAgICAgICAgIFwicGEtZ3VydVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGEtZ3VydVwiOiBbXG4gICAgICAgICAgICBcIkd1cnVcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCoquCpsOConOCovuCorOCpgFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGFnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGFuZ2FzaW5hblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGFtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS2FwYW1wYW5nYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcInBhcFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlBhcGlhbWVudHVcIlxuICAgICAgICBdLFxuICAgICAgICBcInBiYlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk5hc2EgWXV3ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGNkXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGljYXJkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwZGNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRGVpdHNjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGR0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlBsYXV0ZGlldHNjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGZsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUMOkbHppc2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwaVwiOiBbXG4gICAgICAgICAgICBcIkRldmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCkquCkvuCksuCkv1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGloXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTm9yZnVrIFxcLyBQaXRrZXJuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwaXNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJQaWppblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicGp0XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUGl0amFudGphdGphcmFcIlxuICAgICAgICBdLFxuICAgICAgICBcInBrb1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlDDtmtvb3RcIlxuICAgICAgICBdLFxuICAgICAgICBcInBsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicG9sc2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwbXNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJQaWVtb250w6hpc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwicG5iXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItm+2YbYrNin2KjbjFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicG50XCI6IFtcbiAgICAgICAgICAgIFwiR3Jla1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwizqDOv869z4TOuc6xzrrOrFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicHBsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiTmF3YXRcIlxuICAgICAgICBdLFxuICAgICAgICBcInByZ1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlByxatzaXNrYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcInByc1wiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYr9ix24xcIlxuICAgICAgICBdLFxuICAgICAgICBcInBzXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItm+2prYqtmIXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwdC1iclwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBvcnR1Z3XDqnMgZG8gQnJhc2lsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJwdFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIlBBXCIsXG4gICAgICAgICAgICAgICAgXCJBRlwiLFxuICAgICAgICAgICAgICAgIFwiV1dcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicG9ydHVndcOqc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwicXVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJSdW5hIFNpbWlcIlxuICAgICAgICBdLFxuICAgICAgICBcInF1Y1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIksnaWNoZSdcIlxuICAgICAgICBdLFxuICAgICAgICBcInF1Z1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlJ1bmEgc2hpbWlcIlxuICAgICAgICBdLFxuICAgICAgICBcInF3aFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImFucWFzaCBxaWNod2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInJhcFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImFyZXJvIHJhcGEgbnVpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyY2ZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLcmVvbCBSw6l5b27DqVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicmduXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiUnVtYWduw7RsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyaWZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUYXJpZml0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJya2lcIjogW1xuICAgICAgICAgICAgXCJNeW1yXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhgJvhgIHhgK3hgK/hgIThgLpcIlxuICAgICAgICBdLFxuICAgICAgICBcInJtXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwicnVtYW50c2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJybWZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJrYWFsZW5nbyB0xaFpbWJcIlxuICAgICAgICBdLFxuICAgICAgICBcInJteVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlJvbWFuaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicm5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLaXJ1bmRpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyb1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInJvbcOibsSDXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyb2EtcnVwXCI6IFtcbiAgICAgICAgICAgIFwicnVwXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyb2EtdGFyYVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInRhcmFuZMOtbmVcIlxuICAgICAgICBdLFxuICAgICAgICBcInJ0bVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkZhZWFnIFJvdHVtYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicnVcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGA0YPRgdGB0LrQuNC5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJydWVcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLRgNGD0YHQuNC90YzRgdC60YvQuVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicnVwXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiYXJtw6NuZWFzaHRpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJydXFcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLQktC70LDRhdC10YHRgtC1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJydXEtY3lybFwiOiBbXG4gICAgICAgICAgICBcInJ1cVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwicnVxLWdyZWtcIjogW1xuICAgICAgICAgICAgXCJHcmVrXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNZWdsZW5vLVJvbWFuaWFuIChHcmVlayBzY3JpcHQpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJydXEtbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlZsxINoZcWfdGVcIlxuICAgICAgICBdLFxuICAgICAgICBcInJ1dFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItC80YvRhdCw04DQsdC40YjQtNGLXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyd1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIktpbnlhcndhbmRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJyd3JcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpK7gpL7gpLDgpLXgpL7gpKHgpLzgpYBcIlxuICAgICAgICBdLFxuICAgICAgICBcInJ5dVwiOiBbXG4gICAgICAgICAgICBcIkthbmFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIsqUdWNpbsSBZ3VjaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2FcIjogW1xuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgpLjgpILgpLjgpY3gpJXgpYPgpKTgpK7gpY1cIlxuICAgICAgICBdLFxuICAgICAgICBcInNhaFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLRgdCw0YXQsCDRgtGL0LvQsFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2F0XCI6IFtcbiAgICAgICAgICAgIFwiT2xja1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4bGl4bGf4bGx4bGb4bGf4bGy4bGkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzYXpcIjogW1xuICAgICAgICAgICAgXCJTYXVyXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLqorHqo4PqoqzqorXqoq/qo4TqoqHqo4TqoqzqorVcIlxuICAgICAgICBdLFxuICAgICAgICBcInNjXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2FyZHVcIlxuICAgICAgICBdLFxuICAgICAgICBcInNjblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInNpY2lsaWFudVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2NvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU2NvdHNcIlxuICAgICAgICBdLFxuICAgICAgICBcInNkXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2LPZhtqM2YpcIlxuICAgICAgICBdLFxuICAgICAgICBcInNkY1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlNhc3NhcmVzdVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2RoXCI6IFtcbiAgICAgICAgICAgIFwiQXJhYlwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi2qnZiNix2K/bjCDYrtmI2KfYsdqvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzZVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRhdnZpc8OhbWVnaWVsbGFcIlxuICAgICAgICBdLFxuICAgICAgICBcInNlc1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIktveXJhYm9ybyBTZW5uaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2VpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQU1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQ21pcXVlIEl0b21cIlxuICAgICAgICBdLFxuICAgICAgICBcInNnXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU8OkbmfDtlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2dzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwixb5lbWFpdMSXxaFrYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2hcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJzcnBza29ocnZhdHNraVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2hpLWxhdG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUYcWhbOG4pWl5dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2hpLXRmbmdcIjogW1xuICAgICAgICAgICAgXCJUZm5nXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLitZzitLDitZvitY3itYPitYnitZxcIlxuICAgICAgICBdLFxuICAgICAgICBcInNoaVwiOiBbXG4gICAgICAgICAgICBcInNoaS1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzaG5cIjogW1xuICAgICAgICAgICAgXCJNeW1yXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhgJzhgK3hgbXhgLrhgojhgJDhgobhgLhcIlxuICAgICAgICBdLFxuICAgICAgICBcInNpXCI6IFtcbiAgICAgICAgICAgIFwiU2luaFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4LeD4LeS4LaC4LeE4La9XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzaW1wbGVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJXV1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTaW1wbGUgRW5nbGlzaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2pkXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0JrTo9C70LvRgiDRgdCwzITQvNGMINC606PQu9C7XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzamVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJiaWR1bXPDoW1lZ2llbGxhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzam9cIjogW1xuICAgICAgICAgICAgXCJNb25nXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhoLDhoZ7hoKrhoZ0g4aGk4aGe4aCw4aGg4aCoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzanVcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJ1Ym1lamVuc8OhbWllbiBnaWVsbGFcIlxuICAgICAgICBdLFxuICAgICAgICBcInNrXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2xvdmVuxI1pbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcInNsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2xvdmVuxaHEjWluYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic2xpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU2NobMOkc2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzbHJcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTYWzEsXLDp2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInNseVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkJhaGFzYSBTZWxheWFyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJza3ItYXJhYlwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItiz2LHYp9im24zaqduMXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJza3JcIjogW1xuICAgICAgICAgICAgXCJza3ItYXJhYlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3ljXCI6IFtcbiAgICAgICAgICAgIFwiU3lyY1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiTUVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi3KPcmNyq3J3cndyQXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzbVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkdhZ2FuYSBTYW1vYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic21hXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiw6VhcmplbHNhZW1pZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcInNtalwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImp1bGV2c8OhbWVnaWVsbGFcIlxuICAgICAgICBdLFxuICAgICAgICBcInNtblwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImFuYXLDosWha2llbMOiXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzbXNcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJzw6TDpMK0bcepacO1bGxcIlxuICAgICAgICBdLFxuICAgICAgICBcInNuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiY2hpU2hvbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcInNvXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU29vbWFhbGlnYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic29uXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2/Fi2F5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzcVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInNocWlwXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzclwiOiBbXG4gICAgICAgICAgICBcInNyLWN5cmxcIlxuICAgICAgICBdLFxuICAgICAgICBcInNyLWVjXCI6IFtcbiAgICAgICAgICAgIFwic3ItY3lybFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3ItY3lybFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGB0YDQv9GB0LrQuFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3ItZWxcIjogW1xuICAgICAgICAgICAgXCJzci1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzci1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic3Jwc2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzcm5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiLFxuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU3JhbmFudG9uZ29cIlxuICAgICAgICBdLFxuICAgICAgICBcInNzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiU2lTd2F0aVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3RcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTZXNvdGhvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzdHFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTZWVsdGVyc2tcIlxuICAgICAgICBdLFxuICAgICAgICBcInN0eVwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLRgdC10LHQtdGA0YLQsNGC0LDRgFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3VcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJCYXNhIFN1bmRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzdlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInN2ZW5za2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInN3XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiS2lzd2FoaWxpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJzd2JcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTaGlrb21vcm9cIlxuICAgICAgICBdLFxuICAgICAgICBcInN4dVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlPDpGdnc3NjaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwic3psXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwixZtsxa9uc2tpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0YVwiOiBbXG4gICAgICAgICAgICBcIlRhbWxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCupOCuruCuv+CutOCvjVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGF5XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVGF5YWxcIlxuICAgICAgICBdLFxuICAgICAgICBcInRjeVwiOiBbXG4gICAgICAgICAgICBcIktuZGFcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuCypOCzgeCys+CzgVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGVcIjogW1xuICAgICAgICAgICAgXCJUZWx1XCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLgsKTgsYbgsLLgsYHgsJfgsYFcIlxuICAgICAgICBdLFxuICAgICAgICBcInRldFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJ0ZXR1blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGctY3lybFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGC0L7St9C40LrTo1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGctbGF0blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInRvamlrxKtcIlxuICAgICAgICBdLFxuICAgICAgICBcInRnXCI6IFtcbiAgICAgICAgICAgIFwidGctY3lybFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGhcIjogW1xuICAgICAgICAgICAgXCJUaGFpXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLguYTguJfguKJcIlxuICAgICAgICBdLFxuICAgICAgICBcInRpXCI6IFtcbiAgICAgICAgICAgIFwiRXRoaVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4Ym14YyN4Yit4YqbXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0aWdcIjogW1xuICAgICAgICAgICAgXCJFdGhpXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLhibXhjI3hiKhcIlxuICAgICAgICBdLFxuICAgICAgICBcInRrXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVMO8cmttZW7Dp2VcIlxuICAgICAgICBdLFxuICAgICAgICBcInRrclwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItCm04DQsNOA0YXQvdCwINC80LjQt1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwidGxcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUYWdhbG9nXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0bHlcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiLFxuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGC0L7Qu9GL0YjTmSDQt9GL0LLQvtC9XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0bXJcIjogW1xuICAgICAgICAgICAgXCJIZWJyXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJNRVwiLFxuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIteQ16jXnteZ16og15HXkdec15nXqlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidG5cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTZXRzd2FuYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidG9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJQQVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJsZWEgZmFrYS1Ub25nYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidG9raXBvbmFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJXV1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUb2tpIFBvbmFcIlxuICAgICAgICBdLFxuICAgICAgICBcInRwaVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCIsXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUb2sgUGlzaW5cIlxuICAgICAgICBdLFxuICAgICAgICBcInRyXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIk1FXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlTDvHJrw6dlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0cnBcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJLb2tib3JvayAoVHJpcHVyaSlcIlxuICAgICAgICBdLFxuICAgICAgICBcInRydVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuG5qnVyb3lvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0cnZcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTZWRpcSBUYXJva29cIlxuICAgICAgICBdLFxuICAgICAgICBcInRzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiWGl0c29uZ2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInRzZFwiOiBbXG4gICAgICAgICAgICBcIkdyZWtcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIs6kz4POsc66z4nOvc65zrrOrFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidHRcIjogW1xuICAgICAgICAgICAgXCJDeXJsXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLRgtCw0YLQsNGA0YfQsFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidHQtY3lybFwiOiBbXG4gICAgICAgICAgICBcInR0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0dC1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwidGF0YXLDp2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInR0dFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlRhdGlcIlxuICAgICAgICBdLFxuICAgICAgICBcInR1bVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImNoaVR1bWJ1a2FcIlxuICAgICAgICBdLFxuICAgICAgICBcInR3XCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVHdpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0d2RcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJUd2VhbnRzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ0eVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlBBXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInJlbyB0YWhpdGlcIlxuICAgICAgICBdLFxuICAgICAgICBcInR5dlwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGC0YvQstCwINC00YvQu1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwidHpsXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiV1dcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVGFsb3NzYW5cIlxuICAgICAgICBdLFxuICAgICAgICBcInR6bVwiOiBbXG4gICAgICAgICAgICBcIlRmbmdcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuK1nOK0sOK1juK0sOK1o+K1ieK1luK1nFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidWRtXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0YPQtNC80YPRgNGCXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ1Z1wiOiBbXG4gICAgICAgICAgICBcInVnLWFyYWJcIlxuICAgICAgICBdLFxuICAgICAgICBcInVnLWFyYWJcIjogW1xuICAgICAgICAgICAgXCJBcmFiXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYptuH2YrYutuH2LHahtuVXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ1Zy1sYXRuXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwidXlnaHVyY2hlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ1Zy1jeXJsXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0YPQudKT0YPRgNGH05lcIlxuICAgICAgICBdLFxuICAgICAgICBcInVrXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0YPQutGA0LDRl9C90YHRjNC60LBcIlxuICAgICAgICBdLFxuICAgICAgICBcInVtdVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkh1bHVuw61peHN1d2Fha2FuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ1clwiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgICAgICAgXCJNRVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLYp9ix2K/ZiFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidXpcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJvyrt6YmVrY2hhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ2ZVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlRzaGl2ZW5kYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwidmVjXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwidsOobmV0b1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwidmVwXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwidmVwc8OkbiBrZWzigJlcIlxuICAgICAgICBdLFxuICAgICAgICBcInZpXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiVGnhur9uZyBWaeG7h3RcIlxuICAgICAgICBdLFxuICAgICAgICBcInZsc1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIldlc3QtVmxhbXNcIlxuICAgICAgICBdLFxuICAgICAgICBcInZtZlwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIk1haW5mcsOkbmtpc2NoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ2b1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIldXXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlZvbGFww7xrXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ2b3RcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJWYcSPxI9hXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ2cm9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJWw7Vyb1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwid2FcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJFVVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJ3YWxvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwid2FyXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiV2luYXJheVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwid2xzXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiUEFcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiRmFrYSd1dmVhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ3b1wiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIldvbG9mXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ3dXVcIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLlkLTor61cIlxuICAgICAgICBdLFxuICAgICAgICBcInhhbFwiOiBbXG4gICAgICAgICAgICBcIkN5cmxcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcItGF0LDQu9GM0LzQs1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwieGhcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJpc2lYaG9zYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieG1mXCI6IFtcbiAgICAgICAgICAgIFwiR2VvclwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4YOb4YOQ4YOg4YOS4YOQ4YOa4YOj4YOg4YOYXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ4c3lcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJTYWlTaXlhdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieWRkXCI6IFtcbiAgICAgICAgICAgIFwiSGViclwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICAgICAgICBcIkVVXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIkVhc3Rlcm4gWWlkZGlzaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieWlcIjogW1xuICAgICAgICAgICAgXCJIZWJyXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJNRVwiLFxuICAgICAgICAgICAgICAgIFwiRVVcIixcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIteZ15nWtNeT15nXqVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieW9cIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBRlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJZb3LDuWLDoVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieXJrXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi0J3QtdC90Y3RhtGPyrwg0LLQsNC00LBcIlxuICAgICAgICBdLFxuICAgICAgICBcInlybFwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIsOxZSdlbmdhdMO6XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ5dWFcIjogW1xuICAgICAgICAgICAgXCJMYXRuXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJNYWF5YSBUJ2FhblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwieXVlXCI6IFtcbiAgICAgICAgICAgIFwiSGFudFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi57K16KqeXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ6YVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlZhaGN1ZW5naFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemVhXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiRVVcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiWmXDqnV3c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemdoXCI6IFtcbiAgICAgICAgICAgIFwiVGZuZ1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQUZcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi4rWc4rSw4rWO4rSw4rWj4rWJ4rWW4rWcIOK1nOK0sOK1j+K0sOK1oeK0sOK1ouK1nFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemhcIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLkuK3mlodcIlxuICAgICAgICBdLFxuICAgICAgICBcInpoLWNsYXNzaWNhbFwiOiBbXG4gICAgICAgICAgICBcImx6aFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemgtY25cIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLkuK3mlofvvIjkuK3lm73lpKfpmYbvvIlcIlxuICAgICAgICBdLFxuICAgICAgICBcInpoLWhhbnNcIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLkuK3mlofvvIjnroDkvZPvvIlcIlxuICAgICAgICBdLFxuICAgICAgICBcInpoLWhhbnRcIjogW1xuICAgICAgICAgICAgXCJIYW50XCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLkuK3mlofvvIjnuYHpq5TvvIlcIlxuICAgICAgICBdLFxuICAgICAgICBcInpoLWhrXCI6IFtcbiAgICAgICAgICAgIFwiSGFudFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi5Lit5paH77yI6aaZ5riv77yJXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ6aC1taW4tbmFuXCI6IFtcbiAgICAgICAgICAgIFwibmFuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ6aC1tb1wiOiBbXG4gICAgICAgICAgICBcIkhhbnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuS4reaWh++8iOa+s+mWgO+8iVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemgtbXlcIjogW1xuICAgICAgICAgICAgXCJIYW5zXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJBU1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCLkuK3mlofvvIjpqazmnaXopb/kuprvvIlcIlxuICAgICAgICBdLFxuICAgICAgICBcInpoLXNnXCI6IFtcbiAgICAgICAgICAgIFwiSGFuc1wiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiQVNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwi5Lit5paH77yI5paw5Yqg5Z2h77yJXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ6aC10d1wiOiBbXG4gICAgICAgICAgICBcIkhhbnRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFTXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIuS4reaWh++8iOWPsOeBo++8iVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiemgteXVlXCI6IFtcbiAgICAgICAgICAgIFwieXVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ6dVwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFGXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImlzaVp1bHVcIlxuICAgICAgICBdLFxuICAgICAgICBcInp1blwiOiBbXG4gICAgICAgICAgICBcIkxhdG5cIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIlNoaXdpJ21hXCJcbiAgICAgICAgXVxuICAgIH0sXG4gICAgXCJzY3JpcHRncm91cHNcIjoge1xuICAgICAgICBcIkxhdGluXCI6IFtcbiAgICAgICAgICAgIFwiTGF0blwiLFxuICAgICAgICAgICAgXCJHb3RoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHcmVla1wiOiBbXG4gICAgICAgICAgICBcIkdyZWtcIlxuICAgICAgICBdLFxuICAgICAgICBcIldlc3RDYXVjYXNpYW5cIjogW1xuICAgICAgICAgICAgXCJBcm1uXCIsXG4gICAgICAgICAgICBcIkdlb3JcIlxuICAgICAgICBdLFxuICAgICAgICBcIkFyYWJpY1wiOiBbXG4gICAgICAgICAgICBcIkFyYWJcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1pZGRsZUVhc3Rlcm5cIjogW1xuICAgICAgICAgICAgXCJIZWJyXCIsXG4gICAgICAgICAgICBcIlN5cmNcIlxuICAgICAgICBdLFxuICAgICAgICBcIkFmcmljYW5cIjogW1xuICAgICAgICAgICAgXCJFdGhpXCIsXG4gICAgICAgICAgICBcIk5rb29cIixcbiAgICAgICAgICAgIFwiVGZuZ1wiLFxuICAgICAgICAgICAgXCJDb3B0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJTb3V0aEFzaWFuXCI6IFtcbiAgICAgICAgICAgIFwiQmVuZ1wiLFxuICAgICAgICAgICAgXCJEZXZhXCIsXG4gICAgICAgICAgICBcIkd1anJcIixcbiAgICAgICAgICAgIFwiR3VydVwiLFxuICAgICAgICAgICAgXCJLbmRhXCIsXG4gICAgICAgICAgICBcIk1seW1cIixcbiAgICAgICAgICAgIFwiT2xja1wiLFxuICAgICAgICAgICAgXCJPcnlhXCIsXG4gICAgICAgICAgICBcIlNhdXJcIixcbiAgICAgICAgICAgIFwiU2luaFwiLFxuICAgICAgICAgICAgXCJUYW1sXCIsXG4gICAgICAgICAgICBcIlRlbHVcIixcbiAgICAgICAgICAgIFwiVGlidFwiLFxuICAgICAgICAgICAgXCJUaGFhXCIsXG4gICAgICAgICAgICBcIldhcmFcIlxuICAgICAgICBdLFxuICAgICAgICBcIkN5cmlsbGljXCI6IFtcbiAgICAgICAgICAgIFwiQ3lybFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ0pLXCI6IFtcbiAgICAgICAgICAgIFwiSGFuc1wiLFxuICAgICAgICAgICAgXCJIYW50XCIsXG4gICAgICAgICAgICBcIkthbmFcIixcbiAgICAgICAgICAgIFwiS29yZVwiLFxuICAgICAgICAgICAgXCJKcGFuXCIsXG4gICAgICAgICAgICBcIllpaWlcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNvdXRoRWFzdEFzaWFuXCI6IFtcbiAgICAgICAgICAgIFwiQmFsaVwiLFxuICAgICAgICAgICAgXCJCYXRrXCIsXG4gICAgICAgICAgICBcIkJ1Z2lcIixcbiAgICAgICAgICAgIFwiSmF2YVwiLFxuICAgICAgICAgICAgXCJLaG1yXCIsXG4gICAgICAgICAgICBcIkxhb29cIixcbiAgICAgICAgICAgIFwiTXltclwiLFxuICAgICAgICAgICAgXCJUaGFpXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNb25nb2xpYW5cIjogW1xuICAgICAgICAgICAgXCJNb25nXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJTaWduV3JpdGluZ1wiOiBbXG4gICAgICAgICAgICBcIlNnbndcIlxuICAgICAgICBdLFxuICAgICAgICBcIk5hdGl2ZUFtZXJpY2FuXCI6IFtcbiAgICAgICAgICAgIFwiQ2hlclwiLFxuICAgICAgICAgICAgXCJDYW5zXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJTcGVjaWFsXCI6IFtcbiAgICAgICAgICAgIFwiWnl5eVwiXG4gICAgICAgIF1cbiAgICB9LFxuICAgIFwicnRsc2NyaXB0c1wiOiBbXG4gICAgICAgIFwiQXJhYlwiLFxuICAgICAgICBcIkhlYnJcIixcbiAgICAgICAgXCJTeXJjXCIsXG4gICAgICAgIFwiTmtvb1wiLFxuICAgICAgICBcIlRoYWFcIlxuICAgIF0sXG4gICAgXCJyZWdpb25ncm91cHNcIjoge1xuICAgICAgICBcIldXXCI6IDEsXG4gICAgICAgIFwiU1BcIjogMSxcbiAgICAgICAgXCJBTVwiOiAyLFxuICAgICAgICBcIkVVXCI6IDMsXG4gICAgICAgIFwiTUVcIjogMyxcbiAgICAgICAgXCJBRlwiOiAzLFxuICAgICAgICBcIkFTXCI6IDQsXG4gICAgICAgIFwiUEFcIjogNFxuICAgIH0sXG4gICAgXCJ0ZXJyaXRvcmllc1wiOiB7XG4gICAgICAgIFwiQUNcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQURcIjogW1xuICAgICAgICAgICAgXCJjYVwiLFxuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQUVcIjogW1xuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJtbFwiLFxuICAgICAgICAgICAgXCJwc1wiLFxuICAgICAgICAgICAgXCJmYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQUZcIjogW1xuICAgICAgICAgICAgXCJmYVwiLFxuICAgICAgICAgICAgXCJwc1wiLFxuICAgICAgICAgICAgXCJ1elwiLFxuICAgICAgICAgICAgXCJ0a1wiLFxuICAgICAgICAgICAgXCJiZ25cIixcbiAgICAgICAgICAgIFwidWctYXJhYlwiLFxuICAgICAgICAgICAgXCJray1hcmFiXCIsXG4gICAgICAgICAgICBcImtrLWN5cmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIkFHXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwicHRcIlxuICAgICAgICBdLFxuICAgICAgICBcIkFJXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkFMXCI6IFtcbiAgICAgICAgICAgIFwic3FcIixcbiAgICAgICAgICAgIFwiZWxcIixcbiAgICAgICAgICAgIFwibWtcIlxuICAgICAgICBdLFxuICAgICAgICBcIkFNXCI6IFtcbiAgICAgICAgICAgIFwiaHlcIixcbiAgICAgICAgICAgIFwia3UtbGF0blwiLFxuICAgICAgICAgICAgXCJhei1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJBT1wiOiBbXG4gICAgICAgICAgICBcInB0XCIsXG4gICAgICAgICAgICBcImxuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJBUlwiOiBbXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImN5XCIsXG4gICAgICAgICAgICBcImduXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJBU1wiOiBbXG4gICAgICAgICAgICBcInNtXCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJBVFwiOiBbXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcImJhclwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJpdFwiLFxuICAgICAgICAgICAgXCJoclwiLFxuICAgICAgICAgICAgXCJzbFwiLFxuICAgICAgICAgICAgXCJodVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQVVcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJ6aC1oYW50XCIsXG4gICAgICAgICAgICBcInpoXCIsXG4gICAgICAgICAgICBcIml0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJBV1wiOiBbXG4gICAgICAgICAgICBcIm5sXCIsXG4gICAgICAgICAgICBcInBhcFwiLFxuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQVhcIjogW1xuICAgICAgICAgICAgXCJzdlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQVpcIjogW1xuICAgICAgICAgICAgXCJhei1sYXRuXCIsXG4gICAgICAgICAgICBcImF6LWN5cmxcIixcbiAgICAgICAgICAgIFwidGx5XCIsXG4gICAgICAgICAgICBcImt1LWxhdG5cIixcbiAgICAgICAgICAgIFwidHR0XCIsXG4gICAgICAgICAgICBcInRrclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQkFcIjogW1xuICAgICAgICAgICAgXCJic1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJoclwiLFxuICAgICAgICAgICAgXCJzci1jeXJsXCIsXG4gICAgICAgICAgICBcInNyLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJCXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJEXCI6IFtcbiAgICAgICAgICAgIFwiYm5cIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwibXlcIixcbiAgICAgICAgICAgIFwibW5pXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJCRVwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcIm5sXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInZsc1wiLFxuICAgICAgICAgICAgXCJ3YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQkZcIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJmZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQkdcIjogW1xuICAgICAgICAgICAgXCJiZ1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJydVwiLFxuICAgICAgICAgICAgXCJ0clwiLFxuICAgICAgICAgICAgXCJkZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQkhcIjogW1xuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJtbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQklcIjogW1xuICAgICAgICAgICAgXCJyblwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJzd1wiLFxuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQkpcIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJmb25cIixcbiAgICAgICAgICAgIFwieW9cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJMXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkJNXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJOXCI6IFtcbiAgICAgICAgICAgIFwibXNcIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQk9cIjogW1xuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJxdVwiLFxuICAgICAgICAgICAgXCJheVwiLFxuICAgICAgICAgICAgXCJnblwiLFxuICAgICAgICAgICAgXCJhcm9cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJRXCI6IFtcbiAgICAgICAgICAgIFwicGFwXCIsXG4gICAgICAgICAgICBcIm5sXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJCUlwiOiBbXG4gICAgICAgICAgICBcInB0XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcImphXCIsXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImtvXCIsXG4gICAgICAgICAgICBcImtncFwiLFxuICAgICAgICAgICAgXCJ5cmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIkJTXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJUXCI6IFtcbiAgICAgICAgICAgIFwiZHpcIixcbiAgICAgICAgICAgIFwibmVcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkJXXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwidG5cIixcbiAgICAgICAgICAgIFwiYWZcIlxuICAgICAgICBdLFxuICAgICAgICBcIkJZXCI6IFtcbiAgICAgICAgICAgIFwiYmVcIixcbiAgICAgICAgICAgIFwicnVcIlxuICAgICAgICBdLFxuICAgICAgICBcIkJaXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNBXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiaXRcIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwicGR0XCIsXG4gICAgICAgICAgICBcImNyXCIsXG4gICAgICAgICAgICBcInlpXCIsXG4gICAgICAgICAgICBcImlrZS1jYW5zXCIsXG4gICAgICAgICAgICBcIm1vZVwiLFxuICAgICAgICAgICAgXCJhdGpcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNDXCI6IFtcbiAgICAgICAgICAgIFwibXNcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkNEXCI6IFtcbiAgICAgICAgICAgIFwic3dcIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwibG5cIixcbiAgICAgICAgICAgIFwia2dcIixcbiAgICAgICAgICAgIFwicndcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNGXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwic2dcIixcbiAgICAgICAgICAgIFwibG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkNHXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwibG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkNIXCI6IFtcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwiZ3N3XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcImxtb1wiLFxuICAgICAgICAgICAgXCJwdFwiLFxuICAgICAgICAgICAgXCJybVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ0lcIjogW1xuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ0tcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ0xcIjogW1xuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJhcm5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkNNXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZmZcIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwia3NmXCIsXG4gICAgICAgICAgICBcImhhLWFyYWJcIixcbiAgICAgICAgICAgIFwiaGEtbGF0blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ05cIjogW1xuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJ3dXVcIixcbiAgICAgICAgICAgIFwieXVlXCIsXG4gICAgICAgICAgICBcImhzblwiLFxuICAgICAgICAgICAgXCJoYWtcIixcbiAgICAgICAgICAgIFwibmFuXCIsXG4gICAgICAgICAgICBcImdhblwiLFxuICAgICAgICAgICAgXCJpaVwiLFxuICAgICAgICAgICAgXCJ1Zy1hcmFiXCIsXG4gICAgICAgICAgICBcInphXCIsXG4gICAgICAgICAgICBcIm1uXCIsXG4gICAgICAgICAgICBcImJvXCIsXG4gICAgICAgICAgICBcImtvXCIsXG4gICAgICAgICAgICBcImtrLWFyYWJcIixcbiAgICAgICAgICAgIFwia2stY3lybFwiLFxuICAgICAgICAgICAgXCJreVwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJydVwiLFxuICAgICAgICAgICAgXCJ2aVwiLFxuICAgICAgICAgICAgXCJ1elwiLFxuICAgICAgICAgICAgXCJsemhcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNPXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZ3VjXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJDUlwiOiBbXG4gICAgICAgICAgICBcImVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJDVVwiOiBbXG4gICAgICAgICAgICBcImVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJDVlwiOiBbXG4gICAgICAgICAgICBcImtlYVwiLFxuICAgICAgICAgICAgXCJwdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiQ1dcIjogW1xuICAgICAgICAgICAgXCJwYXBcIixcbiAgICAgICAgICAgIFwibmxcIixcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNYXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkNZXCI6IFtcbiAgICAgICAgICAgIFwiZWxcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwidHJcIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiaHlcIixcbiAgICAgICAgICAgIFwiYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkNaXCI6IFtcbiAgICAgICAgICAgIFwiY3NcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwic2tcIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwicGxcIlxuICAgICAgICBdLFxuICAgICAgICBcIkRFXCI6IFtcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiYmFyXCIsXG4gICAgICAgICAgICBcIm5kc1wiLFxuICAgICAgICAgICAgXCJubFwiLFxuICAgICAgICAgICAgXCJpdFwiLFxuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJydVwiLFxuICAgICAgICAgICAgXCJ2bWZcIixcbiAgICAgICAgICAgIFwidHJcIixcbiAgICAgICAgICAgIFwiZ3N3XCIsXG4gICAgICAgICAgICBcImRhXCIsXG4gICAgICAgICAgICBcImhyXCIsXG4gICAgICAgICAgICBcImt1LWxhdG5cIixcbiAgICAgICAgICAgIFwiZWxcIixcbiAgICAgICAgICAgIFwia3NoXCIsXG4gICAgICAgICAgICBcInBsXCIsXG4gICAgICAgICAgICBcImhzYlwiLFxuICAgICAgICAgICAgXCJmcnJcIixcbiAgICAgICAgICAgIFwiZHNiXCIsXG4gICAgICAgICAgICBcInN0cVwiLFxuICAgICAgICAgICAgXCJwZmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIkRHXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkRKXCI6IFtcbiAgICAgICAgICAgIFwiYWFcIixcbiAgICAgICAgICAgIFwic29cIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkRLXCI6IFtcbiAgICAgICAgICAgIFwiZGFcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwic3ZcIixcbiAgICAgICAgICAgIFwiZm9cIixcbiAgICAgICAgICAgIFwia2xcIixcbiAgICAgICAgICAgIFwianV0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJETVwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJET1wiOiBbXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJEWlwiOiBbXG4gICAgICAgICAgICBcImFycVwiLFxuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJrYWJcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkVBXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIkVDXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwicXVcIixcbiAgICAgICAgICAgIFwicXVnXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJFRVwiOiBbXG4gICAgICAgICAgICBcImV0XCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImZpXCIsXG4gICAgICAgICAgICBcInZyb1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiRUdcIjogW1xuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJhcnpcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZWxcIlxuICAgICAgICBdLFxuICAgICAgICBcIkVIXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkVSXCI6IFtcbiAgICAgICAgICAgIFwidGlcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwidGlnXCIsXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImFhXCIsXG4gICAgICAgICAgICBcImJ5blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiRVNcIjogW1xuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJjYVwiLFxuICAgICAgICAgICAgXCJnbFwiLFxuICAgICAgICAgICAgXCJldVwiLFxuICAgICAgICAgICAgXCJhc3RcIixcbiAgICAgICAgICAgIFwiZXh0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJFVFwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImFtXCIsXG4gICAgICAgICAgICBcIm9tXCIsXG4gICAgICAgICAgICBcInNvXCIsXG4gICAgICAgICAgICBcInRpXCIsXG4gICAgICAgICAgICBcImFhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJGSVwiOiBbXG4gICAgICAgICAgICBcImZpXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInN2XCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcImV0XCIsXG4gICAgICAgICAgICBcInJtZlwiLFxuICAgICAgICAgICAgXCJzZVwiLFxuICAgICAgICAgICAgXCJzbW5cIixcbiAgICAgICAgICAgIFwic21zXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJGSlwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImhpXCIsXG4gICAgICAgICAgICBcImhpZlwiLFxuICAgICAgICAgICAgXCJmalwiLFxuICAgICAgICAgICAgXCJydG1cIlxuICAgICAgICBdLFxuICAgICAgICBcIkZLXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkZNXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkZPXCI6IFtcbiAgICAgICAgICAgIFwiZm9cIlxuICAgICAgICBdLFxuICAgICAgICBcIkZSXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwib2NcIixcbiAgICAgICAgICAgIFwiaXRcIixcbiAgICAgICAgICAgIFwicHRcIixcbiAgICAgICAgICAgIFwicGNkXCIsXG4gICAgICAgICAgICBcImdzd1wiLFxuICAgICAgICAgICAgXCJiclwiLFxuICAgICAgICAgICAgXCJjb1wiLFxuICAgICAgICAgICAgXCJjYVwiLFxuICAgICAgICAgICAgXCJubFwiLFxuICAgICAgICAgICAgXCJldVwiLFxuICAgICAgICAgICAgXCJmcnBcIixcbiAgICAgICAgICAgIFwiaWFcIlxuICAgICAgICBdLFxuICAgICAgICBcIkdBXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkdCXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwic2NvXCIsXG4gICAgICAgICAgICBcInBhLWd1cnVcIixcbiAgICAgICAgICAgIFwiY3lcIixcbiAgICAgICAgICAgIFwiYm5cIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJlbFwiLFxuICAgICAgICAgICAgXCJpdFwiLFxuICAgICAgICAgICAgXCJrcy1hcmFiXCIsXG4gICAgICAgICAgICBcImdkXCIsXG4gICAgICAgICAgICBcInlpXCIsXG4gICAgICAgICAgICBcIm1sXCIsXG4gICAgICAgICAgICBcImdhXCIsXG4gICAgICAgICAgICBcImt3XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHRFwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHRVwiOiBbXG4gICAgICAgICAgICBcImthXCIsXG4gICAgICAgICAgICBcInhtZlwiLFxuICAgICAgICAgICAgXCJydVwiLFxuICAgICAgICAgICAgXCJoeVwiLFxuICAgICAgICAgICAgXCJhYlwiLFxuICAgICAgICAgICAgXCJvc1wiLFxuICAgICAgICAgICAgXCJrdS1sYXRuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHRlwiOiBbXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImdjclwiLFxuICAgICAgICAgICAgXCJ6aC1oYW50XCIsXG4gICAgICAgICAgICBcInpoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHR1wiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHSFwiOiBbXG4gICAgICAgICAgICBcImFrXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImVlXCIsXG4gICAgICAgICAgICBcImd1clwiLFxuICAgICAgICAgICAgXCJnYWFcIixcbiAgICAgICAgICAgIFwiaGEtbGF0blwiLFxuICAgICAgICAgICAgXCJmZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiR0lcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJlc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiR0xcIjogW1xuICAgICAgICAgICAgXCJrbFwiLFxuICAgICAgICAgICAgXCJkYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiR01cIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJmZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiR05cIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJmZlwiLFxuICAgICAgICAgICAgXCJucW9cIlxuICAgICAgICBdLFxuICAgICAgICBcIkdQXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIkdRXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZmFuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcInB0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHUlwiOiBbXG4gICAgICAgICAgICBcImVsXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInBudFwiLFxuICAgICAgICAgICAgXCJta1wiLFxuICAgICAgICAgICAgXCJ0clwiLFxuICAgICAgICAgICAgXCJiZ1wiLFxuICAgICAgICAgICAgXCJzcVwiLFxuICAgICAgICAgICAgXCJ0c2RcIlxuICAgICAgICBdLFxuICAgICAgICBcIkdUXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwicXVjXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHVVwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImNoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHV1wiOiBbXG4gICAgICAgICAgICBcInB0XCIsXG4gICAgICAgICAgICBcImZmXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJHWVwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJIS1wiOiBbXG4gICAgICAgICAgICBcInpoLWhhbnRcIixcbiAgICAgICAgICAgIFwiemhcIixcbiAgICAgICAgICAgIFwieXVlXCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJITlwiOiBbXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJIUlwiOiBbXG4gICAgICAgICAgICBcImhyXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcIml0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJIVFwiOiBbXG4gICAgICAgICAgICBcImh0XCIsXG4gICAgICAgICAgICBcImZyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJIVVwiOiBbXG4gICAgICAgICAgICBcImh1XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcInJvXCIsXG4gICAgICAgICAgICBcImhyXCIsXG4gICAgICAgICAgICBcInNrXCIsXG4gICAgICAgICAgICBcInNsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJQ1wiOiBbXG4gICAgICAgICAgICBcImVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJRFwiOiBbXG4gICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICBcImp2XCIsXG4gICAgICAgICAgICBcInN1XCIsXG4gICAgICAgICAgICBcIm1zXCIsXG4gICAgICAgICAgICBcIm1pblwiLFxuICAgICAgICAgICAgXCJiZXdcIixcbiAgICAgICAgICAgIFwiYmFuXCIsXG4gICAgICAgICAgICBcImJ1Z1wiLFxuICAgICAgICAgICAgXCJiam5cIixcbiAgICAgICAgICAgIFwiYWNlXCIsXG4gICAgICAgICAgICBcImJiYy1sYXRuXCIsXG4gICAgICAgICAgICBcInpoLWhhbnRcIixcbiAgICAgICAgICAgIFwiemhcIixcbiAgICAgICAgICAgIFwiZ29yXCIsXG4gICAgICAgICAgICBcInNseVwiLFxuICAgICAgICAgICAgXCJtd3ZcIlxuICAgICAgICBdLFxuICAgICAgICBcIklFXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZ2FcIixcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIklMXCI6IFtcbiAgICAgICAgICAgIFwiaGVcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwicm9cIixcbiAgICAgICAgICAgIFwieWlcIixcbiAgICAgICAgICAgIFwicGxcIixcbiAgICAgICAgICAgIFwibGFkLWxhdG5cIixcbiAgICAgICAgICAgIFwiaHVcIixcbiAgICAgICAgICAgIFwiYW1cIixcbiAgICAgICAgICAgIFwidGlcIixcbiAgICAgICAgICAgIFwibWxcIlxuICAgICAgICBdLFxuICAgICAgICBcIklNXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZ3ZcIlxuICAgICAgICBdLFxuICAgICAgICBcIklOXCI6IFtcbiAgICAgICAgICAgIFwiaGlcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiYm5cIixcbiAgICAgICAgICAgIFwidGVcIixcbiAgICAgICAgICAgIFwibXJcIixcbiAgICAgICAgICAgIFwidGFcIixcbiAgICAgICAgICAgIFwidXJcIixcbiAgICAgICAgICAgIFwiZ3VcIixcbiAgICAgICAgICAgIFwia25cIixcbiAgICAgICAgICAgIFwibWxcIixcbiAgICAgICAgICAgIFwib3JcIixcbiAgICAgICAgICAgIFwicGEtZ3VydVwiLFxuICAgICAgICAgICAgXCJiaG9cIixcbiAgICAgICAgICAgIFwiYXNcIixcbiAgICAgICAgICAgIFwibWFpXCIsXG4gICAgICAgICAgICBcImhuZVwiLFxuICAgICAgICAgICAgXCJuZVwiLFxuICAgICAgICAgICAgXCJzYXRcIixcbiAgICAgICAgICAgIFwia3MtYXJhYlwiLFxuICAgICAgICAgICAgXCJnb20tZGV2YVwiLFxuICAgICAgICAgICAgXCJnYm1cIixcbiAgICAgICAgICAgIFwic2RcIixcbiAgICAgICAgICAgIFwiZG9pXCIsXG4gICAgICAgICAgICBcInRjeVwiLFxuICAgICAgICAgICAgXCJicnhcIixcbiAgICAgICAgICAgIFwibW5pXCIsXG4gICAgICAgICAgICBcImhvY1wiLFxuICAgICAgICAgICAgXCJzYXpcIixcbiAgICAgICAgICAgIFwiYmZxXCIsXG4gICAgICAgICAgICBcIm5qb1wiLFxuICAgICAgICAgICAgXCJib1wiLFxuICAgICAgICAgICAgXCJicHlcIixcbiAgICAgICAgICAgIFwiYmZ0XCIsXG4gICAgICAgICAgICBcInNhXCIsXG4gICAgICAgICAgICBcImR2XCIsXG4gICAgICAgICAgICBcImR6XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJT1wiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJUVwiOiBbXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImNrYlwiLFxuICAgICAgICAgICAgXCJhei1hcmFiXCIsXG4gICAgICAgICAgICBcImF6LWxhdG5cIixcbiAgICAgICAgICAgIFwiZmFcIixcbiAgICAgICAgICAgIFwibHJjXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJUlwiOiBbXG4gICAgICAgICAgICBcImZhXCIsXG4gICAgICAgICAgICBcImF6LWFyYWJcIixcbiAgICAgICAgICAgIFwiYXotbGF0blwiLFxuICAgICAgICAgICAgXCJtem5cIixcbiAgICAgICAgICAgIFwiZ2xrXCIsXG4gICAgICAgICAgICBcImNrYlwiLFxuICAgICAgICAgICAgXCJzZGhcIixcbiAgICAgICAgICAgIFwidGtcIixcbiAgICAgICAgICAgIFwibHJjXCIsXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImJxaVwiLFxuICAgICAgICAgICAgXCJsdXpcIixcbiAgICAgICAgICAgIFwibGtpXCIsXG4gICAgICAgICAgICBcImJnblwiLFxuICAgICAgICAgICAgXCJoeVwiLFxuICAgICAgICAgICAgXCJwc1wiLFxuICAgICAgICAgICAgXCJrYVwiLFxuICAgICAgICAgICAgXCJnYnpcIixcbiAgICAgICAgICAgIFwia2stYXJhYlwiLFxuICAgICAgICAgICAgXCJray1jeXJsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJU1wiOiBbXG4gICAgICAgICAgICBcImlzXCIsXG4gICAgICAgICAgICBcImRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJJVFwiOiBbXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcInNjXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInZlY1wiLFxuICAgICAgICAgICAgXCJuYXBcIixcbiAgICAgICAgICAgIFwibGlqXCIsXG4gICAgICAgICAgICBcInNjblwiLFxuICAgICAgICAgICAgXCJzbFwiLFxuICAgICAgICAgICAgXCJzZGNcIixcbiAgICAgICAgICAgIFwiZnVyXCIsXG4gICAgICAgICAgICBcImVnbFwiLFxuICAgICAgICAgICAgXCJjYVwiLFxuICAgICAgICAgICAgXCJlbFwiLFxuICAgICAgICAgICAgXCJsbW9cIixcbiAgICAgICAgICAgIFwicG1zXCIsXG4gICAgICAgICAgICBcImhyXCIsXG4gICAgICAgICAgICBcInJnblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiSkVcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiSk1cIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJqYW1cIlxuICAgICAgICBdLFxuICAgICAgICBcIkpPXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkpQXCI6IFtcbiAgICAgICAgICAgIFwiamFcIixcbiAgICAgICAgICAgIFwicnl1XCIsXG4gICAgICAgICAgICBcImtvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLRVwiOiBbXG4gICAgICAgICAgICBcInN3XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImtpXCIsXG4gICAgICAgICAgICBcInNvXCIsXG4gICAgICAgICAgICBcInBrb1wiLFxuICAgICAgICAgICAgXCJvbVwiLFxuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJwYS1ndXJ1XCIsXG4gICAgICAgICAgICBcImd1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLR1wiOiBbXG4gICAgICAgICAgICBcImt5XCIsXG4gICAgICAgICAgICBcInJ1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLSFwiOiBbXG4gICAgICAgICAgICBcImttXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLSVwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLTVwiOiBbXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImZyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLTlwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLUFwiOiBbXG4gICAgICAgICAgICBcImtvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLUlwiOiBbXG4gICAgICAgICAgICBcImtvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLV1wiOiBbXG4gICAgICAgICAgICBcImFyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLWVwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJLWlwiOiBbXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcImtrLWN5cmxcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwidWctY3lybFwiLFxuICAgICAgICAgICAgXCJ1Zy1hcmFiXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJMQVwiOiBbXG4gICAgICAgICAgICBcImxvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJMQlwiOiBbXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImh5XCIsXG4gICAgICAgICAgICBcImt1LWFyYWJcIixcbiAgICAgICAgICAgIFwia3UtbGF0blwiLFxuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTENcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTElcIjogW1xuICAgICAgICAgICAgXCJkZVwiLFxuICAgICAgICAgICAgXCJnc3dcIlxuICAgICAgICBdLFxuICAgICAgICBcIkxLXCI6IFtcbiAgICAgICAgICAgIFwic2lcIixcbiAgICAgICAgICAgIFwidGFcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIkxSXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZmZcIlxuICAgICAgICBdLFxuICAgICAgICBcIkxTXCI6IFtcbiAgICAgICAgICAgIFwic3RcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwienVcIixcbiAgICAgICAgICAgIFwic3NcIixcbiAgICAgICAgICAgIFwieGhcIlxuICAgICAgICBdLFxuICAgICAgICBcIkxUXCI6IFtcbiAgICAgICAgICAgIFwibHRcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwic2dzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJMVVwiOiBbXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImxiXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInB0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJMVlwiOiBbXG4gICAgICAgICAgICBcImx2XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcImx0Z1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTFlcIjogW1xuICAgICAgICAgICAgXCJhclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUFcIjogW1xuICAgICAgICAgICAgXCJhcnlcIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiemdoXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInR6bVwiLFxuICAgICAgICAgICAgXCJzaGktbGF0blwiLFxuICAgICAgICAgICAgXCJyaWZcIixcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1DXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1EXCI6IFtcbiAgICAgICAgICAgIFwicm9cIixcbiAgICAgICAgICAgIFwidWtcIixcbiAgICAgICAgICAgIFwiYmdcIixcbiAgICAgICAgICAgIFwiZ2FnXCIsXG4gICAgICAgICAgICBcInJ1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNRVwiOiBbXG4gICAgICAgICAgICBcInNyLWxhdG5cIixcbiAgICAgICAgICAgIFwic3ItY3lybFwiLFxuICAgICAgICAgICAgXCJzcVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUZcIjogW1xuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUdcIjogW1xuICAgICAgICAgICAgXCJtZ1wiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUhcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJtaFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUtcIjogW1xuICAgICAgICAgICAgXCJta1wiLFxuICAgICAgICAgICAgXCJzcVwiLFxuICAgICAgICAgICAgXCJ0clwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTUxcIjogW1xuICAgICAgICAgICAgXCJibVwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJzZXNcIixcbiAgICAgICAgICAgIFwiYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1NXCI6IFtcbiAgICAgICAgICAgIFwibXlcIixcbiAgICAgICAgICAgIFwic2huXCIsXG4gICAgICAgICAgICBcImthY1wiLFxuICAgICAgICAgICAgXCJtbndcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1OXCI6IFtcbiAgICAgICAgICAgIFwibW5cIixcbiAgICAgICAgICAgIFwia2stYXJhYlwiLFxuICAgICAgICAgICAgXCJray1jeXJsXCIsXG4gICAgICAgICAgICBcInpoXCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcInVnLWN5cmxcIixcbiAgICAgICAgICAgIFwidWctYXJhYlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTU9cIjogW1xuICAgICAgICAgICAgXCJ6aC1oYW50XCIsXG4gICAgICAgICAgICBcInpoXCIsXG4gICAgICAgICAgICBcInB0XCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNUFwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImNoXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNUVwiOiBbXG4gICAgICAgICAgICBcImZyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNUlwiOiBbXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImZmXCIsXG4gICAgICAgICAgICBcIndvXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNU1wiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNVFwiOiBbXG4gICAgICAgICAgICBcIm10XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcImZyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNVVwiOiBbXG4gICAgICAgICAgICBcIm1mZVwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJiaG9cIixcbiAgICAgICAgICAgIFwidXJcIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwidGFcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1WXCI6IFtcbiAgICAgICAgICAgIFwiZHZcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1XXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwibnlcIixcbiAgICAgICAgICAgIFwidHVtXCIsXG4gICAgICAgICAgICBcInp1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJNWFwiOiBbXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInl1YVwiLFxuICAgICAgICAgICAgXCJzZWlcIlxuICAgICAgICBdLFxuICAgICAgICBcIk1ZXCI6IFtcbiAgICAgICAgICAgIFwibXNcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJ0YVwiLFxuICAgICAgICAgICAgXCJqdlwiLFxuICAgICAgICAgICAgXCJkdHBcIixcbiAgICAgICAgICAgIFwibWxcIixcbiAgICAgICAgICAgIFwiYnVnXCIsXG4gICAgICAgICAgICBcImJqblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTVpcIjogW1xuICAgICAgICAgICAgXCJwdFwiLFxuICAgICAgICAgICAgXCJ0c1wiLFxuICAgICAgICAgICAgXCJueVwiLFxuICAgICAgICAgICAgXCJzd1wiLFxuICAgICAgICAgICAgXCJ6dVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTkFcIjogW1xuICAgICAgICAgICAgXCJhZlwiLFxuICAgICAgICAgICAgXCJralwiLFxuICAgICAgICAgICAgXCJuZ1wiLFxuICAgICAgICAgICAgXCJoelwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJkZVwiLFxuICAgICAgICAgICAgXCJ0blwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTkNcIjogW1xuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTkVcIjogW1xuICAgICAgICAgICAgXCJoYS1sYXRuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImZmXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJORlwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJOR1wiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImhhLWxhdG5cIixcbiAgICAgICAgICAgIFwiaWdcIixcbiAgICAgICAgICAgIFwieW9cIixcbiAgICAgICAgICAgIFwiaGEtYXJhYlwiLFxuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJmZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTklcIjogW1xuICAgICAgICAgICAgXCJlc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTkxcIjogW1xuICAgICAgICAgICAgXCJubFwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJkZVwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJuZHNcIixcbiAgICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICAgIFwiZnlcIixcbiAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgIFwiemVhXCIsXG4gICAgICAgICAgICBcInJpZlwiLFxuICAgICAgICAgICAgXCJ0clwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTk9cIjogW1xuICAgICAgICAgICAgXCJuYlwiLFxuICAgICAgICAgICAgXCJublwiLFxuICAgICAgICAgICAgXCJzZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiTlBcIjogW1xuICAgICAgICAgICAgXCJuZVwiLFxuICAgICAgICAgICAgXCJtYWlcIixcbiAgICAgICAgICAgIFwiYmhvXCIsXG4gICAgICAgICAgICBcIm5ld1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJkdHlcIixcbiAgICAgICAgICAgIFwiaGlcIixcbiAgICAgICAgICAgIFwiYm9cIixcbiAgICAgICAgICAgIFwiYm5cIlxuICAgICAgICBdLFxuICAgICAgICBcIk5SXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwibmFcIlxuICAgICAgICBdLFxuICAgICAgICBcIk5VXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwibml1XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJOWlwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcIm1pXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJPTVwiOiBbXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImZhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJQQVwiOiBbXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInpoLWhhbnRcIixcbiAgICAgICAgICAgIFwiemhcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBFXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwicXVcIixcbiAgICAgICAgICAgIFwiYXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBGXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwidHlcIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiUEdcIjogW1xuICAgICAgICAgICAgXCJ0cGlcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiaG9cIlxuICAgICAgICBdLFxuICAgICAgICBcIlBIXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwidGxcIixcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiY2ViXCIsXG4gICAgICAgICAgICBcImlsb1wiLFxuICAgICAgICAgICAgXCJoaWxcIixcbiAgICAgICAgICAgIFwid2FyXCIsXG4gICAgICAgICAgICBcInBhbVwiLFxuICAgICAgICAgICAgXCJwYWdcIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJjcHNcIixcbiAgICAgICAgICAgIFwia3JqXCIsXG4gICAgICAgICAgICBcImJ0b1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiUEtcIjogW1xuICAgICAgICAgICAgXCJ1clwiLFxuICAgICAgICAgICAgXCJwYS1ndXJ1XCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInBzXCIsXG4gICAgICAgICAgICBcInNkXCIsXG4gICAgICAgICAgICBcInNrci1hcmFiXCIsXG4gICAgICAgICAgICBcImJyaFwiLFxuICAgICAgICAgICAgXCJmYVwiLFxuICAgICAgICAgICAgXCJiZ25cIixcbiAgICAgICAgICAgIFwidGctY3lybFwiLFxuICAgICAgICAgICAgXCJiZnRcIixcbiAgICAgICAgICAgIFwia2h3XCIsXG4gICAgICAgICAgICBcImtzLWFyYWJcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBMXCI6IFtcbiAgICAgICAgICAgIFwicGxcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZGVcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwic3psXCIsXG4gICAgICAgICAgICBcImJlXCIsXG4gICAgICAgICAgICBcInVrXCIsXG4gICAgICAgICAgICBcImNzYlwiLFxuICAgICAgICAgICAgXCJzbGlcIixcbiAgICAgICAgICAgIFwibHRcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBNXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlBOXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlBSXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlBTXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBUXCI6IFtcbiAgICAgICAgICAgIFwicHRcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZ2xcIlxuICAgICAgICBdLFxuICAgICAgICBcIlBXXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlBZXCI6IFtcbiAgICAgICAgICAgIFwiZ25cIixcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwiZGVcIlxuICAgICAgICBdLFxuICAgICAgICBcIlFBXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZmFcIixcbiAgICAgICAgICAgIFwibWxcIlxuICAgICAgICBdLFxuICAgICAgICBcIlJFXCI6IFtcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwicmNmXCIsXG4gICAgICAgICAgICBcInRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJST1wiOiBbXG4gICAgICAgICAgICBcInJvXCIsXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImVzXCIsXG4gICAgICAgICAgICBcImh1XCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInRyXCIsXG4gICAgICAgICAgICBcInNyLWxhdG5cIixcbiAgICAgICAgICAgIFwic3ItY3lybFwiLFxuICAgICAgICAgICAgXCJiZ1wiLFxuICAgICAgICAgICAgXCJlbFwiLFxuICAgICAgICAgICAgXCJwbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiUlNcIjogW1xuICAgICAgICAgICAgXCJzci1jeXJsXCIsXG4gICAgICAgICAgICBcInNyLWxhdG5cIixcbiAgICAgICAgICAgIFwic3FcIixcbiAgICAgICAgICAgIFwiaHVcIixcbiAgICAgICAgICAgIFwicm9cIixcbiAgICAgICAgICAgIFwiaHJcIixcbiAgICAgICAgICAgIFwic2tcIixcbiAgICAgICAgICAgIFwidWtcIlxuICAgICAgICBdLFxuICAgICAgICBcIlJVXCI6IFtcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwidHRcIixcbiAgICAgICAgICAgIFwiYmFcIixcbiAgICAgICAgICAgIFwiY3ZcIixcbiAgICAgICAgICAgIFwiaHlcIixcbiAgICAgICAgICAgIFwiY2VcIixcbiAgICAgICAgICAgIFwiYXZcIixcbiAgICAgICAgICAgIFwidWRtXCIsXG4gICAgICAgICAgICBcIm1oclwiLFxuICAgICAgICAgICAgXCJzYWhcIixcbiAgICAgICAgICAgIFwib3NcIixcbiAgICAgICAgICAgIFwia2JkXCIsXG4gICAgICAgICAgICBcIm15dlwiLFxuICAgICAgICAgICAgXCJtZGZcIixcbiAgICAgICAgICAgIFwia3VtXCIsXG4gICAgICAgICAgICBcImt2XCIsXG4gICAgICAgICAgICBcImxlelwiLFxuICAgICAgICAgICAgXCJrcmNcIixcbiAgICAgICAgICAgIFwiaW5oXCIsXG4gICAgICAgICAgICBcInR5dlwiLFxuICAgICAgICAgICAgXCJhei1jeXJsXCIsXG4gICAgICAgICAgICBcImF6LWxhdG5cIixcbiAgICAgICAgICAgIFwiYWR5XCIsXG4gICAgICAgICAgICBcImtybFwiLFxuICAgICAgICAgICAgXCJsYmVcIixcbiAgICAgICAgICAgIFwia29pXCIsXG4gICAgICAgICAgICBcIm1yalwiLFxuICAgICAgICAgICAgXCJmaVwiLFxuICAgICAgICAgICAgXCJzci1sYXRuXCIsXG4gICAgICAgICAgICBcInNyLWN5cmxcIixcbiAgICAgICAgICAgIFwidmVwXCIsXG4gICAgICAgICAgICBcIm1uXCIsXG4gICAgICAgICAgICBcInZvdFwiLFxuICAgICAgICAgICAgXCJjdVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiUldcIjogW1xuICAgICAgICAgICAgXCJyd1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0FcIjogW1xuICAgICAgICAgICAgXCJhclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0JcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0NcIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0RcIjogW1xuICAgICAgICAgICAgXCJhclwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJoYS1hcmFiXCIsXG4gICAgICAgICAgICBcImhhLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlNFXCI6IFtcbiAgICAgICAgICAgIFwic3ZcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZmlcIixcbiAgICAgICAgICAgIFwiZml0XCIsXG4gICAgICAgICAgICBcInNlXCIsXG4gICAgICAgICAgICBcInlpXCIsXG4gICAgICAgICAgICBcInNtalwiLFxuICAgICAgICAgICAgXCJzbWFcIixcbiAgICAgICAgICAgIFwiaWFcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNHXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiemhcIixcbiAgICAgICAgICAgIFwibXNcIixcbiAgICAgICAgICAgIFwidGFcIixcbiAgICAgICAgICAgIFwibWxcIixcbiAgICAgICAgICAgIFwicGEtZ3VydVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0hcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0lcIjogW1xuICAgICAgICAgICAgXCJzbFwiLFxuICAgICAgICAgICAgXCJoclwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJkZVwiLFxuICAgICAgICAgICAgXCJodVwiLFxuICAgICAgICAgICAgXCJpdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0pcIjogW1xuICAgICAgICAgICAgXCJuYlwiLFxuICAgICAgICAgICAgXCJydVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0tcIjogW1xuICAgICAgICAgICAgXCJza1wiLFxuICAgICAgICAgICAgXCJjc1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJkZVwiLFxuICAgICAgICAgICAgXCJodVwiLFxuICAgICAgICAgICAgXCJ1a1wiLFxuICAgICAgICAgICAgXCJwbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU0xcIjogW1xuICAgICAgICAgICAgXCJrcmlcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZmZcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNNXCI6IFtcbiAgICAgICAgICAgIFwiaXRcIixcbiAgICAgICAgICAgIFwiZW9cIlxuICAgICAgICBdLFxuICAgICAgICBcIlNOXCI6IFtcbiAgICAgICAgICAgIFwid29cIixcbiAgICAgICAgICAgIFwiZnJcIixcbiAgICAgICAgICAgIFwiZmZcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNPXCI6IFtcbiAgICAgICAgICAgIFwic29cIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwic3dcIixcbiAgICAgICAgICAgIFwib21cIlxuICAgICAgICBdLFxuICAgICAgICBcIlNSXCI6IFtcbiAgICAgICAgICAgIFwibmxcIixcbiAgICAgICAgICAgIFwic3JuXCIsXG4gICAgICAgICAgICBcInpoLWhhbnRcIixcbiAgICAgICAgICAgIFwiemhcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNTXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlNUXCI6IFtcbiAgICAgICAgICAgIFwicHRcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNWXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNYXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZXNcIixcbiAgICAgICAgICAgIFwibmxcIlxuICAgICAgICBdLFxuICAgICAgICBcIlNZXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwia3UtbGF0blwiLFxuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJoeVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiU1pcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJzc1wiLFxuICAgICAgICAgICAgXCJ6dVwiLFxuICAgICAgICAgICAgXCJ0c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVEFcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVENcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVERcIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJhclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVEZcIjogW1xuICAgICAgICAgICAgXCJmclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVEdcIjogW1xuICAgICAgICAgICAgXCJmclwiLFxuICAgICAgICAgICAgXCJlZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVEhcIjogW1xuICAgICAgICAgICAgXCJ0aFwiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJub2RcIixcbiAgICAgICAgICAgIFwiemgtaGFudFwiLFxuICAgICAgICAgICAgXCJ6aFwiLFxuICAgICAgICAgICAgXCJtbndcIixcbiAgICAgICAgICAgIFwic2huXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJUSlwiOiBbXG4gICAgICAgICAgICBcInRnLWN5cmxcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwiZmFcIixcbiAgICAgICAgICAgIFwiYXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIlRLXCI6IFtcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlRMXCI6IFtcbiAgICAgICAgICAgIFwicHRcIixcbiAgICAgICAgICAgIFwidGV0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJUTVwiOiBbXG4gICAgICAgICAgICBcInRrXCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcInV6XCIsXG4gICAgICAgICAgICBcImt1LWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlROXCI6IFtcbiAgICAgICAgICAgIFwiYWViLWFyYWJcIixcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIlRPXCI6IFtcbiAgICAgICAgICAgIFwidG9cIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIlRSXCI6IFtcbiAgICAgICAgICAgIFwidHJcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwia3UtbGF0blwiLFxuICAgICAgICAgICAgXCJrYmRcIixcbiAgICAgICAgICAgIFwiYXotbGF0blwiLFxuICAgICAgICAgICAgXCJhei1hcmFiXCIsXG4gICAgICAgICAgICBcImFyXCIsXG4gICAgICAgICAgICBcImJnXCIsXG4gICAgICAgICAgICBcImFkeVwiLFxuICAgICAgICAgICAgXCJraXVcIixcbiAgICAgICAgICAgIFwiaHlcIixcbiAgICAgICAgICAgIFwia2FcIixcbiAgICAgICAgICAgIFwic3ItbGF0blwiLFxuICAgICAgICAgICAgXCJzci1jeXJsXCIsXG4gICAgICAgICAgICBcImx6elwiLFxuICAgICAgICAgICAgXCJzcVwiLFxuICAgICAgICAgICAgXCJhYlwiLFxuICAgICAgICAgICAgXCJlbFwiLFxuICAgICAgICAgICAgXCJ0cnVcIixcbiAgICAgICAgICAgIFwidXpcIixcbiAgICAgICAgICAgIFwia3lcIixcbiAgICAgICAgICAgIFwia2stY3lybFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVFRcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJlc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVFZcIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVFdcIjogW1xuICAgICAgICAgICAgXCJ6aC1oYW50XCIsXG4gICAgICAgICAgICBcInpoXCIsXG4gICAgICAgICAgICBcInRydlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVFpcIjogW1xuICAgICAgICAgICAgXCJzd1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJsYWdcIlxuICAgICAgICBdLFxuICAgICAgICBcIlVBXCI6IFtcbiAgICAgICAgICAgIFwidWtcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwicGxcIixcbiAgICAgICAgICAgIFwieWlcIixcbiAgICAgICAgICAgIFwicnVlXCIsXG4gICAgICAgICAgICBcImJlXCIsXG4gICAgICAgICAgICBcImNyaFwiLFxuICAgICAgICAgICAgXCJyb1wiLFxuICAgICAgICAgICAgXCJiZ1wiLFxuICAgICAgICAgICAgXCJ0clwiLFxuICAgICAgICAgICAgXCJodVwiLFxuICAgICAgICAgICAgXCJlbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVUdcIjogW1xuICAgICAgICAgICAgXCJzd1wiLFxuICAgICAgICAgICAgXCJsZ1wiLFxuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJyd1wiLFxuICAgICAgICAgICAgXCJoaVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVU1cIjogW1xuICAgICAgICAgICAgXCJlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiVVNcIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJlc1wiLFxuICAgICAgICAgICAgXCJ6aC1oYW50XCIsXG4gICAgICAgICAgICBcInpoXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcImRlXCIsXG4gICAgICAgICAgICBcInRsXCIsXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcInZpXCIsXG4gICAgICAgICAgICBcImtvXCIsXG4gICAgICAgICAgICBcInJ1XCIsXG4gICAgICAgICAgICBcIm52XCIsXG4gICAgICAgICAgICBcInlpXCIsXG4gICAgICAgICAgICBcInBkY1wiLFxuICAgICAgICAgICAgXCJoYXdcIixcbiAgICAgICAgICAgIFwiZnJjXCIsXG4gICAgICAgICAgICBcImNoclwiLFxuICAgICAgICAgICAgXCJlc3VcIixcbiAgICAgICAgICAgIFwiY2hvXCIsXG4gICAgICAgICAgICBcImxrdFwiLFxuICAgICAgICAgICAgXCJpa1wiLFxuICAgICAgICAgICAgXCJtdXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIlVZXCI6IFtcbiAgICAgICAgICAgIFwiZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIlVaXCI6IFtcbiAgICAgICAgICAgIFwidXpcIixcbiAgICAgICAgICAgIFwicnVcIixcbiAgICAgICAgICAgIFwia2FhXCIsXG4gICAgICAgICAgICBcInRyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWQVwiOiBbXG4gICAgICAgICAgICBcIml0XCIsXG4gICAgICAgICAgICBcImxhXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWQ1wiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWRVwiOiBbXG4gICAgICAgICAgICBcImVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWR1wiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWSVwiOiBbXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJWTlwiOiBbXG4gICAgICAgICAgICBcInZpXCIsXG4gICAgICAgICAgICBcInpoLWhhbnRcIixcbiAgICAgICAgICAgIFwiemhcIlxuICAgICAgICBdLFxuICAgICAgICBcIlZVXCI6IFtcbiAgICAgICAgICAgIFwiYmlcIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwiZnJcIlxuICAgICAgICBdLFxuICAgICAgICBcIldGXCI6IFtcbiAgICAgICAgICAgIFwid2xzXCIsXG4gICAgICAgICAgICBcImZyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJXU1wiOiBbXG4gICAgICAgICAgICBcInNtXCIsXG4gICAgICAgICAgICBcImVuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJYS1wiOiBbXG4gICAgICAgICAgICBcInNxXCIsXG4gICAgICAgICAgICBcImFsblwiLFxuICAgICAgICAgICAgXCJzci1jeXJsXCIsXG4gICAgICAgICAgICBcInNyLWxhdG5cIlxuICAgICAgICBdLFxuICAgICAgICBcIllFXCI6IFtcbiAgICAgICAgICAgIFwiYXJcIixcbiAgICAgICAgICAgIFwiZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIllUXCI6IFtcbiAgICAgICAgICAgIFwic3diXCIsXG4gICAgICAgICAgICBcImZyXCIsXG4gICAgICAgICAgICBcInN3XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJaQVwiOiBbXG4gICAgICAgICAgICBcImVuXCIsXG4gICAgICAgICAgICBcInp1XCIsXG4gICAgICAgICAgICBcInhoXCIsXG4gICAgICAgICAgICBcImFmXCIsXG4gICAgICAgICAgICBcIm5zb1wiLFxuICAgICAgICAgICAgXCJ0blwiLFxuICAgICAgICAgICAgXCJzdFwiLFxuICAgICAgICAgICAgXCJ0c1wiLFxuICAgICAgICAgICAgXCJzc1wiLFxuICAgICAgICAgICAgXCJ2ZVwiLFxuICAgICAgICAgICAgXCJoaVwiLFxuICAgICAgICAgICAgXCJuclwiLFxuICAgICAgICAgICAgXCJzd1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiWk1cIjogW1xuICAgICAgICAgICAgXCJlblwiLFxuICAgICAgICAgICAgXCJueVwiLFxuICAgICAgICAgICAgXCJsb3pcIlxuICAgICAgICBdLFxuICAgICAgICBcIlpXXCI6IFtcbiAgICAgICAgICAgIFwic25cIixcbiAgICAgICAgICAgIFwiZW5cIixcbiAgICAgICAgICAgIFwibmRcIixcbiAgICAgICAgICAgIFwibnlcIixcbiAgICAgICAgICAgIFwidmVcIixcbiAgICAgICAgICAgIFwidG5cIlxuICAgICAgICBdXG4gICAgfVxufVxufSAoIGpRdWVyeSApICk7XG59LHt9XX0se30sWzFdKTtcbiIsIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHF1ZXJ5aW5nIGxhbmd1YWdlIGRhdGEuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEyIEFsb2xpdGEgU2hhcm1hLCBBbWlyIEFoYXJvbmksIEFydW4gR2FuZXNoLCBCcmFuZG9uIEhhcnJpcyxcbiAqIE5pa2xhcyBMYXhzdHLDtm0sIFBhdSBHaW5lciwgU2FudGhvc2ggVGhvdHRpbmdhbCwgU2llYnJhbmQgTWF6ZWxhbmQgYW5kIG90aGVyXG4gKiBjb250cmlidXRvcnMuIFNlZSBDUkVESVRTIGZvciBhIGxpc3QuXG4gKlxuICogVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpcyBkdWFsIGxpY2Vuc2VkIEdQTHYyIG9yIGxhdGVyIGFuZCBNSVQuIFlvdSBkb24ndFxuICogaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsIHRvIGNob29zZSBvbmUgbGljZW5zZSBvciB0aGUgb3RoZXIgYW5kIHlvdSBkb24ndFxuICogaGF2ZSB0byBub3RpZnkgYW55b25lIHdoaWNoIGxpY2Vuc2UgeW91IGFyZSB1c2luZy4gWW91IGFyZSBmcmVlIHRvIHVzZVxuICogVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpbiBjb21tZXJjaWFsIHByb2plY3RzIGFzIGxvbmcgYXMgdGhlIGNvcHlyaWdodFxuICogaGVhZGVyIGlzIGxlZnQgaW50YWN0LiBTZWUgZmlsZXMgR1BMLUxJQ0VOU0UgYW5kIE1JVC1MSUNFTlNFIGZvciBkZXRhaWxzLlxuICpcbiAqIEBmaWxlXG4gKiBAaW5ncm91cCBFeHRlbnNpb25zXG4gKiBAbGljZW5jZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5jZSAyLjAgb3IgbGF0ZXJcbiAqIEBsaWNlbmNlIE1JVCBMaWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbiAoICQgKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvKipcblx0ICogSXMgdGhpcyBsYW5ndWFnZSBhIHJlZGlyZWN0IHRvIGFub3RoZXIgbGFuZ3VhZ2U/XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBMYW5ndWFnZSBjb2RlXG5cdCAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufSBUYXJnZXQgbGFuZ3VhZ2UgY29kZSBpZiBpdCdzIGEgcmVkaXJlY3Qgb3IgZmFsc2UgaWYgaXQncyBub3Rcblx0ICovXG5cdCQudWxzLmRhdGEuaXNSZWRpcmVjdCA9IGZ1bmN0aW9uICggbGFuZ3VhZ2UgKSB7XG5cdFx0cmV0dXJuICggJC51bHMuZGF0YS5sYW5ndWFnZXNbIGxhbmd1YWdlIF0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0JC51bHMuZGF0YS5sYW5ndWFnZXNbIGxhbmd1YWdlIF0ubGVuZ3RoID09PSAxICkgP1xuXHRcdFx0JC51bHMuZGF0YS5sYW5ndWFnZXNbIGxhbmd1YWdlIF1bIDAgXSA6IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY3JpcHQgb2YgdGhlIGxhbmd1YWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29kZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHQkLnVscy5kYXRhLmdldFNjcmlwdCA9IGZ1bmN0aW9uICggbGFuZ3VhZ2UgKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQudWxzLmRhdGEuaXNSZWRpcmVjdCggbGFuZ3VhZ2UgKTtcblxuXHRcdGlmICggdGFyZ2V0ICkge1xuXHRcdFx0cmV0dXJuICQudWxzLmRhdGEuZ2V0U2NyaXB0KCB0YXJnZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoICEkLnVscy5kYXRhLmxhbmd1YWdlc1sgbGFuZ3VhZ2UgXSApIHtcblx0XHRcdC8vIFVuZGV0ZXJtaW5lZFxuXHRcdFx0cmV0dXJuICdaeXl5Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJC51bHMuZGF0YS5sYW5ndWFnZXNbIGxhbmd1YWdlIF1bIDAgXTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcmVnaW9ucyBpbiB3aGljaCBhIGxhbmd1YWdlIGlzIHNwb2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIExhbmd1YWdlIGNvZGVcblx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfVxuXHQgKi9cblx0JC51bHMuZGF0YS5nZXRSZWdpb25zID0gZnVuY3Rpb24gKCBsYW5ndWFnZSApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJC51bHMuZGF0YS5pc1JlZGlyZWN0KCBsYW5ndWFnZSApO1xuXG5cdFx0aWYgKCB0YXJnZXQgKSB7XG5cdFx0XHRyZXR1cm4gJC51bHMuZGF0YS5nZXRSZWdpb25zKCB0YXJnZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCAkLnVscy5kYXRhLmxhbmd1YWdlc1sgbGFuZ3VhZ2UgXSAmJiAkLnVscy5kYXRhLmxhbmd1YWdlc1sgbGFuZ3VhZ2UgXVsgMSBdICkgfHwgJ1VOS05PV04nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdXRvbnltIG9mIHRoZSBsYW5ndWFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIExhbmd1YWdlIGNvZGVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0JC51bHMuZGF0YS5nZXRBdXRvbnltID0gZnVuY3Rpb24gKCBsYW5ndWFnZSApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJC51bHMuZGF0YS5pc1JlZGlyZWN0KCBsYW5ndWFnZSApO1xuXG5cdFx0aWYgKCB0YXJnZXQgKSB7XG5cdFx0XHRyZXR1cm4gJC51bHMuZGF0YS5nZXRBdXRvbnltKCB0YXJnZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCAkLnVscy5kYXRhLmxhbmd1YWdlc1sgbGFuZ3VhZ2UgXSAmJlxuXHRcdFx0JC51bHMuZGF0YS5sYW5ndWFnZXNbIGxhbmd1YWdlIF1bIDIgXSApIHx8IGxhbmd1YWdlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCBsYW5ndWFnZSBjb2RlcyBhbmQgY29ycmVzcG9uZGluZyBhdXRvbnltc1xuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX1cblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0QXV0b255bXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxhbmd1YWdlLFxuXHRcdFx0YXV0b255bXNCeUNvZGUgPSB7fTtcblxuXHRcdGZvciAoIGxhbmd1YWdlIGluICQudWxzLmRhdGEubGFuZ3VhZ2VzICkge1xuXHRcdFx0aWYgKCAkLnVscy5kYXRhLmlzUmVkaXJlY3QoIGxhbmd1YWdlICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhdXRvbnltc0J5Q29kZVsgbGFuZ3VhZ2UgXSA9ICQudWxzLmRhdGEuZ2V0QXV0b255bSggbGFuZ3VhZ2UgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXV0b255bXNCeUNvZGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIGxhbmd1YWdlcyB3cml0dGVuIGluIHNjcmlwdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBzdHJpbmdcblx0ICogQHJldHVybiB7c3RyaW5nW119IGxhbmd1YWdlcyBjb2Rlc1xuXHQgKi9cblx0JC51bHMuZGF0YS5nZXRMYW5ndWFnZXNJblNjcmlwdCA9IGZ1bmN0aW9uICggc2NyaXB0ICkge1xuXHRcdHJldHVybiAkLnVscy5kYXRhLmdldExhbmd1YWdlc0luU2NyaXB0cyggWyBzY3JpcHQgXSApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCBsYW5ndWFnZXMgd3JpdHRlbiBpbiB0aGUgZ2l2ZW4gc2NyaXB0cy5cblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gc2NyaXB0c1xuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX0gbGFuZ3VhZ2VzIGNvZGVzXG5cdCAqL1xuXHQkLnVscy5kYXRhLmdldExhbmd1YWdlc0luU2NyaXB0cyA9IGZ1bmN0aW9uICggc2NyaXB0cyApIHtcblx0XHR2YXIgbGFuZ3VhZ2UsIGksXG5cdFx0XHRsYW5ndWFnZXNJblNjcmlwdHMgPSBbXTtcblxuXHRcdGZvciAoIGxhbmd1YWdlIGluICQudWxzLmRhdGEubGFuZ3VhZ2VzICkge1xuXHRcdFx0aWYgKCAkLnVscy5kYXRhLmlzUmVkaXJlY3QoIGxhbmd1YWdlICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2NyaXB0c1sgaSBdID09PSAkLnVscy5kYXRhLmdldFNjcmlwdCggbGFuZ3VhZ2UgKSApIHtcblx0XHRcdFx0XHRsYW5ndWFnZXNJblNjcmlwdHMucHVzaCggbGFuZ3VhZ2UgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBsYW5ndWFnZXNJblNjcmlwdHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbGFuZ3VhZ2VzIGluIGEgcmVnaW9uLFxuXHQgKiBncm91cGVkIGJ5IHNjcmlwdCBncm91cC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lvbiBSZWdpb24gY29kZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHQkLnVscy5kYXRhLmdldExhbmd1YWdlc0J5U2NyaXB0R3JvdXBJblJlZ2lvbiA9IGZ1bmN0aW9uICggcmVnaW9uICkge1xuXHRcdHJldHVybiAkLnVscy5kYXRhLmdldExhbmd1YWdlc0J5U2NyaXB0R3JvdXBJblJlZ2lvbnMoIFsgcmVnaW9uIF0gKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBnaXZlbiBsaXN0IG9mIGxhbmd1YWdlcyBncm91cGVkIGJ5IHNjcmlwdC5cblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gbGFuZ3VhZ2VzIEFycmF5IG9mIGxhbmd1YWdlIGNvZGVzIHRvIGdyb3VwXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfSBBcnJheSBvZiBsYW5ndWFnZSBjb2Rlc1xuXHQgKi9cblx0JC51bHMuZGF0YS5nZXRMYW5ndWFnZXNCeVNjcmlwdEdyb3VwID0gZnVuY3Rpb24gKCBsYW5ndWFnZXMgKSB7XG5cdFx0dmFyIGxhbmd1YWdlc0J5U2NyaXB0R3JvdXAgPSB7fSxcblx0XHRcdGxhbmd1YWdlLCBsYW5ndWFnZUluZGV4LCByZXNvbHZlZFJlZGlyZWN0LCBsYW5nU2NyaXB0R3JvdXA7XG5cblx0XHRmb3IgKCBsYW5ndWFnZUluZGV4ID0gMDsgbGFuZ3VhZ2VJbmRleCA8IGxhbmd1YWdlcy5sZW5ndGg7IGxhbmd1YWdlSW5kZXgrKyApIHtcblx0XHRcdGxhbmd1YWdlID0gbGFuZ3VhZ2VzWyBsYW5ndWFnZUluZGV4IF07XG5cdFx0XHRyZXNvbHZlZFJlZGlyZWN0ID0gJC51bHMuZGF0YS5pc1JlZGlyZWN0KCBsYW5ndWFnZSApIHx8IGxhbmd1YWdlO1xuXHRcdFx0bGFuZ1NjcmlwdEdyb3VwID0gJC51bHMuZGF0YS5nZXRTY3JpcHRHcm91cE9mTGFuZ3VhZ2UoIHJlc29sdmVkUmVkaXJlY3QgKTtcblx0XHRcdGlmICggIWxhbmd1YWdlc0J5U2NyaXB0R3JvdXBbIGxhbmdTY3JpcHRHcm91cCBdICkge1xuXHRcdFx0XHRsYW5ndWFnZXNCeVNjcmlwdEdyb3VwWyBsYW5nU2NyaXB0R3JvdXAgXSA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0bGFuZ3VhZ2VzQnlTY3JpcHRHcm91cFsgbGFuZ1NjcmlwdEdyb3VwIF0ucHVzaCggbGFuZ3VhZ2UgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxhbmd1YWdlc0J5U2NyaXB0R3JvdXA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbGFuZ3VhZ2VzIGluIHNldmVyYWwgcmVnaW9ucyxcblx0ICogZ3JvdXBlZCBieSBzY3JpcHQgZ3JvdXAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IHJlZ2lvbnMgcmVnaW9uIGNvZGVzXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0TGFuZ3VhZ2VzQnlTY3JpcHRHcm91cEluUmVnaW9ucyA9IGZ1bmN0aW9uICggcmVnaW9ucyApIHtcblx0XHR2YXIgbGFuZ3VhZ2UsIGksIHNjcmlwdEdyb3VwLFxuXHRcdFx0bGFuZ3VhZ2VzQnlTY3JpcHRHcm91cEluUmVnaW9ucyA9IHt9O1xuXG5cdFx0Zm9yICggbGFuZ3VhZ2UgaW4gJC51bHMuZGF0YS5sYW5ndWFnZXMgKSB7XG5cdFx0XHRpZiAoICQudWxzLmRhdGEuaXNSZWRpcmVjdCggbGFuZ3VhZ2UgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcmVnaW9ucy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCAkLnVscy5kYXRhLmdldFJlZ2lvbnMoIGxhbmd1YWdlICkuaW5kZXhPZiggcmVnaW9uc1sgaSBdICkgIT09IC0xICkge1xuXHRcdFx0XHRcdHNjcmlwdEdyb3VwID0gJC51bHMuZGF0YS5nZXRTY3JpcHRHcm91cE9mTGFuZ3VhZ2UoIGxhbmd1YWdlICk7XG5cblx0XHRcdFx0XHRpZiAoIGxhbmd1YWdlc0J5U2NyaXB0R3JvdXBJblJlZ2lvbnNbIHNjcmlwdEdyb3VwIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGxhbmd1YWdlc0J5U2NyaXB0R3JvdXBJblJlZ2lvbnNbIHNjcmlwdEdyb3VwIF0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYW5ndWFnZXNCeVNjcmlwdEdyb3VwSW5SZWdpb25zWyBzY3JpcHRHcm91cCBdLnB1c2goIGxhbmd1YWdlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbGFuZ3VhZ2VzQnlTY3JpcHRHcm91cEluUmVnaW9ucztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NyaXB0IGdyb3VwIG9mIGEgc2NyaXB0IG9yICdPdGhlcicgaWYgaXQgZG9lc24ndFxuXHQgKiBiZWxvbmcgdG8gYW55IGdyb3VwLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IFNjcmlwdCBjb2RlXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gc2NyaXB0IGdyb3VwIG5hbWVcblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0R3JvdXBPZlNjcmlwdCA9IGZ1bmN0aW9uICggc2NyaXB0ICkge1xuXHRcdHZhciBzY3JpcHRHcm91cDtcblxuXHRcdGZvciAoIHNjcmlwdEdyb3VwIGluICQudWxzLmRhdGEuc2NyaXB0Z3JvdXBzICkge1xuXHRcdFx0aWYgKCAkLnVscy5kYXRhLnNjcmlwdGdyb3Vwc1sgc2NyaXB0R3JvdXAgXS5pbmRleE9mKCBzY3JpcHQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybiBzY3JpcHRHcm91cDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJ090aGVyJztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NyaXB0IGdyb3VwIG9mIGEgbGFuZ3VhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBMYW5ndWFnZSBjb2RlXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gc2NyaXB0IGdyb3VwIG5hbWVcblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0U2NyaXB0R3JvdXBPZkxhbmd1YWdlID0gZnVuY3Rpb24gKCBsYW5ndWFnZSApIHtcblx0XHRyZXR1cm4gJC51bHMuZGF0YS5nZXRHcm91cE9mU2NyaXB0KCAkLnVscy5kYXRhLmdldFNjcmlwdCggbGFuZ3VhZ2UgKSApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIHNvcnRlZCBieSBzY3JpcHQgZ3JvdXBzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYW5ndWFnZXMgQXJyYXkgb2YgbGFuZ3VhZ2UgY29kZXMgdG8gc29ydFxuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX0gQXJyYXkgb2YgbGFuZ3VhZ2UgY29kZXNcblx0ICovXG5cdCQudWxzLmRhdGEuc29ydEJ5U2NyaXB0R3JvdXAgPSBmdW5jdGlvbiAoIGxhbmd1YWdlcyApIHtcblx0XHR2YXIgZ3JvdXBlZExhbmd1YWdlcywgc2NyaXB0R3JvdXBzLCBpLFxuXHRcdFx0YWxsTGFuZ3VhZ2VzID0gW107XG5cblx0XHRncm91cGVkTGFuZ3VhZ2VzID0gJC51bHMuZGF0YS5nZXRMYW5ndWFnZXNCeVNjcmlwdEdyb3VwKCBsYW5ndWFnZXMgKTtcblx0XHRzY3JpcHRHcm91cHMgPSBPYmplY3Qua2V5cyggZ3JvdXBlZExhbmd1YWdlcyApLnNvcnQoKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgc2NyaXB0R3JvdXBzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YWxsTGFuZ3VhZ2VzID0gYWxsTGFuZ3VhZ2VzLmNvbmNhdCggZ3JvdXBlZExhbmd1YWdlc1sgc2NyaXB0R3JvdXBzWyBpIF0gXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhbGxMYW5ndWFnZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgY2FsbGJhY2sgZm9yIHNvcnRpbmcgbGFuZ3VhZ2VzIGJ5IGF1dG9ueW0uXG5cdCAqIENhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIGEgc29ydCBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGEgTGFuZ3VhZ2UgY29kZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYiBMYW5ndWFnZSBjb2RlXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdCQudWxzLmRhdGEuc29ydEJ5QXV0b255bSA9IGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHR2YXIgYXV0b255bUEgPSAkLnVscy5kYXRhLmdldEF1dG9ueW0oIGEgKSB8fCBhLFxuXHRcdFx0YXV0b255bUIgPSAkLnVscy5kYXRhLmdldEF1dG9ueW0oIGIgKSB8fCBiO1xuXG5cdFx0cmV0dXJuICggYXV0b255bUEudG9Mb3dlckNhc2UoKSA8IGF1dG9ueW1CLnRvTG93ZXJDYXNlKCkgKSA/IC0xIDogMTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBsYW5ndWFnZSBpcyByaWdodC10by1sZWZ0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29kZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0JC51bHMuZGF0YS5pc1J0bCA9IGZ1bmN0aW9uICggbGFuZ3VhZ2UgKSB7XG5cdFx0cmV0dXJuICQudWxzLmRhdGEucnRsc2NyaXB0cy5pbmRleE9mKCAkLnVscy5kYXRhLmdldFNjcmlwdCggbGFuZ3VhZ2UgKSApICE9PSAtMTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxhbmd1YWdlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBMYW5ndWFnZSBjb2RlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0RGlyID0gZnVuY3Rpb24gKCBsYW5ndWFnZSApIHtcblx0XHRyZXR1cm4gJC51bHMuZGF0YS5pc1J0bCggbGFuZ3VhZ2UgKSA/ICdydGwnIDogJ2x0cic7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxhbmd1YWdlcyBzcG9rZW4gaW4gYSB0ZXJyaXRvcnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJyaXRvcnkgVGVycml0b3J5IGNvZGVcblx0ICogQHJldHVybiB7c3RyaW5nW119IGxpc3Qgb2YgbGFuZ3VhZ2UgY29kZXNcblx0ICovXG5cdCQudWxzLmRhdGEuZ2V0TGFuZ3VhZ2VzSW5UZXJyaXRvcnkgPSBmdW5jdGlvbiAoIHRlcnJpdG9yeSApIHtcblx0XHRyZXR1cm4gJC51bHMuZGF0YS50ZXJyaXRvcmllc1sgdGVycml0b3J5IF07XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYW5ndWFnZSBpbiBydW4gdGltZSBhbmQgc2V0cyBpdHMgb3B0aW9ucyBhcyBwcm92aWRlZC5cblx0ICogSWYgdGhlIHRhcmdldCBvcHRpb24gaXMgcHJvdmlkZWQsIHRoZSBsYW5ndWFnZSBpcyBkZWZpbmVkIGFzIGEgcmVkaXJlY3QuXG5cdCAqIE90aGVyIHBvc3NpYmxlIG9wdGlvbnMgYXJlIHNjcmlwdCwgcmVnaW9ucyBhbmQgYXV0b255bS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgTmV3IGxhbmd1YWdlIGNvZGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIExhbmd1YWdlIHByb3BlcnRpZXMuXG5cdCAqL1xuXHQkLnVscy5kYXRhLmFkZExhbmd1YWdlID0gZnVuY3Rpb24gKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdGlmICggb3B0aW9ucy50YXJnZXQgKSB7XG5cdFx0XHQkLnVscy5kYXRhLmxhbmd1YWdlc1sgY29kZSBdID0gWyBvcHRpb25zLnRhcmdldCBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLnVscy5kYXRhLmxhbmd1YWdlc1sgY29kZSBdID0gWyBvcHRpb25zLnNjcmlwdCwgb3B0aW9ucy5yZWdpb25zLCBvcHRpb25zLmF1dG9ueW0gXTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsYW5ndWFnZSBmcm9tIHRoZSBsYW5nZGIgaW4gcnVuIHRpbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIExhbmd1YWdlIGNvZGUgdG8gZGVsZXRlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBsYW5ndWFnZSB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0JC51bHMuZGF0YS5kZWxldGVMYW5ndWFnZSA9IGZ1bmN0aW9uICggY29kZSApIHtcblx0XHRpZiAoICQudWxzLmRhdGEubGFuZ3VhZ2VzWyBjb2RlIF0gKSB7XG5cdFx0XHRkZWxldGUgJC51bHMuZGF0YS5sYW5ndWFnZXNbIGNvZGUgXTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufSggalF1ZXJ5ICkgKTtcbiIsIi8qKlxuICogalF1ZXJ5IGxhbmd1YWdlIGZpbHRlciBwbHVnaW4uXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEyIEFsb2xpdGEgU2hhcm1hLCBBbWlyIEFoYXJvbmksIEFydW4gR2FuZXNoLCBCcmFuZG9uIEhhcnJpcyxcbiAqIE5pa2xhcyBMYXhzdHLDtm0sIFBhdSBHaW5lciwgU2FudGhvc2ggVGhvdHRpbmdhbCwgU2llYnJhbmQgTWF6ZWxhbmQgYW5kIG90aGVyXG4gKiBjb250cmlidXRvcnMuIFNlZSBDUkVESVRTIGZvciBhIGxpc3QuXG4gKlxuICogVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpcyBkdWFsIGxpY2Vuc2VkIEdQTHYyIG9yIGxhdGVyIGFuZCBNSVQuIFlvdSBkb24ndFxuICogaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsIHRvIGNob29zZSBvbmUgbGljZW5zZSBvciB0aGUgb3RoZXIgYW5kIHlvdSBkb24ndFxuICogaGF2ZSB0byBub3RpZnkgYW55b25lIHdoaWNoIGxpY2Vuc2UgeW91IGFyZSB1c2luZy4gWW91IGFyZSBmcmVlIHRvIHVzZVxuICogVW5pdmVyc2FsTGFuZ3VhZ2VTZWxlY3RvciBpbiBjb21tZXJjaWFsIHByb2plY3RzIGFzIGxvbmcgYXMgdGhlIGNvcHlyaWdodFxuICogaGVhZGVyIGlzIGxlZnQgaW50YWN0LiBTZWUgZmlsZXMgR1BMLUxJQ0VOU0UgYW5kIE1JVC1MSUNFTlNFIGZvciBkZXRhaWxzLlxuICpcbiAqIEBmaWxlXG4gKiBAaW5ncm91cCBFeHRlbnNpb25zXG4gKiBAbGljZW5jZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5jZSAyLjAgb3IgbGF0ZXJcbiAqIEBsaWNlbmNlIE1JVCBMaWNlbnNlXG4gKi9cblxuLyoqXG4gKiBVc2FnZTogJCggJ2lucHV0Ym94JyApLmxhbmd1YWdlZmlsdGVyKCk7XG4gKiBUaGUgdmFsdWVzIGZvciBhdXRvY29tcGxldGlvbiBpcyBmcm9tIHRoZSBvcHRpb25zLmxhbmd1YWdlcyBvciBvcHRpb25zLnNlYXJjaEFQSS5cbiAqL1xuKCBmdW5jdGlvbiAoICQgKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgTGFuZ3VhZ2VGaWx0ZXI7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgcHJlZml4IGlzIHZpc3VhbGx5IHByZWZpeCBvZiBhIHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzVmlzdWFsUHJlZml4KCBwcmVmaXgsIHN0cmluZyApIHtcblx0XHQvLyBQcmUtYmFzZSB2b3dlbCBzaWducyBvZiBJbmRpYyBsYW5ndWFnZXMuIEEgdm93ZWwgc2lnbiBpcyBjYWxsZWQgcHJlLWJhc2UgaWZcblx0XHQvLyBjb25zb25hbnQgKyB2b3dlbCBiZWNvbWVzIFt2b3dlbF1bY29uc29uYW50XSB3aGVuIHJlbmRlcmVkLiBFZzog4LSVICsg4LWGID0+IOC0leC1hlxuXHRcdHZhciBwcmViYXNlcyA9ICfgtYbgtYfgtYjgtYrgtYvgtYzgr4bgr4fgr4jgr4rgr4vgr4zgrYfgrYjgrYvgrYzgqr/gqL/gpL/gpr/gp4fgp4jgp4vgp4zgt5ngt5rgt5vgt5zgt53gt54nO1xuXHRcdHJldHVybiBwcmViYXNlcy5pbmRleE9mKCBzdHJpbmdbIHByZWZpeC5sZW5ndGggXSApIDw9IDA7XG5cdH1cblxuXHRMYW5ndWFnZUZpbHRlciA9IGZ1bmN0aW9uICggZWxlbWVudCwgb3B0aW9ucyApIHtcblx0XHR0aGlzLiRlbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgJC5mbi5sYW5ndWFnZWZpbHRlci5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdsYW5ndWFnZWZpbHRlcicgKTtcblx0XHR0aGlzLnJlc3VsdENvdW50ID0gMDtcblx0XHR0aGlzLiRzdWdnZXN0aW9uID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncyggJy4nICsgdGhpcy4kZWxlbWVudC5kYXRhKCAnc3VnZ2VzdGlvbicgKSApO1xuXHRcdHRoaXMuJGNsZWFyID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncyggJy4nICsgdGhpcy4kZWxlbWVudC5kYXRhKCAnY2xlYXInICkgKTtcblx0XHR0aGlzLnNlbGVjdGVkTGFuZ3VhZ2UgPSBudWxsO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHRcdHRoaXMubGlzdGVuKCk7XG5cdH07XG5cblx0TGFuZ3VhZ2VGaWx0ZXIucHJvdG90eXBlID0ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2VhcmNoKCk7XG5cdFx0fSxcblxuXHRcdGxpc3RlbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy4kZWxlbWVudC5vbiggJ2tleWRvd24nLCB0aGlzLmtleXByZXNzLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0dGhpcy4kZWxlbWVudC5vbiggJ2lucHV0JywgJC5mbi51bHMuZGVib3VuY2UoIHRoaXMub25JbnB1dENoYW5nZS5iaW5kKCB0aGlzICksIDMwMCApICk7XG5cblx0XHRcdGlmICggdGhpcy4kY2xlYXIubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLiRjbGVhci5vbiggJ2NsaWNrJywgdGhpcy5jbGVhci5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50b2dnbGVDbGVhcigpO1xuXHRcdH0sXG5cblx0XHRvbklucHV0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnNlbGVjdGVkTGFuZ3VhZ2UgPSBudWxsO1xuXG5cdFx0XHRpZiAoICF0aGlzLiRlbGVtZW50LnZhbCgpICkge1xuXHRcdFx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMubGNkLmVtcHR5KCk7XG5cdFx0XHRcdHRoaXMuc2VhcmNoKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudG9nZ2xlQ2xlYXIoKTtcblx0XHR9LFxuXG5cdFx0a2V5cHJlc3M6IGZ1bmN0aW9uICggZSApIHtcblx0XHRcdHZhciBzdWdnZXN0aW9uLCBxdWVyeTtcblxuXHRcdFx0c3dpdGNoICggZS5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIDk6IC8vIFRhYiAtPiBBdXRvY29tcGxldGVcblx0XHRcdFx0XHRzdWdnZXN0aW9uID0gdGhpcy4kc3VnZ2VzdGlvbi52YWwoKTtcblxuXHRcdFx0XHRcdGlmICggc3VnZ2VzdGlvbiAmJiBzdWdnZXN0aW9uICE9PSB0aGlzLiRlbGVtZW50LnZhbCgpICkge1xuXHRcdFx0XHRcdFx0dGhpcy4kZWxlbWVudC52YWwoIHN1Z2dlc3Rpb24gKTtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDEzOiAvLyBFbnRlclxuXHRcdFx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5vblNlbGVjdCApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEF2b2lkIGJ1YmJsaW5nIHRoaXMgJ2VudGVyJyB0byBiYWNrZ3JvdW5kIHBhZ2UgZWxlbWVudHNcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0XHRcdHF1ZXJ5ID0gJC50cmltKCB0aGlzLiRlbGVtZW50LnZhbCgpICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5zZWxlY3RlZExhbmd1YWdlICkge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcy5zZWxlY3RMYW5ndWFnZSB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tIGEgbWF0Y2hpbmcgc2VhcmNoXG5cdFx0XHRcdFx0XHR0aGlzLm9wdGlvbnMub25TZWxlY3QoIHRoaXMuc2VsZWN0ZWRMYW5ndWFnZSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5sYW5ndWFnZXNbIHF1ZXJ5IF0gKSB7XG5cdFx0XHRcdFx0XHQvLyBTZWFyY2ggaXMgeWV0IHRvIGhhcHBlbiAoaW4gdGltZW91dCBkZWxheSksXG5cdFx0XHRcdFx0XHQvLyBidXQgd2UgaGF2ZSBhIG1hdGNoaW5nIGxhbmd1YWdlIGNvZGUuXG5cdFx0XHRcdFx0XHR0aGlzLm9wdGlvbnMub25TZWxlY3QoIHF1ZXJ5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFycyB0aGUgY3VycmVudCBzZWFyY2ggcmVtb3Zpbmdcblx0XHQgKiBjbGVhciBidXR0b25zIGFuZCBzdWdnZXN0aW9ucy5cblx0XHQgKi9cblx0XHRkZWFjdGl2YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LnZhbCggJycgKTtcblxuXHRcdFx0aWYgKCAhJC5mbi51bHMuQ29uc3RydWN0b3IucHJvdG90eXBlLmlzTW9iaWxlKCkgKSB7XG5cdFx0XHRcdHRoaXMuJGVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50b2dnbGVDbGVhcigpO1xuXHRcdFx0dGhpcy5hdXRvZmlsbCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDbGVhcnMgdGhlIHNlYXJjaCBhbmQgc2hvd3MgYWxsIGxhbmd1YWdlc1xuXHRcdCAqL1xuXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcblx0XHRcdHRoaXMuc2VhcmNoKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgY2xlYXIgaWNvbiBkZXBlbmRpbmdcblx0XHQgKiBvbiB3aGV0aGVyIHRoZXJlIGlzIGFueXRoaW5nIHRvIGNsZWFyLlxuXHRcdCAqL1xuXHRcdHRvZ2dsZUNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoICF0aGlzLiRjbGVhci5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLiRlbGVtZW50LnZhbCgpICkge1xuXHRcdFx0XHR0aGlzLiRjbGVhci5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiRjbGVhci5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNlYXJjaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxhbmd1YWdlcyA9IE9iamVjdC5rZXlzKCB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VzICksXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0cXVlcnkgPSAkLnRyaW0oIHRoaXMuJGVsZW1lbnQudmFsKCkgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIHF1ZXJ5ID09PSAnJyApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmxjZC5zZXRHcm91cEJ5UmVnaW9uT3ZlcnJpZGUoIG51bGwgKTtcblx0XHRcdFx0dGhpcy5yZXN1bHRIYW5kbGVyKCBxdWVyeSwgbGFuZ3VhZ2VzICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vcHRpb25zLmxjZC5zZXRHcm91cEJ5UmVnaW9uT3ZlcnJpZGUoIGZhbHNlICk7XG5cdFx0XHQvLyBMb2NhbCBzZWFyY2ggcmVzdWx0c1xuXHRcdFx0cmVzdWx0cyA9IGxhbmd1YWdlcy5maWx0ZXIoIGZ1bmN0aW9uICggbGFuZ0NvZGUgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZpbHRlciggbGFuZ0NvZGUsIHF1ZXJ5ICk7XG5cdFx0XHR9LmJpbmQoIHRoaXMgKSApO1xuXG5cdFx0XHQvLyBVc2UgdGhlIHNlYXJjaEFQSSBpZiBhdmFpbGFibGUsIGFzc3VtaW5nIHRoYXQgaXQgaGFzIHN1cGVyaW9yIHNlYXJjaCByZXN1bHRzLlxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2VhcmNoQVBJICkge1xuXHRcdFx0XHR0aGlzLnNlYXJjaEFQSSggcXVlcnkgKVxuXHRcdFx0XHRcdC5kb25lKCB0aGlzLnJlc3VsdEhhbmRsZXIuYmluZCggdGhpcyApIClcblx0XHRcdFx0XHQuZmFpbCggdGhpcy5yZXN1bHRIYW5kbGVyLmJpbmQoIHRoaXMsIHF1ZXJ5LCByZXN1bHRzLCB1bmRlZmluZWQgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZXN1bHRIYW5kbGVyKCBxdWVyeSwgcmVzdWx0cyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZWFyY2hBUEk6IGZ1bmN0aW9uICggcXVlcnkgKSB7XG5cdFx0XHRyZXR1cm4gJC5nZXQoIHRoaXMub3B0aW9ucy5zZWFyY2hBUEksIHsgc2VhcmNoOiBxdWVyeSB9ICkudGhlbiggZnVuY3Rpb24gKCByZXN1bHQgKSB7XG5cdFx0XHRcdHZhciBhdXRvZmlsbExhYmVsLFxuXHRcdFx0XHRcdHJlc3VsdHMgPSBbXTtcblxuXHRcdFx0XHQkLmVhY2goIHJlc3VsdC5sYW5ndWFnZXNlYXJjaCwgZnVuY3Rpb24gKCBhcGlDb2RlLCBuYW1lICkge1xuXHRcdFx0XHRcdHZhciBjb2RlLCByZWRpcmVjdDtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxhbmd1YWdlc1sgYXBpQ29kZSBdICkge1xuXHRcdFx0XHRcdFx0Y29kZSA9IGFwaUNvZGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlZGlyZWN0ID0gJC51bHMuZGF0YS5pc1JlZGlyZWN0KCBhcGlDb2RlICk7XG5cdFx0XHRcdFx0XHRpZiAoICFyZWRpcmVjdCB8fCAhdGhpcy5vcHRpb25zLmxhbmd1YWdlc1sgcmVkaXJlY3QgXSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29kZSA9IHJlZGlyZWN0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEJlY2F1c2Ugb2YgdGhlIHJlZGlyZWN0IGNoZWNraW5nIGFib3ZlLCB3ZSBtaWdodCBnZXQgZHVwbGljYXRlcy5cblx0XHRcdFx0XHQvLyBGb3IgZXhhbXBsZSBpZiBBUEkgcmV0dXJucyBib3RoIGBzcmAgYW5kIGBzci1jeXJsYCwgdGhlIGZvcm1lclxuXHRcdFx0XHRcdC8vIGNvdWxkIGdldCBtYXBwZWQgdG8gYHNyLWN5cmxgIGFuZCB0aGVuIHdlIHdvdWxkIGhhdmUgaXQgdHdpY2UuXG5cdFx0XHRcdFx0Ly8gVGhlIGV4YWN0IGNhc2VzIHdoZW4gdGhpcyBoYXBwZW5zIG9mIGNvdXJzZSBkZXBlbmRzIG9uIHdoYXQgaXMgaW5cblx0XHRcdFx0XHQvLyBvcHRpb25zLmxhbmd1YWdlcywgd2hpY2ggbWlnaHQgY29udGFpbiByZWRpcmVjdHMgc3VjaCBhcyBgc3JgLiBJblxuXHRcdFx0XHRcdC8vIHRoaXMgY2FzZSB3ZSBvbmx5IHNob3cgYHNyYCBpZiBubyBvdGhlciB2YXJpYW50cyBhcmUgdGhlcmUuXG5cdFx0XHRcdFx0Ly8gVGhpcyBhbHNvIHByb3RlY3RzIGFnYWluc3QgYnJva2VuIHNlYXJjaCBBUElzIHJldHVybmluZyBkdXBsaWNhdGVcblx0XHRcdFx0XHQvLyByZXN1bHRzLCBhbHRob3VnaCB0aGF0IGlzIG5vdCBoYXBwZW5pbmcgaW4gcHJhY3RpY2UuXG5cdFx0XHRcdFx0aWYgKCByZXN1bHRzLmluZGV4T2YoIGNvZGUgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRhdXRvZmlsbExhYmVsID0gYXV0b2ZpbGxMYWJlbCB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBjb2RlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LmJpbmQoIHRoaXMgKSApO1xuXG5cdFx0XHRcdHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSggcXVlcnksIHJlc3VsdHMsIGF1dG9maWxsTGFiZWwgKTtcblx0XHRcdH0uYmluZCggdGhpcyApICk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgbWV0aG9kIHRvIGJlIGNhbGxlZCBvbmNlIHNlYXJjaCBpcyBvdmVyLlxuXHRcdCAqIEJhc2VkIG9uIHNlYXJjaCByZXN1bHQgdHJpZ2dlcnMgcmVzdWx0c2ZvdW5kIG9yIG5vcmVzdWx0cyBldmVudHNcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0XHQgKiBAcGFyYW0ge3N0cmluZ1tdfSByZXN1bHRzXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFthdXRvZmlsbExhYmVsXVxuXHRcdCAqL1xuXHRcdHJlc3VsdEhhbmRsZXI6IGZ1bmN0aW9uICggcXVlcnksIHJlc3VsdHMsIGF1dG9maWxsTGFiZWwgKSB7XG5cdFx0XHRpZiAoIHJlc3VsdHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHR0aGlzLiRzdWdnZXN0aW9uLnZhbCggJycgKTtcblx0XHRcdFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxuXHRcdFx0XHRcdCdub3Jlc3VsdHMudWxzJyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRxdWVyeTogcXVlcnksXG5cdFx0XHRcdFx0XHR1bHNQdXJwb3NlOiB0aGlzLm9wdGlvbnMudWxzUHVycG9zZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHF1ZXJ5ICkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkTGFuZ3VhZ2UgPSByZXN1bHRzWyAwIF07XG5cdFx0XHRcdHRoaXMuYXV0b2ZpbGwoIHJlc3VsdHNbIDAgXSwgYXV0b2ZpbGxMYWJlbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHRzLm1hcCggdGhpcy5yZW5kZXIuYmluZCggdGhpcyApICk7XG5cdFx0XHR0aGlzLiRlbGVtZW50LnRyaWdnZXIoICdyZXN1bHRzZm91bmQudWxzJywgWyBxdWVyeSwgcmVzdWx0cy5sZW5ndGggXSApO1xuXHRcdH0sXG5cblx0XHRhdXRvZmlsbDogZnVuY3Rpb24gKCBsYW5nQ29kZSwgbGFuZ3VhZ2VOYW1lICkge1xuXHRcdFx0dmFyIGF1dG9ueW0sIHVzZXJJbnB1dCwgc3VnZ2VzdGlvbjtcblxuXHRcdFx0aWYgKCAhdGhpcy4kc3VnZ2VzdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhdGhpcy4kZWxlbWVudC52YWwoKSApIHtcblx0XHRcdFx0dGhpcy4kc3VnZ2VzdGlvbi52YWwoICcnICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bGFuZ3VhZ2VOYW1lID0gbGFuZ3VhZ2VOYW1lIHx8IHRoaXMub3B0aW9ucy5sYW5ndWFnZXNbIGxhbmdDb2RlIF07XG5cblx0XHRcdGlmICggIWxhbmd1YWdlTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1c2VySW5wdXQgPSB0aGlzLiRlbGVtZW50LnZhbCgpO1xuXHRcdFx0c3VnZ2VzdGlvbiA9IHVzZXJJbnB1dCArXG5cdFx0XHRcdGxhbmd1YWdlTmFtZS5zdWJzdHJpbmcoIHVzZXJJbnB1dC5sZW5ndGgsIGxhbmd1YWdlTmFtZS5sZW5ndGggKTtcblxuXHRcdFx0aWYgKCBzdWdnZXN0aW9uLnRvTG93ZXJDYXNlKCkgIT09IGxhbmd1YWdlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHQvLyBzZWUgaWYgaXQgd2FzIGF1dG9ueW0gbWF0Y2hcblx0XHRcdFx0YXV0b255bSA9ICQudWxzLmRhdGEuZ2V0QXV0b255bSggbGFuZ0NvZGUgKSB8fCAnJztcblx0XHRcdFx0c3VnZ2VzdGlvbiA9IHVzZXJJbnB1dCArIGF1dG9ueW0uc3Vic3RyaW5nKCB1c2VySW5wdXQubGVuZ3RoLCBhdXRvbnltLmxlbmd0aCApO1xuXG5cdFx0XHRcdGlmICggc3VnZ2VzdGlvbiAhPT0gYXV0b255bSApIHtcblx0XHRcdFx0XHQvLyBHaXZlIHVwLiBJdCBtYXkgYmUgYW4gSVNPL3NjcmlwdCBjb2RlIG1hdGNoLlxuXHRcdFx0XHRcdHN1Z2dlc3Rpb24gPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpdCBpcyBhIHZpc3VhbCBwcmVmaXguXG5cdFx0XHRpZiAoICFpc1Zpc3VhbFByZWZpeCggdXNlcklucHV0LCBzdWdnZXN0aW9uICkgKSB7XG5cdFx0XHRcdHN1Z2dlc3Rpb24gPSAnJztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4kc3VnZ2VzdGlvbi52YWwoIHN1Z2dlc3Rpb24gKTtcblx0XHR9LFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoIGxhbmdDb2RlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sY2QuYXBwZW5kKCBsYW5nQ29kZSApO1xuXHRcdH0sXG5cblx0XHRlc2NhcGVSZWdleDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnICk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEEgc2VhcmNoIG1hdGNoIGhhcHBlbnMgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgcGFzc2VzOlxuXHRcdCAqIGEpIExhbmd1YWdlIG5hbWUgaW4gY3VycmVudCB1c2VyIGludGVyZmFjZSBsYW5ndWFnZVxuXHRcdCAqICdzdGFydHMgd2l0aCcgc2VhcmNoIHN0cmluZy5cblx0XHQgKiBiKSBMYW5ndWFnZSBhdXRvbnltICdzdGFydHMgd2l0aCcgc2VhcmNoIHN0cmluZy5cblx0XHQgKiBjKSBJU08gNjM5IGNvZGUgbWF0Y2ggd2l0aCBzZWFyY2ggc3RyaW5nLlxuXHRcdCAqIGQpIElTTyAxNTkyNCBjb2RlIGZvciB0aGUgc2NyaXB0IG1hdGNoIHRoZSBzZWFyY2ggc3RyaW5nLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nQ29kZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hUZXJtXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRmaWx0ZXI6IGZ1bmN0aW9uICggbGFuZ0NvZGUsIHNlYXJjaFRlcm0gKSB7XG5cdFx0XHQvLyBGSVhNRSBzY3JpcHQgaXMgSVNPIDE1OTI0IGNvZGUuIFdlIG1pZ2h0IG5lZWQgYWN0dWFsIG5hbWUgb2Ygc2NyaXB0LlxuXHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCAnXicgKyB0aGlzLmVzY2FwZVJlZ2V4KCBzZWFyY2hUZXJtICksICdpJyApLFxuXHRcdFx0XHRsYW5ndWFnZU5hbWUgPSB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VzWyBsYW5nQ29kZSBdO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlci50ZXN0KCBsYW5ndWFnZU5hbWUgKSB8fFxuXHRcdFx0XHRtYXRjaGVyLnRlc3QoICQudWxzLmRhdGEuZ2V0QXV0b255bSggbGFuZ0NvZGUgKSApIHx8XG5cdFx0XHRcdG1hdGNoZXIudGVzdCggbGFuZ0NvZGUgKSB8fFxuXHRcdFx0XHRtYXRjaGVyLnRlc3QoICQudWxzLmRhdGEuZ2V0U2NyaXB0KCBsYW5nQ29kZSApICk7XG5cdFx0fVxuXHR9O1xuXG5cdCQuZm4ubGFuZ3VhZ2VmaWx0ZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKCB0aGlzICksXG5cdFx0XHRcdGRhdGEgPSAkdGhpcy5kYXRhKCAnbGFuZ3VhZ2VmaWx0ZXInICksXG5cdFx0XHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb247XG5cblx0XHRcdGlmICggIWRhdGEgKSB7XG5cdFx0XHRcdCR0aGlzLmRhdGEoICdsYW5ndWFnZWZpbHRlcicsICggZGF0YSA9IG5ldyBMYW5ndWFnZUZpbHRlciggdGhpcywgb3B0aW9ucyApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZGF0YVsgb3B0aW9uIF0oKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH07XG5cblx0JC5mbi5sYW5ndWFnZWZpbHRlci5kZWZhdWx0cyA9IHtcblx0XHQvLyBMYW5ndWFnZUNhdGVnb3J5RGlzcGxheVxuXHRcdGxjZDogdW5kZWZpbmVkLFxuXHRcdC8vIFVSTCB0byB3aGljaCB3ZSBhcHBlbmQgcXVlcnkgcGFyYW1ldGVyIHdpdGggdGhlIHF1ZXJ5IHZhbHVlXG5cdFx0c2VhcmNoQVBJOiB1bmRlZmluZWQsXG5cdFx0Ly8gV2hhdCBpcyB0aGlzIFVMUyB1c2VkIGZvci5cblx0XHQvLyBTaG91bGQgYmUgc2V0IGZvciBkaXN0aW5ndWlzaGluZyBiZXR3ZWVuIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgVUxTXG5cdFx0Ly8gaW4gdGhlIHNhbWUgYXBwbGljYXRpb24uXG5cdFx0dWxzUHVycG9zZTogJycsXG5cdFx0Ly8gT2JqZWN0IG9mIGxhbmd1YWdlIHRhZ3MgdG8gbGFuZ3VhZ2UgbmFtZXNcblx0XHRsYW5ndWFnZXM6IFtdLFxuXHRcdC8vIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gbGFuZ3VhZ2UgaXMgc2VsZWN0ZWRcblx0XHRvblNlbGVjdDogdW5kZWZpbmVkXG5cdH07XG5cblx0JC5mbi5sYW5ndWFnZWZpbHRlci5Db25zdHJ1Y3RvciA9IExhbmd1YWdlRmlsdGVyO1xuXG59KCBqUXVlcnkgKSApO1xuIiwiLyoqXG4gKiBVbml2ZXJzYWwgTGFuZ3VhZ2UgU2VsZWN0b3JcbiAqIExhbmd1YWdlIGNhdGVnb3J5IGRpc3BsYXkgY29tcG9uZW50IC0gVXNlZCBmb3Igc2hvd2luZyB0aGUgc2VhcmNoIHJlc3VsdHMsXG4gKiBncm91cGVkIGJ5IHJlZ2lvbnMsIHNjcmlwdHNcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgQWxvbGl0YSBTaGFybWEsIEFtaXIgQWhhcm9uaSwgQXJ1biBHYW5lc2gsIEJyYW5kb24gSGFycmlzLFxuICogTmlrbGFzIExheHN0csO2bSwgUGF1IEdpbmVyLCBTYW50aG9zaCBUaG90dGluZ2FsLCBTaWVicmFuZCBNYXplbGFuZCBhbmQgb3RoZXJcbiAqIGNvbnRyaWJ1dG9ycy4gU2VlIENSRURJVFMgZm9yIGEgbGlzdC5cbiAqXG4gKiBVbml2ZXJzYWxMYW5ndWFnZVNlbGVjdG9yIGlzIGR1YWwgbGljZW5zZWQgR1BMdjIgb3IgbGF0ZXIgYW5kIE1JVC4gWW91IGRvbid0XG4gKiBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgdG8gY2hvb3NlIG9uZSBsaWNlbnNlIG9yIHRoZSBvdGhlciBhbmQgeW91IGRvbid0XG4gKiBoYXZlIHRvIG5vdGlmeSBhbnlvbmUgd2hpY2ggbGljZW5zZSB5b3UgYXJlIHVzaW5nLiBZb3UgYXJlIGZyZWUgdG8gdXNlXG4gKiBVbml2ZXJzYWxMYW5ndWFnZVNlbGVjdG9yIGluIGNvbW1lcmNpYWwgcHJvamVjdHMgYXMgbG9uZyBhcyB0aGUgY29weXJpZ2h0XG4gKiBoZWFkZXIgaXMgbGVmdCBpbnRhY3QuIFNlZSBmaWxlcyBHUEwtTElDRU5TRSBhbmQgTUlULUxJQ0VOU0UgZm9yIGRldGFpbHMuXG4gKlxuICogQGZpbGVcbiAqIEBpbmdyb3VwIEV4dGVuc2lvbnNcbiAqIEBsaWNlbmNlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbmNlIDIuMCBvciBsYXRlclxuICogQGxpY2VuY2UgTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uICggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1zdHJcblx0dmFyIG5vUmVzdWx0c1RlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJ1bHMtbm8tcmVzdWx0cy12aWV3XCI+IFxcXG5cdFx0PGgyIGRhdGEtaTE4bj1cInVscy1uby1yZXN1bHRzLWZvdW5kXCIgY2xhc3M9XCJ1bHMtbm8tcmVzdWx0cy1mb3VuZC10aXRsZVwiPk5vIHJlc3VsdHMgZm91bmQ8L2gyPiBcXFxuXHRcdDxkaXYgY2xhc3M9XCJ1bHMtbm8tcmVzdWx0cy1zdWdnZXN0aW9uc1wiPjwvZGl2PiBcXFxuXHRcdDxkaXYgY2xhc3M9XCJ1bHMtbm8tZm91bmQtbW9yZVwiPiBcXFxuXHRcdDxkaXYgZGF0YS1pMThuPVwidWxzLXNlYXJjaC1oZWxwXCI+WW91IGNhbiBzZWFyY2ggYnkgbGFuZ3VhZ2UgbmFtZSwgc2NyaXB0IG5hbWUsIElTTyBjb2RlIG9mIGxhbmd1YWdlIG9yIHlvdSBjYW4gYnJvd3NlIGJ5IHJlZ2lvbi48L2Rpdj4gXFxcblx0XHQ8L2Rpdj48L2Rpdj4nO1xuXG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBjYXRlZ29yeSBkaXNwbGF5XG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgY29udGFpbmVyIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGxhbmd1YWdlcyB0byBiZSBkaXNwbGF5ZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9iamVjdFxuXHQgKiBAY2ZnIHtPYmplY3R9IFtsYW5ndWFnZXNdIFNlbGVjdGFibGUgbGFuZ3VhZ2VzLiBLZXllZCBieSBsYW5ndWFnZSBjb2RlLCB2YWx1ZXMgYXJlIGF1dG9ueW1zLlxuXHQgKiBAY2ZnIHtzdHJpbmdbXX0gW3Nob3dSZWdpb25zXSBBcnJheSBvZiByZWdpb24gY29kZXMgdG8gc2hvdy4gRGVmYXVsdCBpc1xuXHQgKiAgWyAnV1cnLCAnQU0nLCAnRVUnLCAnTUUnLCAnQUYnLCAnQVMnLCAnUEEnIF1cblx0ICogQGNmZyB7bnVtYmVyfSBbaXRlbXNQZXJDb2x1bW5dIE51bWJlciBvZiBsYW5ndWFnZXMgcGVyIGNvbHVtbi5cblx0ICogQGNmZyB7bnVtYmVyfSBbY29sdW1uc10gTnVtYmVyIG9mIGNvbHVtbnMgZm9yIGxhbmd1YWdlcy4gRGVmYXVsdCBpcyA0LlxuXHQgKiBAY2ZnIHtGdW5jdGlvbn0gW2xhbmd1YWdlRGVjb3JhdG9yXSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIGxhbmd1YWdlXG5cdCAqICBsaW5rIGlzIHByZXBhcmVkIC0gZm9yIGN1c3RvbSBkZWNvcmF0aW9uLlxuXHQgKiBAY2ZnIHtGdW5jdGlvbnxzdHJpbmdbXX0gW3F1aWNrTGlzdF0gVGhlIGxhbmd1YWdlcyB0byBkaXNwbGF5IGFzIHN1Z2dlc3Rpb25zIGZvciBxdWlja1xuXHQgKiAgc2VsZWN0aW9uLlxuXHQgKiBAY2ZnIHtGdW5jdGlvbn0gW2NsaWNraGFuZGxlcl0gQ2FsbGJhY2sgd2hlbiBsYW5ndWFnZSBpcyBzZWxlY3RlZC5cblx0ICogQGNmZyB7alF1ZXJ5fEZ1bmN0aW9ufSBbbm9SZXN1bHRzVGVtcGxhdGVdXG5cdCAqL1xuXHRmdW5jdGlvbiBMYW5ndWFnZUNhdGVnb3J5RGlzcGxheSggZWxlbWVudCwgb3B0aW9ucyApIHtcblx0XHR0aGlzLiRlbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgJC5mbi5sY2QuZGVmYXVsdHMsIG9wdGlvbnMgKTtcblx0XHQvLyBFbnN1cmUgdGhlIGludGVybmFsIHJlZ2lvbiAnYWxsJyBpcyBhbHdheXMgcHJlc2VudFxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNob3dSZWdpb25zLmluZGV4T2YoICdhbGwnICkgPT09IC0xICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNob3dSZWdpb25zLnB1c2goICdhbGwnICk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ3Vscy1sY2QnICk7XG5cdFx0dGhpcy5yZWdpb25MYW5ndWFnZXMgPSB7fTtcblx0XHR0aGlzLnJlbmRlclRpbWVvdXQgPSBudWxsO1xuXHRcdHRoaXMuY2FjaGVkUXVpY2tsaXN0ID0gbnVsbDtcblx0XHR0aGlzLmdyb3VwQnlSZWdpb25PdmVycmlkZSA9IG51bGw7XG5cblx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdHRoaXMubGlzdGVuKCk7XG5cdH1cblxuXHRMYW5ndWFnZUNhdGVnb3J5RGlzcGxheS5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IExhbmd1YWdlQ2F0ZWdvcnlEaXNwbGF5LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBsYW5ndWFnZSB0byB0aGUgbGFuZ3VhZ2UgbGlzdC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ0NvZGVcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3JlZ2lvbkNvZGVdXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbGFuZ3VhZ2Ugd2FzIGtub3duIGFuZCBhY2NlcHRlZFxuXHRcdCAqL1xuXHRcdGFwcGVuZDogZnVuY3Rpb24gKCBsYW5nQ29kZSwgcmVnaW9uQ29kZSApIHtcblx0XHRcdHZhciBpLCByZWdpb25zO1xuXG5cdFx0XHRpZiAoICEkLnVscy5kYXRhLmxhbmd1YWdlc1sgbGFuZ0NvZGUgXSApIHtcblx0XHRcdFx0Ly8gTGFuZ3VhZ2UgaXMgdW5rbm93biBvciBub3QgaW4gdGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIGZvciB0aGlzIGNvbnRleHQuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhdGhpcy5pc0dyb3VwaW5nQnlSZWdpb25FbmFibGVkKCkgKSB7XG5cdFx0XHRcdHJlZ2lvbnMgPSBbICdhbGwnIF07XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRvIG5vdCBnZXQgZHVwbGljYXRlc1xuXHRcdFx0XHRpZiAoIHRoaXMucmVnaW9uTGFuZ3VhZ2VzLmFsbC5pbmRleE9mKCBsYW5nQ29kZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggcmVnaW9uQ29kZSApIHtcblx0XHRcdFx0XHRyZWdpb25zID0gWyByZWdpb25Db2RlIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVnaW9ucyA9ICQudWxzLmRhdGEuZ2V0UmVnaW9ucyggbGFuZ0NvZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHJlZ2lvbnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHRoaXMucmVnaW9uTGFuZ3VhZ2VzWyByZWdpb25zWyBpIF0gXS5wdXNoKCBsYW5nQ29kZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXb3JrIGFyb3VuZCB0aGUgYmFkIGludGVyZmFjZSwgZGVsYXkgcmVuZGVyaW5nIHVudGlsIHdlIGhhdmUgZ290XG5cdFx0XHQvLyBhbGwgdGhlIGxhbmd1YWdlcyB0byBzcGVlZCB1cCBwZXJmb3JtYW5jZS5cblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5yZW5kZXJUaW1lb3V0ICk7XG5cdFx0XHR0aGlzLnJlbmRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyUmVnaW9ucygpO1xuXHRcdFx0fS5iaW5kKCB0aGlzICksIDUwICk7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHdlIHNob3VsZCByZW5kZXIgbGFuZ3VhZ2VzIGdyb3VwZWQgdG8gZ2VvZ3JhcGhpYyByZWdpb25zLlxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNHcm91cGluZ0J5UmVnaW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCB0aGlzLmdyb3VwQnlSZWdpb25PdmVycmlkZSAhPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBCeVJlZ2lvbk92ZXJyaWRlO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmdyb3VwQnlSZWdpb24gIT09ICdhdXRvJyApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5ncm91cEJ5UmVnaW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jb2x1bW5zID4gMTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcmVnaW9uIGdyb3VwaW5nIHNldHRpbmcuXG5cdFx0ICogVGhpcyBpcyB0byBhbGxvdyBMYW5ndWFnZUZpbHRlciB0byBkaXNhYmxlIGdyb3VwaW5nIHdoZW4gZGlzcGxheWluZyBzZWFyY2ggcmVzdWx0cy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbnxudWxsfSB2YWwgVHJ1ZSB0byBmb3JjZSBncm91cGluZywgZmFsc2UgdG8gZGlzYWJsZSwgbnVsbFxuXHRcdCAqIHRvIHVuZG8gb3ZlcnJpZGUuXG5cdFx0ICovXG5cdFx0c2V0R3JvdXBCeVJlZ2lvbk92ZXJyaWRlOiBmdW5jdGlvbiAoIHZhbCApIHtcblx0XHRcdHRoaXMuZ3JvdXBCeVJlZ2lvbk92ZXJyaWRlID0gdmFsO1xuXHRcdH0sXG5cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciAkc2VjdGlvbixcblx0XHRcdFx0JHF1aWNrbGlzdCA9IHRoaXMuYnVpbGRRdWlja2xpc3QoKSxcblx0XHRcdFx0cmVnaW9ucyA9IFtdLFxuXHRcdFx0XHRyZWdpb25OYW1lcyA9IHtcblx0XHRcdFx0XHQvLyBUaGVzZSBhcmUgZmFsbGJhY2sgdGV4dCB3aGVuIGkxOG4gbGlicmFyeSBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGFsbDogJ0FsbCBsYW5ndWFnZXMnLCAvLyBVc2VkIGlmIHRoZXJlIGlzIHF1aWNrbGlzdCBhbmQgbm8gcmVnaW9uIGdyb3VwaW5nXG5cdFx0XHRcdFx0V1c6ICdXb3JsZHdpZGUnLFxuXHRcdFx0XHRcdFNQOiAnU3BlY2lhbCcsXG5cdFx0XHRcdFx0QU06ICdBbWVyaWNhJyxcblx0XHRcdFx0XHRFVTogJ0V1cm9wZScsXG5cdFx0XHRcdFx0TUU6ICdNaWRkbGUgRWFzdCcsXG5cdFx0XHRcdFx0QVM6ICdBc2lhJyxcblx0XHRcdFx0XHRBRjogJ0FmcmljYScsXG5cdFx0XHRcdFx0UEE6ICdQYWNpZmljJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRpZiAoICRxdWlja2xpc3QubGVuZ3RoICkge1xuXHRcdFx0XHRyZWdpb25zLnB1c2goICRxdWlja2xpc3QgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIHVzZSBDU1MgdG8gaGlkZSB0aGUgaGVhZGVyIGZvciAnYWxsJyB3aGVuIHF1aWNrbGlzdCBpcyBOT1QgcHJlc2VudFxuXHRcdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAndWxzLWxjZC0tbm8tcXVpY2tsaXN0JyApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9wdGlvbnMuc2hvd1JlZ2lvbnMuZm9yRWFjaCggZnVuY3Rpb24gKCByZWdpb25Db2RlICkge1xuXHRcdFx0XHR0aGlzLnJlZ2lvbkxhbmd1YWdlc1sgcmVnaW9uQ29kZSBdID0gW107XG5cblx0XHRcdFx0JHNlY3Rpb24gPSAkKCAnPGRpdj4nIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoICd1bHMtbGNkLXJlZ2lvbi1zZWN0aW9uIGhpZGUnIClcblx0XHRcdFx0XHQuYXR0ciggJ2RhdGEtcmVnaW9uJywgcmVnaW9uQ29kZSApO1xuXG5cdFx0XHRcdCQoICc8aDM+JyApXG5cdFx0XHRcdFx0LmF0dHIoICdkYXRhLWkxOG4nLCAndWxzLXJlZ2lvbi0nICsgcmVnaW9uQ29kZSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCAndWxzLWxjZC1yZWdpb24tdGl0bGUnIClcblx0XHRcdFx0XHQudGV4dCggcmVnaW9uTmFtZXNbIHJlZ2lvbkNvZGUgXSApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCAkc2VjdGlvbiApO1xuXG5cdFx0XHRcdHJlZ2lvbnMucHVzaCggJHNlY3Rpb24gKTtcblx0XHRcdH0uYmluZCggdGhpcyApICk7XG5cblx0XHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKCByZWdpb25zICk7XG5cblx0XHRcdHRoaXMuaTE4bigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXJzIGEgcmVnaW9uIGFuZCBkaXNwbGF5cyBpdCBpZiBpdCBoYXMgY29udGVudC5cblx0XHQgKi9cblx0XHRyZW5kZXJSZWdpb25zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbGFuZ3VhZ2VzLFxuXHRcdFx0XHRsY2QgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAndWxzLW5vLXJlc3VsdHMnICk7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCAnLnVscy1sY2QtcmVnaW9uLXNlY3Rpb24nICkuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgJHJlZ2lvbiA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRyZWdpb25Db2RlID0gJHJlZ2lvbi5kYXRhKCAncmVnaW9uJyApO1xuXG5cdFx0XHRcdGlmICggJHJlZ2lvbi5pcyggJy51bHMtbGNkLXF1aWNrbGlzdCcgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkcmVnaW9uLmNoaWxkcmVuKCAnLnVscy1sYW5ndWFnZS1ibG9jaycgKS5yZW1vdmUoKTtcblxuXHRcdFx0XHRsYW5ndWFnZXMgPSBsY2QucmVnaW9uTGFuZ3VhZ2VzWyByZWdpb25Db2RlIF07XG5cdFx0XHRcdGlmICggIWxhbmd1YWdlcyB8fCBsYW5ndWFnZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdCRyZWdpb24uYWRkQ2xhc3MoICdoaWRlJyApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxjZC5yZW5kZXJSZWdpb24oXG5cdFx0XHRcdFx0JHJlZ2lvbixcblx0XHRcdFx0XHRsYW5ndWFnZXMsXG5cdFx0XHRcdFx0bGNkLm9wdGlvbnMuaXRlbXNQZXJDb2x1bW4sXG5cdFx0XHRcdFx0bGNkLm9wdGlvbnMuY29sdW1uc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHQkcmVnaW9uLnJlbW92ZUNsYXNzKCAnaGlkZScgKTtcblxuXHRcdFx0XHRsY2QucmVnaW9uTGFuZ3VhZ2VzWyByZWdpb25Db2RlIF0gPSBbXTtcblx0XHRcdH0gKTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGRzIGdpdmVuIGxhbmd1YWdlcyBzb3J0ZWQgaW50byByb3dzIGFuZCBjb2x1bW5zIGludG8gZ2l2ZW4gZWxlbWVudC5cblx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gJHJlZ2lvbiBFbGVtZW50IHRvIGFkZCBsYW5ndWFnZSBsaXN0LlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhbmd1YWdlcyBMaXN0IG9mIGxhbmd1YWdlIGNvZGVzLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtc1BlckNvbHVtbiBIb3cgbWFueSBsYW5ndWFnZXMgZml0IGluIGEgY29sdW1uLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zUGVyUm93IEhvdyBtYW55IGNvbHVtbnMgZml0IGluIGEgcm93LlxuXHRcdCAqL1xuXHRcdHJlbmRlclJlZ2lvbjogZnVuY3Rpb24gKCAkcmVnaW9uLCBsYW5ndWFnZXMsIGl0ZW1zUGVyQ29sdW1uLCBjb2x1bW5zUGVyUm93ICkge1xuXHRcdFx0dmFyIGNvbHVtbnNDbGFzc2VzLCBpLCBsYXN0SXRlbSwgY3VycmVudFNjcmlwdCwgbmV4dFNjcmlwdCwgZm9yY2UsXG5cdFx0XHRcdGxhbmd1YWdlc0NvdW50ID0gbGFuZ3VhZ2VzLmxlbmd0aCxcblx0XHRcdFx0aXRlbXMgPSBbXSxcblx0XHRcdFx0Y29sdW1ucyA9IFtdLFxuXHRcdFx0XHRyb3dzID0gW107XG5cblx0XHRcdGxhbmd1YWdlcyA9ICQudWxzLmRhdGEuc29ydEJ5U2NyaXB0R3JvdXAoXG5cdFx0XHRcdGxhbmd1YWdlcy5zb3J0KCAkLnVscy5kYXRhLnNvcnRCeUF1dG9ueW0gKVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBjb2x1bW5zUGVyUm93ID09PSAxICkge1xuXHRcdFx0XHRjb2x1bW5zQ2xhc3NlcyA9ICd0d2VsdmUgY29sdW1ucyc7XG5cdFx0XHR9IGVsc2UgaWYgKCBjb2x1bW5zUGVyUm93ID09PSAyICkge1xuXHRcdFx0XHRjb2x1bW5zQ2xhc3NlcyA9ICdzaXggY29sdW1ucyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2x1bW5zQ2xhc3NlcyA9ICd0aHJlZSBjb2x1bW5zJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY29sdW1ucyA9PT0gMSApIHtcblx0XHRcdFx0Ly8gRm9yIG9uZS1jb2x1bW4gbmFycm93IFVMUywganVzdCByZW5kZXIgYWxsIHRoZSBsYW5ndWFnZXNcblx0XHRcdFx0Ly8gaW4gb25lIHNpbXBsZSBsaXN0IHdpdGhvdXQgc2VwYXJhdG9ycyBvciBzY3JpcHQgZ3JvdXBzXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGFuZ3VhZ2VzQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKCB0aGlzLnJlbmRlckl0ZW0oIGxhbmd1YWdlc1sgaSBdICkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbHVtbnMucHVzaCggJCggJzx1bD4nICkuYWRkQ2xhc3MoIGNvbHVtbnNDbGFzc2VzICkuYXBwZW5kKCBpdGVtcyApICk7XG5cdFx0XHRcdHJvd3MucHVzaCggJCggJzxkaXY+JyApLmFkZENsYXNzKCAncm93IHVscy1sYW5ndWFnZS1ibG9jaycgKS5hcHBlbmQoIGNvbHVtbnMgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRm9yIG1lZGl1bSBhbmQgd2lkZSBVTFMsIGNsZXZlciBjb2x1bW4gcGxhY2VtZW50XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGFuZ3VhZ2VzQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRmb3JjZSA9IGZhbHNlO1xuXHRcdFx0XHRcdG5leHRTY3JpcHQgPSAkLnVscy5kYXRhLmdldFNjcmlwdEdyb3VwT2ZMYW5ndWFnZSggbGFuZ3VhZ2VzWyBpICsgMSBdICk7XG5cblx0XHRcdFx0XHRsYXN0SXRlbSA9IGxhbmd1YWdlc0NvdW50IC0gaSA9PT0gMTtcblx0XHRcdFx0XHQvLyBGb3JjZSBjb2x1bW4gYnJlYWsgaWYgc2NyaXB0IGNoYW5nZXMgYW5kIGNvbHVtbiBoYXMgbW9yZSB0aGFuIG9uZVxuXHRcdFx0XHRcdC8vIHJvdyBhbHJlYWR5LCBidXQgb25seSBpZiBncm91cGluZyBieSByZWdpb25cblx0XHRcdFx0XHRpZiAoIGkgPT09IDAgfHwgIXRoaXMuaXNHcm91cGluZ0J5UmVnaW9uRW5hYmxlZCgpICkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFNjcmlwdCA9ICQudWxzLmRhdGEuZ2V0U2NyaXB0R3JvdXBPZkxhbmd1YWdlKCBsYW5ndWFnZXNbIGkgXSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnJlbnRTY3JpcHQgIT09IG5leHRTY3JpcHQgJiYgaXRlbXMubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudFNjcmlwdCA9IG5leHRTY3JpcHQ7XG5cblx0XHRcdFx0XHRpdGVtcy5wdXNoKCB0aGlzLnJlbmRlckl0ZW0oIGxhbmd1YWdlc1sgaSBdICkgKTtcblxuXHRcdFx0XHRcdGlmICggaXRlbXMubGVuZ3RoID49IGl0ZW1zUGVyQ29sdW1uIHx8IGxhc3RJdGVtIHx8IGZvcmNlICkge1xuXHRcdFx0XHRcdFx0Y29sdW1ucy5wdXNoKCAkKCAnPHVsPicgKS5hZGRDbGFzcyggY29sdW1uc0NsYXNzZXMgKS5hcHBlbmQoIGl0ZW1zICkgKTtcblx0XHRcdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHRcdFx0XHRpZiAoIGNvbHVtbnMubGVuZ3RoID49IGNvbHVtbnNQZXJSb3cgfHwgbGFzdEl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJvd3MucHVzaCggJCggJzxkaXY+JyApLmFkZENsYXNzKCAncm93IHVscy1sYW5ndWFnZS1ibG9jaycgKS5hcHBlbmQoIGNvbHVtbnMgKSApO1xuXHRcdFx0XHRcdFx0XHRjb2x1bW5zID0gW107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCRyZWdpb24uYXBwZW5kKCByb3dzICk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgZG9tIG5vZGUgcmVwcmVzZW50aW5nIG9uZSBpdGVtIGluIGxhbmd1YWdlIGxpc3QuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgTGFuZ3VhZ2UgY29kZVxuXHRcdCAqIEByZXR1cm4ge0VsZW1lbnR9XG5cdFx0ICovXG5cdFx0cmVuZGVySXRlbTogZnVuY3Rpb24gKCBjb2RlICkge1xuXHRcdFx0dmFyIGEsIG5hbWUsIGF1dG9ueW0sIGxpO1xuXG5cdFx0XHRuYW1lID0gdGhpcy5vcHRpb25zLmxhbmd1YWdlc1sgY29kZSBdO1xuXHRcdFx0YXV0b255bSA9ICQudWxzLmRhdGEuZ2V0QXV0b255bSggY29kZSApIHx8IG5hbWUgfHwgY29kZTtcblxuXHRcdFx0Ly8gTm90IHVzaW5nIGpRdWVyeSBhcyB0aGlzIGlzIHBlcmZvcm1hbmNlIGhvdHNwb3Rcblx0XHRcdGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2xpJyApO1xuXHRcdFx0bGkudGl0bGUgPSBuYW1lO1xuXHRcdFx0bGkuc2V0QXR0cmlidXRlKCAnZGF0YS1jb2RlJywgY29kZSApO1xuXG5cdFx0XHRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG5cdFx0XHRhLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggYXV0b255bSApICk7XG5cdFx0XHRhLmNsYXNzTmFtZSA9ICdhdXRvbnltJztcblx0XHRcdGEubGFuZyA9IGNvZGU7XG5cdFx0XHRhLmRpciA9ICQudWxzLmRhdGEuZ2V0RGlyKCBjb2RlICk7XG5cblx0XHRcdGxpLmFwcGVuZENoaWxkKCBhICk7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5sYW5ndWFnZURlY29yYXRvciApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmxhbmd1YWdlRGVjb3JhdG9yKCAkKCBhICksIGNvZGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsaTtcblx0XHR9LFxuXG5cdFx0aTE4bjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy4kZWxlbWVudC5maW5kKCAnW2RhdGEtaTE4bl0nICkuaTE4bigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGRzIHF1aWNrbGlzdCBhcyBhIHJlZ2lvbi5cblx0XHQgKi9cblx0XHRxdWlja2xpc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuJGVsZW1lbnQuZmluZCggJy51bHMtbGNkLXF1aWNrbGlzdCcgKS5yZW1vdmVDbGFzcyggJ2hpZGUnICk7XG5cdFx0fSxcblxuXHRcdGJ1aWxkUXVpY2tsaXN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcXVpY2tMaXN0LCAkcXVpY2tMaXN0U2VjdGlvbiwgJHF1aWNrTGlzdFNlY3Rpb25UaXRsZTtcblxuXHRcdFx0aWYgKCB0aGlzLmNhY2hlZFF1aWNrbGlzdCAhPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVkUXVpY2tsaXN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggdGhpcy5vcHRpb25zLnF1aWNrTGlzdCApICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMucXVpY2tMaXN0ID0gdGhpcy5vcHRpb25zLnF1aWNrTGlzdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF0aGlzLm9wdGlvbnMucXVpY2tMaXN0Lmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5jYWNoZWRRdWlja2xpc3QgPSAkKCBbXSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jYWNoZWRRdWlja2xpc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBpY2sgb25seSB0aGUgZmlyc3QgZWxlbWVudHMsIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSByb29tIGZvciBtb3JlXG5cdFx0XHRxdWlja0xpc3QgPSB0aGlzLm9wdGlvbnMucXVpY2tMaXN0O1xuXHRcdFx0cXVpY2tMaXN0ID0gcXVpY2tMaXN0LnNsaWNlKCAwLCAxNiApO1xuXHRcdFx0cXVpY2tMaXN0LnNvcnQoICQudWxzLmRhdGEuc29ydEJ5QXV0b255bSApO1xuXG5cdFx0XHQkcXVpY2tMaXN0U2VjdGlvbiA9ICQoICc8ZGl2PicgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoICd1bHMtbGNkLXJlZ2lvbi1zZWN0aW9uIHVscy1sY2QtcXVpY2tsaXN0JyApO1xuXG5cdFx0XHQkcXVpY2tMaXN0U2VjdGlvblRpdGxlID0gJCggJzxoMz4nIClcblx0XHRcdFx0LmF0dHIoICdkYXRhLWkxOG4nLCAndWxzLWNvbW1vbi1sYW5ndWFnZXMnIClcblx0XHRcdFx0LmFkZENsYXNzKCAndWxzLWxjZC1yZWdpb24tdGl0bGUnIClcblx0XHRcdFx0LnRleHQoICdTdWdnZXN0ZWQgbGFuZ3VhZ2VzJyApOyAvLyBUaGlzIGlzIHBsYWNlaG9sZGVyIHRleHQgaWYganF1ZXJ5LmkxOG4gbm90IHByZXNlbnRcblx0XHRcdCRxdWlja0xpc3RTZWN0aW9uLmFwcGVuZCggJHF1aWNrTGlzdFNlY3Rpb25UaXRsZSApO1xuXG5cdFx0XHR0aGlzLnJlbmRlclJlZ2lvbihcblx0XHRcdFx0JHF1aWNrTGlzdFNlY3Rpb24sXG5cdFx0XHRcdHF1aWNrTGlzdCxcblx0XHRcdFx0dGhpcy5vcHRpb25zLml0ZW1zUGVyQ29sdW1uLFxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuY29sdW1uc1xuXHRcdFx0KTtcblxuXHRcdFx0JHF1aWNrTGlzdFNlY3Rpb25UaXRsZS5pMThuKCk7XG5cblx0XHRcdHRoaXMuY2FjaGVkUXVpY2tsaXN0ID0gJHF1aWNrTGlzdFNlY3Rpb247XG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZWRRdWlja2xpc3Q7XG5cdFx0fSxcblxuXHRcdHNob3c6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICggIXRoaXMucmVnaW9uRGl2cyApIHtcblx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIHdoZW4gYSBmcmVzaCBzZWFyY2ggaXMgc3RhcnRlZFxuXHRcdCAqL1xuXHRcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAndWxzLWxjZC0tbm8tcXVpY2tsaXN0JyApO1xuXHRcdFx0dGhpcy4kZWxlbWVudC5maW5kKCAnLnVscy1sY2QtcXVpY2tsaXN0JyApLmFkZENsYXNzKCAnaGlkZScgKTtcblx0XHR9LFxuXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuJGVsZW1lbnQuZm9jdXMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTm8tcmVzdWx0cyBldmVudCBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZmFpbGVkIHNlYXJjaCBxdWVyeVxuXHRcdCAqL1xuXHRcdG5vUmVzdWx0czogZnVuY3Rpb24gKCBldmVudCwgZGF0YSApIHtcblx0XHRcdHZhciAkbm9SZXN1bHRzO1xuXG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAndWxzLW5vLXJlc3VsdHMnICk7XG5cblx0XHRcdHRoaXMuJGVsZW1lbnQuZmluZCggJy51bHMtbm8tcmVzdWx0cy12aWV3JyApLnJlbW92ZSgpO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMubm9SZXN1bHRzVGVtcGxhdGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdCRub1Jlc3VsdHMgPVxuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5ub1Jlc3VsdHNUZW1wbGF0ZS5jYWxsKCB0aGlzLCBkYXRhLnF1ZXJ5ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMubm9SZXN1bHRzVGVtcGxhdGUgaW5zdGFuY2VvZiBqUXVlcnkgKSB7XG5cdFx0XHRcdCRub1Jlc3VsdHMgPSB0aGlzLm9wdGlvbnMubm9SZXN1bHRzVGVtcGxhdGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdub1Jlc3VsdHNUZW1wbGF0ZSBvcHRpb24gbXVzdCBiZSAnICtcblx0XHRcdFx0XHQnZWl0aGVyIGpRdWVyeSBvciBmdW5jdGlvbiByZXR1cm5pbmcgalF1ZXJ5JyApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLiRlbGVtZW50LmFwcGVuZCggJG5vUmVzdWx0cy5hZGRDbGFzcyggJ3Vscy1uby1yZXN1bHRzLXZpZXcnICkuaTE4bigpICk7XG5cdFx0fSxcblxuXHRcdGxpc3RlbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxjZCA9IHRoaXM7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNraGFuZGxlciApIHtcblx0XHRcdFx0dGhpcy4kZWxlbWVudC5vbiggJ2NsaWNrJywgJy5yb3cgbGknLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRcdGxjZC5vcHRpb25zLmNsaWNraGFuZGxlci5jYWxsKCB0aGlzLCAkKCB0aGlzICkuZGF0YSggJ2NvZGUnICksIGV2ZW50ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0JC5mbi5sY2QgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKCB0aGlzICksXG5cdFx0XHRcdGRhdGEgPSAkdGhpcy5kYXRhKCAnbGNkJyApLFxuXHRcdFx0XHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXG5cdFx0XHRpZiAoICFkYXRhICkge1xuXHRcdFx0XHQkdGhpcy5kYXRhKCAnbGNkJywgKCBkYXRhID0gbmV3IExhbmd1YWdlQ2F0ZWdvcnlEaXNwbGF5KCB0aGlzLCBvcHRpb25zICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRkYXRhWyBvcHRpb24gXSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fTtcblxuXHQkLmZuLmxjZC5kZWZhdWx0cyA9IHtcblx0XHQvLyBMaXN0IG9mIGxhbmd1YWdlcyB0byBzaG93XG5cdFx0bGFuZ3VhZ2VzOiBbXSxcblx0XHQvLyBMaXN0IG9mIHJlZ2lvbnMgdG8gc2hvd1xuXHRcdHNob3dSZWdpb25zOiBbICdXVycsICdBTScsICdFVScsICdNRScsICdBRicsICdBUycsICdQQScgXSxcblx0XHQvLyBXaGV0aGVyIHRvIGdyb3VwIGJ5IHJlZ2lvbiwgZGVmYXVsdHMgdG8gdHJ1ZSB3aGVuIGNvbHVtbnMgPiAxXG5cdFx0Z3JvdXBCeVJlZ2lvbjogJ2F1dG8nLFxuXHRcdC8vIEhvdyBtYW55IGl0ZW1zIHBlciBjb2x1bW4gdW50aWwgbmV3IFwicm93XCIgc3RhcnRzXG5cdFx0aXRlbXNQZXJDb2x1bW46IDgsXG5cdFx0Ly8gTnVtYmVyIG9mIGNvbHVtbnMsIG9ubHkgMSwgMiBhbmQgNCBhcmUgc3VwcG9ydGVkXG5cdFx0Y29sdW1uczogNCxcblx0XHQvLyBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbGFuZ3VhZ2UgaXRlbSBzdHlsaW5nXG5cdFx0bGFuZ3VhZ2VEZWNvcmF0b3I6IHVuZGVmaW5lZCxcblx0XHQvLyBMaWtlbHkgY2FuZGlkYXRlc1xuXHRcdHF1aWNrTGlzdDogW10sXG5cdFx0Ly8gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxhbmd1YWdlIHNlbGVjdGlvblxuXHRcdGNsaWNraGFuZGxlcjogdW5kZWZpbmVkLFxuXHRcdC8vIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gbm8gc2VhcmNoIHJlc3VsdHMuXG5cdFx0Ly8gSWYgb3ZlcmxvYWRlZCwgaXQgY2FuIGFjY2VwdCB0aGUgc2VhcmNoIHN0cmluZyBhcyBhbiBhcmd1bWVudC5cblx0XHRub1Jlc3VsdHNUZW1wbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICRzdWdnZXN0aW9uc0NvbnRhaW5lciwgJHN1Z2dlc3Rpb25zLFxuXHRcdFx0XHQkbm9SZXN1bHRzVGVtcGxhdGUgPSAkKCBub1Jlc3VsdHNUZW1wbGF0ZSApO1xuXG5cdFx0XHQkc3VnZ2VzdGlvbnMgPSB0aGlzLmJ1aWxkUXVpY2tsaXN0KCkuY2xvbmUoKTtcblx0XHRcdCRzdWdnZXN0aW9ucy5yZW1vdmVDbGFzcyggJ2hpZGUnIClcblx0XHRcdFx0LmZpbmQoICdoMycgKVxuXHRcdFx0XHQuZGF0YSggJ2kxOG4nLCAndWxzLW5vLXJlc3VsdHMtc3VnZ2VzdGlvbi10aXRsZScgKVxuXHRcdFx0XHQudGV4dCggJ1lvdSBtYXkgYmUgaW50ZXJlc3RlZCBpbjonIClcblx0XHRcdFx0LmkxOG4oKTtcblx0XHRcdCRzdWdnZXN0aW9uc0NvbnRhaW5lciA9ICRub1Jlc3VsdHNUZW1wbGF0ZS5maW5kKCAnLnVscy1uby1yZXN1bHRzLXN1Z2dlc3Rpb25zJyApO1xuXHRcdFx0JHN1Z2dlc3Rpb25zQ29udGFpbmVyLmFwcGVuZCggJHN1Z2dlc3Rpb25zICk7XG5cdFx0XHRyZXR1cm4gJG5vUmVzdWx0c1RlbXBsYXRlO1xuXHRcdH1cblx0fTtcblxufSggalF1ZXJ5ICkgKTtcbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjMuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jLCBub2RlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblx0XHQpICk7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSB7XG5cblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF07XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuNC4wLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHA6Ly9sZWFmbGV0anMuY29tXG4gKiAoYykgMjAxMC0yMDE4IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiAqL1xuIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/aShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0saSk6aSh0Lkw9e30pfSh0aGlzLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkodCl7dmFyIGksZSxuLG87Zm9yKGU9MSxuPWFyZ3VtZW50cy5sZW5ndGg7ZTxuO2UrKyl7bz1hcmd1bWVudHNbZV07Zm9yKGkgaW4gbyl0W2ldPW9baV19cmV0dXJuIHR9ZnVuY3Rpb24gZSh0LGkpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZTtpZih0LmJpbmQpcmV0dXJuIHQuYmluZC5hcHBseSh0LGUuY2FsbChhcmd1bWVudHMsMSkpO3ZhciBuPWUuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoaSxuLmxlbmd0aD9uLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSk6YXJndW1lbnRzKX19ZnVuY3Rpb24gbih0KXtyZXR1cm4gdC5fbGVhZmxldF9pZD10Ll9sZWFmbGV0X2lkfHwrK2VpLHQuX2xlYWZsZXRfaWR9ZnVuY3Rpb24gbyh0LGksZSl7dmFyIG4sbyxzLHI7cmV0dXJuIHI9ZnVuY3Rpb24oKXtuPSExLG8mJihzLmFwcGx5KGUsbyksbz0hMSl9LHM9ZnVuY3Rpb24oKXtuP289YXJndW1lbnRzOih0LmFwcGx5KGUsYXJndW1lbnRzKSxzZXRUaW1lb3V0KHIsaSksbj0hMCl9fWZ1bmN0aW9uIHModCxpLGUpe3ZhciBuPWlbMV0sbz1pWzBdLHM9bi1vO3JldHVybiB0PT09biYmZT90OigodC1vKSVzK3MpJXMrb31mdW5jdGlvbiByKCl7cmV0dXJuITF9ZnVuY3Rpb24gYSh0LGkpe3ZhciBlPU1hdGgucG93KDEwLHZvaWQgMD09PWk/NjppKTtyZXR1cm4gTWF0aC5yb3VuZCh0KmUpL2V9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gdC50cmltP3QudHJpbSgpOnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX1mdW5jdGlvbiB1KHQpe3JldHVybiBoKHQpLnNwbGl0KC9cXHMrLyl9ZnVuY3Rpb24gbCh0LGkpe3QuaGFzT3duUHJvcGVydHkoXCJvcHRpb25zXCIpfHwodC5vcHRpb25zPXQub3B0aW9ucz9paSh0Lm9wdGlvbnMpOnt9KTtmb3IodmFyIGUgaW4gaSl0Lm9wdGlvbnNbZV09aVtlXTtyZXR1cm4gdC5vcHRpb25zfWZ1bmN0aW9uIGModCxpLGUpe3ZhciBuPVtdO2Zvcih2YXIgbyBpbiB0KW4ucHVzaChlbmNvZGVVUklDb21wb25lbnQoZT9vLnRvVXBwZXJDYXNlKCk6bykrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRbb10pKTtyZXR1cm4oaSYmLTEhPT1pLmluZGV4T2YoXCI/XCIpP1wiJlwiOlwiP1wiKStuLmpvaW4oXCImXCIpfWZ1bmN0aW9uIF8odCxpKXtyZXR1cm4gdC5yZXBsYWNlKG5pLGZ1bmN0aW9uKHQsZSl7dmFyIG49aVtlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSBcIit0KTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKGkpKSxufSl9ZnVuY3Rpb24gZCh0LGkpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV09PT1pKXJldHVybiBlO3JldHVybi0xfWZ1bmN0aW9uIHAodCl7cmV0dXJuIHdpbmRvd1tcIndlYmtpdFwiK3RdfHx3aW5kb3dbXCJtb3pcIit0XXx8d2luZG93W1wibXNcIit0XX1mdW5jdGlvbiBtKHQpe3ZhciBpPStuZXcgRGF0ZSxlPU1hdGgubWF4KDAsMTYtKGktcmkpKTtyZXR1cm4gcmk9aStlLHdpbmRvdy5zZXRUaW1lb3V0KHQsZSl9ZnVuY3Rpb24gZih0LGksbil7aWYoIW58fGFpIT09bSlyZXR1cm4gYWkuY2FsbCh3aW5kb3csZSh0LGkpKTt0LmNhbGwoaSl9ZnVuY3Rpb24gZyh0KXt0JiZoaS5jYWxsKHdpbmRvdyx0KX1mdW5jdGlvbiB2KCl7fWZ1bmN0aW9uIHkodCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEwmJkwmJkwuTWl4aW4pe3Q9b2kodCk/dDpbdF07Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXT09PUwuTWl4aW4uRXZlbnRzJiZjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6IHRoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgcGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC5cIiwobmV3IEVycm9yKS5zdGFjayl9fWZ1bmN0aW9uIHgodCxpLGUpe3RoaXMueD1lP01hdGgucm91bmQodCk6dCx0aGlzLnk9ZT9NYXRoLnJvdW5kKGkpOml9ZnVuY3Rpb24gdyh0LGksZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiB4P3Q6b2kodCk/bmV3IHgodFswXSx0WzFdKTp2b2lkIDA9PT10fHxudWxsPT09dD90Olwib2JqZWN0XCI9PXR5cGVvZiB0JiZcInhcImluIHQmJlwieVwiaW4gdD9uZXcgeCh0LngsdC55KTpuZXcgeCh0LGksZSl9ZnVuY3Rpb24gUCh0LGkpe2lmKHQpZm9yKHZhciBlPWk/W3QsaV06dCxuPTAsbz1lLmxlbmd0aDtuPG87bisrKXRoaXMuZXh0ZW5kKGVbbl0pfWZ1bmN0aW9uIGIodCxpKXtyZXR1cm4hdHx8dCBpbnN0YW5jZW9mIFA/dDpuZXcgUCh0LGkpfWZ1bmN0aW9uIFQodCxpKXtpZih0KWZvcih2YXIgZT1pP1t0LGldOnQsbj0wLG89ZS5sZW5ndGg7bjxvO24rKyl0aGlzLmV4dGVuZChlW25dKX1mdW5jdGlvbiB6KHQsaSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUP3Q6bmV3IFQodCxpKX1mdW5jdGlvbiBNKHQsaSxlKXtpZihpc05hTih0KXx8aXNOYU4oaSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoXCIrdCtcIiwgXCIraStcIilcIik7dGhpcy5sYXQ9K3QsdGhpcy5sbmc9K2ksdm9pZCAwIT09ZSYmKHRoaXMuYWx0PStlKX1mdW5jdGlvbiBDKHQsaSxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIE0/dDpvaSh0KSYmXCJvYmplY3RcIiE9dHlwZW9mIHRbMF0/Mz09PXQubGVuZ3RoP25ldyBNKHRbMF0sdFsxXSx0WzJdKToyPT09dC5sZW5ndGg/bmV3IE0odFswXSx0WzFdKTpudWxsOnZvaWQgMD09PXR8fG51bGw9PT10P3Q6XCJvYmplY3RcIj09dHlwZW9mIHQmJlwibGF0XCJpbiB0P25ldyBNKHQubGF0LFwibG5nXCJpbiB0P3QubG5nOnQubG9uLHQuYWx0KTp2b2lkIDA9PT1pP251bGw6bmV3IE0odCxpLGUpfWZ1bmN0aW9uIFModCxpLGUsbil7aWYob2kodCkpcmV0dXJuIHRoaXMuX2E9dFswXSx0aGlzLl9iPXRbMV0sdGhpcy5fYz10WzJdLHZvaWQodGhpcy5fZD10WzNdKTt0aGlzLl9hPXQsdGhpcy5fYj1pLHRoaXMuX2M9ZSx0aGlzLl9kPW59ZnVuY3Rpb24gWih0LGksZSxuKXtyZXR1cm4gbmV3IFModCxpLGUsbil9ZnVuY3Rpb24gRSh0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix0KX1mdW5jdGlvbiBrKHQsaSl7dmFyIGUsbixvLHMscixhLGg9XCJcIjtmb3IoZT0wLG89dC5sZW5ndGg7ZTxvO2UrKyl7Zm9yKG49MCxzPShyPXRbZV0pLmxlbmd0aDtuPHM7bisrKWE9cltuXSxoKz0obj9cIkxcIjpcIk1cIikrYS54K1wiIFwiK2EueTtoKz1pP0ppP1wielwiOlwieFwiOlwiXCJ9cmV0dXJuIGh8fFwiTTAgMFwifWZ1bmN0aW9uIEIodCl7cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHQpPj0wfWZ1bmN0aW9uIEEodCxpLGUsbil7cmV0dXJuXCJ0b3VjaHN0YXJ0XCI9PT1pP08odCxlLG4pOlwidG91Y2htb3ZlXCI9PT1pP1codCxlLG4pOlwidG91Y2hlbmRcIj09PWkmJkgodCxlLG4pLHRoaXN9ZnVuY3Rpb24gSSh0LGksZSl7dmFyIG49dFtcIl9sZWFmbGV0X1wiK2krZV07cmV0dXJuXCJ0b3VjaHN0YXJ0XCI9PT1pP3QucmVtb3ZlRXZlbnRMaXN0ZW5lcih0ZSxuLCExKTpcInRvdWNobW92ZVwiPT09aT90LnJlbW92ZUV2ZW50TGlzdGVuZXIoaWUsbiwhMSk6XCJ0b3VjaGVuZFwiPT09aSYmKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlZSxuLCExKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmUsbiwhMSkpLHRoaXN9ZnVuY3Rpb24gTyh0LGksbil7dmFyIG89ZShmdW5jdGlvbih0KXtpZihcIm1vdXNlXCIhPT10LnBvaW50ZXJUeXBlJiZ0Lk1TUE9JTlRFUl9UWVBFX01PVVNFJiZ0LnBvaW50ZXJUeXBlIT09dC5NU1BPSU5URVJfVFlQRV9NT1VTRSl7aWYoIShvZS5pbmRleE9mKHQudGFyZ2V0LnRhZ05hbWUpPDApKXJldHVybjtQdCh0KX1qKHQsaSl9KTt0W1wiX2xlYWZsZXRfdG91Y2hzdGFydFwiK25dPW8sdC5hZGRFdmVudExpc3RlbmVyKHRlLG8sITEpLHJlfHwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGUsUiwhMCksZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoaWUsTiwhMCksZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZWUsRCwhMCksZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmUsRCwhMCkscmU9ITApfWZ1bmN0aW9uIFIodCl7c2VbdC5wb2ludGVySWRdPXQsYWUrK31mdW5jdGlvbiBOKHQpe3NlW3QucG9pbnRlcklkXSYmKHNlW3QucG9pbnRlcklkXT10KX1mdW5jdGlvbiBEKHQpe2RlbGV0ZSBzZVt0LnBvaW50ZXJJZF0sYWUtLX1mdW5jdGlvbiBqKHQsaSl7dC50b3VjaGVzPVtdO2Zvcih2YXIgZSBpbiBzZSl0LnRvdWNoZXMucHVzaChzZVtlXSk7dC5jaGFuZ2VkVG91Y2hlcz1bdF0saSh0KX1mdW5jdGlvbiBXKHQsaSxlKXt2YXIgbj1mdW5jdGlvbih0KXsodC5wb2ludGVyVHlwZSE9PXQuTVNQT0lOVEVSX1RZUEVfTU9VU0UmJlwibW91c2VcIiE9PXQucG9pbnRlclR5cGV8fDAhPT10LmJ1dHRvbnMpJiZqKHQsaSl9O3RbXCJfbGVhZmxldF90b3VjaG1vdmVcIitlXT1uLHQuYWRkRXZlbnRMaXN0ZW5lcihpZSxuLCExKX1mdW5jdGlvbiBIKHQsaSxlKXt2YXIgbj1mdW5jdGlvbih0KXtqKHQsaSl9O3RbXCJfbGVhZmxldF90b3VjaGVuZFwiK2VdPW4sdC5hZGRFdmVudExpc3RlbmVyKGVlLG4sITEpLHQuYWRkRXZlbnRMaXN0ZW5lcihuZSxuLCExKX1mdW5jdGlvbiBGKHQsaSxlKXtmdW5jdGlvbiBuKHQpe3ZhciBpO2lmKFZpKXtpZighYml8fFwibW91c2VcIj09PXQucG9pbnRlclR5cGUpcmV0dXJuO2k9YWV9ZWxzZSBpPXQudG91Y2hlcy5sZW5ndGg7aWYoIShpPjEpKXt2YXIgZT1EYXRlLm5vdygpLG49ZS0oc3x8ZSk7cj10LnRvdWNoZXM/dC50b3VjaGVzWzBdOnQsYT1uPjAmJm48PWgscz1lfX1mdW5jdGlvbiBvKHQpe2lmKGEmJiFyLmNhbmNlbEJ1YmJsZSl7aWYoVmkpe2lmKCFiaXx8XCJtb3VzZVwiPT09dC5wb2ludGVyVHlwZSlyZXR1cm47dmFyIGUsbixvPXt9O2ZvcihuIGluIHIpZT1yW25dLG9bbl09ZSYmZS5iaW5kP2UuYmluZChyKTplO3I9b31yLnR5cGU9XCJkYmxjbGlja1wiLGkocikscz1udWxsfX12YXIgcyxyLGE9ITEsaD0yNTA7cmV0dXJuIHRbbGUraGUrZV09bix0W2xlK3VlK2VdPW8sdFtsZStcImRibGNsaWNrXCIrZV09aSx0LmFkZEV2ZW50TGlzdGVuZXIoaGUsbiwhMSksdC5hZGRFdmVudExpc3RlbmVyKHVlLG8sITEpLHQuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsaSwhMSksdGhpc31mdW5jdGlvbiBVKHQsaSl7dmFyIGU9dFtsZStoZStpXSxuPXRbbGUrdWUraV0sbz10W2xlK1wiZGJsY2xpY2tcIitpXTtyZXR1cm4gdC5yZW1vdmVFdmVudExpc3RlbmVyKGhlLGUsITEpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih1ZSxuLCExKSxiaXx8dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIixvLCExKSx0aGlzfWZ1bmN0aW9uIFYodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodCk6dH1mdW5jdGlvbiBxKHQsaSl7dmFyIGU9dC5zdHlsZVtpXXx8dC5jdXJyZW50U3R5bGUmJnQuY3VycmVudFN0eWxlW2ldO2lmKCghZXx8XCJhdXRvXCI9PT1lKSYmZG9jdW1lbnQuZGVmYXVsdFZpZXcpe3ZhciBuPWRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodCxudWxsKTtlPW4/bltpXTpudWxsfXJldHVyblwiYXV0b1wiPT09ZT9udWxsOmV9ZnVuY3Rpb24gRyh0LGksZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0KTtyZXR1cm4gbi5jbGFzc05hbWU9aXx8XCJcIixlJiZlLmFwcGVuZENoaWxkKG4pLG59ZnVuY3Rpb24gSyh0KXt2YXIgaT10LnBhcmVudE5vZGU7aSYmaS5yZW1vdmVDaGlsZCh0KX1mdW5jdGlvbiBZKHQpe2Zvcig7dC5maXJzdENoaWxkOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCl9ZnVuY3Rpb24gWCh0KXt2YXIgaT10LnBhcmVudE5vZGU7aSYmaS5sYXN0Q2hpbGQhPT10JiZpLmFwcGVuZENoaWxkKHQpfWZ1bmN0aW9uIEoodCl7dmFyIGk9dC5wYXJlbnROb2RlO2kmJmkuZmlyc3RDaGlsZCE9PXQmJmkuaW5zZXJ0QmVmb3JlKHQsaS5maXJzdENoaWxkKX1mdW5jdGlvbiAkKHQsaSl7aWYodm9pZCAwIT09dC5jbGFzc0xpc3QpcmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKGkpO3ZhciBlPWV0KHQpO3JldHVybiBlLmxlbmd0aD4wJiZuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIraStcIihcXFxcc3wkKVwiKS50ZXN0KGUpfWZ1bmN0aW9uIFEodCxpKXtpZih2b2lkIDAhPT10LmNsYXNzTGlzdClmb3IodmFyIGU9dShpKSxuPTAsbz1lLmxlbmd0aDtuPG87bisrKXQuY2xhc3NMaXN0LmFkZChlW25dKTtlbHNlIGlmKCEkKHQsaSkpe3ZhciBzPWV0KHQpO2l0KHQsKHM/cytcIiBcIjpcIlwiKStpKX19ZnVuY3Rpb24gdHQodCxpKXt2b2lkIDAhPT10LmNsYXNzTGlzdD90LmNsYXNzTGlzdC5yZW1vdmUoaSk6aXQodCxoKChcIiBcIitldCh0KStcIiBcIikucmVwbGFjZShcIiBcIitpK1wiIFwiLFwiIFwiKSkpfWZ1bmN0aW9uIGl0KHQsaSl7dm9pZCAwPT09dC5jbGFzc05hbWUuYmFzZVZhbD90LmNsYXNzTmFtZT1pOnQuY2xhc3NOYW1lLmJhc2VWYWw9aX1mdW5jdGlvbiBldCh0KXtyZXR1cm4gdC5jb3JyZXNwb25kaW5nRWxlbWVudCYmKHQ9dC5jb3JyZXNwb25kaW5nRWxlbWVudCksdm9pZCAwPT09dC5jbGFzc05hbWUuYmFzZVZhbD90LmNsYXNzTmFtZTp0LmNsYXNzTmFtZS5iYXNlVmFsfWZ1bmN0aW9uIG50KHQsaSl7XCJvcGFjaXR5XCJpbiB0LnN0eWxlP3Quc3R5bGUub3BhY2l0eT1pOlwiZmlsdGVyXCJpbiB0LnN0eWxlJiZvdCh0LGkpfWZ1bmN0aW9uIG90KHQsaSl7dmFyIGU9ITEsbj1cIkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhXCI7dHJ5e2U9dC5maWx0ZXJzLml0ZW0obil9Y2F0Y2godCl7aWYoMT09PWkpcmV0dXJufWk9TWF0aC5yb3VuZCgxMDAqaSksZT8oZS5FbmFibGVkPTEwMCE9PWksZS5PcGFjaXR5PWkpOnQuc3R5bGUuZmlsdGVyKz1cIiBwcm9naWQ6XCIrbitcIihvcGFjaXR5PVwiK2krXCIpXCJ9ZnVuY3Rpb24gc3QodCl7Zm9yKHZhciBpPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxlPTA7ZTx0Lmxlbmd0aDtlKyspaWYodFtlXWluIGkpcmV0dXJuIHRbZV07cmV0dXJuITF9ZnVuY3Rpb24gcnQodCxpLGUpe3ZhciBuPWl8fG5ldyB4KDAsMCk7dC5zdHlsZVtjZV09KFJpP1widHJhbnNsYXRlKFwiK24ueCtcInB4LFwiK24ueStcInB4KVwiOlwidHJhbnNsYXRlM2QoXCIrbi54K1wicHgsXCIrbi55K1wicHgsMClcIikrKGU/XCIgc2NhbGUoXCIrZStcIilcIjpcIlwiKX1mdW5jdGlvbiBhdCh0LGkpe3QuX2xlYWZsZXRfcG9zPWksamk/cnQodCxpKToodC5zdHlsZS5sZWZ0PWkueCtcInB4XCIsdC5zdHlsZS50b3A9aS55K1wicHhcIil9ZnVuY3Rpb24gaHQodCl7cmV0dXJuIHQuX2xlYWZsZXRfcG9zfHxuZXcgeCgwLDApfWZ1bmN0aW9uIHV0KCl7bXQod2luZG93LFwiZHJhZ3N0YXJ0XCIsUHQpfWZ1bmN0aW9uIGx0KCl7ZnQod2luZG93LFwiZHJhZ3N0YXJ0XCIsUHQpfWZ1bmN0aW9uIGN0KHQpe2Zvcig7LTE9PT10LnRhYkluZGV4Oyl0PXQucGFyZW50Tm9kZTt0LnN0eWxlJiYoX3QoKSxtZT10LGZlPXQuc3R5bGUub3V0bGluZSx0LnN0eWxlLm91dGxpbmU9XCJub25lXCIsbXQod2luZG93LFwia2V5ZG93blwiLF90KSl9ZnVuY3Rpb24gX3QoKXttZSYmKG1lLnN0eWxlLm91dGxpbmU9ZmUsbWU9dm9pZCAwLGZlPXZvaWQgMCxmdCh3aW5kb3csXCJrZXlkb3duXCIsX3QpKX1mdW5jdGlvbiBkdCh0KXtkb3t0PXQucGFyZW50Tm9kZX13aGlsZSghKHQub2Zmc2V0V2lkdGgmJnQub2Zmc2V0SGVpZ2h0fHx0PT09ZG9jdW1lbnQuYm9keSkpO3JldHVybiB0fWZ1bmN0aW9uIHB0KHQpe3ZhciBpPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6aS53aWR0aC90Lm9mZnNldFdpZHRofHwxLHk6aS5oZWlnaHQvdC5vZmZzZXRIZWlnaHR8fDEsYm91bmRpbmdDbGllbnRSZWN0Oml9fWZ1bmN0aW9uIG10KHQsaSxlLG4pe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBpKWZvcih2YXIgbyBpbiBpKWd0KHQsbyxpW29dLGUpO2Vsc2UgZm9yKHZhciBzPTAscj0oaT11KGkpKS5sZW5ndGg7czxyO3MrKylndCh0LGlbc10sZSxuKTtyZXR1cm4gdGhpc31mdW5jdGlvbiBmdCh0LGksZSxuKXtpZihcIm9iamVjdFwiPT10eXBlb2YgaSlmb3IodmFyIG8gaW4gaSl2dCh0LG8saVtvXSxlKTtlbHNlIGlmKGkpZm9yKHZhciBzPTAscj0oaT11KGkpKS5sZW5ndGg7czxyO3MrKyl2dCh0LGlbc10sZSxuKTtlbHNle2Zvcih2YXIgYSBpbiB0W3llXSl2dCh0LGEsdFt5ZV1bYV0pO2RlbGV0ZSB0W3llXX1yZXR1cm4gdGhpc31mdW5jdGlvbiBndCh0LGksZSxvKXt2YXIgcz1pK24oZSkrKG8/XCJfXCIrbihvKTpcIlwiKTtpZih0W3llXSYmdFt5ZV1bc10pcmV0dXJuIHRoaXM7dmFyIHI9ZnVuY3Rpb24oaSl7cmV0dXJuIGUuY2FsbChvfHx0LGl8fHdpbmRvdy5ldmVudCl9LGE9cjtWaSYmMD09PWkuaW5kZXhPZihcInRvdWNoXCIpP0EodCxpLHIscyk6IXFpfHxcImRibGNsaWNrXCIhPT1pfHwhRnx8VmkmJkVpP1wiYWRkRXZlbnRMaXN0ZW5lclwiaW4gdD9cIm1vdXNld2hlZWxcIj09PWk/dC5hZGRFdmVudExpc3RlbmVyKFwib253aGVlbFwiaW4gdD9cIndoZWVsXCI6XCJtb3VzZXdoZWVsXCIsciwhMSk6XCJtb3VzZWVudGVyXCI9PT1pfHxcIm1vdXNlbGVhdmVcIj09PWk/KHI9ZnVuY3Rpb24oaSl7aT1pfHx3aW5kb3cuZXZlbnQsQ3QodCxpKSYmYShpKX0sdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiPT09aT9cIm1vdXNlb3ZlclwiOlwibW91c2VvdXRcIixyLCExKSk6KFwiY2xpY2tcIj09PWkmJnppJiYocj1mdW5jdGlvbih0KXtTdCh0LGEpfSksdC5hZGRFdmVudExpc3RlbmVyKGksciwhMSkpOlwiYXR0YWNoRXZlbnRcImluIHQmJnQuYXR0YWNoRXZlbnQoXCJvblwiK2kscik6Rih0LHIscyksdFt5ZV09dFt5ZV18fHt9LHRbeWVdW3NdPXJ9ZnVuY3Rpb24gdnQodCxpLGUsbyl7dmFyIHM9aStuKGUpKyhvP1wiX1wiK24obyk6XCJcIikscj10W3llXSYmdFt5ZV1bc107aWYoIXIpcmV0dXJuIHRoaXM7VmkmJjA9PT1pLmluZGV4T2YoXCJ0b3VjaFwiKT9JKHQsaSxzKTohcWl8fFwiZGJsY2xpY2tcIiE9PWl8fCFVfHxWaSYmRWk/XCJyZW1vdmVFdmVudExpc3RlbmVyXCJpbiB0P1wibW91c2V3aGVlbFwiPT09aT90LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbndoZWVsXCJpbiB0P1wid2hlZWxcIjpcIm1vdXNld2hlZWxcIixyLCExKTp0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCI9PT1pP1wibW91c2VvdmVyXCI6XCJtb3VzZWxlYXZlXCI9PT1pP1wibW91c2VvdXRcIjppLHIsITEpOlwiZGV0YWNoRXZlbnRcImluIHQmJnQuZGV0YWNoRXZlbnQoXCJvblwiK2kscik6VSh0LHMpLHRbeWVdW3NdPW51bGx9ZnVuY3Rpb24geXQodCl7cmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uP3Quc3RvcFByb3BhZ2F0aW9uKCk6dC5vcmlnaW5hbEV2ZW50P3Qub3JpZ2luYWxFdmVudC5fc3RvcHBlZD0hMDp0LmNhbmNlbEJ1YmJsZT0hMCxNdCh0KSx0aGlzfWZ1bmN0aW9uIHh0KHQpe3JldHVybiBndCh0LFwibW91c2V3aGVlbFwiLHl0KSx0aGlzfWZ1bmN0aW9uIHd0KHQpe3JldHVybiBtdCh0LFwibW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2tcIix5dCksZ3QodCxcImNsaWNrXCIsenQpLHRoaXN9ZnVuY3Rpb24gUHQodCl7cmV0dXJuIHQucHJldmVudERlZmF1bHQ/dC5wcmV2ZW50RGVmYXVsdCgpOnQucmV0dXJuVmFsdWU9ITEsdGhpc31mdW5jdGlvbiBMdCh0KXtyZXR1cm4gUHQodCkseXQodCksdGhpc31mdW5jdGlvbiBidCh0LGkpe2lmKCFpKXJldHVybiBuZXcgeCh0LmNsaWVudFgsdC5jbGllbnRZKTt2YXIgZT1wdChpKSxuPWUuYm91bmRpbmdDbGllbnRSZWN0O3JldHVybiBuZXcgeCgodC5jbGllbnRYLW4ubGVmdCkvZS54LWkuY2xpZW50TGVmdCwodC5jbGllbnRZLW4udG9wKS9lLnktaS5jbGllbnRUb3ApfWZ1bmN0aW9uIFR0KHQpe3JldHVybiBiaT90LndoZWVsRGVsdGFZLzI6dC5kZWx0YVkmJjA9PT10LmRlbHRhTW9kZT8tdC5kZWx0YVkveGU6dC5kZWx0YVkmJjE9PT10LmRlbHRhTW9kZT8yMCotdC5kZWx0YVk6dC5kZWx0YVkmJjI9PT10LmRlbHRhTW9kZT82MCotdC5kZWx0YVk6dC5kZWx0YVh8fHQuZGVsdGFaPzA6dC53aGVlbERlbHRhPyh0LndoZWVsRGVsdGFZfHx0LndoZWVsRGVsdGEpLzI6dC5kZXRhaWwmJk1hdGguYWJzKHQuZGV0YWlsKTwzMjc2NT8yMCotdC5kZXRhaWw6dC5kZXRhaWw/dC5kZXRhaWwvLTMyNzY1KjYwOjB9ZnVuY3Rpb24genQodCl7d2VbdC50eXBlXT0hMH1mdW5jdGlvbiBNdCh0KXt2YXIgaT13ZVt0LnR5cGVdO3JldHVybiB3ZVt0LnR5cGVdPSExLGl9ZnVuY3Rpb24gQ3QodCxpKXt2YXIgZT1pLnJlbGF0ZWRUYXJnZXQ7aWYoIWUpcmV0dXJuITA7dHJ5e2Zvcig7ZSYmZSE9PXQ7KWU9ZS5wYXJlbnROb2RlfWNhdGNoKHQpe3JldHVybiExfXJldHVybiBlIT09dH1mdW5jdGlvbiBTdCh0LGkpe3ZhciBlPXQudGltZVN0YW1wfHx0Lm9yaWdpbmFsRXZlbnQmJnQub3JpZ2luYWxFdmVudC50aW1lU3RhbXAsbj1nZSYmZS1nZTtuJiZuPjEwMCYmbjw1MDB8fHQudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayYmIXQuX3NpbXVsYXRlZD9MdCh0KTooZ2U9ZSxpKHQpKX1mdW5jdGlvbiBadCh0LGkpe2lmKCFpfHwhdC5sZW5ndGgpcmV0dXJuIHQuc2xpY2UoKTt2YXIgZT1pKmk7cmV0dXJuIHQ9QXQodCxlKSx0PWt0KHQsZSl9ZnVuY3Rpb24gRXQodCxpLGUpe3JldHVybiBNYXRoLnNxcnQoRHQodCxpLGUsITApKX1mdW5jdGlvbiBrdCh0LGkpe3ZhciBlPXQubGVuZ3RoLG49bmV3KHR5cGVvZiBVaW50OEFycmF5IT12b2lkIDArXCJcIj9VaW50OEFycmF5OkFycmF5KShlKTtuWzBdPW5bZS0xXT0xLEJ0KHQsbixpLDAsZS0xKTt2YXIgbyxzPVtdO2ZvcihvPTA7bzxlO28rKyluW29dJiZzLnB1c2godFtvXSk7cmV0dXJuIHN9ZnVuY3Rpb24gQnQodCxpLGUsbixvKXt2YXIgcyxyLGEsaD0wO2ZvcihyPW4rMTtyPD1vLTE7cisrKShhPUR0KHRbcl0sdFtuXSx0W29dLCEwKSk+aCYmKHM9cixoPWEpO2g+ZSYmKGlbc109MSxCdCh0LGksZSxuLHMpLEJ0KHQsaSxlLHMsbykpfWZ1bmN0aW9uIEF0KHQsaSl7Zm9yKHZhciBlPVt0WzBdXSxuPTEsbz0wLHM9dC5sZW5ndGg7bjxzO24rKylOdCh0W25dLHRbb10pPmkmJihlLnB1c2godFtuXSksbz1uKTtyZXR1cm4gbzxzLTEmJmUucHVzaCh0W3MtMV0pLGV9ZnVuY3Rpb24gSXQodCxpLGUsbixvKXt2YXIgcyxyLGEsaD1uP2tlOlJ0KHQsZSksdT1SdChpLGUpO2ZvcihrZT11Ozspe2lmKCEoaHx1KSlyZXR1cm5bdCxpXTtpZihoJnUpcmV0dXJuITE7YT1SdChyPU90KHQsaSxzPWh8fHUsZSxvKSxlKSxzPT09aD8odD1yLGg9YSk6KGk9cix1PWEpfX1mdW5jdGlvbiBPdCh0LGksZSxuLG8pe3ZhciBzLHIsYT1pLngtdC54LGg9aS55LXQueSx1PW4ubWluLGw9bi5tYXg7cmV0dXJuIDgmZT8ocz10LngrYSoobC55LXQueSkvaCxyPWwueSk6NCZlPyhzPXQueCthKih1LnktdC55KS9oLHI9dS55KToyJmU/KHM9bC54LHI9dC55K2gqKGwueC10LngpL2EpOjEmZSYmKHM9dS54LHI9dC55K2gqKHUueC10LngpL2EpLG5ldyB4KHMscixvKX1mdW5jdGlvbiBSdCh0LGkpe3ZhciBlPTA7cmV0dXJuIHQueDxpLm1pbi54P2V8PTE6dC54PmkubWF4LngmJihlfD0yKSx0Lnk8aS5taW4ueT9lfD00OnQueT5pLm1heC55JiYoZXw9OCksZX1mdW5jdGlvbiBOdCh0LGkpe3ZhciBlPWkueC10Lngsbj1pLnktdC55O3JldHVybiBlKmUrbipufWZ1bmN0aW9uIER0KHQsaSxlLG4pe3ZhciBvLHM9aS54LHI9aS55LGE9ZS54LXMsaD1lLnktcix1PWEqYStoKmg7cmV0dXJuIHU+MCYmKChvPSgodC54LXMpKmErKHQueS1yKSpoKS91KT4xPyhzPWUueCxyPWUueSk6bz4wJiYocys9YSpvLHIrPWgqbykpLGE9dC54LXMsaD10LnktcixuP2EqYStoKmg6bmV3IHgocyxyKX1mdW5jdGlvbiBqdCh0KXtyZXR1cm4hb2kodFswXSl8fFwib2JqZWN0XCIhPXR5cGVvZiB0WzBdWzBdJiZ2b2lkIDAhPT10WzBdWzBdfWZ1bmN0aW9uIFd0KHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLlwiKSxqdCh0KX1mdW5jdGlvbiBIdCh0LGksZSl7dmFyIG4sbyxzLHIsYSxoLHUsbCxjLF89WzEsNCwyLDhdO2ZvcihvPTAsdT10Lmxlbmd0aDtvPHU7bysrKXRbb10uX2NvZGU9UnQodFtvXSxpKTtmb3Iocj0wO3I8NDtyKyspe2ZvcihsPV9bcl0sbj1bXSxvPTAscz0odT10Lmxlbmd0aCktMTtvPHU7cz1vKyspYT10W29dLGg9dFtzXSxhLl9jb2RlJmw/aC5fY29kZSZsfHwoKGM9T3QoaCxhLGwsaSxlKSkuX2NvZGU9UnQoYyxpKSxuLnB1c2goYykpOihoLl9jb2RlJmwmJigoYz1PdChoLGEsbCxpLGUpKS5fY29kZT1SdChjLGkpLG4ucHVzaChjKSksbi5wdXNoKGEpKTt0PW59cmV0dXJuIHR9ZnVuY3Rpb24gRnQodCxpKXt2YXIgZSxuLG8scyxyPVwiRmVhdHVyZVwiPT09dC50eXBlP3QuZ2VvbWV0cnk6dCxhPXI/ci5jb29yZGluYXRlczpudWxsLGg9W10sdT1pJiZpLnBvaW50VG9MYXllcixsPWkmJmkuY29vcmRzVG9MYXRMbmd8fFV0O2lmKCFhJiYhcilyZXR1cm4gbnVsbDtzd2l0Y2goci50eXBlKXtjYXNlXCJQb2ludFwiOnJldHVybiBlPWwoYSksdT91KHQsZSk6bmV3ICRlKGUpO2Nhc2VcIk11bHRpUG9pbnRcIjpmb3Iobz0wLHM9YS5sZW5ndGg7bzxzO28rKyllPWwoYVtvXSksaC5wdXNoKHU/dSh0LGUpOm5ldyAkZShlKSk7cmV0dXJuIG5ldyBLZShoKTtjYXNlXCJMaW5lU3RyaW5nXCI6Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6cmV0dXJuIG49VnQoYSxcIkxpbmVTdHJpbmdcIj09PXIudHlwZT8wOjEsbCksbmV3IG5uKG4saSk7Y2FzZVwiUG9seWdvblwiOmNhc2VcIk11bHRpUG9seWdvblwiOnJldHVybiBuPVZ0KGEsXCJQb2x5Z29uXCI9PT1yLnR5cGU/MToyLGwpLG5ldyBvbihuLGkpO2Nhc2VcIkdlb21ldHJ5Q29sbGVjdGlvblwiOmZvcihvPTAscz1yLmdlb21ldHJpZXMubGVuZ3RoO288cztvKyspe3ZhciBjPUZ0KHtnZW9tZXRyeTpyLmdlb21ldHJpZXNbb10sdHlwZTpcIkZlYXR1cmVcIixwcm9wZXJ0aWVzOnQucHJvcGVydGllc30saSk7YyYmaC5wdXNoKGMpfXJldHVybiBuZXcgS2UoaCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlb0pTT04gb2JqZWN0LlwiKX19ZnVuY3Rpb24gVXQodCl7cmV0dXJuIG5ldyBNKHRbMV0sdFswXSx0WzJdKX1mdW5jdGlvbiBWdCh0LGksZSl7Zm9yKHZhciBuLG89W10scz0wLHI9dC5sZW5ndGg7czxyO3MrKyluPWk/VnQodFtzXSxpLTEsZSk6KGV8fFV0KSh0W3NdKSxvLnB1c2gobik7cmV0dXJuIG99ZnVuY3Rpb24gcXQodCxpKXtyZXR1cm4gaT1cIm51bWJlclwiPT10eXBlb2YgaT9pOjYsdm9pZCAwIT09dC5hbHQ/W2EodC5sbmcsaSksYSh0LmxhdCxpKSxhKHQuYWx0LGkpXTpbYSh0LmxuZyxpKSxhKHQubGF0LGkpXX1mdW5jdGlvbiBHdCh0LGksZSxuKXtmb3IodmFyIG89W10scz0wLHI9dC5sZW5ndGg7czxyO3MrKylvLnB1c2goaT9HdCh0W3NdLGktMSxlLG4pOnF0KHRbc10sbikpO3JldHVybiFpJiZlJiZvLnB1c2gob1swXSksb31mdW5jdGlvbiBLdCh0LGUpe3JldHVybiB0LmZlYXR1cmU/aSh7fSx0LmZlYXR1cmUse2dlb21ldHJ5OmV9KTpZdChlKX1mdW5jdGlvbiBZdCh0KXtyZXR1cm5cIkZlYXR1cmVcIj09PXQudHlwZXx8XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09dC50eXBlP3Q6e3R5cGU6XCJGZWF0dXJlXCIscHJvcGVydGllczp7fSxnZW9tZXRyeTp0fX1mdW5jdGlvbiBYdCh0LGkpe3JldHVybiBuZXcgc24odCxpKX1mdW5jdGlvbiBKdCh0LGkpe3JldHVybiBuZXcgbW4odCxpKX1mdW5jdGlvbiAkdCh0KXtyZXR1cm4gWGk/bmV3IHZuKHQpOm51bGx9ZnVuY3Rpb24gUXQodCl7cmV0dXJuIEppfHwkaT9uZXcgUG4odCk6bnVsbH12YXIgdGk9T2JqZWN0LmZyZWV6ZTtPYmplY3QuZnJlZXplPWZ1bmN0aW9uKHQpe3JldHVybiB0fTt2YXIgaWk9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gdC5wcm90b3R5cGU9aSxuZXcgdH19KCksZWk9MCxuaT0vXFx7ICooW1xcd18tXSspICpcXH0vZyxvaT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9LHNpPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPVwiLHJpPTAsYWk9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8cChcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiKXx8bSxoaT13aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fHAoXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiKXx8cChcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiKXx8ZnVuY3Rpb24odCl7d2luZG93LmNsZWFyVGltZW91dCh0KX0sdWk9KE9iamVjdC5mcmVlemV8fE9iamVjdCkoe2ZyZWV6ZTp0aSxleHRlbmQ6aSxjcmVhdGU6aWksYmluZDplLGxhc3RJZDplaSxzdGFtcDpuLHRocm90dGxlOm8sd3JhcE51bTpzLGZhbHNlRm46cixmb3JtYXROdW06YSx0cmltOmgsc3BsaXRXb3Jkczp1LHNldE9wdGlvbnM6bCxnZXRQYXJhbVN0cmluZzpjLHRlbXBsYXRlOl8saXNBcnJheTpvaSxpbmRleE9mOmQsZW1wdHlJbWFnZVVybDpzaSxyZXF1ZXN0Rm46YWksY2FuY2VsRm46aGkscmVxdWVzdEFuaW1GcmFtZTpmLGNhbmNlbEFuaW1GcmFtZTpnfSk7di5leHRlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXt0aGlzLmluaXRpYWxpemUmJnRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5jYWxsSW5pdEhvb2tzKCl9LG49ZS5fX3N1cGVyX189dGhpcy5wcm90b3R5cGUsbz1paShuKTtvLmNvbnN0cnVjdG9yPWUsZS5wcm90b3R5cGU9bztmb3IodmFyIHMgaW4gdGhpcyl0aGlzLmhhc093blByb3BlcnR5KHMpJiZcInByb3RvdHlwZVwiIT09cyYmXCJfX3N1cGVyX19cIiE9PXMmJihlW3NdPXRoaXNbc10pO3JldHVybiB0LnN0YXRpY3MmJihpKGUsdC5zdGF0aWNzKSxkZWxldGUgdC5zdGF0aWNzKSx0LmluY2x1ZGVzJiYoeSh0LmluY2x1ZGVzKSxpLmFwcGx5KG51bGwsW29dLmNvbmNhdCh0LmluY2x1ZGVzKSksZGVsZXRlIHQuaW5jbHVkZXMpLG8ub3B0aW9ucyYmKHQub3B0aW9ucz1pKGlpKG8ub3B0aW9ucyksdC5vcHRpb25zKSksaShvLHQpLG8uX2luaXRIb29rcz1bXSxvLmNhbGxJbml0SG9va3M9ZnVuY3Rpb24oKXtpZighdGhpcy5faW5pdEhvb2tzQ2FsbGVkKXtuLmNhbGxJbml0SG9va3MmJm4uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpLHRoaXMuX2luaXRIb29rc0NhbGxlZD0hMDtmb3IodmFyIHQ9MCxpPW8uX2luaXRIb29rcy5sZW5ndGg7dDxpO3QrKylvLl9pbml0SG9va3NbdF0uY2FsbCh0aGlzKX19LGV9LHYuaW5jbHVkZT1mdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLnByb3RvdHlwZSx0KSx0aGlzfSx2Lm1lcmdlT3B0aW9ucz1mdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLnByb3RvdHlwZS5vcHRpb25zLHQpLHRoaXN9LHYuYWRkSW5pdEhvb2s9ZnVuY3Rpb24odCl7dmFyIGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGU9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OmZ1bmN0aW9uKCl7dGhpc1t0XS5hcHBseSh0aGlzLGkpfTtyZXR1cm4gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcz10aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzfHxbXSx0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goZSksdGhpc307dmFyIGxpPXtvbjpmdW5jdGlvbih0LGksZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpZm9yKHZhciBuIGluIHQpdGhpcy5fb24obix0W25dLGkpO2Vsc2UgZm9yKHZhciBvPTAscz0odD11KHQpKS5sZW5ndGg7bzxzO28rKyl0aGlzLl9vbih0W29dLGksZSk7cmV0dXJuIHRoaXN9LG9mZjpmdW5jdGlvbih0LGksZSl7aWYodClpZihcIm9iamVjdFwiPT10eXBlb2YgdClmb3IodmFyIG4gaW4gdCl0aGlzLl9vZmYobix0W25dLGkpO2Vsc2UgZm9yKHZhciBvPTAscz0odD11KHQpKS5sZW5ndGg7bzxzO28rKyl0aGlzLl9vZmYodFtvXSxpLGUpO2Vsc2UgZGVsZXRlIHRoaXMuX2V2ZW50cztyZXR1cm4gdGhpc30sX29uOmZ1bmN0aW9uKHQsaSxlKXt0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzfHx7fTt2YXIgbj10aGlzLl9ldmVudHNbdF07bnx8KG49W10sdGhpcy5fZXZlbnRzW3RdPW4pLGU9PT10aGlzJiYoZT12b2lkIDApO2Zvcih2YXIgbz17Zm46aSxjdHg6ZX0scz1uLHI9MCxhPXMubGVuZ3RoO3I8YTtyKyspaWYoc1tyXS5mbj09PWkmJnNbcl0uY3R4PT09ZSlyZXR1cm47cy5wdXNoKG8pfSxfb2ZmOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbixvLHM7aWYodGhpcy5fZXZlbnRzJiYobj10aGlzLl9ldmVudHNbdF0pKWlmKGkpe2lmKGU9PT10aGlzJiYoZT12b2lkIDApLG4pZm9yKG89MCxzPW4ubGVuZ3RoO288cztvKyspe3ZhciBhPW5bb107aWYoYS5jdHg9PT1lJiZhLmZuPT09aSlyZXR1cm4gYS5mbj1yLHRoaXMuX2ZpcmluZ0NvdW50JiYodGhpcy5fZXZlbnRzW3RdPW49bi5zbGljZSgpKSx2b2lkIG4uc3BsaWNlKG8sMSl9fWVsc2V7Zm9yKG89MCxzPW4ubGVuZ3RoO288cztvKyspbltvXS5mbj1yO2RlbGV0ZSB0aGlzLl9ldmVudHNbdF19fSxmaXJlOmZ1bmN0aW9uKHQsZSxuKXtpZighdGhpcy5saXN0ZW5zKHQsbikpcmV0dXJuIHRoaXM7dmFyIG89aSh7fSxlLHt0eXBlOnQsdGFyZ2V0OnRoaXMsc291cmNlVGFyZ2V0OmUmJmUuc291cmNlVGFyZ2V0fHx0aGlzfSk7aWYodGhpcy5fZXZlbnRzKXt2YXIgcz10aGlzLl9ldmVudHNbdF07aWYocyl7dGhpcy5fZmlyaW5nQ291bnQ9dGhpcy5fZmlyaW5nQ291bnQrMXx8MTtmb3IodmFyIHI9MCxhPXMubGVuZ3RoO3I8YTtyKyspe3ZhciBoPXNbcl07aC5mbi5jYWxsKGguY3R4fHx0aGlzLG8pfXRoaXMuX2ZpcmluZ0NvdW50LS19fXJldHVybiBuJiZ0aGlzLl9wcm9wYWdhdGVFdmVudChvKSx0aGlzfSxsaXN0ZW5zOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5fZXZlbnRzJiZ0aGlzLl9ldmVudHNbdF07aWYoZSYmZS5sZW5ndGgpcmV0dXJuITA7aWYoaSlmb3IodmFyIG4gaW4gdGhpcy5fZXZlbnRQYXJlbnRzKWlmKHRoaXMuX2V2ZW50UGFyZW50c1tuXS5saXN0ZW5zKHQsaSkpcmV0dXJuITA7cmV0dXJuITF9LG9uY2U6ZnVuY3Rpb24odCxpLG4pe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtmb3IodmFyIG8gaW4gdCl0aGlzLm9uY2Uobyx0W29dLGkpO3JldHVybiB0aGlzfXZhciBzPWUoZnVuY3Rpb24oKXt0aGlzLm9mZih0LGksbikub2ZmKHQscyxuKX0sdGhpcyk7cmV0dXJuIHRoaXMub24odCxpLG4pLm9uKHQscyxuKX0sYWRkRXZlbnRQYXJlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2V2ZW50UGFyZW50cz10aGlzLl9ldmVudFBhcmVudHN8fHt9LHRoaXMuX2V2ZW50UGFyZW50c1tuKHQpXT10LHRoaXN9LHJlbW92ZUV2ZW50UGFyZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9ldmVudFBhcmVudHMmJmRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbbih0KV0sdGhpc30sX3Byb3BhZ2F0ZUV2ZW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0aGlzLl9ldmVudFBhcmVudHMpdGhpcy5fZXZlbnRQYXJlbnRzW2VdLmZpcmUodC50eXBlLGkoe2xheWVyOnQudGFyZ2V0LHByb3BhZ2F0ZWRGcm9tOnQudGFyZ2V0fSx0KSwhMCl9fTtsaS5hZGRFdmVudExpc3RlbmVyPWxpLm9uLGxpLnJlbW92ZUV2ZW50TGlzdGVuZXI9bGkuY2xlYXJBbGxFdmVudExpc3RlbmVycz1saS5vZmYsbGkuYWRkT25lVGltZUV2ZW50TGlzdGVuZXI9bGkub25jZSxsaS5maXJlRXZlbnQ9bGkuZmlyZSxsaS5oYXNFdmVudExpc3RlbmVycz1saS5saXN0ZW5zO3ZhciBjaT12LmV4dGVuZChsaSksX2k9TWF0aC50cnVuY3x8ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD9NYXRoLmZsb29yKHQpOk1hdGguY2VpbCh0KX07eC5wcm90b3R5cGU9e2Nsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB4KHRoaXMueCx0aGlzLnkpfSxhZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHcodCkpfSxfYWRkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzfSxzdWJ0cmFjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh3KHQpKX0sX3N1YnRyYWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzfSxkaXZpZGVCeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeSh0KX0sX2RpdmlkZUJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLngvPXQsdGhpcy55Lz10LHRoaXN9LG11bHRpcGx5Qnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeSh0KX0sX211bHRpcGx5Qnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpc30sc2NhbGVCeTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHgodGhpcy54KnQueCx0aGlzLnkqdC55KX0sdW5zY2FsZUJ5OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeCh0aGlzLngvdC54LHRoaXMueS90LnkpfSxyb3VuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCl9LF9yb3VuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpc30sZmxvb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpfSxfZmxvb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXN9LGNlaWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCl9LF9jZWlsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpc30sdHJ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpfSxfdHJ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54PV9pKHRoaXMueCksdGhpcy55PV9pKHRoaXMueSksdGhpc30sZGlzdGFuY2VUbzpmdW5jdGlvbih0KXt2YXIgaT0odD13KHQpKS54LXRoaXMueCxlPXQueS10aGlzLnk7cmV0dXJuIE1hdGguc3FydChpKmkrZSplKX0sZXF1YWxzOmZ1bmN0aW9uKHQpe3JldHVybih0PXcodCkpLng9PT10aGlzLngmJnQueT09PXRoaXMueX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dyh0KSxNYXRoLmFicyh0LngpPD1NYXRoLmFicyh0aGlzLngpJiZNYXRoLmFicyh0LnkpPD1NYXRoLmFicyh0aGlzLnkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiUG9pbnQoXCIrYSh0aGlzLngpK1wiLCBcIithKHRoaXMueSkrXCIpXCJ9fSxQLnByb3RvdHlwZT17ZXh0ZW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0PXcodCksdGhpcy5taW58fHRoaXMubWF4Pyh0aGlzLm1pbi54PU1hdGgubWluKHQueCx0aGlzLm1pbi54KSx0aGlzLm1heC54PU1hdGgubWF4KHQueCx0aGlzLm1heC54KSx0aGlzLm1pbi55PU1hdGgubWluKHQueSx0aGlzLm1pbi55KSx0aGlzLm1heC55PU1hdGgubWF4KHQueSx0aGlzLm1heC55KSk6KHRoaXMubWluPXQuY2xvbmUoKSx0aGlzLm1heD10LmNsb25lKCkpLHRoaXN9LGdldENlbnRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHgoKHRoaXMubWluLngrdGhpcy5tYXgueCkvMiwodGhpcy5taW4ueSt0aGlzLm1heC55KS8yLHQpfSxnZXRCb3R0b21MZWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB4KHRoaXMubWluLngsdGhpcy5tYXgueSl9LGdldFRvcFJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB4KHRoaXMubWF4LngsdGhpcy5taW4ueSl9LGdldFRvcExlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LGdldEJvdHRvbVJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4fSxnZXRTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKX0sY29udGFpbnM6ZnVuY3Rpb24odCl7dmFyIGksZTtyZXR1cm4odD1cIm51bWJlclwiPT10eXBlb2YgdFswXXx8dCBpbnN0YW5jZW9mIHg/dyh0KTpiKHQpKWluc3RhbmNlb2YgUD8oaT10Lm1pbixlPXQubWF4KTppPWU9dCxpLng+PXRoaXMubWluLngmJmUueDw9dGhpcy5tYXgueCYmaS55Pj10aGlzLm1pbi55JiZlLnk8PXRoaXMubWF4Lnl9LGludGVyc2VjdHM6ZnVuY3Rpb24odCl7dD1iKHQpO3ZhciBpPXRoaXMubWluLGU9dGhpcy5tYXgsbj10Lm1pbixvPXQubWF4LHM9by54Pj1pLngmJm4ueDw9ZS54LHI9by55Pj1pLnkmJm4ueTw9ZS55O3JldHVybiBzJiZyfSxvdmVybGFwczpmdW5jdGlvbih0KXt0PWIodCk7dmFyIGk9dGhpcy5taW4sZT10aGlzLm1heCxuPXQubWluLG89dC5tYXgscz1vLng+aS54JiZuLng8ZS54LHI9by55PmkueSYmbi55PGUueTtyZXR1cm4gcyYmcn0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiEoIXRoaXMubWlufHwhdGhpcy5tYXgpfX0sVC5wcm90b3R5cGU9e2V4dGVuZDpmdW5jdGlvbih0KXt2YXIgaSxlLG49dGhpcy5fc291dGhXZXN0LG89dGhpcy5fbm9ydGhFYXN0O2lmKHQgaW5zdGFuY2VvZiBNKWk9dCxlPXQ7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBUKSlyZXR1cm4gdD90aGlzLmV4dGVuZChDKHQpfHx6KHQpKTp0aGlzO2lmKGk9dC5fc291dGhXZXN0LGU9dC5fbm9ydGhFYXN0LCFpfHwhZSlyZXR1cm4gdGhpc31yZXR1cm4gbnx8bz8obi5sYXQ9TWF0aC5taW4oaS5sYXQsbi5sYXQpLG4ubG5nPU1hdGgubWluKGkubG5nLG4ubG5nKSxvLmxhdD1NYXRoLm1heChlLmxhdCxvLmxhdCksby5sbmc9TWF0aC5tYXgoZS5sbmcsby5sbmcpKToodGhpcy5fc291dGhXZXN0PW5ldyBNKGkubGF0LGkubG5nKSx0aGlzLl9ub3J0aEVhc3Q9bmV3IE0oZS5sYXQsZS5sbmcpKSx0aGlzfSxwYWQ6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fc291dGhXZXN0LGU9dGhpcy5fbm9ydGhFYXN0LG49TWF0aC5hYnMoaS5sYXQtZS5sYXQpKnQsbz1NYXRoLmFicyhpLmxuZy1lLmxuZykqdDtyZXR1cm4gbmV3IFQobmV3IE0oaS5sYXQtbixpLmxuZy1vKSxuZXcgTShlLmxhdCtuLGUubG5nK28pKX0sZ2V0Q2VudGVyOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBNKCh0aGlzLl9zb3V0aFdlc3QubGF0K3RoaXMuX25vcnRoRWFzdC5sYXQpLzIsKHRoaXMuX3NvdXRoV2VzdC5sbmcrdGhpcy5fbm9ydGhFYXN0LmxuZykvMil9LGdldFNvdXRoV2VzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3V0aFdlc3R9LGdldE5vcnRoRWFzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3J0aEVhc3R9LGdldE5vcnRoV2VzdDpmdW5jdGlvbigpe3JldHVybiBuZXcgTSh0aGlzLmdldE5vcnRoKCksdGhpcy5nZXRXZXN0KCkpfSxnZXRTb3V0aEVhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE0odGhpcy5nZXRTb3V0aCgpLHRoaXMuZ2V0RWFzdCgpKX0sZ2V0V2VzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nfSxnZXRTb3V0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0fSxnZXRFYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmd9LGdldE5vcnRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXR9LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3Q9XCJudW1iZXJcIj09dHlwZW9mIHRbMF18fHQgaW5zdGFuY2VvZiBNfHxcImxhdFwiaW4gdD9DKHQpOnoodCk7dmFyIGksZSxuPXRoaXMuX3NvdXRoV2VzdCxvPXRoaXMuX25vcnRoRWFzdDtyZXR1cm4gdCBpbnN0YW5jZW9mIFQ/KGk9dC5nZXRTb3V0aFdlc3QoKSxlPXQuZ2V0Tm9ydGhFYXN0KCkpOmk9ZT10LGkubGF0Pj1uLmxhdCYmZS5sYXQ8PW8ubGF0JiZpLmxuZz49bi5sbmcmJmUubG5nPD1vLmxuZ30saW50ZXJzZWN0czpmdW5jdGlvbih0KXt0PXoodCk7dmFyIGk9dGhpcy5fc291dGhXZXN0LGU9dGhpcy5fbm9ydGhFYXN0LG49dC5nZXRTb3V0aFdlc3QoKSxvPXQuZ2V0Tm9ydGhFYXN0KCkscz1vLmxhdD49aS5sYXQmJm4ubGF0PD1lLmxhdCxyPW8ubG5nPj1pLmxuZyYmbi5sbmc8PWUubG5nO3JldHVybiBzJiZyfSxvdmVybGFwczpmdW5jdGlvbih0KXt0PXoodCk7dmFyIGk9dGhpcy5fc291dGhXZXN0LGU9dGhpcy5fbm9ydGhFYXN0LG49dC5nZXRTb3V0aFdlc3QoKSxvPXQuZ2V0Tm9ydGhFYXN0KCkscz1vLmxhdD5pLmxhdCYmbi5sYXQ8ZS5sYXQscj1vLmxuZz5pLmxuZyYmbi5sbmc8ZS5sbmc7cmV0dXJuIHMmJnJ9LHRvQkJveFN0cmluZzpmdW5jdGlvbigpe3JldHVyblt0aGlzLmdldFdlc3QoKSx0aGlzLmdldFNvdXRoKCksdGhpcy5nZXRFYXN0KCksdGhpcy5nZXROb3J0aCgpXS5qb2luKFwiLFwiKX0sZXF1YWxzOmZ1bmN0aW9uKHQsaSl7cmV0dXJuISF0JiYodD16KHQpLHRoaXMuX3NvdXRoV2VzdC5lcXVhbHModC5nZXRTb3V0aFdlc3QoKSxpKSYmdGhpcy5fbm9ydGhFYXN0LmVxdWFscyh0LmdldE5vcnRoRWFzdCgpLGkpKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiEoIXRoaXMuX3NvdXRoV2VzdHx8IXRoaXMuX25vcnRoRWFzdCl9fSxNLnByb3RvdHlwZT17ZXF1YWxzOmZ1bmN0aW9uKHQsaSl7cmV0dXJuISF0JiYodD1DKHQpLE1hdGgubWF4KE1hdGguYWJzKHRoaXMubGF0LXQubGF0KSxNYXRoLmFicyh0aGlzLmxuZy10LmxuZykpPD0odm9pZCAwPT09aT8xZS05OmkpKX0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuXCJMYXRMbmcoXCIrYSh0aGlzLmxhdCx0KStcIiwgXCIrYSh0aGlzLmxuZyx0KStcIilcIn0sZGlzdGFuY2VUbzpmdW5jdGlvbih0KXtyZXR1cm4gcGkuZGlzdGFuY2UodGhpcyxDKHQpKX0sd3JhcDpmdW5jdGlvbigpe3JldHVybiBwaS53cmFwTGF0TG5nKHRoaXMpfSx0b0JvdW5kczpmdW5jdGlvbih0KXt2YXIgaT0xODAqdC80MDA3NTAxNyxlPWkvTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYXQpO3JldHVybiB6KFt0aGlzLmxhdC1pLHRoaXMubG5nLWVdLFt0aGlzLmxhdCtpLHRoaXMubG5nK2VdKX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE0odGhpcy5sYXQsdGhpcy5sbmcsdGhpcy5hbHQpfX07dmFyIGRpPXtsYXRMbmdUb1BvaW50OmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uLnByb2plY3QodCksbj10aGlzLnNjYWxlKGkpO3JldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0oZSxuKX0scG9pbnRUb0xhdExuZzpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuc2NhbGUoaSksbj10aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHQsZSk7cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3Qobil9LHByb2plY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KHQpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodCl9LHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiAyNTYqTWF0aC5wb3coMix0KX0sem9vbTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5sb2codC8yNTYpL01hdGguTE4yfSxnZXRQcm9qZWN0ZWRCb3VuZHM6ZnVuY3Rpb24odCl7aWYodGhpcy5pbmZpbml0ZSlyZXR1cm4gbnVsbDt2YXIgaT10aGlzLnByb2plY3Rpb24uYm91bmRzLGU9dGhpcy5zY2FsZSh0KTtyZXR1cm4gbmV3IFAodGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oaS5taW4sZSksdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oaS5tYXgsZSkpfSxpbmZpbml0ZTohMSx3cmFwTGF0TG5nOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMud3JhcExuZz9zKHQubG5nLHRoaXMud3JhcExuZywhMCk6dC5sbmc7cmV0dXJuIG5ldyBNKHRoaXMud3JhcExhdD9zKHQubGF0LHRoaXMud3JhcExhdCwhMCk6dC5sYXQsaSx0LmFsdCl9LHdyYXBMYXRMbmdCb3VuZHM6ZnVuY3Rpb24odCl7dmFyIGk9dC5nZXRDZW50ZXIoKSxlPXRoaXMud3JhcExhdExuZyhpKSxuPWkubGF0LWUubGF0LG89aS5sbmctZS5sbmc7aWYoMD09PW4mJjA9PT1vKXJldHVybiB0O3ZhciBzPXQuZ2V0U291dGhXZXN0KCkscj10LmdldE5vcnRoRWFzdCgpO3JldHVybiBuZXcgVChuZXcgTShzLmxhdC1uLHMubG5nLW8pLG5ldyBNKHIubGF0LW4sci5sbmctbykpfX0scGk9aSh7fSxkaSx7d3JhcExuZzpbLTE4MCwxODBdLFI6NjM3MWUzLGRpc3RhbmNlOmZ1bmN0aW9uKHQsaSl7dmFyIGU9TWF0aC5QSS8xODAsbj10LmxhdCplLG89aS5sYXQqZSxzPU1hdGguc2luKChpLmxhdC10LmxhdCkqZS8yKSxyPU1hdGguc2luKChpLmxuZy10LmxuZykqZS8yKSxhPXMqcytNYXRoLmNvcyhuKSpNYXRoLmNvcyhvKSpyKnIsaD0yKk1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLE1hdGguc3FydCgxLWEpKTtyZXR1cm4gdGhpcy5SKmh9fSksbWk9e1I6NjM3ODEzNyxNQVhfTEFUSVRVREU6ODUuMDUxMTI4Nzc5OCxwcm9qZWN0OmZ1bmN0aW9uKHQpe3ZhciBpPU1hdGguUEkvMTgwLGU9dGhpcy5NQVhfTEFUSVRVREUsbj1NYXRoLm1heChNYXRoLm1pbihlLHQubGF0KSwtZSksbz1NYXRoLnNpbihuKmkpO3JldHVybiBuZXcgeCh0aGlzLlIqdC5sbmcqaSx0aGlzLlIqTWF0aC5sb2coKDErbykvKDEtbykpLzIpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCl7dmFyIGk9MTgwL01hdGguUEk7cmV0dXJuIG5ldyBNKCgyKk1hdGguYXRhbihNYXRoLmV4cCh0LnkvdGhpcy5SKSktTWF0aC5QSS8yKSppLHQueCppL3RoaXMuUil9LGJvdW5kczpmdW5jdGlvbigpe3ZhciB0PTYzNzgxMzcqTWF0aC5QSTtyZXR1cm4gbmV3IFAoWy10LC10XSxbdCx0XSl9KCl9O1MucHJvdG90eXBlPXt0cmFuc2Zvcm06ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHQuY2xvbmUoKSxpKX0sX3RyYW5zZm9ybTpmdW5jdGlvbih0LGkpe3JldHVybiBpPWl8fDEsdC54PWkqKHRoaXMuX2EqdC54K3RoaXMuX2IpLHQueT1pKih0aGlzLl9jKnQueSt0aGlzLl9kKSx0fSx1bnRyYW5zZm9ybTpmdW5jdGlvbih0LGkpe3JldHVybiBpPWl8fDEsbmV3IHgoKHQueC9pLXRoaXMuX2IpL3RoaXMuX2EsKHQueS9pLXRoaXMuX2QpL3RoaXMuX2MpfX07dmFyIGZpLGdpLHZpLHlpPWkoe30scGkse2NvZGU6XCJFUFNHOjM4NTdcIixwcm9qZWN0aW9uOm1pLHRyYW5zZm9ybWF0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9LjUvKE1hdGguUEkqbWkuUik7cmV0dXJuIFoodCwuNSwtdCwuNSl9KCl9KSx4aT1pKHt9LHlpLHtjb2RlOlwiRVBTRzo5MDA5MTNcIn0pLHdpPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxQaT1cIkFjdGl2ZVhPYmplY3RcImluIHdpbmRvdyxMaT1QaSYmIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIsYmk9XCJtc0xhdW5jaFVyaVwiaW4gbmF2aWdhdG9yJiYhKFwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCksVGk9QihcIndlYmtpdFwiKSx6aT1CKFwiYW5kcm9pZFwiKSxNaT1CKFwiYW5kcm9pZCAyXCIpfHxCKFwiYW5kcm9pZCAzXCIpLENpPXBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLDEwKSxTaT16aSYmQihcIkdvb2dsZVwiKSYmQ2k8NTM3JiYhKFwiQXVkaW9Ob2RlXCJpbiB3aW5kb3cpLFppPSEhd2luZG93Lm9wZXJhLEVpPUIoXCJjaHJvbWVcIiksa2k9QihcImdlY2tvXCIpJiYhVGkmJiFaaSYmIVBpLEJpPSFFaSYmQihcInNhZmFyaVwiKSxBaT1CKFwicGhhbnRvbVwiKSxJaT1cIk9UcmFuc2l0aW9uXCJpbiB3aSxPaT0wPT09bmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoXCJXaW5cIiksUmk9UGkmJlwidHJhbnNpdGlvblwiaW4gd2ksTmk9XCJXZWJLaXRDU1NNYXRyaXhcImluIHdpbmRvdyYmXCJtMTFcImluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4JiYhTWksRGk9XCJNb3pQZXJzcGVjdGl2ZVwiaW4gd2ksamk9IXdpbmRvdy5MX0RJU0FCTEVfM0QmJihSaXx8Tml8fERpKSYmIUlpJiYhQWksV2k9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9yaWVudGF0aW9ufHxCKFwibW9iaWxlXCIpLEhpPVdpJiZUaSxGaT1XaSYmTmksVWk9IXdpbmRvdy5Qb2ludGVyRXZlbnQmJndpbmRvdy5NU1BvaW50ZXJFdmVudCxWaT0hKCF3aW5kb3cuUG9pbnRlckV2ZW50JiYhVWkpLHFpPSF3aW5kb3cuTF9OT19UT1VDSCYmKFZpfHxcIm9udG91Y2hzdGFydFwiaW4gd2luZG93fHx3aW5kb3cuRG9jdW1lbnRUb3VjaCYmZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksR2k9V2kmJlppLEtpPVdpJiZraSxZaT0od2luZG93LmRldmljZVBpeGVsUmF0aW98fHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSS93aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKT4xLFhpPSEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0LEppPSEoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROU3x8IUUoXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCksJGk9IUppJiZmdW5jdGlvbigpe3RyeXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3QuaW5uZXJIVE1MPSc8djpzaGFwZSBhZGo9XCIxXCIvPic7dmFyIGk9dC5maXJzdENoaWxkO3JldHVybiBpLnN0eWxlLmJlaGF2aW9yPVwidXJsKCNkZWZhdWx0I1ZNTClcIixpJiZcIm9iamVjdFwiPT10eXBlb2YgaS5hZGp9Y2F0Y2godCl7cmV0dXJuITF9fSgpLFFpPShPYmplY3QuZnJlZXplfHxPYmplY3QpKHtpZTpQaSxpZWx0OTpMaSxlZGdlOmJpLHdlYmtpdDpUaSxhbmRyb2lkOnppLGFuZHJvaWQyMzpNaSxhbmRyb2lkU3RvY2s6U2ksb3BlcmE6WmksY2hyb21lOkVpLGdlY2tvOmtpLHNhZmFyaTpCaSxwaGFudG9tOkFpLG9wZXJhMTI6SWksd2luOk9pLGllM2Q6Umksd2Via2l0M2Q6TmksZ2Vja28zZDpEaSxhbnkzZDpqaSxtb2JpbGU6V2ksbW9iaWxlV2Via2l0OkhpLG1vYmlsZVdlYmtpdDNkOkZpLG1zUG9pbnRlcjpVaSxwb2ludGVyOlZpLHRvdWNoOnFpLG1vYmlsZU9wZXJhOkdpLG1vYmlsZUdlY2tvOktpLHJldGluYTpZaSxjYW52YXM6WGksc3ZnOkppLHZtbDokaX0pLHRlPVVpP1wiTVNQb2ludGVyRG93blwiOlwicG9pbnRlcmRvd25cIixpZT1VaT9cIk1TUG9pbnRlck1vdmVcIjpcInBvaW50ZXJtb3ZlXCIsZWU9VWk/XCJNU1BvaW50ZXJVcFwiOlwicG9pbnRlcnVwXCIsbmU9VWk/XCJNU1BvaW50ZXJDYW5jZWxcIjpcInBvaW50ZXJjYW5jZWxcIixvZT1bXCJJTlBVVFwiLFwiU0VMRUNUXCIsXCJPUFRJT05cIl0sc2U9e30scmU9ITEsYWU9MCxoZT1VaT9cIk1TUG9pbnRlckRvd25cIjpWaT9cInBvaW50ZXJkb3duXCI6XCJ0b3VjaHN0YXJ0XCIsdWU9VWk/XCJNU1BvaW50ZXJVcFwiOlZpP1wicG9pbnRlcnVwXCI6XCJ0b3VjaGVuZFwiLGxlPVwiX2xlYWZsZXRfXCIsY2U9c3QoW1widHJhbnNmb3JtXCIsXCJ3ZWJraXRUcmFuc2Zvcm1cIixcIk9UcmFuc2Zvcm1cIixcIk1velRyYW5zZm9ybVwiLFwibXNUcmFuc2Zvcm1cIl0pLF9lPXN0KFtcIndlYmtpdFRyYW5zaXRpb25cIixcInRyYW5zaXRpb25cIixcIk9UcmFuc2l0aW9uXCIsXCJNb3pUcmFuc2l0aW9uXCIsXCJtc1RyYW5zaXRpb25cIl0pLGRlPVwid2Via2l0VHJhbnNpdGlvblwiPT09X2V8fFwiT1RyYW5zaXRpb25cIj09PV9lP19lK1wiRW5kXCI6XCJ0cmFuc2l0aW9uZW5kXCI7aWYoXCJvbnNlbGVjdHN0YXJ0XCJpbiBkb2N1bWVudClmaT1mdW5jdGlvbigpe210KHdpbmRvdyxcInNlbGVjdHN0YXJ0XCIsUHQpfSxnaT1mdW5jdGlvbigpe2Z0KHdpbmRvdyxcInNlbGVjdHN0YXJ0XCIsUHQpfTtlbHNle3ZhciBwZT1zdChbXCJ1c2VyU2VsZWN0XCIsXCJXZWJraXRVc2VyU2VsZWN0XCIsXCJPVXNlclNlbGVjdFwiLFwiTW96VXNlclNlbGVjdFwiLFwibXNVc2VyU2VsZWN0XCJdKTtmaT1mdW5jdGlvbigpe2lmKHBlKXt2YXIgdD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7dmk9dFtwZV0sdFtwZV09XCJub25lXCJ9fSxnaT1mdW5jdGlvbigpe3BlJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3BlXT12aSx2aT12b2lkIDApfX12YXIgbWUsZmUsZ2UsdmU9KE9iamVjdC5mcmVlemV8fE9iamVjdCkoe1RSQU5TRk9STTpjZSxUUkFOU0lUSU9OOl9lLFRSQU5TSVRJT05fRU5EOmRlLGdldDpWLGdldFN0eWxlOnEsY3JlYXRlOkcscmVtb3ZlOkssZW1wdHk6WSx0b0Zyb250OlgsdG9CYWNrOkosaGFzQ2xhc3M6JCxhZGRDbGFzczpRLHJlbW92ZUNsYXNzOnR0LHNldENsYXNzOml0LGdldENsYXNzOmV0LHNldE9wYWNpdHk6bnQsdGVzdFByb3A6c3Qsc2V0VHJhbnNmb3JtOnJ0LHNldFBvc2l0aW9uOmF0LGdldFBvc2l0aW9uOmh0LGRpc2FibGVUZXh0U2VsZWN0aW9uOmZpLGVuYWJsZVRleHRTZWxlY3Rpb246Z2ksZGlzYWJsZUltYWdlRHJhZzp1dCxlbmFibGVJbWFnZURyYWc6bHQscHJldmVudE91dGxpbmU6Y3QscmVzdG9yZU91dGxpbmU6X3QsZ2V0U2l6ZWRQYXJlbnROb2RlOmR0LGdldFNjYWxlOnB0fSkseWU9XCJfbGVhZmxldF9ldmVudHNcIix4ZT1PaSYmRWk/Mip3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzpraT93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzoxLHdlPXt9LFBlPShPYmplY3QuZnJlZXplfHxPYmplY3QpKHtvbjptdCxvZmY6ZnQsc3RvcFByb3BhZ2F0aW9uOnl0LGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjp4dCxkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjp3dCxwcmV2ZW50RGVmYXVsdDpQdCxzdG9wOkx0LGdldE1vdXNlUG9zaXRpb246YnQsZ2V0V2hlZWxEZWx0YTpUdCxmYWtlU3RvcDp6dCxza2lwcGVkOk10LGlzRXh0ZXJuYWxUYXJnZXQ6Q3QsYWRkTGlzdGVuZXI6bXQscmVtb3ZlTGlzdGVuZXI6ZnR9KSxMZT1jaS5leHRlbmQoe3J1bjpmdW5jdGlvbih0LGksZSxuKXt0aGlzLnN0b3AoKSx0aGlzLl9lbD10LHRoaXMuX2luUHJvZ3Jlc3M9ITAsdGhpcy5fZHVyYXRpb249ZXx8LjI1LHRoaXMuX2Vhc2VPdXRQb3dlcj0xL01hdGgubWF4KG58fC41LC4yKSx0aGlzLl9zdGFydFBvcz1odCh0KSx0aGlzLl9vZmZzZXQ9aS5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyksdGhpcy5fc3RhcnRUaW1lPStuZXcgRGF0ZSx0aGlzLmZpcmUoXCJzdGFydFwiKSx0aGlzLl9hbmltYXRlKCl9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLl9pblByb2dyZXNzJiYodGhpcy5fc3RlcCghMCksdGhpcy5fY29tcGxldGUoKSl9LF9hbmltYXRlOmZ1bmN0aW9uKCl7dGhpcy5fYW5pbUlkPWYodGhpcy5fYW5pbWF0ZSx0aGlzKSx0aGlzLl9zdGVwKCl9LF9zdGVwOmZ1bmN0aW9uKHQpe3ZhciBpPStuZXcgRGF0ZS10aGlzLl9zdGFydFRpbWUsZT0xZTMqdGhpcy5fZHVyYXRpb247aTxlP3RoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoaS9lKSx0KToodGhpcy5fcnVuRnJhbWUoMSksdGhpcy5fY29tcGxldGUoKSl9LF9ydW5GcmFtZTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeSh0KSk7aSYmZS5fcm91bmQoKSxhdCh0aGlzLl9lbCxlKSx0aGlzLmZpcmUoXCJzdGVwXCIpfSxfY29tcGxldGU6ZnVuY3Rpb24oKXtnKHRoaXMuX2FuaW1JZCksdGhpcy5faW5Qcm9ncmVzcz0hMSx0aGlzLmZpcmUoXCJlbmRcIil9LF9lYXNlT3V0OmZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGgucG93KDEtdCx0aGlzLl9lYXNlT3V0UG93ZXIpfX0pLGJlPWNpLmV4dGVuZCh7b3B0aW9uczp7Y3JzOnlpLGNlbnRlcjp2b2lkIDAsem9vbTp2b2lkIDAsbWluWm9vbTp2b2lkIDAsbWF4Wm9vbTp2b2lkIDAsbGF5ZXJzOltdLG1heEJvdW5kczp2b2lkIDAscmVuZGVyZXI6dm9pZCAwLHpvb21BbmltYXRpb246ITAsem9vbUFuaW1hdGlvblRocmVzaG9sZDo0LGZhZGVBbmltYXRpb246ITAsbWFya2VyWm9vbUFuaW1hdGlvbjohMCx0cmFuc2Zvcm0zRExpbWl0OjgzODg2MDgsem9vbVNuYXA6MSx6b29tRGVsdGE6MSx0cmFja1Jlc2l6ZTohMH0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe2k9bCh0aGlzLGkpLHRoaXMuX2hhbmRsZXJzPVtdLHRoaXMuX2xheWVycz17fSx0aGlzLl96b29tQm91bmRMYXllcnM9e30sdGhpcy5fc2l6ZUNoYW5nZWQ9ITAsdGhpcy5faW5pdENvbnRhaW5lcih0KSx0aGlzLl9pbml0TGF5b3V0KCksdGhpcy5fb25SZXNpemU9ZSh0aGlzLl9vblJlc2l6ZSx0aGlzKSx0aGlzLl9pbml0RXZlbnRzKCksaS5tYXhCb3VuZHMmJnRoaXMuc2V0TWF4Qm91bmRzKGkubWF4Qm91bmRzKSx2b2lkIDAhPT1pLnpvb20mJih0aGlzLl96b29tPXRoaXMuX2xpbWl0Wm9vbShpLnpvb20pKSxpLmNlbnRlciYmdm9pZCAwIT09aS56b29tJiZ0aGlzLnNldFZpZXcoQyhpLmNlbnRlciksaS56b29tLHtyZXNldDohMH0pLHRoaXMuY2FsbEluaXRIb29rcygpLHRoaXMuX3pvb21BbmltYXRlZD1fZSYmamkmJiFHaSYmdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24sdGhpcy5fem9vbUFuaW1hdGVkJiYodGhpcy5fY3JlYXRlQW5pbVByb3h5KCksbXQodGhpcy5fcHJveHksZGUsdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLHRoaXMpKSx0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyl9LHNldFZpZXc6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBlPXZvaWQgMD09PWU/dGhpcy5fem9vbTp0aGlzLl9saW1pdFpvb20oZSksdD10aGlzLl9saW1pdENlbnRlcihDKHQpLGUsdGhpcy5vcHRpb25zLm1heEJvdW5kcyksbj1ufHx7fSx0aGlzLl9zdG9wKCksdGhpcy5fbG9hZGVkJiYhbi5yZXNldCYmITAhPT1uJiYodm9pZCAwIT09bi5hbmltYXRlJiYobi56b29tPWkoe2FuaW1hdGU6bi5hbmltYXRlfSxuLnpvb20pLG4ucGFuPWkoe2FuaW1hdGU6bi5hbmltYXRlLGR1cmF0aW9uOm4uZHVyYXRpb259LG4ucGFuKSksdGhpcy5fem9vbSE9PWU/dGhpcy5fdHJ5QW5pbWF0ZWRab29tJiZ0aGlzLl90cnlBbmltYXRlZFpvb20odCxlLG4uem9vbSk6dGhpcy5fdHJ5QW5pbWF0ZWRQYW4odCxuLnBhbikpPyhjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKSx0aGlzKToodGhpcy5fcmVzZXRWaWV3KHQsZSksdGhpcyl9LHNldFpvb206ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fbG9hZGVkP3RoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLHQse3pvb206aX0pOih0aGlzLl96b29tPXQsdGhpcyl9LHpvb21JbjpmdW5jdGlvbih0LGkpe3JldHVybiB0PXR8fChqaT90aGlzLm9wdGlvbnMuem9vbURlbHRhOjEpLHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tK3QsaSl9LHpvb21PdXQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdD10fHwoamk/dGhpcy5vcHRpb25zLnpvb21EZWx0YToxKSx0aGlzLnNldFpvb20odGhpcy5fem9vbS10LGkpfSxzZXRab29tQXJvdW5kOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbj10aGlzLmdldFpvb21TY2FsZShpKSxvPXRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLHM9KHQgaW5zdGFuY2VvZiB4P3Q6dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHQpKS5zdWJ0cmFjdChvKS5tdWx0aXBseUJ5KDEtMS9uKSxyPXRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyhvLmFkZChzKSk7cmV0dXJuIHRoaXMuc2V0VmlldyhyLGkse3pvb206ZX0pfSxfZ2V0Qm91bmRzQ2VudGVyWm9vbTpmdW5jdGlvbih0LGkpe2k9aXx8e30sdD10LmdldEJvdW5kcz90LmdldEJvdW5kcygpOnoodCk7dmFyIGU9dyhpLnBhZGRpbmdUb3BMZWZ0fHxpLnBhZGRpbmd8fFswLDBdKSxuPXcoaS5wYWRkaW5nQm90dG9tUmlnaHR8fGkucGFkZGluZ3x8WzAsMF0pLG89dGhpcy5nZXRCb3VuZHNab29tKHQsITEsZS5hZGQobikpO2lmKChvPVwibnVtYmVyXCI9PXR5cGVvZiBpLm1heFpvb20/TWF0aC5taW4oaS5tYXhab29tLG8pOm8pPT09MS8wKXJldHVybntjZW50ZXI6dC5nZXRDZW50ZXIoKSx6b29tOm99O3ZhciBzPW4uc3VidHJhY3QoZSkuZGl2aWRlQnkoMikscj10aGlzLnByb2plY3QodC5nZXRTb3V0aFdlc3QoKSxvKSxhPXRoaXMucHJvamVjdCh0LmdldE5vcnRoRWFzdCgpLG8pO3JldHVybntjZW50ZXI6dGhpcy51bnByb2plY3Qoci5hZGQoYSkuZGl2aWRlQnkoMikuYWRkKHMpLG8pLHpvb206b319LGZpdEJvdW5kczpmdW5jdGlvbih0LGkpe2lmKCEodD16KHQpKS5pc1ZhbGlkKCkpdGhyb3cgbmV3IEVycm9yKFwiQm91bmRzIGFyZSBub3QgdmFsaWQuXCIpO3ZhciBlPXRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20odCxpKTtyZXR1cm4gdGhpcy5zZXRWaWV3KGUuY2VudGVyLGUuem9vbSxpKX0sZml0V29ybGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLC0xODBdLFs5MCwxODBdXSx0KX0scGFuVG86ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5zZXRWaWV3KHQsdGhpcy5fem9vbSx7cGFuOml9KX0scGFuQnk6ZnVuY3Rpb24odCxpKXtpZih0PXcodCkucm91bmQoKSxpPWl8fHt9LCF0LngmJiF0LnkpcmV0dXJuIHRoaXMuZmlyZShcIm1vdmVlbmRcIik7aWYoITAhPT1pLmFuaW1hdGUmJiF0aGlzLmdldFNpemUoKS5jb250YWlucyh0KSlyZXR1cm4gdGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQodCkpLHRoaXMuZ2V0Wm9vbSgpKSx0aGlzO2lmKHRoaXMuX3BhbkFuaW18fCh0aGlzLl9wYW5BbmltPW5ldyBMZSx0aGlzLl9wYW5BbmltLm9uKHtzdGVwOnRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsZW5kOnRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZH0sdGhpcykpLGkubm9Nb3ZlU3RhcnR8fHRoaXMuZmlyZShcIm1vdmVzdGFydFwiKSwhMSE9PWkuYW5pbWF0ZSl7USh0aGlzLl9tYXBQYW5lLFwibGVhZmxldC1wYW4tYW5pbVwiKTt2YXIgZT10aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3QodCkucm91bmQoKTt0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLGUsaS5kdXJhdGlvbnx8LjI1LGkuZWFzZUxpbmVhcml0eSl9ZWxzZSB0aGlzLl9yYXdQYW5CeSh0KSx0aGlzLmZpcmUoXCJtb3ZlXCIpLmZpcmUoXCJtb3ZlZW5kXCIpO3JldHVybiB0aGlzfSxmbHlUbzpmdW5jdGlvbih0LGksZSl7ZnVuY3Rpb24gbih0KXt2YXIgaT0oZypnLW0qbSsodD8tMToxKSp4Kngqdip2KS8oMioodD9nOm0pKngqdiksZT1NYXRoLnNxcnQoaSppKzEpLWk7cmV0dXJuIGU8MWUtOT8tMTg6TWF0aC5sb2coZSl9ZnVuY3Rpb24gbyh0KXtyZXR1cm4oTWF0aC5leHAodCktTWF0aC5leHAoLXQpKS8yfWZ1bmN0aW9uIHModCl7cmV0dXJuKE1hdGguZXhwKHQpK01hdGguZXhwKC10KSkvMn1mdW5jdGlvbiByKHQpe3JldHVybiBvKHQpL3ModCl9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gbSoocyh3KS9zKHcreSp0KSl9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gbSoocyh3KSpyKHcreSp0KS1vKHcpKS94fWZ1bmN0aW9uIHUodCl7cmV0dXJuIDEtTWF0aC5wb3coMS10LDEuNSl9ZnVuY3Rpb24gbCgpe3ZhciBlPShEYXRlLm5vdygpLVApL2Isbj11KGUpKkw7ZTw9MT8odGhpcy5fZmx5VG9GcmFtZT1mKGwsdGhpcyksdGhpcy5fbW92ZSh0aGlzLnVucHJvamVjdChjLmFkZChfLnN1YnRyYWN0KGMpLm11bHRpcGx5QnkoaChuKS92KSkscCksdGhpcy5nZXRTY2FsZVpvb20obS9hKG4pLHApLHtmbHlUbzohMH0pKTp0aGlzLl9tb3ZlKHQsaSkuX21vdmVFbmQoITApfWlmKCExPT09KGU9ZXx8e30pLmFuaW1hdGV8fCFqaSlyZXR1cm4gdGhpcy5zZXRWaWV3KHQsaSxlKTt0aGlzLl9zdG9wKCk7dmFyIGM9dGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLF89dGhpcy5wcm9qZWN0KHQpLGQ9dGhpcy5nZXRTaXplKCkscD10aGlzLl96b29tO3Q9Qyh0KSxpPXZvaWQgMD09PWk/cDppO3ZhciBtPU1hdGgubWF4KGQueCxkLnkpLGc9bSp0aGlzLmdldFpvb21TY2FsZShwLGkpLHY9Xy5kaXN0YW5jZVRvKGMpfHwxLHk9MS40Mix4PXkqeSx3PW4oMCksUD1EYXRlLm5vdygpLEw9KG4oMSktdykveSxiPWUuZHVyYXRpb24/MWUzKmUuZHVyYXRpb246MWUzKkwqLjg7cmV0dXJuIHRoaXMuX21vdmVTdGFydCghMCxlLm5vTW92ZVN0YXJ0KSxsLmNhbGwodGhpcyksdGhpc30sZmx5VG9Cb3VuZHM6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKHQsaSk7cmV0dXJuIHRoaXMuZmx5VG8oZS5jZW50ZXIsZS56b29tLGkpfSxzZXRNYXhCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9eih0KSkuaXNWYWxpZCgpPyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzJiZ0aGlzLm9mZihcIm1vdmVlbmRcIix0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpLHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9dCx0aGlzLl9sb2FkZWQmJnRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpLHRoaXMub24oXCJtb3ZlZW5kXCIsdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSk6KHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9bnVsbCx0aGlzLm9mZihcIm1vdmVlbmRcIix0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpKX0sc2V0TWluWm9vbTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLm9wdGlvbnMubWluWm9vbTtyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb209dCx0aGlzLl9sb2FkZWQmJmkhPT10JiYodGhpcy5maXJlKFwiem9vbWxldmVsc2NoYW5nZVwiKSx0aGlzLmdldFpvb20oKTx0aGlzLm9wdGlvbnMubWluWm9vbSk/dGhpcy5zZXRab29tKHQpOnRoaXN9LHNldE1heFpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5vcHRpb25zLm1heFpvb207cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tPXQsdGhpcy5fbG9hZGVkJiZpIT09dCYmKHRoaXMuZmlyZShcInpvb21sZXZlbHNjaGFuZ2VcIiksdGhpcy5nZXRab29tKCk+dGhpcy5vcHRpb25zLm1heFpvb20pP3RoaXMuc2V0Wm9vbSh0KTp0aGlzfSxwYW5JbnNpZGVCb3VuZHM6ZnVuY3Rpb24odCxpKXt0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITA7dmFyIGU9dGhpcy5nZXRDZW50ZXIoKSxuPXRoaXMuX2xpbWl0Q2VudGVyKGUsdGhpcy5fem9vbSx6KHQpKTtyZXR1cm4gZS5lcXVhbHMobil8fHRoaXMucGFuVG8obixpKSx0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITEsdGhpc30scGFuSW5zaWRlOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dygoaT1pfHx7fSkucGFkZGluZ1RvcExlZnR8fGkucGFkZGluZ3x8WzAsMF0pLG49dyhpLnBhZGRpbmdCb3R0b21SaWdodHx8aS5wYWRkaW5nfHxbMCwwXSksbz10aGlzLmdldENlbnRlcigpLHM9dGhpcy5wcm9qZWN0KG8pLHI9dGhpcy5wcm9qZWN0KHQpLGE9dGhpcy5nZXRQaXhlbEJvdW5kcygpLGg9YS5nZXRTaXplKCkuZGl2aWRlQnkoMiksdT1iKFthLm1pbi5hZGQoZSksYS5tYXguc3VidHJhY3QobildKTtpZighdS5jb250YWlucyhyKSl7dGhpcy5fZW5mb3JjaW5nQm91bmRzPSEwO3ZhciBsPXMuc3VidHJhY3QociksYz13KHIueCtsLngsci55K2wueSk7KHIueDx1Lm1pbi54fHxyLng+dS5tYXgueCkmJihjLng9cy54LWwueCxsLng+MD9jLngrPWgueC1lLng6Yy54LT1oLngtbi54KSwoci55PHUubWluLnl8fHIueT51Lm1heC55KSYmKGMueT1zLnktbC55LGwueT4wP2MueSs9aC55LWUueTpjLnktPWgueS1uLnkpLHRoaXMucGFuVG8odGhpcy51bnByb2plY3QoYyksaSksdGhpcy5fZW5mb3JjaW5nQm91bmRzPSExfXJldHVybiB0aGlzfSxpbnZhbGlkYXRlU2l6ZTpmdW5jdGlvbih0KXtpZighdGhpcy5fbG9hZGVkKXJldHVybiB0aGlzO3Q9aSh7YW5pbWF0ZTohMSxwYW46ITB9LCEwPT09dD97YW5pbWF0ZTohMH06dCk7dmFyIG49dGhpcy5nZXRTaXplKCk7dGhpcy5fc2l6ZUNoYW5nZWQ9ITAsdGhpcy5fbGFzdENlbnRlcj1udWxsO3ZhciBvPXRoaXMuZ2V0U2l6ZSgpLHM9bi5kaXZpZGVCeSgyKS5yb3VuZCgpLHI9by5kaXZpZGVCeSgyKS5yb3VuZCgpLGE9cy5zdWJ0cmFjdChyKTtyZXR1cm4gYS54fHxhLnk/KHQuYW5pbWF0ZSYmdC5wYW4/dGhpcy5wYW5CeShhKToodC5wYW4mJnRoaXMuX3Jhd1BhbkJ5KGEpLHRoaXMuZmlyZShcIm1vdmVcIiksdC5kZWJvdW5jZU1vdmVlbmQ/KGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpLHRoaXMuX3NpemVUaW1lcj1zZXRUaW1lb3V0KGUodGhpcy5maXJlLHRoaXMsXCJtb3ZlZW5kXCIpLDIwMCkpOnRoaXMuZmlyZShcIm1vdmVlbmRcIikpLHRoaXMuZmlyZShcInJlc2l6ZVwiLHtvbGRTaXplOm4sbmV3U2l6ZTpvfSkpOnRoaXN9LHN0b3A6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSksdGhpcy5vcHRpb25zLnpvb21TbmFwfHx0aGlzLmZpcmUoXCJ2aWV3cmVzZXRcIiksdGhpcy5fc3RvcCgpfSxsb2NhdGU6ZnVuY3Rpb24odCl7aWYodD10aGlzLl9sb2NhdGVPcHRpb25zPWkoe3RpbWVvdXQ6MWU0LHdhdGNoOiExfSx0KSwhKFwiZ2VvbG9jYXRpb25cImluIG5hdmlnYXRvcikpcmV0dXJuIHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe2NvZGU6MCxtZXNzYWdlOlwiR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC5cIn0pLHRoaXM7dmFyIG49ZSh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLHRoaXMpLG89ZSh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLHRoaXMpO3JldHVybiB0LndhdGNoP3RoaXMuX2xvY2F0aW9uV2F0Y2hJZD1uYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihuLG8sdCk6bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihuLG8sdCksdGhpc30sc3RvcExvY2F0ZTpmdW5jdGlvbigpe3JldHVybiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24mJm5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoJiZuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpLHRoaXMuX2xvY2F0ZU9wdGlvbnMmJih0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXc9ITEpLHRoaXN9LF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOmZ1bmN0aW9uKHQpe3ZhciBpPXQuY29kZSxlPXQubWVzc2FnZXx8KDE9PT1pP1wicGVybWlzc2lvbiBkZW5pZWRcIjoyPT09aT9cInBvc2l0aW9uIHVuYXZhaWxhYmxlXCI6XCJ0aW1lb3V0XCIpO3RoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyYmIXRoaXMuX2xvYWRlZCYmdGhpcy5maXRXb3JsZCgpLHRoaXMuZmlyZShcImxvY2F0aW9uZXJyb3JcIix7Y29kZTppLG1lc3NhZ2U6XCJHZW9sb2NhdGlvbiBlcnJvcjogXCIrZStcIi5cIn0pfSxfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTpmdW5jdGlvbih0KXt2YXIgaT1uZXcgTSh0LmNvb3Jkcy5sYXRpdHVkZSx0LmNvb3Jkcy5sb25naXR1ZGUpLGU9aS50b0JvdW5kcygyKnQuY29vcmRzLmFjY3VyYWN5KSxuPXRoaXMuX2xvY2F0ZU9wdGlvbnM7aWYobi5zZXRWaWV3KXt2YXIgbz10aGlzLmdldEJvdW5kc1pvb20oZSk7dGhpcy5zZXRWaWV3KGksbi5tYXhab29tP01hdGgubWluKG8sbi5tYXhab29tKTpvKX12YXIgcz17bGF0bG5nOmksYm91bmRzOmUsdGltZXN0YW1wOnQudGltZXN0YW1wfTtmb3IodmFyIHIgaW4gdC5jb29yZHMpXCJudW1iZXJcIj09dHlwZW9mIHQuY29vcmRzW3JdJiYoc1tyXT10LmNvb3Jkc1tyXSk7dGhpcy5maXJlKFwibG9jYXRpb25mb3VuZFwiLHMpfSxhZGRIYW5kbGVyOmZ1bmN0aW9uKHQsaSl7aWYoIWkpcmV0dXJuIHRoaXM7dmFyIGU9dGhpc1t0XT1uZXcgaSh0aGlzKTtyZXR1cm4gdGhpcy5faGFuZGxlcnMucHVzaChlKSx0aGlzLm9wdGlvbnNbdF0mJmUuZW5hYmxlKCksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7aWYodGhpcy5faW5pdEV2ZW50cyghMCksdGhpcy5fY29udGFpbmVySWQhPT10aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpdGhyb3cgbmV3IEVycm9yKFwiTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZVwiKTt0cnl7ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCxkZWxldGUgdGhpcy5fY29udGFpbmVySWR9Y2F0Y2godCl7dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkPXZvaWQgMCx0aGlzLl9jb250YWluZXJJZD12b2lkIDB9dm9pZCAwIT09dGhpcy5fbG9jYXRpb25XYXRjaElkJiZ0aGlzLnN0b3BMb2NhdGUoKSx0aGlzLl9zdG9wKCksSyh0aGlzLl9tYXBQYW5lKSx0aGlzLl9jbGVhckNvbnRyb2xQb3MmJnRoaXMuX2NsZWFyQ29udHJvbFBvcygpLHRoaXMuX3Jlc2l6ZVJlcXVlc3QmJihnKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpLHRoaXMuX3Jlc2l6ZVJlcXVlc3Q9bnVsbCksdGhpcy5fY2xlYXJIYW5kbGVycygpLHRoaXMuX2xvYWRlZCYmdGhpcy5maXJlKFwidW5sb2FkXCIpO3ZhciB0O2Zvcih0IGluIHRoaXMuX2xheWVycyl0aGlzLl9sYXllcnNbdF0ucmVtb3ZlKCk7Zm9yKHQgaW4gdGhpcy5fcGFuZXMpSyh0aGlzLl9wYW5lc1t0XSk7cmV0dXJuIHRoaXMuX2xheWVycz1bXSx0aGlzLl9wYW5lcz1bXSxkZWxldGUgdGhpcy5fbWFwUGFuZSxkZWxldGUgdGhpcy5fcmVuZGVyZXIsdGhpc30sY3JlYXRlUGFuZTpmdW5jdGlvbih0LGkpe3ZhciBlPUcoXCJkaXZcIixcImxlYWZsZXQtcGFuZVwiKyh0P1wiIGxlYWZsZXQtXCIrdC5yZXBsYWNlKFwiUGFuZVwiLFwiXCIpK1wiLXBhbmVcIjpcIlwiKSxpfHx0aGlzLl9tYXBQYW5lKTtyZXR1cm4gdCYmKHRoaXMuX3BhbmVzW3RdPWUpLGV9LGdldENlbnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jaGVja0lmTG9hZGVkKCksdGhpcy5fbGFzdENlbnRlciYmIXRoaXMuX21vdmVkKCk/dGhpcy5fbGFzdENlbnRlcjp0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpfSxnZXRab29tOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3pvb219LGdldEJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0UGl4ZWxCb3VuZHMoKTtyZXR1cm4gbmV3IFQodGhpcy51bnByb2plY3QodC5nZXRCb3R0b21MZWZ0KCkpLHRoaXMudW5wcm9qZWN0KHQuZ2V0VG9wUmlnaHQoKSkpfSxnZXRNaW5ab29tOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMub3B0aW9ucy5taW5ab29tP3RoaXMuX2xheWVyc01pblpvb218fDA6dGhpcy5vcHRpb25zLm1pblpvb219LGdldE1heFpvb206ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5vcHRpb25zLm1heFpvb20/dm9pZCAwPT09dGhpcy5fbGF5ZXJzTWF4Wm9vbT8xLzA6dGhpcy5fbGF5ZXJzTWF4Wm9vbTp0aGlzLm9wdGlvbnMubWF4Wm9vbX0sZ2V0Qm91bmRzWm9vbTpmdW5jdGlvbih0LGksZSl7dD16KHQpLGU9dyhlfHxbMCwwXSk7dmFyIG49dGhpcy5nZXRab29tKCl8fDAsbz10aGlzLmdldE1pblpvb20oKSxzPXRoaXMuZ2V0TWF4Wm9vbSgpLHI9dC5nZXROb3J0aFdlc3QoKSxhPXQuZ2V0U291dGhFYXN0KCksaD10aGlzLmdldFNpemUoKS5zdWJ0cmFjdChlKSx1PWIodGhpcy5wcm9qZWN0KGEsbiksdGhpcy5wcm9qZWN0KHIsbikpLmdldFNpemUoKSxsPWppP3RoaXMub3B0aW9ucy56b29tU25hcDoxLGM9aC54L3UueCxfPWgueS91LnksZD1pP01hdGgubWF4KGMsXyk6TWF0aC5taW4oYyxfKTtyZXR1cm4gbj10aGlzLmdldFNjYWxlWm9vbShkLG4pLGwmJihuPU1hdGgucm91bmQobi8obC8xMDApKSoobC8xMDApLG49aT9NYXRoLmNlaWwobi9sKSpsOk1hdGguZmxvb3Iobi9sKSpsKSxNYXRoLm1heChvLE1hdGgubWluKHMsbikpfSxnZXRTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemUmJiF0aGlzLl9zaXplQ2hhbmdlZHx8KHRoaXMuX3NpemU9bmV3IHgodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRofHwwLHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHR8fDApLHRoaXMuX3NpemVDaGFuZ2VkPSExKSx0aGlzLl9zaXplLmNsb25lKCl9LGdldFBpeGVsQm91bmRzOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5fZ2V0VG9wTGVmdFBvaW50KHQsaSk7cmV0dXJuIG5ldyBQKGUsZS5hZGQodGhpcy5nZXRTaXplKCkpKX0sZ2V0UGl4ZWxPcmlnaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2hlY2tJZkxvYWRlZCgpLHRoaXMuX3BpeGVsT3JpZ2lufSxnZXRQaXhlbFdvcmxkQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh2b2lkIDA9PT10P3RoaXMuZ2V0Wm9vbSgpOnQpfSxnZXRQYW5lOmZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P3RoaXMuX3BhbmVzW3RdOnR9LGdldFBhbmVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhbmVzfSxnZXRDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbmVyfSxnZXRab29tU2NhbGU6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLm9wdGlvbnMuY3JzO3JldHVybiBpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppLGUuc2NhbGUodCkvZS5zY2FsZShpKX0sZ2V0U2NhbGVab29tOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5vcHRpb25zLmNycztpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppO3ZhciBuPWUuem9vbSh0KmUuc2NhbGUoaSkpO3JldHVybiBpc05hTihuKT8xLzA6bn0scHJvamVjdDpmdW5jdGlvbih0LGkpe3JldHVybiBpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppLHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludChDKHQpLGkpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCxpKXtyZXR1cm4gaT12b2lkIDA9PT1pP3RoaXMuX3pvb206aSx0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodyh0KSxpKX0sbGF5ZXJQb2ludFRvTGF0TG5nOmZ1bmN0aW9uKHQpe3ZhciBpPXcodCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7cmV0dXJuIHRoaXMudW5wcm9qZWN0KGkpfSxsYXRMbmdUb0xheWVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdChDKHQpKS5fcm91bmQoKS5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKX0sd3JhcExhdExuZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKEModCkpfSx3cmFwTGF0TG5nQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHMoeih0KSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UoQyh0KSxDKGkpKX0sY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHcodCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKX0sbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHcodCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSl9LGNvbnRhaW5lclBvaW50VG9MYXRMbmc6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh3KHQpKTtyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcoaSl9LGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoQyh0KSkpfSxtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gYnQodCx0aGlzLl9jb250YWluZXIpfSxtb3VzZUV2ZW50VG9MYXllclBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCkpfSxtb3VzZUV2ZW50VG9MYXRMbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0KSl9LF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX2NvbnRhaW5lcj1WKHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIk1hcCBjb250YWluZXIgbm90IGZvdW5kLlwiKTtpZihpLl9sZWFmbGV0X2lkKXRocm93IG5ldyBFcnJvcihcIk1hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7bXQoaSxcInNjcm9sbFwiLHRoaXMuX29uU2Nyb2xsLHRoaXMpLHRoaXMuX2NvbnRhaW5lcklkPW4oaSl9LF9pbml0TGF5b3V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY29udGFpbmVyO3RoaXMuX2ZhZGVBbmltYXRlZD10aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiYmamksUSh0LFwibGVhZmxldC1jb250YWluZXJcIisocWk/XCIgbGVhZmxldC10b3VjaFwiOlwiXCIpKyhZaT9cIiBsZWFmbGV0LXJldGluYVwiOlwiXCIpKyhMaT9cIiBsZWFmbGV0LW9sZGllXCI6XCJcIikrKEJpP1wiIGxlYWZsZXQtc2FmYXJpXCI6XCJcIikrKHRoaXMuX2ZhZGVBbmltYXRlZD9cIiBsZWFmbGV0LWZhZGUtYW5pbVwiOlwiXCIpKTt2YXIgaT1xKHQsXCJwb3NpdGlvblwiKTtcImFic29sdXRlXCIhPT1pJiZcInJlbGF0aXZlXCIhPT1pJiZcImZpeGVkXCIhPT1pJiYodC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLHRoaXMuX2luaXRQYW5lcygpLHRoaXMuX2luaXRDb250cm9sUG9zJiZ0aGlzLl9pbml0Q29udHJvbFBvcygpfSxfaW5pdFBhbmVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcGFuZXM9e307dGhpcy5fcGFuZVJlbmRlcmVycz17fSx0aGlzLl9tYXBQYW5lPXRoaXMuY3JlYXRlUGFuZShcIm1hcFBhbmVcIix0aGlzLl9jb250YWluZXIpLGF0KHRoaXMuX21hcFBhbmUsbmV3IHgoMCwwKSksdGhpcy5jcmVhdGVQYW5lKFwidGlsZVBhbmVcIiksdGhpcy5jcmVhdGVQYW5lKFwic2hhZG93UGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJvdmVybGF5UGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJtYXJrZXJQYW5lXCIpLHRoaXMuY3JlYXRlUGFuZShcInRvb2x0aXBQYW5lXCIpLHRoaXMuY3JlYXRlUGFuZShcInBvcHVwUGFuZVwiKSx0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbnx8KFEodC5tYXJrZXJQYW5lLFwibGVhZmxldC16b29tLWhpZGVcIiksUSh0LnNoYWRvd1BhbmUsXCJsZWFmbGV0LXpvb20taGlkZVwiKSl9LF9yZXNldFZpZXc6ZnVuY3Rpb24odCxpKXthdCh0aGlzLl9tYXBQYW5lLG5ldyB4KDAsMCkpO3ZhciBlPSF0aGlzLl9sb2FkZWQ7dGhpcy5fbG9hZGVkPSEwLGk9dGhpcy5fbGltaXRab29tKGkpLHRoaXMuZmlyZShcInZpZXdwcmVyZXNldFwiKTt2YXIgbj10aGlzLl96b29tIT09aTt0aGlzLl9tb3ZlU3RhcnQobiwhMSkuX21vdmUodCxpKS5fbW92ZUVuZChuKSx0aGlzLmZpcmUoXCJ2aWV3cmVzZXRcIiksZSYmdGhpcy5maXJlKFwibG9hZFwiKX0sX21vdmVTdGFydDpmdW5jdGlvbih0LGkpe3JldHVybiB0JiZ0aGlzLmZpcmUoXCJ6b29tc3RhcnRcIiksaXx8dGhpcy5maXJlKFwibW92ZXN0YXJ0XCIpLHRoaXN9LF9tb3ZlOmZ1bmN0aW9uKHQsaSxlKXt2b2lkIDA9PT1pJiYoaT10aGlzLl96b29tKTt2YXIgbj10aGlzLl96b29tIT09aTtyZXR1cm4gdGhpcy5fem9vbT1pLHRoaXMuX2xhc3RDZW50ZXI9dCx0aGlzLl9waXhlbE9yaWdpbj10aGlzLl9nZXROZXdQaXhlbE9yaWdpbih0KSwobnx8ZSYmZS5waW5jaCkmJnRoaXMuZmlyZShcInpvb21cIixlKSx0aGlzLmZpcmUoXCJtb3ZlXCIsZSl9LF9tb3ZlRW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLmZpcmUoXCJ6b29tZW5kXCIpLHRoaXMuZmlyZShcIm1vdmVlbmRcIil9LF9zdG9wOmZ1bmN0aW9uKCl7cmV0dXJuIGcodGhpcy5fZmx5VG9GcmFtZSksdGhpcy5fcGFuQW5pbSYmdGhpcy5fcGFuQW5pbS5zdG9wKCksdGhpc30sX3Jhd1BhbkJ5OmZ1bmN0aW9uKHQpe2F0KHRoaXMuX21hcFBhbmUsdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KHQpKX0sX2dldFpvb21TcGFuOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpLXRoaXMuZ2V0TWluWm9vbSgpfSxfcGFuSW5zaWRlTWF4Qm91bmRzOmZ1bmN0aW9uKCl7dGhpcy5fZW5mb3JjaW5nQm91bmRzfHx0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKX0sX2NoZWNrSWZMb2FkZWQ6ZnVuY3Rpb24oKXtpZighdGhpcy5fbG9hZGVkKXRocm93IG5ldyBFcnJvcihcIlNldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LlwiKX0sX2luaXRFdmVudHM6ZnVuY3Rpb24odCl7dGhpcy5fdGFyZ2V0cz17fSx0aGlzLl90YXJnZXRzW24odGhpcy5fY29udGFpbmVyKV09dGhpczt2YXIgaT10P2Z0Om10O2kodGhpcy5fY29udGFpbmVyLFwiY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzc1wiLHRoaXMuX2hhbmRsZURPTUV2ZW50LHRoaXMpLHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSYmaSh3aW5kb3csXCJyZXNpemVcIix0aGlzLl9vblJlc2l6ZSx0aGlzKSxqaSYmdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQmJih0P3RoaXMub2ZmOnRoaXMub24pLmNhbGwodGhpcyxcIm1vdmVlbmRcIix0aGlzLl9vbk1vdmVFbmQpfSxfb25SZXNpemU6ZnVuY3Rpb24oKXtnKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpLHRoaXMuX3Jlc2l6ZVJlcXVlc3Q9ZihmdW5jdGlvbigpe3RoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDohMH0pfSx0aGlzKX0sX29uU2Nyb2xsOmZ1bmN0aW9uKCl7dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcD0wLHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0PTB9LF9vbk1vdmVFbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRNYXBQYW5lUG9zKCk7TWF0aC5tYXgoTWF0aC5hYnModC54KSxNYXRoLmFicyh0LnkpKT49dGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQmJnRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLHRoaXMuZ2V0Wm9vbSgpKX0sX2ZpbmRFdmVudFRhcmdldHM6ZnVuY3Rpb24odCxpKXtmb3IodmFyIGUsbz1bXSxzPVwibW91c2VvdXRcIj09PWl8fFwibW91c2VvdmVyXCI9PT1pLHI9dC50YXJnZXR8fHQuc3JjRWxlbWVudCxhPSExO3I7KXtpZigoZT10aGlzLl90YXJnZXRzW24ocildKSYmKFwiY2xpY2tcIj09PWl8fFwicHJlY2xpY2tcIj09PWkpJiYhdC5fc2ltdWxhdGVkJiZ0aGlzLl9kcmFnZ2FibGVNb3ZlZChlKSl7YT0hMDticmVha31pZihlJiZlLmxpc3RlbnMoaSwhMCkpe2lmKHMmJiFDdChyLHQpKWJyZWFrO2lmKG8ucHVzaChlKSxzKWJyZWFrfWlmKHI9PT10aGlzLl9jb250YWluZXIpYnJlYWs7cj1yLnBhcmVudE5vZGV9cmV0dXJuIG8ubGVuZ3RofHxhfHxzfHwhQ3Qocix0KXx8KG89W3RoaXNdKSxvfSxfaGFuZGxlRE9NRXZlbnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5fbG9hZGVkJiYhTXQodCkpe3ZhciBpPXQudHlwZTtcIm1vdXNlZG93blwiIT09aSYmXCJrZXlwcmVzc1wiIT09aXx8Y3QodC50YXJnZXR8fHQuc3JjRWxlbWVudCksdGhpcy5fZmlyZURPTUV2ZW50KHQsaSl9fSxfbW91c2VFdmVudHM6W1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZW92ZXJcIixcIm1vdXNlb3V0XCIsXCJjb250ZXh0bWVudVwiXSxfZmlyZURPTUV2ZW50OmZ1bmN0aW9uKHQsZSxuKXtpZihcImNsaWNrXCI9PT10LnR5cGUpe3ZhciBvPWkoe30sdCk7by50eXBlPVwicHJlY2xpY2tcIix0aGlzLl9maXJlRE9NRXZlbnQobyxvLnR5cGUsbil9aWYoIXQuX3N0b3BwZWQmJihuPShufHxbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHModCxlKSkpLmxlbmd0aCl7dmFyIHM9blswXTtcImNvbnRleHRtZW51XCI9PT1lJiZzLmxpc3RlbnMoZSwhMCkmJlB0KHQpO3ZhciByPXtvcmlnaW5hbEV2ZW50OnR9O2lmKFwia2V5cHJlc3NcIiE9PXQudHlwZSl7dmFyIGE9cy5nZXRMYXRMbmcmJighcy5fcmFkaXVzfHxzLl9yYWRpdXM8PTEwKTtyLmNvbnRhaW5lclBvaW50PWE/dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHMuZ2V0TGF0TG5nKCkpOnRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCksci5sYXllclBvaW50PXRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoci5jb250YWluZXJQb2ludCksci5sYXRsbmc9YT9zLmdldExhdExuZygpOnRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHIubGF5ZXJQb2ludCl9Zm9yKHZhciBoPTA7aDxuLmxlbmd0aDtoKyspaWYobltoXS5maXJlKGUsciwhMCksci5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkfHwhMT09PW5baF0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzJiYtMSE9PWQodGhpcy5fbW91c2VFdmVudHMsZSkpcmV0dXJufX0sX2RyYWdnYWJsZU1vdmVkOmZ1bmN0aW9uKHQpe3JldHVybih0PXQuZHJhZ2dpbmcmJnQuZHJhZ2dpbmcuZW5hYmxlZCgpP3Q6dGhpcykuZHJhZ2dpbmcmJnQuZHJhZ2dpbmcubW92ZWQoKXx8dGhpcy5ib3hab29tJiZ0aGlzLmJveFpvb20ubW92ZWQoKX0sX2NsZWFySGFuZGxlcnM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxpPXRoaXMuX2hhbmRsZXJzLmxlbmd0aDt0PGk7dCsrKXRoaXMuX2hhbmRsZXJzW3RdLmRpc2FibGUoKX0sd2hlblJlYWR5OmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMuX2xvYWRlZD90LmNhbGwoaXx8dGhpcyx7dGFyZ2V0OnRoaXN9KTp0aGlzLm9uKFwibG9hZFwiLHQsaSksdGhpc30sX2dldE1hcFBhbmVQb3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHQodGhpcy5fbWFwUGFuZSl8fG5ldyB4KDAsMCl9LF9tb3ZlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2dldE1hcFBhbmVQb3MoKTtyZXR1cm4gdCYmIXQuZXF1YWxzKFswLDBdKX0sX2dldFRvcExlZnRQb2ludDpmdW5jdGlvbih0LGkpe3JldHVybih0JiZ2b2lkIDAhPT1pP3RoaXMuX2dldE5ld1BpeGVsT3JpZ2luKHQsaSk6dGhpcy5nZXRQaXhlbE9yaWdpbigpKS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpfSxfZ2V0TmV3UGl4ZWxPcmlnaW46ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7cmV0dXJuIHRoaXMucHJvamVjdCh0LGkpLl9zdWJ0cmFjdChlKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCl9LF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6ZnVuY3Rpb24odCxpLGUpe3ZhciBuPXRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGUsaSk7cmV0dXJuIHRoaXMucHJvamVjdCh0LGkpLl9zdWJ0cmFjdChuKX0sX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6ZnVuY3Rpb24odCxpLGUpe3ZhciBuPXRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGUsaSk7cmV0dXJuIGIoW3RoaXMucHJvamVjdCh0LmdldFNvdXRoV2VzdCgpLGkpLl9zdWJ0cmFjdChuKSx0aGlzLnByb2plY3QodC5nZXROb3J0aFdlc3QoKSxpKS5fc3VidHJhY3QobiksdGhpcy5wcm9qZWN0KHQuZ2V0U291dGhFYXN0KCksaSkuX3N1YnRyYWN0KG4pLHRoaXMucHJvamVjdCh0LmdldE5vcnRoRWFzdCgpLGkpLl9zdWJ0cmFjdChuKV0pfSxfZ2V0Q2VudGVyTGF5ZXJQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSl9LF9nZXRDZW50ZXJPZmZzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KHQpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSl9LF9saW1pdENlbnRlcjpmdW5jdGlvbih0LGksZSl7aWYoIWUpcmV0dXJuIHQ7dmFyIG49dGhpcy5wcm9qZWN0KHQsaSksbz10aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxzPW5ldyBQKG4uc3VidHJhY3Qobyksbi5hZGQobykpLHI9dGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHMsZSxpKTtyZXR1cm4gci5yb3VuZCgpLmVxdWFscyhbMCwwXSk/dDp0aGlzLnVucHJvamVjdChuLmFkZChyKSxpKX0sX2xpbWl0T2Zmc2V0OmZ1bmN0aW9uKHQsaSl7aWYoIWkpcmV0dXJuIHQ7dmFyIGU9dGhpcy5nZXRQaXhlbEJvdW5kcygpLG49bmV3IFAoZS5taW4uYWRkKHQpLGUubWF4LmFkZCh0KSk7cmV0dXJuIHQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuLGkpKX0sX2dldEJvdW5kc09mZnNldDpmdW5jdGlvbih0LGksZSl7dmFyIG49Yih0aGlzLnByb2plY3QoaS5nZXROb3J0aEVhc3QoKSxlKSx0aGlzLnByb2plY3QoaS5nZXRTb3V0aFdlc3QoKSxlKSksbz1uLm1pbi5zdWJ0cmFjdCh0Lm1pbikscz1uLm1heC5zdWJ0cmFjdCh0Lm1heCk7cmV0dXJuIG5ldyB4KHRoaXMuX3JlYm91bmQoby54LC1zLngpLHRoaXMuX3JlYm91bmQoby55LC1zLnkpKX0sX3JlYm91bmQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdCtpPjA/TWF0aC5yb3VuZCh0LWkpLzI6TWF0aC5tYXgoMCxNYXRoLmNlaWwodCkpLU1hdGgubWF4KDAsTWF0aC5mbG9vcihpKSl9LF9saW1pdFpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5nZXRNaW5ab29tKCksZT10aGlzLmdldE1heFpvb20oKSxuPWppP3RoaXMub3B0aW9ucy56b29tU25hcDoxO3JldHVybiBuJiYodD1NYXRoLnJvdW5kKHQvbikqbiksTWF0aC5tYXgoaSxNYXRoLm1pbihlLHQpKX0sX29uUGFuVHJhbnNpdGlvblN0ZXA6ZnVuY3Rpb24oKXt0aGlzLmZpcmUoXCJtb3ZlXCIpfSxfb25QYW5UcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKCl7dHQodGhpcy5fbWFwUGFuZSxcImxlYWZsZXQtcGFuLWFuaW1cIiksdGhpcy5maXJlKFwibW92ZWVuZFwiKX0sX3RyeUFuaW1hdGVkUGFuOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KHQpLl90cnVuYygpO3JldHVybiEoITAhPT0oaSYmaS5hbmltYXRlKSYmIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKGUpKSYmKHRoaXMucGFuQnkoZSxpKSwhMCl9LF9jcmVhdGVBbmltUHJveHk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9wcm94eT1HKFwiZGl2XCIsXCJsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZFwiKTt0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHQpLHRoaXMub24oXCJ6b29tYW5pbVwiLGZ1bmN0aW9uKHQpe3ZhciBpPWNlLGU9dGhpcy5fcHJveHkuc3R5bGVbaV07cnQodGhpcy5fcHJveHksdGhpcy5wcm9qZWN0KHQuY2VudGVyLHQuem9vbSksdGhpcy5nZXRab29tU2NhbGUodC56b29tLDEpKSxlPT09dGhpcy5fcHJveHkuc3R5bGVbaV0mJnRoaXMuX2FuaW1hdGluZ1pvb20mJnRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKX0sdGhpcyksdGhpcy5vbihcImxvYWQgbW92ZWVuZFwiLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDZW50ZXIoKSxpPXRoaXMuZ2V0Wm9vbSgpO3J0KHRoaXMuX3Byb3h5LHRoaXMucHJvamVjdCh0LGkpLHRoaXMuZ2V0Wm9vbVNjYWxlKGksMSkpfSx0aGlzKSx0aGlzLl9vbihcInVubG9hZFwiLHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksdGhpcyl9LF9kZXN0cm95QW5pbVByb3h5OmZ1bmN0aW9uKCl7Syh0aGlzLl9wcm94eSksZGVsZXRlIHRoaXMuX3Byb3h5fSxfY2F0Y2hUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKHQpe3RoaXMuX2FuaW1hdGluZ1pvb20mJnQucHJvcGVydHlOYW1lLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIik+PTAmJnRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKX0sX25vdGhpbmdUb0FuaW1hdGU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIikubGVuZ3RofSxfdHJ5QW5pbWF0ZWRab29tOmZ1bmN0aW9uKHQsaSxlKXtpZih0aGlzLl9hbmltYXRpbmdab29tKXJldHVybiEwO2lmKGU9ZXx8e30sIXRoaXMuX3pvb21BbmltYXRlZHx8ITE9PT1lLmFuaW1hdGV8fHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKXx8TWF0aC5hYnMoaS10aGlzLl96b29tKT50aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZClyZXR1cm4hMTt2YXIgbj10aGlzLmdldFpvb21TY2FsZShpKSxvPXRoaXMuX2dldENlbnRlck9mZnNldCh0KS5fZGl2aWRlQnkoMS0xL24pO3JldHVybiEoITAhPT1lLmFuaW1hdGUmJiF0aGlzLmdldFNpemUoKS5jb250YWlucyhvKSkmJihmKGZ1bmN0aW9uKCl7dGhpcy5fbW92ZVN0YXJ0KCEwLCExKS5fYW5pbWF0ZVpvb20odCxpLCEwKX0sdGhpcyksITApfSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCxpLG4sbyl7dGhpcy5fbWFwUGFuZSYmKG4mJih0aGlzLl9hbmltYXRpbmdab29tPSEwLHRoaXMuX2FuaW1hdGVUb0NlbnRlcj10LHRoaXMuX2FuaW1hdGVUb1pvb209aSxRKHRoaXMuX21hcFBhbmUsXCJsZWFmbGV0LXpvb20tYW5pbVwiKSksdGhpcy5maXJlKFwiem9vbWFuaW1cIix7Y2VudGVyOnQsem9vbTppLG5vVXBkYXRlOm99KSxzZXRUaW1lb3V0KGUodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCx0aGlzKSwyNTApKX0sX29uWm9vbVRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oKXt0aGlzLl9hbmltYXRpbmdab29tJiYodGhpcy5fbWFwUGFuZSYmdHQodGhpcy5fbWFwUGFuZSxcImxlYWZsZXQtem9vbS1hbmltXCIpLHRoaXMuX2FuaW1hdGluZ1pvb209ITEsdGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsdGhpcy5fYW5pbWF0ZVRvWm9vbSksZihmdW5jdGlvbigpe3RoaXMuX21vdmVFbmQoITApfSx0aGlzKSl9fSksVGU9di5leHRlbmQoe29wdGlvbnM6e3Bvc2l0aW9uOlwidG9wcmlnaHRcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXtsKHRoaXMsdCl9LGdldFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbn0sc2V0UG9zaXRpb246ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwO3JldHVybiBpJiZpLnJlbW92ZUNvbnRyb2wodGhpcyksdGhpcy5vcHRpb25zLnBvc2l0aW9uPXQsaSYmaS5hZGRDb250cm9sKHRoaXMpLHRoaXN9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXJ9LGFkZFRvOmZ1bmN0aW9uKHQpe3RoaXMucmVtb3ZlKCksdGhpcy5fbWFwPXQ7dmFyIGk9dGhpcy5fY29udGFpbmVyPXRoaXMub25BZGQodCksZT10aGlzLmdldFBvc2l0aW9uKCksbj10Ll9jb250cm9sQ29ybmVyc1tlXTtyZXR1cm4gUShpLFwibGVhZmxldC1jb250cm9sXCIpLC0xIT09ZS5pbmRleE9mKFwiYm90dG9tXCIpP24uaW5zZXJ0QmVmb3JlKGksbi5maXJzdENoaWxkKTpuLmFwcGVuZENoaWxkKGkpLHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXA/KEsodGhpcy5fY29udGFpbmVyKSx0aGlzLm9uUmVtb3ZlJiZ0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCksdGhpcy5fbWFwPW51bGwsdGhpcyk6dGhpc30sX3JlZm9jdXNPbk1hcDpmdW5jdGlvbih0KXt0aGlzLl9tYXAmJnQmJnQuc2NyZWVuWD4wJiZ0LnNjcmVlblk+MCYmdGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCl9fSksemU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUZSh0KX07YmUuaW5jbHVkZSh7YWRkQ29udHJvbDpmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGRUbyh0aGlzKSx0aGlzfSxyZW1vdmVDb250cm9sOmZ1bmN0aW9uKHQpe3JldHVybiB0LnJlbW92ZSgpLHRoaXN9LF9pbml0Q29udHJvbFBvczpmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxvKXt2YXIgcz1lK3QrXCIgXCIrZStvO2lbdCtvXT1HKFwiZGl2XCIscyxuKX12YXIgaT10aGlzLl9jb250cm9sQ29ybmVycz17fSxlPVwibGVhZmxldC1cIixuPXRoaXMuX2NvbnRyb2xDb250YWluZXI9RyhcImRpdlwiLGUrXCJjb250cm9sLWNvbnRhaW5lclwiLHRoaXMuX2NvbnRhaW5lcik7dChcInRvcFwiLFwibGVmdFwiKSx0KFwidG9wXCIsXCJyaWdodFwiKSx0KFwiYm90dG9tXCIsXCJsZWZ0XCIpLHQoXCJib3R0b21cIixcInJpZ2h0XCIpfSxfY2xlYXJDb250cm9sUG9zOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKUsodGhpcy5fY29udHJvbENvcm5lcnNbdF0pO0sodGhpcy5fY29udHJvbENvbnRhaW5lciksZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzLGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyfX0pO3ZhciBNZT1UZS5leHRlbmQoe29wdGlvbnM6e2NvbGxhcHNlZDohMCxwb3NpdGlvbjpcInRvcHJpZ2h0XCIsYXV0b1pJbmRleDohMCxoaWRlU2luZ2xlQmFzZTohMSxzb3J0TGF5ZXJzOiExLHNvcnRGdW5jdGlvbjpmdW5jdGlvbih0LGksZSxuKXtyZXR1cm4gZTxuPy0xOm48ZT8xOjB9fSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSxlKXtsKHRoaXMsZSksdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzPVtdLHRoaXMuX2xheWVycz1bXSx0aGlzLl9sYXN0WkluZGV4PTAsdGhpcy5faGFuZGxpbmdDbGljaz0hMTtmb3IodmFyIG4gaW4gdCl0aGlzLl9hZGRMYXllcih0W25dLG4pO2ZvcihuIGluIGkpdGhpcy5fYWRkTGF5ZXIoaVtuXSxuLCEwKX0sb25BZGQ6ZnVuY3Rpb24odCl7dGhpcy5faW5pdExheW91dCgpLHRoaXMuX3VwZGF0ZSgpLHRoaXMuX21hcD10LHQub24oXCJ6b29tZW5kXCIsdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycyx0aGlzKTtmb3IodmFyIGk9MDtpPHRoaXMuX2xheWVycy5sZW5ndGg7aSsrKXRoaXMuX2xheWVyc1tpXS5sYXllci5vbihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpO3JldHVybiB0aGlzLl9jb250YWluZXJ9LGFkZFRvOmZ1bmN0aW9uKHQpe3JldHVybiBUZS5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLHQpLHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLm9mZihcInpvb21lbmRcIix0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLHRoaXMpO2Zvcih2YXIgdD0wO3Q8dGhpcy5fbGF5ZXJzLmxlbmd0aDt0KyspdGhpcy5fbGF5ZXJzW3RdLmxheWVyLm9mZihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpfSxhZGRCYXNlTGF5ZXI6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fYWRkTGF5ZXIodCxpKSx0aGlzLl9tYXA/dGhpcy5fdXBkYXRlKCk6dGhpc30sYWRkT3ZlcmxheTpmdW5jdGlvbih0LGkpe3JldHVybiB0aGlzLl9hZGRMYXllcih0LGksITApLHRoaXMuX21hcD90aGlzLl91cGRhdGUoKTp0aGlzfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0KXt0Lm9mZihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpO3ZhciBpPXRoaXMuX2dldExheWVyKG4odCkpO3JldHVybiBpJiZ0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKGkpLDEpLHRoaXMuX21hcD90aGlzLl91cGRhdGUoKTp0aGlzfSxleHBhbmQ6ZnVuY3Rpb24oKXtRKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWRcIiksdGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQ9bnVsbDt2YXIgdD10aGlzLl9tYXAuZ2V0U2l6ZSgpLnktKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3ArNTApO3JldHVybiB0PHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0PyhRKHRoaXMuX3NlY3Rpb24sXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhclwiKSx0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodD10K1wicHhcIik6dHQodGhpcy5fc2VjdGlvbixcImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyXCIpLHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKSx0aGlzfSxjb2xsYXBzZTpmdW5jdGlvbigpe3JldHVybiB0dCh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkXCIpLHRoaXN9LF9pbml0TGF5b3V0OmZ1bmN0aW9uKCl7dmFyIHQ9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzXCIsaT10aGlzLl9jb250YWluZXI9RyhcImRpdlwiLHQpLGU9dGhpcy5vcHRpb25zLmNvbGxhcHNlZDtpLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwhMCksd3QoaSkseHQoaSk7dmFyIG49dGhpcy5fc2VjdGlvbj1HKFwic2VjdGlvblwiLHQrXCItbGlzdFwiKTtlJiYodGhpcy5fbWFwLm9uKFwiY2xpY2tcIix0aGlzLmNvbGxhcHNlLHRoaXMpLHppfHxtdChpLHttb3VzZWVudGVyOnRoaXMuZXhwYW5kLG1vdXNlbGVhdmU6dGhpcy5jb2xsYXBzZX0sdGhpcykpO3ZhciBvPXRoaXMuX2xheWVyc0xpbms9RyhcImFcIix0K1wiLXRvZ2dsZVwiLGkpO28uaHJlZj1cIiNcIixvLnRpdGxlPVwiTGF5ZXJzXCIscWk/KG10KG8sXCJjbGlja1wiLEx0KSxtdChvLFwiY2xpY2tcIix0aGlzLmV4cGFuZCx0aGlzKSk6bXQobyxcImZvY3VzXCIsdGhpcy5leHBhbmQsdGhpcyksZXx8dGhpcy5leHBhbmQoKSx0aGlzLl9iYXNlTGF5ZXJzTGlzdD1HKFwiZGl2XCIsdCtcIi1iYXNlXCIsbiksdGhpcy5fc2VwYXJhdG9yPUcoXCJkaXZcIix0K1wiLXNlcGFyYXRvclwiLG4pLHRoaXMuX292ZXJsYXlzTGlzdD1HKFwiZGl2XCIsdCtcIi1vdmVybGF5c1wiLG4pLGkuYXBwZW5kQ2hpbGQobil9LF9nZXRMYXllcjpmdW5jdGlvbih0KXtmb3IodmFyIGk9MDtpPHRoaXMuX2xheWVycy5sZW5ndGg7aSsrKWlmKHRoaXMuX2xheWVyc1tpXSYmbih0aGlzLl9sYXllcnNbaV0ubGF5ZXIpPT09dClyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldfSxfYWRkTGF5ZXI6ZnVuY3Rpb24odCxpLG4pe3RoaXMuX21hcCYmdC5vbihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpLHRoaXMuX2xheWVycy5wdXNoKHtsYXllcjp0LG5hbWU6aSxvdmVybGF5Om59KSx0aGlzLm9wdGlvbnMuc29ydExheWVycyYmdGhpcy5fbGF5ZXJzLnNvcnQoZShmdW5jdGlvbih0LGkpe3JldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKHQubGF5ZXIsaS5sYXllcix0Lm5hbWUsaS5uYW1lKX0sdGhpcykpLHRoaXMub3B0aW9ucy5hdXRvWkluZGV4JiZ0LnNldFpJbmRleCYmKHRoaXMuX2xhc3RaSW5kZXgrKyx0LnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KSksdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKX0sX3VwZGF0ZTpmdW5jdGlvbigpe2lmKCF0aGlzLl9jb250YWluZXIpcmV0dXJuIHRoaXM7WSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCksWSh0aGlzLl9vdmVybGF5c0xpc3QpLHRoaXMuX2xheWVyQ29udHJvbElucHV0cz1bXTt2YXIgdCxpLGUsbixvPTA7Zm9yKGU9MDtlPHRoaXMuX2xheWVycy5sZW5ndGg7ZSsrKW49dGhpcy5fbGF5ZXJzW2VdLHRoaXMuX2FkZEl0ZW0obiksaT1pfHxuLm92ZXJsYXksdD10fHwhbi5vdmVybGF5LG8rPW4ub3ZlcmxheT8wOjE7cmV0dXJuIHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSYmKHQ9dCYmbz4xLHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXk9dD9cIlwiOlwibm9uZVwiKSx0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheT1pJiZ0P1wiXCI6XCJub25lXCIsdGhpc30sX29uTGF5ZXJDaGFuZ2U6ZnVuY3Rpb24odCl7dGhpcy5faGFuZGxpbmdDbGlja3x8dGhpcy5fdXBkYXRlKCk7dmFyIGk9dGhpcy5fZ2V0TGF5ZXIobih0LnRhcmdldCkpLGU9aS5vdmVybGF5P1wiYWRkXCI9PT10LnR5cGU/XCJvdmVybGF5YWRkXCI6XCJvdmVybGF5cmVtb3ZlXCI6XCJhZGRcIj09PXQudHlwZT9cImJhc2VsYXllcmNoYW5nZVwiOm51bGw7ZSYmdGhpcy5fbWFwLmZpcmUoZSxpKX0sX2NyZWF0ZVJhZGlvRWxlbWVudDpmdW5jdGlvbih0LGkpe3ZhciBlPSc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicrdCsnXCInKyhpPycgY2hlY2tlZD1cImNoZWNrZWRcIic6XCJcIikrXCIvPlwiLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gbi5pbm5lckhUTUw9ZSxuLmZpcnN0Q2hpbGR9LF9hZGRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpLG89dGhpcy5fbWFwLmhhc0xheWVyKHQubGF5ZXIpO3Qub3ZlcmxheT8oKGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS50eXBlPVwiY2hlY2tib3hcIixpLmNsYXNzTmFtZT1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIixpLmRlZmF1bHRDaGVja2VkPW8pOmk9dGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KFwibGVhZmxldC1iYXNlLWxheWVyc1wiLG8pLHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGkpLGkubGF5ZXJJZD1uKHQubGF5ZXIpLG10KGksXCJjbGlja1wiLHRoaXMuX29uSW5wdXRDbGljayx0aGlzKTt2YXIgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtzLmlubmVySFRNTD1cIiBcIit0Lm5hbWU7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5hcHBlbmRDaGlsZChyKSxyLmFwcGVuZENoaWxkKGkpLHIuYXBwZW5kQ2hpbGQocyksKHQub3ZlcmxheT90aGlzLl9vdmVybGF5c0xpc3Q6dGhpcy5fYmFzZUxheWVyc0xpc3QpLmFwcGVuZENoaWxkKGUpLHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKSxlfSxfb25JbnB1dENsaWNrOmZ1bmN0aW9uKCl7dmFyIHQsaSxlPXRoaXMuX2xheWVyQ29udHJvbElucHV0cyxuPVtdLG89W107dGhpcy5faGFuZGxpbmdDbGljaz0hMDtmb3IodmFyIHM9ZS5sZW5ndGgtMTtzPj0wO3MtLSl0PWVbc10saT10aGlzLl9nZXRMYXllcih0LmxheWVySWQpLmxheWVyLHQuY2hlY2tlZD9uLnB1c2goaSk6dC5jaGVja2VkfHxvLnB1c2goaSk7Zm9yKHM9MDtzPG8ubGVuZ3RoO3MrKyl0aGlzLl9tYXAuaGFzTGF5ZXIob1tzXSkmJnRoaXMuX21hcC5yZW1vdmVMYXllcihvW3NdKTtmb3Iocz0wO3M8bi5sZW5ndGg7cysrKXRoaXMuX21hcC5oYXNMYXllcihuW3NdKXx8dGhpcy5fbWFwLmFkZExheWVyKG5bc10pO3RoaXMuX2hhbmRsaW5nQ2xpY2s9ITEsdGhpcy5fcmVmb2N1c09uTWFwKCl9LF9jaGVja0Rpc2FibGVkTGF5ZXJzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGksZT10aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsbj10aGlzLl9tYXAuZ2V0Wm9vbSgpLG89ZS5sZW5ndGgtMTtvPj0wO28tLSl0PWVbb10saT10aGlzLl9nZXRMYXllcih0LmxheWVySWQpLmxheWVyLHQuZGlzYWJsZWQ9dm9pZCAwIT09aS5vcHRpb25zLm1pblpvb20mJm48aS5vcHRpb25zLm1pblpvb218fHZvaWQgMCE9PWkub3B0aW9ucy5tYXhab29tJiZuPmkub3B0aW9ucy5tYXhab29tfSxfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCYmdGhpcy5leHBhbmQoKSx0aGlzfSxfZXhwYW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhwYW5kKCl9LF9jb2xsYXBzZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbGxhcHNlKCl9fSksQ2U9VGUuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcInRvcGxlZnRcIix6b29tSW5UZXh0OlwiK1wiLHpvb21JblRpdGxlOlwiWm9vbSBpblwiLHpvb21PdXRUZXh0OlwiJiN4MjIxMjtcIix6b29tT3V0VGl0bGU6XCJab29tIG91dFwifSxvbkFkZDpmdW5jdGlvbih0KXt2YXIgaT1cImxlYWZsZXQtY29udHJvbC16b29tXCIsZT1HKFwiZGl2XCIsaStcIiBsZWFmbGV0LWJhclwiKSxuPXRoaXMub3B0aW9ucztyZXR1cm4gdGhpcy5fem9vbUluQnV0dG9uPXRoaXMuX2NyZWF0ZUJ1dHRvbihuLnpvb21JblRleHQsbi56b29tSW5UaXRsZSxpK1wiLWluXCIsZSx0aGlzLl96b29tSW4pLHRoaXMuX3pvb21PdXRCdXR0b249dGhpcy5fY3JlYXRlQnV0dG9uKG4uem9vbU91dFRleHQsbi56b29tT3V0VGl0bGUsaStcIi1vdXRcIixlLHRoaXMuX3pvb21PdXQpLHRoaXMuX3VwZGF0ZURpc2FibGVkKCksdC5vbihcInpvb21lbmQgem9vbWxldmVsc2NoYW5nZVwiLHRoaXMuX3VwZGF0ZURpc2FibGVkLHRoaXMpLGV9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3Qub2ZmKFwiem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlXCIsdGhpcy5fdXBkYXRlRGlzYWJsZWQsdGhpcyl9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlzYWJsZWQ9ITAsdGhpcy5fdXBkYXRlRGlzYWJsZWQoKSx0aGlzfSxlbmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlzYWJsZWQ9ITEsdGhpcy5fdXBkYXRlRGlzYWJsZWQoKSx0aGlzfSxfem9vbUluOmZ1bmN0aW9uKHQpeyF0aGlzLl9kaXNhYmxlZCYmdGhpcy5fbWFwLl96b29tPHRoaXMuX21hcC5nZXRNYXhab29tKCkmJnRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhKih0LnNoaWZ0S2V5PzM6MSkpfSxfem9vbU91dDpmdW5jdGlvbih0KXshdGhpcy5fZGlzYWJsZWQmJnRoaXMuX21hcC5fem9vbT50aGlzLl9tYXAuZ2V0TWluWm9vbSgpJiZ0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEqKHQuc2hpZnRLZXk/MzoxKSl9LF9jcmVhdGVCdXR0b246ZnVuY3Rpb24odCxpLGUsbixvKXt2YXIgcz1HKFwiYVwiLGUsbik7cmV0dXJuIHMuaW5uZXJIVE1MPXQscy5ocmVmPVwiI1wiLHMudGl0bGU9aSxzLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSxzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixpKSx3dChzKSxtdChzLFwiY2xpY2tcIixMdCksbXQocyxcImNsaWNrXCIsbyx0aGlzKSxtdChzLFwiY2xpY2tcIix0aGlzLl9yZWZvY3VzT25NYXAsdGhpcyksc30sX3VwZGF0ZURpc2FibGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwLGk9XCJsZWFmbGV0LWRpc2FibGVkXCI7dHQodGhpcy5fem9vbUluQnV0dG9uLGkpLHR0KHRoaXMuX3pvb21PdXRCdXR0b24saSksKHRoaXMuX2Rpc2FibGVkfHx0Ll96b29tPT09dC5nZXRNaW5ab29tKCkpJiZRKHRoaXMuX3pvb21PdXRCdXR0b24saSksKHRoaXMuX2Rpc2FibGVkfHx0Ll96b29tPT09dC5nZXRNYXhab29tKCkpJiZRKHRoaXMuX3pvb21JbkJ1dHRvbixpKX19KTtiZS5tZXJnZU9wdGlvbnMoe3pvb21Db250cm9sOiEwfSksYmUuYWRkSW5pdEhvb2soZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wmJih0aGlzLnpvb21Db250cm9sPW5ldyBDZSx0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCkpfSk7dmFyIFNlPVRlLmV4dGVuZCh7b3B0aW9uczp7cG9zaXRpb246XCJib3R0b21sZWZ0XCIsbWF4V2lkdGg6MTAwLG1ldHJpYzohMCxpbXBlcmlhbDohMH0sb25BZGQ6ZnVuY3Rpb24odCl7dmFyIGk9RyhcImRpdlwiLFwibGVhZmxldC1jb250cm9sLXNjYWxlXCIpLGU9dGhpcy5vcHRpb25zO3JldHVybiB0aGlzLl9hZGRTY2FsZXMoZSxcImxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lXCIsaSksdC5vbihlLnVwZGF0ZVdoZW5JZGxlP1wibW92ZWVuZFwiOlwibW92ZVwiLHRoaXMuX3VwZGF0ZSx0aGlzKSx0LndoZW5SZWFkeSh0aGlzLl91cGRhdGUsdGhpcyksaX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlP1wibW92ZWVuZFwiOlwibW92ZVwiLHRoaXMuX3VwZGF0ZSx0aGlzKX0sX2FkZFNjYWxlczpmdW5jdGlvbih0LGksZSl7dC5tZXRyaWMmJih0aGlzLl9tU2NhbGU9RyhcImRpdlwiLGksZSkpLHQuaW1wZXJpYWwmJih0aGlzLl9pU2NhbGU9RyhcImRpdlwiLGksZSkpfSxfdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwLGk9dC5nZXRTaXplKCkueS8yLGU9dC5kaXN0YW5jZSh0LmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsaV0pLHQuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLGldKSk7dGhpcy5fdXBkYXRlU2NhbGVzKGUpfSxfdXBkYXRlU2NhbGVzOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucy5tZXRyaWMmJnQmJnRoaXMuX3VwZGF0ZU1ldHJpYyh0KSx0aGlzLm9wdGlvbnMuaW1wZXJpYWwmJnQmJnRoaXMuX3VwZGF0ZUltcGVyaWFsKHQpfSxfdXBkYXRlTWV0cmljOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX2dldFJvdW5kTnVtKHQpLGU9aTwxZTM/aStcIiBtXCI6aS8xZTMrXCIga21cIjt0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsZSxpL3QpfSxfdXBkYXRlSW1wZXJpYWw6ZnVuY3Rpb24odCl7dmFyIGksZSxuLG89My4yODA4Mzk5KnQ7bz41MjgwPyhpPW8vNTI4MCxlPXRoaXMuX2dldFJvdW5kTnVtKGkpLHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSxlK1wiIG1pXCIsZS9pKSk6KG49dGhpcy5fZ2V0Um91bmROdW0obyksdGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLG4rXCIgZnRcIixuL28pKX0sX3VwZGF0ZVNjYWxlOmZ1bmN0aW9uKHQsaSxlKXt0LnN0eWxlLndpZHRoPU1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoKmUpK1wicHhcIix0LmlubmVySFRNTD1pfSxfZ2V0Um91bmROdW06ZnVuY3Rpb24odCl7dmFyIGk9TWF0aC5wb3coMTAsKE1hdGguZmxvb3IodCkrXCJcIikubGVuZ3RoLTEpLGU9dC9pO3JldHVybiBlPWU+PTEwPzEwOmU+PTU/NTplPj0zPzM6ZT49Mj8yOjEsaSplfX0pLFplPVRlLmV4dGVuZCh7b3B0aW9uczp7cG9zaXRpb246XCJib3R0b21yaWdodFwiLHByZWZpeDonPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPid9LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7bCh0aGlzLHQpLHRoaXMuX2F0dHJpYnV0aW9ucz17fX0sb25BZGQ6ZnVuY3Rpb24odCl7dC5hdHRyaWJ1dGlvbkNvbnRyb2w9dGhpcyx0aGlzLl9jb250YWluZXI9RyhcImRpdlwiLFwibGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uXCIpLHd0KHRoaXMuX2NvbnRhaW5lcik7Zm9yKHZhciBpIGluIHQuX2xheWVycyl0Ll9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24mJnRoaXMuYWRkQXR0cmlidXRpb24odC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO3JldHVybiB0aGlzLl91cGRhdGUoKSx0aGlzLl9jb250YWluZXJ9LHNldFByZWZpeDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnByZWZpeD10LHRoaXMuX3VwZGF0ZSgpLHRoaXN9LGFkZEF0dHJpYnV0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0Pyh0aGlzLl9hdHRyaWJ1dGlvbnNbdF18fCh0aGlzLl9hdHRyaWJ1dGlvbnNbdF09MCksdGhpcy5fYXR0cmlidXRpb25zW3RdKyssdGhpcy5fdXBkYXRlKCksdGhpcyk6dGhpc30scmVtb3ZlQXR0cmlidXRpb246ZnVuY3Rpb24odCl7cmV0dXJuIHQ/KHRoaXMuX2F0dHJpYnV0aW9uc1t0XSYmKHRoaXMuX2F0dHJpYnV0aW9uc1t0XS0tLHRoaXMuX3VwZGF0ZSgpKSx0aGlzKTp0aGlzfSxfdXBkYXRlOmZ1bmN0aW9uKCl7aWYodGhpcy5fbWFwKXt2YXIgdD1bXTtmb3IodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKXRoaXMuX2F0dHJpYnV0aW9uc1tpXSYmdC5wdXNoKGkpO3ZhciBlPVtdO3RoaXMub3B0aW9ucy5wcmVmaXgmJmUucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KSx0Lmxlbmd0aCYmZS5wdXNoKHQuam9pbihcIiwgXCIpKSx0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MPWUuam9pbihcIiB8IFwiKX19fSk7YmUubWVyZ2VPcHRpb25zKHthdHRyaWJ1dGlvbkNvbnRyb2w6ITB9KSxiZS5hZGRJbml0SG9vayhmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wmJihuZXcgWmUpLmFkZFRvKHRoaXMpfSk7VGUuTGF5ZXJzPU1lLFRlLlpvb209Q2UsVGUuU2NhbGU9U2UsVGUuQXR0cmlidXRpb249WmUsemUubGF5ZXJzPWZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gbmV3IE1lKHQsaSxlKX0semUuem9vbT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IENlKHQpfSx6ZS5zY2FsZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFNlKHQpfSx6ZS5hdHRyaWJ1dGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFplKHQpfTt2YXIgRWU9di5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbWFwPXR9LGVuYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkP3RoaXM6KHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5hZGRIb29rcygpLHRoaXMpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuYWJsZWQ/KHRoaXMuX2VuYWJsZWQ9ITEsdGhpcy5yZW1vdmVIb29rcygpLHRoaXMpOnRoaXN9LGVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX2VuYWJsZWR9fSk7RWUuYWRkVG89ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5hZGRIYW5kbGVyKGksdGhpcyksdGhpc307dmFyIGtlLEJlPXtFdmVudHM6bGl9LEFlPXFpP1widG91Y2hzdGFydCBtb3VzZWRvd25cIjpcIm1vdXNlZG93blwiLEllPXttb3VzZWRvd246XCJtb3VzZXVwXCIsdG91Y2hzdGFydDpcInRvdWNoZW5kXCIscG9pbnRlcmRvd246XCJ0b3VjaGVuZFwiLE1TUG9pbnRlckRvd246XCJ0b3VjaGVuZFwifSxPZT17bW91c2Vkb3duOlwibW91c2Vtb3ZlXCIsdG91Y2hzdGFydDpcInRvdWNobW92ZVwiLHBvaW50ZXJkb3duOlwidG91Y2htb3ZlXCIsTVNQb2ludGVyRG93bjpcInRvdWNobW92ZVwifSxSZT1jaS5leHRlbmQoe29wdGlvbnM6e2NsaWNrVG9sZXJhbmNlOjN9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxpLGUsbil7bCh0aGlzLG4pLHRoaXMuX2VsZW1lbnQ9dCx0aGlzLl9kcmFnU3RhcnRUYXJnZXQ9aXx8dCx0aGlzLl9wcmV2ZW50T3V0bGluZT1lfSxlbmFibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkfHwobXQodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LEFlLHRoaXMuX29uRG93bix0aGlzKSx0aGlzLl9lbmFibGVkPSEwKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuX2VuYWJsZWQmJihSZS5fZHJhZ2dpbmc9PT10aGlzJiZ0aGlzLmZpbmlzaERyYWcoKSxmdCh0aGlzLl9kcmFnU3RhcnRUYXJnZXQsQWUsdGhpcy5fb25Eb3duLHRoaXMpLHRoaXMuX2VuYWJsZWQ9ITEsdGhpcy5fbW92ZWQ9ITEpfSxfb25Eb3duOmZ1bmN0aW9uKHQpe2lmKCF0Ll9zaW11bGF0ZWQmJnRoaXMuX2VuYWJsZWQmJih0aGlzLl9tb3ZlZD0hMSwhJCh0aGlzLl9lbGVtZW50LFwibGVhZmxldC16b29tLWFuaW1cIikmJiEoUmUuX2RyYWdnaW5nfHx0LnNoaWZ0S2V5fHwxIT09dC53aGljaCYmMSE9PXQuYnV0dG9uJiYhdC50b3VjaGVzfHwoUmUuX2RyYWdnaW5nPXRoaXMsdGhpcy5fcHJldmVudE91dGxpbmUmJmN0KHRoaXMuX2VsZW1lbnQpLHV0KCksZmkoKSx0aGlzLl9tb3ZpbmcpKSkpe3RoaXMuZmlyZShcImRvd25cIik7dmFyIGk9dC50b3VjaGVzP3QudG91Y2hlc1swXTp0LGU9ZHQodGhpcy5fZWxlbWVudCk7dGhpcy5fc3RhcnRQb2ludD1uZXcgeChpLmNsaWVudFgsaS5jbGllbnRZKSx0aGlzLl9wYXJlbnRTY2FsZT1wdChlKSxtdChkb2N1bWVudCxPZVt0LnR5cGVdLHRoaXMuX29uTW92ZSx0aGlzKSxtdChkb2N1bWVudCxJZVt0LnR5cGVdLHRoaXMuX29uVXAsdGhpcyl9fSxfb25Nb3ZlOmZ1bmN0aW9uKHQpe2lmKCF0Ll9zaW11bGF0ZWQmJnRoaXMuX2VuYWJsZWQpaWYodC50b3VjaGVzJiZ0LnRvdWNoZXMubGVuZ3RoPjEpdGhpcy5fbW92ZWQ9ITA7ZWxzZXt2YXIgaT10LnRvdWNoZXMmJjE9PT10LnRvdWNoZXMubGVuZ3RoP3QudG91Y2hlc1swXTp0LGU9bmV3IHgoaS5jbGllbnRYLGkuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpOyhlLnh8fGUueSkmJihNYXRoLmFicyhlLngpK01hdGguYWJzKGUueSk8dGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlfHwoZS54Lz10aGlzLl9wYXJlbnRTY2FsZS54LGUueS89dGhpcy5fcGFyZW50U2NhbGUueSxQdCh0KSx0aGlzLl9tb3ZlZHx8KHRoaXMuZmlyZShcImRyYWdzdGFydFwiKSx0aGlzLl9tb3ZlZD0hMCx0aGlzLl9zdGFydFBvcz1odCh0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChlKSxRKGRvY3VtZW50LmJvZHksXCJsZWFmbGV0LWRyYWdnaW5nXCIpLHRoaXMuX2xhc3RUYXJnZXQ9dC50YXJnZXR8fHQuc3JjRWxlbWVudCx3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlJiZ0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlJiYodGhpcy5fbGFzdFRhcmdldD10aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSxRKHRoaXMuX2xhc3RUYXJnZXQsXCJsZWFmbGV0LWRyYWctdGFyZ2V0XCIpKSx0aGlzLl9uZXdQb3M9dGhpcy5fc3RhcnRQb3MuYWRkKGUpLHRoaXMuX21vdmluZz0hMCxnKHRoaXMuX2FuaW1SZXF1ZXN0KSx0aGlzLl9sYXN0RXZlbnQ9dCx0aGlzLl9hbmltUmVxdWVzdD1mKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLHRoaXMsITApKSl9fSxfdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgdD17b3JpZ2luYWxFdmVudDp0aGlzLl9sYXN0RXZlbnR9O3RoaXMuZmlyZShcInByZWRyYWdcIix0KSxhdCh0aGlzLl9lbGVtZW50LHRoaXMuX25ld1BvcyksdGhpcy5maXJlKFwiZHJhZ1wiLHQpfSxfb25VcDpmdW5jdGlvbih0KXshdC5fc2ltdWxhdGVkJiZ0aGlzLl9lbmFibGVkJiZ0aGlzLmZpbmlzaERyYWcoKX0sZmluaXNoRHJhZzpmdW5jdGlvbigpe3R0KGRvY3VtZW50LmJvZHksXCJsZWFmbGV0LWRyYWdnaW5nXCIpLHRoaXMuX2xhc3RUYXJnZXQmJih0dCh0aGlzLl9sYXN0VGFyZ2V0LFwibGVhZmxldC1kcmFnLXRhcmdldFwiKSx0aGlzLl9sYXN0VGFyZ2V0PW51bGwpO2Zvcih2YXIgdCBpbiBPZSlmdChkb2N1bWVudCxPZVt0XSx0aGlzLl9vbk1vdmUsdGhpcyksZnQoZG9jdW1lbnQsSWVbdF0sdGhpcy5fb25VcCx0aGlzKTtsdCgpLGdpKCksdGhpcy5fbW92ZWQmJnRoaXMuX21vdmluZyYmKGcodGhpcy5fYW5pbVJlcXVlc3QpLHRoaXMuZmlyZShcImRyYWdlbmRcIix7ZGlzdGFuY2U6dGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpfSkpLHRoaXMuX21vdmluZz0hMSxSZS5fZHJhZ2dpbmc9ITF9fSksTmU9KE9iamVjdC5mcmVlemV8fE9iamVjdCkoe3NpbXBsaWZ5Olp0LHBvaW50VG9TZWdtZW50RGlzdGFuY2U6RXQsY2xvc2VzdFBvaW50T25TZWdtZW50OmZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gRHQodCxpLGUpfSxjbGlwU2VnbWVudDpJdCxfZ2V0RWRnZUludGVyc2VjdGlvbjpPdCxfZ2V0Qml0Q29kZTpSdCxfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6RHQsaXNGbGF0Omp0LF9mbGF0Old0fSksRGU9KE9iamVjdC5mcmVlemV8fE9iamVjdCkoe2NsaXBQb2x5Z29uOkh0fSksamU9e3Byb2plY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB4KHQubG5nLHQubGF0KX0sdW5wcm9qZWN0OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTSh0LnksdC54KX0sYm91bmRzOm5ldyBQKFstMTgwLC05MF0sWzE4MCw5MF0pfSxXZT17Ujo2Mzc4MTM3LFJfTUlOT1I6NjM1Njc1Mi4zMTQyNDUxNzksYm91bmRzOm5ldyBQKFstMjAwMzc1MDguMzQyNzksLTE1NDk2NTcwLjczOTcyXSxbMjAwMzc1MDguMzQyNzksMTg3NjQ2NTYuMjMxMzhdKSxwcm9qZWN0OmZ1bmN0aW9uKHQpe3ZhciBpPU1hdGguUEkvMTgwLGU9dGhpcy5SLG49dC5sYXQqaSxvPXRoaXMuUl9NSU5PUi9lLHM9TWF0aC5zcXJ0KDEtbypvKSxyPXMqTWF0aC5zaW4obiksYT1NYXRoLnRhbihNYXRoLlBJLzQtbi8yKS9NYXRoLnBvdygoMS1yKS8oMStyKSxzLzIpO3JldHVybiBuPS1lKk1hdGgubG9nKE1hdGgubWF4KGEsMWUtMTApKSxuZXcgeCh0LmxuZyppKmUsbil9LHVucHJvamVjdDpmdW5jdGlvbih0KXtmb3IodmFyIGksZT0xODAvTWF0aC5QSSxuPXRoaXMuUixvPXRoaXMuUl9NSU5PUi9uLHM9TWF0aC5zcXJ0KDEtbypvKSxyPU1hdGguZXhwKC10LnkvbiksYT1NYXRoLlBJLzItMipNYXRoLmF0YW4ociksaD0wLHU9LjE7aDwxNSYmTWF0aC5hYnModSk+MWUtNztoKyspaT1zKk1hdGguc2luKGEpLGk9TWF0aC5wb3coKDEtaSkvKDEraSkscy8yKSxhKz11PU1hdGguUEkvMi0yKk1hdGguYXRhbihyKmkpLWE7cmV0dXJuIG5ldyBNKGEqZSx0LngqZS9uKX19LEhlPShPYmplY3QuZnJlZXplfHxPYmplY3QpKHtMb25MYXQ6amUsTWVyY2F0b3I6V2UsU3BoZXJpY2FsTWVyY2F0b3I6bWl9KSxGZT1pKHt9LHBpLHtjb2RlOlwiRVBTRzozMzk1XCIscHJvamVjdGlvbjpXZSx0cmFuc2Zvcm1hdGlvbjpmdW5jdGlvbigpe3ZhciB0PS41LyhNYXRoLlBJKldlLlIpO3JldHVybiBaKHQsLjUsLXQsLjUpfSgpfSksVWU9aSh7fSxwaSx7Y29kZTpcIkVQU0c6NDMyNlwiLHByb2plY3Rpb246amUsdHJhbnNmb3JtYXRpb246WigxLzE4MCwxLC0xLzE4MCwuNSl9KSxWZT1pKHt9LGRpLHtwcm9qZWN0aW9uOmplLHRyYW5zZm9ybWF0aW9uOlooMSwwLC0xLDApLHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfSx6b29tOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmxvZyh0KS9NYXRoLkxOMn0sZGlzdGFuY2U6ZnVuY3Rpb24odCxpKXt2YXIgZT1pLmxuZy10LmxuZyxuPWkubGF0LXQubGF0O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9LGluZmluaXRlOiEwfSk7ZGkuRWFydGg9cGksZGkuRVBTRzMzOTU9RmUsZGkuRVBTRzM4NTc9eWksZGkuRVBTRzkwMDkxMz14aSxkaS5FUFNHNDMyNj1VZSxkaS5TaW1wbGU9VmU7dmFyIHFlPWNpLmV4dGVuZCh7b3B0aW9uczp7cGFuZTpcIm92ZXJsYXlQYW5lXCIsYXR0cmlidXRpb246bnVsbCxidWJibGluZ01vdXNlRXZlbnRzOiEwfSxhZGRUbzpmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGRMYXllcih0aGlzKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcHx8dGhpcy5fbWFwVG9BZGQpfSxyZW1vdmVGcm9tOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0LnJlbW92ZUxheWVyKHRoaXMpLHRoaXN9LGdldFBhbmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKHQ/dGhpcy5vcHRpb25zW3RdfHx0OnRoaXMub3B0aW9ucy5wYW5lKX0sYWRkSW50ZXJhY3RpdmVUYXJnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX21hcC5fdGFyZ2V0c1tuKHQpXT10aGlzLHRoaXN9LHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiBkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW24odCldLHRoaXN9LGdldEF0dHJpYnV0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbn0sX2xheWVyQWRkOmZ1bmN0aW9uKHQpe3ZhciBpPXQudGFyZ2V0O2lmKGkuaGFzTGF5ZXIodGhpcykpe2lmKHRoaXMuX21hcD1pLHRoaXMuX3pvb21BbmltYXRlZD1pLl96b29tQW5pbWF0ZWQsdGhpcy5nZXRFdmVudHMpe3ZhciBlPXRoaXMuZ2V0RXZlbnRzKCk7aS5vbihlLHRoaXMpLHRoaXMub25jZShcInJlbW92ZVwiLGZ1bmN0aW9uKCl7aS5vZmYoZSx0aGlzKX0sdGhpcyl9dGhpcy5vbkFkZChpKSx0aGlzLmdldEF0dHJpYnV0aW9uJiZpLmF0dHJpYnV0aW9uQ29udHJvbCYmaS5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKSx0aGlzLmZpcmUoXCJhZGRcIiksaS5maXJlKFwibGF5ZXJhZGRcIix7bGF5ZXI6dGhpc30pfX19KTtiZS5pbmNsdWRlKHthZGRMYXllcjpmdW5jdGlvbih0KXtpZighdC5fbGF5ZXJBZGQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci5cIik7dmFyIGk9bih0KTtyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldP3RoaXM6KHRoaXMuX2xheWVyc1tpXT10LHQuX21hcFRvQWRkPXRoaXMsdC5iZWZvcmVBZGQmJnQuYmVmb3JlQWRkKHRoaXMpLHRoaXMud2hlblJlYWR5KHQuX2xheWVyQWRkLHQpLHRoaXMpfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0KXt2YXIgaT1uKHQpO3JldHVybiB0aGlzLl9sYXllcnNbaV0/KHRoaXMuX2xvYWRlZCYmdC5vblJlbW92ZSh0aGlzKSx0LmdldEF0dHJpYnV0aW9uJiZ0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCYmdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24odC5nZXRBdHRyaWJ1dGlvbigpKSxkZWxldGUgdGhpcy5fbGF5ZXJzW2ldLHRoaXMuX2xvYWRlZCYmKHRoaXMuZmlyZShcImxheWVycmVtb3ZlXCIse2xheWVyOnR9KSx0LmZpcmUoXCJyZW1vdmVcIikpLHQuX21hcD10Ll9tYXBUb0FkZD1udWxsLHRoaXMpOnRoaXN9LGhhc0xheWVyOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmbih0KWluIHRoaXMuX2xheWVyc30sZWFjaExheWVyOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlIGluIHRoaXMuX2xheWVycyl0LmNhbGwoaSx0aGlzLl9sYXllcnNbZV0pO3JldHVybiB0aGlzfSxfYWRkTGF5ZXJzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaT0wLGU9KHQ9dD9vaSh0KT90Olt0XTpbXSkubGVuZ3RoO2k8ZTtpKyspdGhpcy5hZGRMYXllcih0W2ldKX0sX2FkZFpvb21MaW1pdDpmdW5jdGlvbih0KXshaXNOYU4odC5vcHRpb25zLm1heFpvb20pJiZpc05hTih0Lm9wdGlvbnMubWluWm9vbSl8fCh0aGlzLl96b29tQm91bmRMYXllcnNbbih0KV09dCx0aGlzLl91cGRhdGVab29tTGV2ZWxzKCkpfSxfcmVtb3ZlWm9vbUxpbWl0OmZ1bmN0aW9uKHQpe3ZhciBpPW4odCk7dGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldJiYoZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXSx0aGlzLl91cGRhdGVab29tTGV2ZWxzKCkpfSxfdXBkYXRlWm9vbUxldmVsczpmdW5jdGlvbigpe3ZhciB0PTEvMCxpPS0xLzAsZT10aGlzLl9nZXRab29tU3BhbigpO2Zvcih2YXIgbiBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpe3ZhciBvPXRoaXMuX3pvb21Cb3VuZExheWVyc1tuXS5vcHRpb25zO3Q9dm9pZCAwPT09by5taW5ab29tP3Q6TWF0aC5taW4odCxvLm1pblpvb20pLGk9dm9pZCAwPT09by5tYXhab29tP2k6TWF0aC5tYXgoaSxvLm1heFpvb20pfXRoaXMuX2xheWVyc01heFpvb209aT09PS0xLzA/dm9pZCAwOmksdGhpcy5fbGF5ZXJzTWluWm9vbT10PT09MS8wP3ZvaWQgMDp0LGUhPT10aGlzLl9nZXRab29tU3BhbigpJiZ0aGlzLmZpcmUoXCJ6b29tbGV2ZWxzY2hhbmdlXCIpLHZvaWQgMD09PXRoaXMub3B0aW9ucy5tYXhab29tJiZ0aGlzLl9sYXllcnNNYXhab29tJiZ0aGlzLmdldFpvb20oKT50aGlzLl9sYXllcnNNYXhab29tJiZ0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSksdm9pZCAwPT09dGhpcy5vcHRpb25zLm1pblpvb20mJnRoaXMuX2xheWVyc01pblpvb20mJnRoaXMuZ2V0Wm9vbSgpPHRoaXMuX2xheWVyc01pblpvb20mJnRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKX19KTt2YXIgR2U9cWUuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7bCh0aGlzLGkpLHRoaXMuX2xheWVycz17fTt2YXIgZSxuO2lmKHQpZm9yKGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspdGhpcy5hZGRMYXllcih0W2VdKX0sYWRkTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5nZXRMYXllcklkKHQpO3JldHVybiB0aGlzLl9sYXllcnNbaV09dCx0aGlzLl9tYXAmJnRoaXMuX21hcC5hZGRMYXllcih0KSx0aGlzfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0KXt2YXIgaT10IGluIHRoaXMuX2xheWVycz90OnRoaXMuZ2V0TGF5ZXJJZCh0KTtyZXR1cm4gdGhpcy5fbWFwJiZ0aGlzLl9sYXllcnNbaV0mJnRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pLGRlbGV0ZSB0aGlzLl9sYXllcnNbaV0sdGhpc30saGFzTGF5ZXI6ZnVuY3Rpb24odCl7cmV0dXJuISF0JiYodCBpbiB0aGlzLl9sYXllcnN8fHRoaXMuZ2V0TGF5ZXJJZCh0KWluIHRoaXMuX2xheWVycyl9LGNsZWFyTGF5ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsdGhpcyl9LGludm9rZTpmdW5jdGlvbih0KXt2YXIgaSxlLG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2ZvcihpIGluIHRoaXMuX2xheWVycykoZT10aGlzLl9sYXllcnNbaV0pW3RdJiZlW3RdLmFwcGx5KGUsbik7cmV0dXJuIHRoaXN9LG9uQWRkOmZ1bmN0aW9uKHQpe3RoaXMuZWFjaExheWVyKHQuYWRkTGF5ZXIsdCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuZWFjaExheWVyKHQucmVtb3ZlTGF5ZXIsdCl9LGVhY2hMYXllcjpmdW5jdGlvbih0LGkpe2Zvcih2YXIgZSBpbiB0aGlzLl9sYXllcnMpdC5jYWxsKGksdGhpcy5fbGF5ZXJzW2VdKTtyZXR1cm4gdGhpc30sZ2V0TGF5ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2xheWVyc1t0XX0sZ2V0TGF5ZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuZWFjaExheWVyKHQucHVzaCx0KSx0fSxzZXRaSW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW52b2tlKFwic2V0WkluZGV4XCIsdCl9LGdldExheWVySWQ6ZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9fSksS2U9R2UuZXh0ZW5kKHthZGRMYXllcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oYXNMYXllcih0KT90aGlzOih0LmFkZEV2ZW50UGFyZW50KHRoaXMpLEdlLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsdCksdGhpcy5maXJlKFwibGF5ZXJhZGRcIix7bGF5ZXI6dH0pKX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGFzTGF5ZXIodCk/KHQgaW4gdGhpcy5fbGF5ZXJzJiYodD10aGlzLl9sYXllcnNbdF0pLHQucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyksR2UucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcyx0KSx0aGlzLmZpcmUoXCJsYXllcnJlbW92ZVwiLHtsYXllcjp0fSkpOnRoaXN9LHNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmludm9rZShcInNldFN0eWxlXCIsdCl9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludm9rZShcImJyaW5nVG9Gcm9udFwiKX0sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZva2UoXCJicmluZ1RvQmFja1wiKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFQ7Zm9yKHZhciBpIGluIHRoaXMuX2xheWVycyl7dmFyIGU9dGhpcy5fbGF5ZXJzW2ldO3QuZXh0ZW5kKGUuZ2V0Qm91bmRzP2UuZ2V0Qm91bmRzKCk6ZS5nZXRMYXRMbmcoKSl9cmV0dXJuIHR9fSksWWU9di5leHRlbmQoe29wdGlvbnM6e3BvcHVwQW5jaG9yOlswLDBdLHRvb2x0aXBBbmNob3I6WzAsMF19LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7bCh0aGlzLHQpfSxjcmVhdGVJY29uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jcmVhdGVJY29uKFwiaWNvblwiLHQpfSxjcmVhdGVTaGFkb3c6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oXCJzaGFkb3dcIix0KX0sX2NyZWF0ZUljb246ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLl9nZXRJY29uVXJsKHQpO2lmKCFlKXtpZihcImljb25cIj09PXQpdGhyb3cgbmV3IEVycm9yKFwiaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS5cIik7cmV0dXJuIG51bGx9dmFyIG49dGhpcy5fY3JlYXRlSW1nKGUsaSYmXCJJTUdcIj09PWkudGFnTmFtZT9pOm51bGwpO3JldHVybiB0aGlzLl9zZXRJY29uU3R5bGVzKG4sdCksbn0sX3NldEljb25TdHlsZXM6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLm9wdGlvbnMsbj1lW2krXCJTaXplXCJdO1wibnVtYmVyXCI9PXR5cGVvZiBuJiYobj1bbixuXSk7dmFyIG89dyhuKSxzPXcoXCJzaGFkb3dcIj09PWkmJmUuc2hhZG93QW5jaG9yfHxlLmljb25BbmNob3J8fG8mJm8uZGl2aWRlQnkoMiwhMCkpO3QuY2xhc3NOYW1lPVwibGVhZmxldC1tYXJrZXItXCIraStcIiBcIisoZS5jbGFzc05hbWV8fFwiXCIpLHMmJih0LnN0eWxlLm1hcmdpbkxlZnQ9LXMueCtcInB4XCIsdC5zdHlsZS5tYXJnaW5Ub3A9LXMueStcInB4XCIpLG8mJih0LnN0eWxlLndpZHRoPW8ueCtcInB4XCIsdC5zdHlsZS5oZWlnaHQ9by55K1wicHhcIil9LF9jcmVhdGVJbWc6ZnVuY3Rpb24odCxpKXtyZXR1cm4gaT1pfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLGkuc3JjPXQsaX0sX2dldEljb25Vcmw6ZnVuY3Rpb24odCl7cmV0dXJuIFlpJiZ0aGlzLm9wdGlvbnNbdCtcIlJldGluYVVybFwiXXx8dGhpcy5vcHRpb25zW3QrXCJVcmxcIl19fSksWGU9WWUuZXh0ZW5kKHtvcHRpb25zOntpY29uVXJsOlwibWFya2VyLWljb24ucG5nXCIsaWNvblJldGluYVVybDpcIm1hcmtlci1pY29uLTJ4LnBuZ1wiLHNoYWRvd1VybDpcIm1hcmtlci1zaGFkb3cucG5nXCIsaWNvblNpemU6WzI1LDQxXSxpY29uQW5jaG9yOlsxMiw0MV0scG9wdXBBbmNob3I6WzEsLTM0XSx0b29sdGlwQW5jaG9yOlsxNiwtMjhdLHNoYWRvd1NpemU6WzQxLDQxXX0sX2dldEljb25Vcmw6ZnVuY3Rpb24odCl7cmV0dXJuIFhlLmltYWdlUGF0aHx8KFhlLmltYWdlUGF0aD10aGlzLl9kZXRlY3RJY29uUGF0aCgpKSwodGhpcy5vcHRpb25zLmltYWdlUGF0aHx8WGUuaW1hZ2VQYXRoKStZZS5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLHQpfSxfZGV0ZWN0SWNvblBhdGg6ZnVuY3Rpb24oKXt2YXIgdD1HKFwiZGl2XCIsXCJsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoXCIsZG9jdW1lbnQuYm9keSksaT1xKHQsXCJiYWNrZ3JvdW5kLWltYWdlXCIpfHxxKHQsXCJiYWNrZ3JvdW5kSW1hZ2VcIik7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksaT1udWxsPT09aXx8MCE9PWkuaW5kZXhPZihcInVybFwiKT9cIlwiOmkucmVwbGFjZSgvXnVybFxcKFtcIiddPy8sXCJcIikucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLyxcIlwiKX19KSxKZT1FZS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbWFya2VyPXR9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFya2VyLl9pY29uO3RoaXMuX2RyYWdnYWJsZXx8KHRoaXMuX2RyYWdnYWJsZT1uZXcgUmUodCx0LCEwKSksdGhpcy5fZHJhZ2dhYmxlLm9uKHtkcmFnc3RhcnQ6dGhpcy5fb25EcmFnU3RhcnQscHJlZHJhZzp0aGlzLl9vblByZURyYWcsZHJhZzp0aGlzLl9vbkRyYWcsZHJhZ2VuZDp0aGlzLl9vbkRyYWdFbmR9LHRoaXMpLmVuYWJsZSgpLFEodCxcImxlYWZsZXQtbWFya2VyLWRyYWdnYWJsZVwiKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXt0aGlzLl9kcmFnZ2FibGUub2ZmKHtkcmFnc3RhcnQ6dGhpcy5fb25EcmFnU3RhcnQscHJlZHJhZzp0aGlzLl9vblByZURyYWcsZHJhZzp0aGlzLl9vbkRyYWcsZHJhZ2VuZDp0aGlzLl9vbkRyYWdFbmR9LHRoaXMpLmRpc2FibGUoKSx0aGlzLl9tYXJrZXIuX2ljb24mJnR0KHRoaXMuX21hcmtlci5faWNvbixcImxlYWZsZXQtbWFya2VyLWRyYWdnYWJsZVwiKX0sbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlJiZ0aGlzLl9kcmFnZ2FibGUuX21vdmVkfSxfYWRqdXN0UGFuOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcmtlcixlPWkuX21hcCxuPXRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxvPXRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLHM9aHQoaS5faWNvbikscj1lLmdldFBpeGVsQm91bmRzKCksYT1lLmdldFBpeGVsT3JpZ2luKCksaD1iKHIubWluLl9zdWJ0cmFjdChhKS5hZGQobyksci5tYXguX3N1YnRyYWN0KGEpLnN1YnRyYWN0KG8pKTtpZighaC5jb250YWlucyhzKSl7dmFyIHU9dygoTWF0aC5tYXgoaC5tYXgueCxzLngpLWgubWF4LngpLyhyLm1heC54LWgubWF4LngpLShNYXRoLm1pbihoLm1pbi54LHMueCktaC5taW4ueCkvKHIubWluLngtaC5taW4ueCksKE1hdGgubWF4KGgubWF4Lnkscy55KS1oLm1heC55KS8oci5tYXgueS1oLm1heC55KS0oTWF0aC5taW4oaC5taW4ueSxzLnkpLWgubWluLnkpLyhyLm1pbi55LWgubWluLnkpKS5tdWx0aXBseUJ5KG4pO2UucGFuQnkodSx7YW5pbWF0ZTohMX0pLHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQodSksdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKHUpLGF0KGkuX2ljb24sdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpLHRoaXMuX29uRHJhZyh0KSx0aGlzLl9wYW5SZXF1ZXN0PWYodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcyx0KSl9fSxfb25EcmFnU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9vbGRMYXRMbmc9dGhpcy5fbWFya2VyLmdldExhdExuZygpLHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCkuZmlyZShcIm1vdmVzdGFydFwiKS5maXJlKFwiZHJhZ3N0YXJ0XCIpfSxfb25QcmVEcmFnOmZ1bmN0aW9uKHQpe3RoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4mJihnKHRoaXMuX3BhblJlcXVlc3QpLHRoaXMuX3BhblJlcXVlc3Q9Zih0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLHQpKSl9LF9vbkRyYWc6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFya2VyLGU9aS5fc2hhZG93LG49aHQoaS5faWNvbiksbz1pLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKG4pO2UmJmF0KGUsbiksaS5fbGF0bG5nPW8sdC5sYXRsbmc9byx0Lm9sZExhdExuZz10aGlzLl9vbGRMYXRMbmcsaS5maXJlKFwibW92ZVwiLHQpLmZpcmUoXCJkcmFnXCIsdCl9LF9vbkRyYWdFbmQ6ZnVuY3Rpb24odCl7Zyh0aGlzLl9wYW5SZXF1ZXN0KSxkZWxldGUgdGhpcy5fb2xkTGF0TG5nLHRoaXMuX21hcmtlci5maXJlKFwibW92ZWVuZFwiKS5maXJlKFwiZHJhZ2VuZFwiLHQpfX0pLCRlPXFlLmV4dGVuZCh7b3B0aW9uczp7aWNvbjpuZXcgWGUsaW50ZXJhY3RpdmU6ITAsa2V5Ym9hcmQ6ITAsdGl0bGU6XCJcIixhbHQ6XCJcIix6SW5kZXhPZmZzZXQ6MCxvcGFjaXR5OjEscmlzZU9uSG92ZXI6ITEscmlzZU9mZnNldDoyNTAscGFuZTpcIm1hcmtlclBhbmVcIixidWJibGluZ01vdXNlRXZlbnRzOiExLGRyYWdnYWJsZTohMSxhdXRvUGFuOiExLGF1dG9QYW5QYWRkaW5nOls1MCw1MF0sYXV0b1BhblNwZWVkOjEwfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7bCh0aGlzLGkpLHRoaXMuX2xhdGxuZz1DKHQpfSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl96b29tQW5pbWF0ZWQ9dGhpcy5fem9vbUFuaW1hdGVkJiZ0Lm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbix0aGlzLl96b29tQW5pbWF0ZWQmJnQub24oXCJ6b29tYW5pbVwiLHRoaXMuX2FuaW1hdGVab29tLHRoaXMpLHRoaXMuX2luaXRJY29uKCksdGhpcy51cGRhdGUoKX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dGhpcy5kcmFnZ2luZyYmdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkmJih0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlPSEwLHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKSksZGVsZXRlIHRoaXMuZHJhZ2dpbmcsdGhpcy5fem9vbUFuaW1hdGVkJiZ0Lm9mZihcInpvb21hbmltXCIsdGhpcy5fYW5pbWF0ZVpvb20sdGhpcyksdGhpcy5fcmVtb3ZlSWNvbigpLHRoaXMuX3JlbW92ZVNoYWRvdygpfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXtyZXR1cm57em9vbTp0aGlzLnVwZGF0ZSx2aWV3cmVzZXQ6dGhpcy51cGRhdGV9fSxnZXRMYXRMbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nfSxzZXRMYXRMbmc6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbGF0bG5nO3JldHVybiB0aGlzLl9sYXRsbmc9Qyh0KSx0aGlzLnVwZGF0ZSgpLHRoaXMuZmlyZShcIm1vdmVcIix7b2xkTGF0TG5nOmksbGF0bG5nOnRoaXMuX2xhdGxuZ30pfSxzZXRaSW5kZXhPZmZzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ9dCx0aGlzLnVwZGF0ZSgpfSxzZXRJY29uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbj10LHRoaXMuX21hcCYmKHRoaXMuX2luaXRJY29uKCksdGhpcy51cGRhdGUoKSksdGhpcy5fcG9wdXAmJnRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLHRoaXMuX3BvcHVwLm9wdGlvbnMpLHRoaXN9LGdldEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWNvbn0sdXBkYXRlOmZ1bmN0aW9uKCl7aWYodGhpcy5faWNvbiYmdGhpcy5fbWFwKXt2YXIgdD10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTt0aGlzLl9zZXRQb3ModCl9cmV0dXJuIHRoaXN9LF9pbml0SWNvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucyxpPVwibGVhZmxldC16b29tLVwiKyh0aGlzLl96b29tQW5pbWF0ZWQ/XCJhbmltYXRlZFwiOlwiaGlkZVwiKSxlPXQuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLG49ITE7ZSE9PXRoaXMuX2ljb24mJih0aGlzLl9pY29uJiZ0aGlzLl9yZW1vdmVJY29uKCksbj0hMCx0LnRpdGxlJiYoZS50aXRsZT10LnRpdGxlKSxcIklNR1wiPT09ZS50YWdOYW1lJiYoZS5hbHQ9dC5hbHR8fFwiXCIpKSxRKGUsaSksdC5rZXlib2FyZCYmKGUudGFiSW5kZXg9XCIwXCIpLHRoaXMuX2ljb249ZSx0LnJpc2VPbkhvdmVyJiZ0aGlzLm9uKHttb3VzZW92ZXI6dGhpcy5fYnJpbmdUb0Zyb250LG1vdXNlb3V0OnRoaXMuX3Jlc2V0WkluZGV4fSk7dmFyIG89dC5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLHM9ITE7byE9PXRoaXMuX3NoYWRvdyYmKHRoaXMuX3JlbW92ZVNoYWRvdygpLHM9ITApLG8mJihRKG8saSksby5hbHQ9XCJcIiksdGhpcy5fc2hhZG93PW8sdC5vcGFjaXR5PDEmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSxuJiZ0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKSx0aGlzLl9pbml0SW50ZXJhY3Rpb24oKSxvJiZzJiZ0aGlzLmdldFBhbmUoXCJzaGFkb3dQYW5lXCIpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyl9LF9yZW1vdmVJY29uOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyJiZ0aGlzLm9mZih7bW91c2VvdmVyOnRoaXMuX2JyaW5nVG9Gcm9udCxtb3VzZW91dDp0aGlzLl9yZXNldFpJbmRleH0pLEsodGhpcy5faWNvbiksdGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKSx0aGlzLl9pY29uPW51bGx9LF9yZW1vdmVTaGFkb3c6ZnVuY3Rpb24oKXt0aGlzLl9zaGFkb3cmJksodGhpcy5fc2hhZG93KSx0aGlzLl9zaGFkb3c9bnVsbH0sX3NldFBvczpmdW5jdGlvbih0KXthdCh0aGlzLl9pY29uLHQpLHRoaXMuX3NoYWRvdyYmYXQodGhpcy5fc2hhZG93LHQpLHRoaXMuX3pJbmRleD10LnkrdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCx0aGlzLl9yZXNldFpJbmRleCgpfSxfdXBkYXRlWkluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuX2ljb24uc3R5bGUuekluZGV4PXRoaXMuX3pJbmRleCt0fSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLHQuem9vbSx0LmNlbnRlcikucm91bmQoKTt0aGlzLl9zZXRQb3MoaSl9LF9pbml0SW50ZXJhY3Rpb246ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUmJihRKHRoaXMuX2ljb24sXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbiksSmUpKXt2YXIgdD10aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO3RoaXMuZHJhZ2dpbmcmJih0PXRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpLHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpKSx0aGlzLmRyYWdnaW5nPW5ldyBKZSh0aGlzKSx0JiZ0aGlzLmRyYWdnaW5nLmVuYWJsZSgpfX0sc2V0T3BhY2l0eTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzfSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5vcGFjaXR5O250KHRoaXMuX2ljb24sdCksdGhpcy5fc2hhZG93JiZudCh0aGlzLl9zaGFkb3csdCl9LF9icmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpfSxfcmVzZXRaSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVaSW5kZXgoMCl9LF9nZXRQb3B1cEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yfSxfZ2V0VG9vbHRpcEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3J9fSksUWU9cWUuZXh0ZW5kKHtvcHRpb25zOntzdHJva2U6ITAsY29sb3I6XCIjMzM4OGZmXCIsd2VpZ2h0OjMsb3BhY2l0eToxLGxpbmVDYXA6XCJyb3VuZFwiLGxpbmVKb2luOlwicm91bmRcIixkYXNoQXJyYXk6bnVsbCxkYXNoT2Zmc2V0Om51bGwsZmlsbDohMSxmaWxsQ29sb3I6bnVsbCxmaWxsT3BhY2l0eTouMixmaWxsUnVsZTpcImV2ZW5vZGRcIixpbnRlcmFjdGl2ZTohMCxidWJibGluZ01vdXNlRXZlbnRzOiEwfSxiZWZvcmVBZGQ6ZnVuY3Rpb24odCl7dGhpcy5fcmVuZGVyZXI9dC5nZXRSZW5kZXJlcih0aGlzKX0sb25BZGQ6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyksdGhpcy5fcmVzZXQoKSx0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKX0sb25SZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKX0scmVkcmF3OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyksdGhpc30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7cmV0dXJuIGwodGhpcyx0KSx0aGlzLl9yZW5kZXJlciYmdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpLHRoaXN9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJlciYmdGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKSx0aGlzfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJlciYmdGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpLHRoaXN9LGdldEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF0aH0sX3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcHJvamVjdCgpLHRoaXMuX3VwZGF0ZSgpfSxfY2xpY2tUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5vcHRpb25zLnN0cm9rZT90aGlzLm9wdGlvbnMud2VpZ2h0LzI6MCkrdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2V9fSksdG49UWUuZXh0ZW5kKHtvcHRpb25zOntmaWxsOiEwLHJhZGl1czoxMH0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe2wodGhpcyxpKSx0aGlzLl9sYXRsbmc9Qyh0KSx0aGlzLl9yYWRpdXM9dGhpcy5vcHRpb25zLnJhZGl1c30sc2V0TGF0TG5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9sYXRsbmc9Qyh0KSx0aGlzLnJlZHJhdygpLHRoaXMuZmlyZShcIm1vdmVcIix7bGF0bG5nOnRoaXMuX2xhdGxuZ30pfSxnZXRMYXRMbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nfSxzZXRSYWRpdXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5yYWRpdXM9dGhpcy5fcmFkaXVzPXQsdGhpcy5yZWRyYXcoKX0sZ2V0UmFkaXVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JhZGl1c30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7dmFyIGk9dCYmdC5yYWRpdXN8fHRoaXMuX3JhZGl1cztyZXR1cm4gUWUucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcyx0KSx0aGlzLnNldFJhZGl1cyhpKSx0aGlzfSxfcHJvamVjdDpmdW5jdGlvbigpe3RoaXMuX3BvaW50PXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSx0aGlzLl91cGRhdGVCb3VuZHMoKX0sX3VwZGF0ZUJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3JhZGl1cyxpPXRoaXMuX3JhZGl1c1l8fHQsZT10aGlzLl9jbGlja1RvbGVyYW5jZSgpLG49W3QrZSxpK2VdO3RoaXMuX3B4Qm91bmRzPW5ldyBQKHRoaXMuX3BvaW50LnN1YnRyYWN0KG4pLHRoaXMuX3BvaW50LmFkZChuKSl9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZVBhdGgoKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpfSxfZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmFkaXVzJiYhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKX0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCk8PXRoaXMuX3JhZGl1cyt0aGlzLl9jbGlja1RvbGVyYW5jZSgpfX0pLGVuPXRuLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUsbil7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUmJihlPWkoe30sbix7cmFkaXVzOmV9KSksbCh0aGlzLGUpLHRoaXMuX2xhdGxuZz1DKHQpLGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKXRocm93IG5ldyBFcnJvcihcIkNpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTlwiKTt0aGlzLl9tUmFkaXVzPXRoaXMub3B0aW9ucy5yYWRpdXN9LHNldFJhZGl1czpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbVJhZGl1cz10LHRoaXMucmVkcmF3KCl9LGdldFJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tUmFkaXVzfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgdD1bdGhpcy5fcmFkaXVzLHRoaXMuX3JhZGl1c1l8fHRoaXMuX3JhZGl1c107cmV0dXJuIG5ldyBUKHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QodCkpLHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKHQpKSl9LHNldFN0eWxlOlFlLnByb3RvdHlwZS5zZXRTdHlsZSxfcHJvamVjdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2xhdGxuZy5sbmcsaT10aGlzLl9sYXRsbmcubGF0LGU9dGhpcy5fbWFwLG49ZS5vcHRpb25zLmNycztpZihuLmRpc3RhbmNlPT09cGkuZGlzdGFuY2Upe3ZhciBvPU1hdGguUEkvMTgwLHM9dGhpcy5fbVJhZGl1cy9waS5SL28scj1lLnByb2plY3QoW2krcyx0XSksYT1lLnByb2plY3QoW2ktcyx0XSksaD1yLmFkZChhKS5kaXZpZGVCeSgyKSx1PWUudW5wcm9qZWN0KGgpLmxhdCxsPU1hdGguYWNvcygoTWF0aC5jb3MocypvKS1NYXRoLnNpbihpKm8pKk1hdGguc2luKHUqbykpLyhNYXRoLmNvcyhpKm8pKk1hdGguY29zKHUqbykpKS9vOyhpc05hTihsKXx8MD09PWwpJiYobD1zL01hdGguY29zKE1hdGguUEkvMTgwKmkpKSx0aGlzLl9wb2ludD1oLnN1YnRyYWN0KGUuZ2V0UGl4ZWxPcmlnaW4oKSksdGhpcy5fcmFkaXVzPWlzTmFOKGwpPzA6aC54LWUucHJvamVjdChbdSx0LWxdKS54LHRoaXMuX3JhZGl1c1k9aC55LXIueX1lbHNle3ZhciBjPW4udW5wcm9qZWN0KG4ucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLDBdKSk7dGhpcy5fcG9pbnQ9ZS5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSx0aGlzLl9yYWRpdXM9dGhpcy5fcG9pbnQueC1lLmxhdExuZ1RvTGF5ZXJQb2ludChjKS54fXRoaXMuX3VwZGF0ZUJvdW5kcygpfX0pLG5uPVFlLmV4dGVuZCh7b3B0aW9uczp7c21vb3RoRmFjdG9yOjEsbm9DbGlwOiExfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7bCh0aGlzLGkpLHRoaXMuX3NldExhdExuZ3ModCl9LGdldExhdExuZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nc30sc2V0TGF0TG5nczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc2V0TGF0TG5ncyh0KSx0aGlzLnJlZHJhdygpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuX2xhdGxuZ3MubGVuZ3RofSxjbG9zZXN0TGF5ZXJQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGksZSxuPTEvMCxvPW51bGwscz1EdCxyPTAsYT10aGlzLl9wYXJ0cy5sZW5ndGg7cjxhO3IrKylmb3IodmFyIGg9dGhpcy5fcGFydHNbcl0sdT0xLGw9aC5sZW5ndGg7dTxsO3UrKyl7dmFyIGM9cyh0LGk9aFt1LTFdLGU9aFt1XSwhMCk7YzxuJiYobj1jLG89cyh0LGksZSkpfXJldHVybiBvJiYoby5kaXN0YW5jZT1NYXRoLnNxcnQobikpLG99LGdldENlbnRlcjpmdW5jdGlvbigpe2lmKCF0aGlzLl9tYXApdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKVwiKTt2YXIgdCxpLGUsbixvLHMscixhPXRoaXMuX3JpbmdzWzBdLGg9YS5sZW5ndGg7aWYoIWgpcmV0dXJuIG51bGw7Zm9yKHQ9MCxpPTA7dDxoLTE7dCsrKWkrPWFbdF0uZGlzdGFuY2VUbyhhW3QrMV0pLzI7aWYoMD09PWkpcmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoYVswXSk7Zm9yKHQ9MCxuPTA7dDxoLTE7dCsrKWlmKG89YVt0XSxzPWFbdCsxXSxlPW8uZGlzdGFuY2VUbyhzKSwobis9ZSk+aSlyZXR1cm4gcj0obi1pKS9lLHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW3MueC1yKihzLngtby54KSxzLnktcioocy55LW8ueSldKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kc30sYWRkTGF0TG5nOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIGk9aXx8dGhpcy5fZGVmYXVsdFNoYXBlKCksdD1DKHQpLGkucHVzaCh0KSx0aGlzLl9ib3VuZHMuZXh0ZW5kKHQpLHRoaXMucmVkcmF3KCl9LF9zZXRMYXRMbmdzOmZ1bmN0aW9uKHQpe3RoaXMuX2JvdW5kcz1uZXcgVCx0aGlzLl9sYXRsbmdzPXRoaXMuX2NvbnZlcnRMYXRMbmdzKHQpfSxfZGVmYXVsdFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIGp0KHRoaXMuX2xhdGxuZ3MpP3RoaXMuX2xhdGxuZ3M6dGhpcy5fbGF0bG5nc1swXX0sX2NvbnZlcnRMYXRMbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaT1bXSxlPWp0KHQpLG49MCxvPXQubGVuZ3RoO248bztuKyspZT8oaVtuXT1DKHRbbl0pLHRoaXMuX2JvdW5kcy5leHRlbmQoaVtuXSkpOmlbbl09dGhpcy5fY29udmVydExhdExuZ3ModFtuXSk7cmV0dXJuIGl9LF9wcm9qZWN0OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dGhpcy5fcmluZ3M9W10sdGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncyx0aGlzLl9yaW5ncyx0KTt2YXIgaT10aGlzLl9jbGlja1RvbGVyYW5jZSgpLGU9bmV3IHgoaSxpKTt0aGlzLl9ib3VuZHMuaXNWYWxpZCgpJiZ0LmlzVmFsaWQoKSYmKHQubWluLl9zdWJ0cmFjdChlKSx0Lm1heC5fYWRkKGUpLHRoaXMuX3B4Qm91bmRzPXQpfSxfcHJvamVjdExhdGxuZ3M6ZnVuY3Rpb24odCxpLGUpe3ZhciBuLG8scz10WzBdaW5zdGFuY2VvZiBNLHI9dC5sZW5ndGg7aWYocyl7Zm9yKG89W10sbj0wO248cjtuKyspb1tuXT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRbbl0pLGUuZXh0ZW5kKG9bbl0pO2kucHVzaChvKX1lbHNlIGZvcihuPTA7bjxyO24rKyl0aGlzLl9wcm9qZWN0TGF0bG5ncyh0W25dLGksZSl9LF9jbGlwUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmVuZGVyZXIuX2JvdW5kcztpZih0aGlzLl9wYXJ0cz1bXSx0aGlzLl9weEJvdW5kcyYmdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyh0KSlpZih0aGlzLm9wdGlvbnMubm9DbGlwKXRoaXMuX3BhcnRzPXRoaXMuX3JpbmdzO2Vsc2V7dmFyIGksZSxuLG8scyxyLGEsaD10aGlzLl9wYXJ0cztmb3IoaT0wLG49MCxvPXRoaXMuX3JpbmdzLmxlbmd0aDtpPG87aSsrKWZvcihlPTAscz0oYT10aGlzLl9yaW5nc1tpXSkubGVuZ3RoO2U8cy0xO2UrKykocj1JdChhW2VdLGFbZSsxXSx0LGUsITApKSYmKGhbbl09aFtuXXx8W10saFtuXS5wdXNoKHJbMF0pLHJbMV09PT1hW2UrMV0mJmUhPT1zLTJ8fChoW25dLnB1c2goclsxXSksbisrKSl9fSxfc2ltcGxpZnlQb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fcGFydHMsaT10aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yLGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspdFtlXT1adCh0W2VdLGkpfSxfdXBkYXRlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiYodGhpcy5fY2xpcFBvaW50cygpLHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCksdGhpcy5fdXBkYXRlUGF0aCgpKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKX0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCxpKXt2YXIgZSxuLG8scyxyLGEsaD10aGlzLl9jbGlja1RvbGVyYW5jZSgpO2lmKCF0aGlzLl9weEJvdW5kc3x8IXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihlPTAscz10aGlzLl9wYXJ0cy5sZW5ndGg7ZTxzO2UrKylmb3Iobj0wLG89KHI9KGE9dGhpcy5fcGFydHNbZV0pLmxlbmd0aCktMTtuPHI7bz1uKyspaWYoKGl8fDAhPT1uKSYmRXQodCxhW29dLGFbbl0pPD1oKXJldHVybiEwO3JldHVybiExfX0pO25uLl9mbGF0PVd0O3ZhciBvbj1ubi5leHRlbmQoe29wdGlvbnM6e2ZpbGw6ITB9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fbGF0bG5ncy5sZW5ndGh8fCF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aH0sZ2V0Q2VudGVyOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX21hcCl0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpXCIpO3ZhciB0LGksZSxuLG8scyxyLGEsaCx1PXRoaXMuX3JpbmdzWzBdLGw9dS5sZW5ndGg7aWYoIWwpcmV0dXJuIG51bGw7Zm9yKHM9cj1hPTAsdD0wLGk9bC0xO3Q8bDtpPXQrKyllPXVbdF0sbj11W2ldLG89ZS55Km4ueC1uLnkqZS54LHIrPShlLngrbi54KSpvLGErPShlLnkrbi55KSpvLHMrPTMqbztyZXR1cm4gaD0wPT09cz91WzBdOltyL3MsYS9zXSx0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGgpfSxfY29udmVydExhdExuZ3M6ZnVuY3Rpb24odCl7dmFyIGk9bm4ucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsdCksZT1pLmxlbmd0aDtyZXR1cm4gZT49MiYmaVswXWluc3RhbmNlb2YgTSYmaVswXS5lcXVhbHMoaVtlLTFdKSYmaS5wb3AoKSxpfSxfc2V0TGF0TG5nczpmdW5jdGlvbih0KXtubi5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLHQpLGp0KHRoaXMuX2xhdGxuZ3MpJiYodGhpcy5fbGF0bG5ncz1bdGhpcy5fbGF0bG5nc10pfSxfZGVmYXVsdFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIGp0KHRoaXMuX2xhdGxuZ3NbMF0pP3RoaXMuX2xhdGxuZ3NbMF06dGhpcy5fbGF0bG5nc1swXVswXX0sX2NsaXBQb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yZW5kZXJlci5fYm91bmRzLGk9dGhpcy5vcHRpb25zLndlaWdodCxlPW5ldyB4KGksaSk7aWYodD1uZXcgUCh0Lm1pbi5zdWJ0cmFjdChlKSx0Lm1heC5hZGQoZSkpLHRoaXMuX3BhcnRzPVtdLHRoaXMuX3B4Qm91bmRzJiZ0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKHQpKWlmKHRoaXMub3B0aW9ucy5ub0NsaXApdGhpcy5fcGFydHM9dGhpcy5fcmluZ3M7ZWxzZSBmb3IodmFyIG4sbz0wLHM9dGhpcy5fcmluZ3MubGVuZ3RoO288cztvKyspKG49SHQodGhpcy5fcmluZ3Nbb10sdCwhMCkpLmxlbmd0aCYmdGhpcy5fcGFydHMucHVzaChuKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCEwKX0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGksZSxuLG8scyxyLGEsaCx1PSExO2lmKCF0aGlzLl9weEJvdW5kc3x8IXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihvPTAsYT10aGlzLl9wYXJ0cy5sZW5ndGg7bzxhO28rKylmb3Iocz0wLHI9KGg9KGk9dGhpcy5fcGFydHNbb10pLmxlbmd0aCktMTtzPGg7cj1zKyspZT1pW3NdLG49aVtyXSxlLnk+dC55IT1uLnk+dC55JiZ0Lng8KG4ueC1lLngpKih0LnktZS55KS8obi55LWUueSkrZS54JiYodT0hdSk7cmV0dXJuIHV8fG5uLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsdCwhMCl9fSksc249S2UuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7bCh0aGlzLGkpLHRoaXMuX2xheWVycz17fSx0JiZ0aGlzLmFkZERhdGEodCl9LGFkZERhdGE6ZnVuY3Rpb24odCl7dmFyIGksZSxuLG89b2kodCk/dDp0LmZlYXR1cmVzO2lmKG8pe2ZvcihpPTAsZT1vLmxlbmd0aDtpPGU7aSsrKSgobj1vW2ldKS5nZW9tZXRyaWVzfHxuLmdlb21ldHJ5fHxuLmZlYXR1cmVzfHxuLmNvb3JkaW5hdGVzKSYmdGhpcy5hZGREYXRhKG4pO3JldHVybiB0aGlzfXZhciBzPXRoaXMub3B0aW9ucztpZihzLmZpbHRlciYmIXMuZmlsdGVyKHQpKXJldHVybiB0aGlzO3ZhciByPUZ0KHQscyk7cmV0dXJuIHI/KHIuZmVhdHVyZT1ZdCh0KSxyLmRlZmF1bHRPcHRpb25zPXIub3B0aW9ucyx0aGlzLnJlc2V0U3R5bGUocikscy5vbkVhY2hGZWF0dXJlJiZzLm9uRWFjaEZlYXR1cmUodCxyKSx0aGlzLmFkZExheWVyKHIpKTp0aGlzfSxyZXNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiB0Lm9wdGlvbnM9aSh7fSx0LmRlZmF1bHRPcHRpb25zKSx0aGlzLl9zZXRMYXllclN0eWxlKHQsdGhpcy5vcHRpb25zLnN0eWxlKSx0aGlzfSxzZXRTdHlsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oaSl7dGhpcy5fc2V0TGF5ZXJTdHlsZShpLHQpfSx0aGlzKX0sX3NldExheWVyU3R5bGU6ZnVuY3Rpb24odCxpKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiYoaT1pKHQuZmVhdHVyZSkpLHQuc2V0U3R5bGUmJnQuc2V0U3R5bGUoaSl9fSkscm49e3RvR2VvSlNPTjpmdW5jdGlvbih0KXtyZXR1cm4gS3QodGhpcyx7dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6cXQodGhpcy5nZXRMYXRMbmcoKSx0KX0pfX07JGUuaW5jbHVkZShybiksZW4uaW5jbHVkZShybiksdG4uaW5jbHVkZShybiksbm4uaW5jbHVkZSh7dG9HZW9KU09OOmZ1bmN0aW9uKHQpe3ZhciBpPSFqdCh0aGlzLl9sYXRsbmdzKSxlPUd0KHRoaXMuX2xhdGxuZ3MsaT8xOjAsITEsdCk7cmV0dXJuIEt0KHRoaXMse3R5cGU6KGk/XCJNdWx0aVwiOlwiXCIpK1wiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9KX19KSxvbi5pbmNsdWRlKHt0b0dlb0pTT046ZnVuY3Rpb24odCl7dmFyIGk9IWp0KHRoaXMuX2xhdGxuZ3MpLGU9aSYmIWp0KHRoaXMuX2xhdGxuZ3NbMF0pLG49R3QodGhpcy5fbGF0bG5ncyxlPzI6aT8xOjAsITAsdCk7cmV0dXJuIGl8fChuPVtuXSksS3QodGhpcyx7dHlwZTooZT9cIk11bHRpXCI6XCJcIikrXCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6bn0pfX0pLEdlLmluY2x1ZGUoe3RvTXVsdGlQb2ludDpmdW5jdGlvbih0KXt2YXIgaT1bXTtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oZSl7aS5wdXNoKGUudG9HZW9KU09OKHQpLmdlb21ldHJ5LmNvb3JkaW5hdGVzKX0pLEt0KHRoaXMse3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6aX0pfSx0b0dlb0pTT046ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5mZWF0dXJlJiZ0aGlzLmZlYXR1cmUuZ2VvbWV0cnkmJnRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO2lmKFwiTXVsdGlQb2ludFwiPT09aSlyZXR1cm4gdGhpcy50b011bHRpUG9pbnQodCk7dmFyIGU9XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PWksbj1bXTtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oaSl7aWYoaS50b0dlb0pTT04pe3ZhciBvPWkudG9HZW9KU09OKHQpO2lmKGUpbi5wdXNoKG8uZ2VvbWV0cnkpO2Vsc2V7dmFyIHM9WXQobyk7XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09cy50eXBlP24ucHVzaC5hcHBseShuLHMuZmVhdHVyZXMpOm4ucHVzaChzKX19fSksZT9LdCh0aGlzLHtnZW9tZXRyaWVzOm4sdHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwifSk6e3R5cGU6XCJGZWF0dXJlQ29sbGVjdGlvblwiLGZlYXR1cmVzOm59fX0pO3ZhciBhbj1YdCxobj1xZS5leHRlbmQoe29wdGlvbnM6e29wYWNpdHk6MSxhbHQ6XCJcIixpbnRlcmFjdGl2ZTohMSxjcm9zc09yaWdpbjohMSxlcnJvck92ZXJsYXlVcmw6XCJcIix6SW5kZXg6MSxjbGFzc05hbWU6XCJcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGksZSl7dGhpcy5fdXJsPXQsdGhpcy5fYm91bmRzPXooaSksbCh0aGlzLGUpfSxvbkFkZDpmdW5jdGlvbigpe3RoaXMuX2ltYWdlfHwodGhpcy5faW5pdEltYWdlKCksdGhpcy5vcHRpb25zLm9wYWNpdHk8MSYmdGhpcy5fdXBkYXRlT3BhY2l0eSgpKSx0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUmJihRKHRoaXMuX2ltYWdlLFwibGVhZmxldC1pbnRlcmFjdGl2ZVwiKSx0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKSksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpLHRoaXMuX3Jlc2V0KCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7Syh0aGlzLl9pbWFnZSksdGhpcy5vcHRpb25zLmludGVyYWN0aXZlJiZ0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKX0sc2V0T3BhY2l0eTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9pbWFnZSYmdGhpcy5fdXBkYXRlT3BhY2l0eSgpLHRoaXN9LHNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiB0Lm9wYWNpdHkmJnRoaXMuc2V0T3BhY2l0eSh0Lm9wYWNpdHkpLHRoaXN9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJlgodGhpcy5faW1hZ2UpLHRoaXN9LGJyaW5nVG9CYWNrOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmSih0aGlzLl9pbWFnZSksdGhpc30sc2V0VXJsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl91cmw9dCx0aGlzLl9pbWFnZSYmKHRoaXMuX2ltYWdlLnNyYz10KSx0aGlzfSxzZXRCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JvdW5kcz16KHQpLHRoaXMuX21hcCYmdGhpcy5fcmVzZXQoKSx0aGlzfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXt2YXIgdD17em9vbTp0aGlzLl9yZXNldCx2aWV3cmVzZXQ6dGhpcy5fcmVzZXR9O3JldHVybiB0aGlzLl96b29tQW5pbWF0ZWQmJih0Lnpvb21hbmltPXRoaXMuX2FuaW1hdGVab29tKSx0fSxzZXRaSW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy56SW5kZXg9dCx0aGlzLl91cGRhdGVaSW5kZXgoKSx0aGlzfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ltYWdlfSxfaW5pdEltYWdlOmZ1bmN0aW9uKCl7dmFyIHQ9XCJJTUdcIj09PXRoaXMuX3VybC50YWdOYW1lLGk9dGhpcy5faW1hZ2U9dD90aGlzLl91cmw6RyhcImltZ1wiKTtRKGksXCJsZWFmbGV0LWltYWdlLWxheWVyXCIpLHRoaXMuX3pvb21BbmltYXRlZCYmUShpLFwibGVhZmxldC16b29tLWFuaW1hdGVkXCIpLHRoaXMub3B0aW9ucy5jbGFzc05hbWUmJlEoaSx0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSxpLm9uc2VsZWN0c3RhcnQ9cixpLm9ubW91c2Vtb3ZlPXIsaS5vbmxvYWQ9ZSh0aGlzLmZpcmUsdGhpcyxcImxvYWRcIiksaS5vbmVycm9yPWUodGhpcy5fb3ZlcmxheU9uRXJyb3IsdGhpcyxcImVycm9yXCIpLCh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW58fFwiXCI9PT10aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pJiYoaS5jcm9zc09yaWdpbj0hMD09PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj9cIlwiOnRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksdGhpcy5vcHRpb25zLnpJbmRleCYmdGhpcy5fdXBkYXRlWkluZGV4KCksdD90aGlzLl91cmw9aS5zcmM6KGkuc3JjPXRoaXMuX3VybCxpLmFsdD10aGlzLm9wdGlvbnMuYWx0KX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcC5nZXRab29tU2NhbGUodC56b29tKSxlPXRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsdC56b29tLHQuY2VudGVyKS5taW47cnQodGhpcy5faW1hZ2UsZSxpKX0sX3Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faW1hZ2UsaT1uZXcgUCh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxlPWkuZ2V0U2l6ZSgpO2F0KHQsaS5taW4pLHQuc3R5bGUud2lkdGg9ZS54K1wicHhcIix0LnN0eWxlLmhlaWdodD1lLnkrXCJweFwifSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe250KHRoaXMuX2ltYWdlLHRoaXMub3B0aW9ucy5vcGFjaXR5KX0sX3VwZGF0ZVpJbmRleDpmdW5jdGlvbigpe3RoaXMuX2ltYWdlJiZ2b2lkIDAhPT10aGlzLm9wdGlvbnMuekluZGV4JiZudWxsIT09dGhpcy5vcHRpb25zLnpJbmRleCYmKHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleD10aGlzLm9wdGlvbnMuekluZGV4KX0sX292ZXJsYXlPbkVycm9yOmZ1bmN0aW9uKCl7dGhpcy5maXJlKFwiZXJyb3JcIik7dmFyIHQ9dGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDt0JiZ0aGlzLl91cmwhPT10JiYodGhpcy5fdXJsPXQsdGhpcy5faW1hZ2Uuc3JjPXQpfX0pLHVuPWhuLmV4dGVuZCh7b3B0aW9uczp7YXV0b3BsYXk6ITAsbG9vcDohMH0sX2luaXRJbWFnZTpmdW5jdGlvbigpe3ZhciB0PVwiVklERU9cIj09PXRoaXMuX3VybC50YWdOYW1lLGk9dGhpcy5faW1hZ2U9dD90aGlzLl91cmw6RyhcInZpZGVvXCIpO2lmKFEoaSxcImxlYWZsZXQtaW1hZ2UtbGF5ZXJcIiksdGhpcy5fem9vbUFuaW1hdGVkJiZRKGksXCJsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIiksaS5vbnNlbGVjdHN0YXJ0PXIsaS5vbm1vdXNlbW92ZT1yLGkub25sb2FkZWRkYXRhPWUodGhpcy5maXJlLHRoaXMsXCJsb2FkXCIpLHQpe2Zvcih2YXIgbj1pLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic291cmNlXCIpLG89W10scz0wO3M8bi5sZW5ndGg7cysrKW8ucHVzaChuW3NdLnNyYyk7dGhpcy5fdXJsPW4ubGVuZ3RoPjA/bzpbaS5zcmNdfWVsc2V7b2kodGhpcy5fdXJsKXx8KHRoaXMuX3VybD1bdGhpcy5fdXJsXSksaS5hdXRvcGxheT0hIXRoaXMub3B0aW9ucy5hdXRvcGxheSxpLmxvb3A9ISF0aGlzLm9wdGlvbnMubG9vcDtmb3IodmFyIGE9MDthPHRoaXMuX3VybC5sZW5ndGg7YSsrKXt2YXIgaD1HKFwic291cmNlXCIpO2guc3JjPXRoaXMuX3VybFthXSxpLmFwcGVuZENoaWxkKGgpfX19fSksbG49cWUuZXh0ZW5kKHtvcHRpb25zOntvZmZzZXQ6WzAsN10sY2xhc3NOYW1lOlwiXCIscGFuZTpcInBvcHVwUGFuZVwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7bCh0aGlzLHQpLHRoaXMuX3NvdXJjZT1pfSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl96b29tQW5pbWF0ZWQ9dC5fem9vbUFuaW1hdGVkLHRoaXMuX2NvbnRhaW5lcnx8dGhpcy5faW5pdExheW91dCgpLHQuX2ZhZGVBbmltYXRlZCYmbnQodGhpcy5fY29udGFpbmVyLDApLGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KSx0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpLHRoaXMudXBkYXRlKCksdC5fZmFkZUFuaW1hdGVkJiZudCh0aGlzLl9jb250YWluZXIsMSksdGhpcy5icmluZ1RvRnJvbnQoKX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dC5fZmFkZUFuaW1hdGVkPyhudCh0aGlzLl9jb250YWluZXIsMCksdGhpcy5fcmVtb3ZlVGltZW91dD1zZXRUaW1lb3V0KGUoSyx2b2lkIDAsdGhpcy5fY29udGFpbmVyKSwyMDApKTpLKHRoaXMuX2NvbnRhaW5lcil9LGdldExhdExuZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXRsbmd9LHNldExhdExuZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbGF0bG5nPUModCksdGhpcy5fbWFwJiYodGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLl9hZGp1c3RQYW4oKSksdGhpc30sZ2V0Q29udGVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250ZW50fSxzZXRDb250ZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb250ZW50PXQsdGhpcy51cGRhdGUoKSx0aGlzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5lcn0sdXBkYXRlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiYodGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIix0aGlzLl91cGRhdGVDb250ZW50KCksdGhpcy5fdXBkYXRlTGF5b3V0KCksdGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1cIlwiLHRoaXMuX2FkanVzdFBhbigpKX0sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9e3pvb206dGhpcy5fdXBkYXRlUG9zaXRpb24sdmlld3Jlc2V0OnRoaXMuX3VwZGF0ZVBvc2l0aW9ufTtyZXR1cm4gdGhpcy5fem9vbUFuaW1hdGVkJiYodC56b29tYW5pbT10aGlzLl9hbmltYXRlWm9vbSksdH0saXNPcGVuOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl9tYXAmJnRoaXMuX21hcC5oYXNMYXllcih0aGlzKX0sYnJpbmdUb0Zyb250OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmWCh0aGlzLl9jb250YWluZXIpLHRoaXN9LGJyaW5nVG9CYWNrOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmSih0aGlzLl9jb250YWluZXIpLHRoaXN9LF91cGRhdGVDb250ZW50OmZ1bmN0aW9uKCl7aWYodGhpcy5fY29udGVudCl7dmFyIHQ9dGhpcy5fY29udGVudE5vZGUsaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9jb250ZW50P3RoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlfHx0aGlzKTp0aGlzLl9jb250ZW50O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXQuaW5uZXJIVE1MPWk7ZWxzZXtmb3IoO3QuaGFzQ2hpbGROb2RlcygpOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7dC5hcHBlbmRDaGlsZChpKX10aGlzLmZpcmUoXCJjb250ZW50dXBkYXRlXCIpfX0sX3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpcy5fbWFwKXt2YXIgdD10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksaT13KHRoaXMub3B0aW9ucy5vZmZzZXQpLGU9dGhpcy5fZ2V0QW5jaG9yKCk7dGhpcy5fem9vbUFuaW1hdGVkP2F0KHRoaXMuX2NvbnRhaW5lcix0LmFkZChlKSk6aT1pLmFkZCh0KS5hZGQoZSk7dmFyIG49dGhpcy5fY29udGFpbmVyQm90dG9tPS1pLnksbz10aGlzLl9jb250YWluZXJMZWZ0PS1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoLzIpK2kueDt0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tPW4rXCJweFwiLHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0PW8rXCJweFwifX0sX2dldEFuY2hvcjpmdW5jdGlvbigpe3JldHVyblswLDBdfX0pLGNuPWxuLmV4dGVuZCh7b3B0aW9uczp7bWF4V2lkdGg6MzAwLG1pbldpZHRoOjUwLG1heEhlaWdodDpudWxsLGF1dG9QYW46ITAsYXV0b1BhblBhZGRpbmdUb3BMZWZ0Om51bGwsYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDpudWxsLGF1dG9QYW5QYWRkaW5nOls1LDVdLGtlZXBJblZpZXc6ITEsY2xvc2VCdXR0b246ITAsYXV0b0Nsb3NlOiEwLGNsb3NlT25Fc2NhcGVLZXk6ITAsY2xhc3NOYW1lOlwiXCJ9LG9wZW5PbjpmdW5jdGlvbih0KXtyZXR1cm4gdC5vcGVuUG9wdXAodGhpcyksdGhpc30sb25BZGQ6ZnVuY3Rpb24odCl7bG4ucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyx0KSx0LmZpcmUoXCJwb3B1cG9wZW5cIix7cG9wdXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmKHRoaXMuX3NvdXJjZS5maXJlKFwicG9wdXBvcGVuXCIse3BvcHVwOnRoaXN9LCEwKSx0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBRZXx8dGhpcy5fc291cmNlLm9uKFwicHJlY2xpY2tcIix5dCkpfSxvblJlbW92ZTpmdW5jdGlvbih0KXtsbi5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLHQpLHQuZmlyZShcInBvcHVwY2xvc2VcIix7cG9wdXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmKHRoaXMuX3NvdXJjZS5maXJlKFwicG9wdXBjbG9zZVwiLHtwb3B1cDp0aGlzfSwhMCksdGhpcy5fc291cmNlIGluc3RhbmNlb2YgUWV8fHRoaXMuX3NvdXJjZS5vZmYoXCJwcmVjbGlja1wiLHl0KSl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWxuLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4odm9pZCAwIT09dGhpcy5vcHRpb25zLmNsb3NlT25DbGljaz90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrOnRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSYmKHQucHJlY2xpY2s9dGhpcy5fY2xvc2UpLHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3JiYodC5tb3ZlZW5kPXRoaXMuX2FkanVzdFBhbiksdH0sX2Nsb3NlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiZ0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKX0sX2luaXRMYXlvdXQ6ZnVuY3Rpb24oKXt2YXIgdD1cImxlYWZsZXQtcG9wdXBcIixpPXRoaXMuX2NvbnRhaW5lcj1HKFwiZGl2XCIsdCtcIiBcIisodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikrXCIgbGVhZmxldC16b29tLWFuaW1hdGVkXCIpLGU9dGhpcy5fd3JhcHBlcj1HKFwiZGl2XCIsdCtcIi1jb250ZW50LXdyYXBwZXJcIixpKTtpZih0aGlzLl9jb250ZW50Tm9kZT1HKFwiZGl2XCIsdCtcIi1jb250ZW50XCIsZSksd3QoZSkseHQodGhpcy5fY29udGVudE5vZGUpLG10KGUsXCJjb250ZXh0bWVudVwiLHl0KSx0aGlzLl90aXBDb250YWluZXI9RyhcImRpdlwiLHQrXCItdGlwLWNvbnRhaW5lclwiLGkpLHRoaXMuX3RpcD1HKFwiZGl2XCIsdCtcIi10aXBcIix0aGlzLl90aXBDb250YWluZXIpLHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbil7dmFyIG49dGhpcy5fY2xvc2VCdXR0b249RyhcImFcIix0K1wiLWNsb3NlLWJ1dHRvblwiLGkpO24uaHJlZj1cIiNjbG9zZVwiLG4uaW5uZXJIVE1MPVwiJiMyMTU7XCIsbXQobixcImNsaWNrXCIsdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLHRoaXMpfX0sX3VwZGF0ZUxheW91dDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NvbnRlbnROb2RlLGk9dC5zdHlsZTtpLndpZHRoPVwiXCIsaS53aGl0ZVNwYWNlPVwibm93cmFwXCI7dmFyIGU9dC5vZmZzZXRXaWR0aDtlPU1hdGgubWluKGUsdGhpcy5vcHRpb25zLm1heFdpZHRoKSxlPU1hdGgubWF4KGUsdGhpcy5vcHRpb25zLm1pbldpZHRoKSxpLndpZHRoPWUrMStcInB4XCIsaS53aGl0ZVNwYWNlPVwiXCIsaS5oZWlnaHQ9XCJcIjt2YXIgbj10Lm9mZnNldEhlaWdodCxvPXRoaXMub3B0aW9ucy5tYXhIZWlnaHQ7byYmbj5vPyhpLmhlaWdodD1vK1wicHhcIixRKHQsXCJsZWFmbGV0LXBvcHVwLXNjcm9sbGVkXCIpKTp0dCh0LFwibGVhZmxldC1wb3B1cC1zY3JvbGxlZFwiKSx0aGlzLl9jb250YWluZXJXaWR0aD10aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGh9LF9hbmltYXRlWm9vbTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsdC56b29tLHQuY2VudGVyKSxlPXRoaXMuX2dldEFuY2hvcigpO2F0KHRoaXMuX2NvbnRhaW5lcixpLmFkZChlKSl9LF9hZGp1c3RQYW46ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuYXV0b1Bhbil7dGhpcy5fbWFwLl9wYW5BbmltJiZ0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpO3ZhciB0PXRoaXMuX21hcCxpPXBhcnNlSW50KHEodGhpcy5fY29udGFpbmVyLFwibWFyZ2luQm90dG9tXCIpLDEwKXx8MCxlPXRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQraSxuPXRoaXMuX2NvbnRhaW5lcldpZHRoLG89bmV3IHgodGhpcy5fY29udGFpbmVyTGVmdCwtZS10aGlzLl9jb250YWluZXJCb3R0b20pO28uX2FkZChodCh0aGlzLl9jb250YWluZXIpKTt2YXIgcz10LmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KG8pLHI9dyh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLGE9dyh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0fHxyKSxoPXcodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHR8fHIpLHU9dC5nZXRTaXplKCksbD0wLGM9MDtzLngrbitoLng+dS54JiYobD1zLngrbi11LngraC54KSxzLngtbC1hLng8MCYmKGw9cy54LWEueCkscy55K2UraC55PnUueSYmKGM9cy55K2UtdS55K2gueSkscy55LWMtYS55PDAmJihjPXMueS1hLnkpLChsfHxjKSYmdC5maXJlKFwiYXV0b3BhbnN0YXJ0XCIpLnBhbkJ5KFtsLGNdKX19LF9vbkNsb3NlQnV0dG9uQ2xpY2s6ZnVuY3Rpb24odCl7dGhpcy5fY2xvc2UoKSxMdCh0KX0sX2dldEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB3KHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcj90aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCk6WzAsMF0pfX0pO2JlLm1lcmdlT3B0aW9ucyh7Y2xvc2VQb3B1cE9uQ2xpY2s6ITB9KSxiZS5pbmNsdWRlKHtvcGVuUG9wdXA6ZnVuY3Rpb24odCxpLGUpe3JldHVybiB0IGluc3RhbmNlb2YgY258fCh0PW5ldyBjbihlKS5zZXRDb250ZW50KHQpKSxpJiZ0LnNldExhdExuZyhpKSx0aGlzLmhhc0xheWVyKHQpP3RoaXM6KHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSYmdGhpcy5jbG9zZVBvcHVwKCksdGhpcy5fcG9wdXA9dCx0aGlzLmFkZExheWVyKHQpKX0sY2xvc2VQb3B1cDpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdCE9PXRoaXMuX3BvcHVwfHwodD10aGlzLl9wb3B1cCx0aGlzLl9wb3B1cD1udWxsKSx0JiZ0aGlzLnJlbW92ZUxheWVyKHQpLHRoaXN9fSkscWUuaW5jbHVkZSh7YmluZFBvcHVwOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBjbj8obCh0LGkpLHRoaXMuX3BvcHVwPXQsdC5fc291cmNlPXRoaXMpOih0aGlzLl9wb3B1cCYmIWl8fCh0aGlzLl9wb3B1cD1uZXcgY24oaSx0aGlzKSksdGhpcy5fcG9wdXAuc2V0Q29udGVudCh0KSksdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkfHwodGhpcy5vbih7Y2xpY2s6dGhpcy5fb3BlblBvcHVwLGtleXByZXNzOnRoaXMuX29uS2V5UHJlc3MscmVtb3ZlOnRoaXMuY2xvc2VQb3B1cCxtb3ZlOnRoaXMuX21vdmVQb3B1cH0pLHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZD0hMCksdGhpc30sdW5iaW5kUG9wdXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcG9wdXAmJih0aGlzLm9mZih7Y2xpY2s6dGhpcy5fb3BlblBvcHVwLGtleXByZXNzOnRoaXMuX29uS2V5UHJlc3MscmVtb3ZlOnRoaXMuY2xvc2VQb3B1cCxtb3ZlOnRoaXMuX21vdmVQb3B1cH0pLHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZD0hMSx0aGlzLl9wb3B1cD1udWxsKSx0aGlzfSxvcGVuUG9wdXA6ZnVuY3Rpb24odCxpKXtpZih0IGluc3RhbmNlb2YgcWV8fChpPXQsdD10aGlzKSx0IGluc3RhbmNlb2YgS2UpZm9yKHZhciBlIGluIHRoaXMuX2xheWVycyl7dD10aGlzLl9sYXllcnNbZV07YnJlYWt9cmV0dXJuIGl8fChpPXQuZ2V0Q2VudGVyP3QuZ2V0Q2VudGVyKCk6dC5nZXRMYXRMbmcoKSksdGhpcy5fcG9wdXAmJnRoaXMuX21hcCYmKHRoaXMuX3BvcHVwLl9zb3VyY2U9dCx0aGlzLl9wb3B1cC51cGRhdGUoKSx0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLGkpKSx0aGlzfSxjbG9zZVBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5fY2xvc2UoKSx0aGlzfSx0b2dnbGVQb3B1cDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcG9wdXAmJih0aGlzLl9wb3B1cC5fbWFwP3RoaXMuY2xvc2VQb3B1cCgpOnRoaXMub3BlblBvcHVwKHQpKSx0aGlzfSxpc1BvcHVwT3BlbjpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5fcG9wdXAmJnRoaXMuX3BvcHVwLmlzT3BlbigpfSxzZXRQb3B1cENvbnRlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5zZXRDb250ZW50KHQpLHRoaXN9LGdldFBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwfSxfb3BlblBvcHVwOmZ1bmN0aW9uKHQpe3ZhciBpPXQubGF5ZXJ8fHQudGFyZ2V0O3RoaXMuX3BvcHVwJiZ0aGlzLl9tYXAmJihMdCh0KSxpIGluc3RhbmNlb2YgUWU/dGhpcy5vcGVuUG9wdXAodC5sYXllcnx8dC50YXJnZXQsdC5sYXRsbmcpOnRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkmJnRoaXMuX3BvcHVwLl9zb3VyY2U9PT1pP3RoaXMuY2xvc2VQb3B1cCgpOnRoaXMub3BlblBvcHVwKGksdC5sYXRsbmcpKX0sX21vdmVQb3B1cDpmdW5jdGlvbih0KXt0aGlzLl9wb3B1cC5zZXRMYXRMbmcodC5sYXRsbmcpfSxfb25LZXlQcmVzczpmdW5jdGlvbih0KXsxMz09PXQub3JpZ2luYWxFdmVudC5rZXlDb2RlJiZ0aGlzLl9vcGVuUG9wdXAodCl9fSk7dmFyIF9uPWxuLmV4dGVuZCh7b3B0aW9uczp7cGFuZTpcInRvb2x0aXBQYW5lXCIsb2Zmc2V0OlswLDBdLGRpcmVjdGlvbjpcImF1dG9cIixwZXJtYW5lbnQ6ITEsc3RpY2t5OiExLGludGVyYWN0aXZlOiExLG9wYWNpdHk6Ljl9LG9uQWRkOmZ1bmN0aW9uKHQpe2xuLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsdCksdGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KSx0LmZpcmUoXCJ0b29sdGlwb3BlblwiLHt0b29sdGlwOnRoaXN9KSx0aGlzLl9zb3VyY2UmJnRoaXMuX3NvdXJjZS5maXJlKFwidG9vbHRpcG9wZW5cIix7dG9vbHRpcDp0aGlzfSwhMCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe2xuLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsdCksdC5maXJlKFwidG9vbHRpcGNsb3NlXCIse3Rvb2x0aXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLmZpcmUoXCJ0b29sdGlwY2xvc2VcIix7dG9vbHRpcDp0aGlzfSwhMCl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWxuLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gcWkmJiF0aGlzLm9wdGlvbnMucGVybWFuZW50JiYodC5wcmVjbGljaz10aGlzLl9jbG9zZSksdH0sX2Nsb3NlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiZ0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpfSxfaW5pdExheW91dDpmdW5jdGlvbigpe3ZhciB0PVwibGVhZmxldC10b29sdGlwIFwiKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfHxcIlwiKStcIiBsZWFmbGV0LXpvb20tXCIrKHRoaXMuX3pvb21BbmltYXRlZD9cImFuaW1hdGVkXCI6XCJoaWRlXCIpO3RoaXMuX2NvbnRlbnROb2RlPXRoaXMuX2NvbnRhaW5lcj1HKFwiZGl2XCIsdCl9LF91cGRhdGVMYXlvdXQ6ZnVuY3Rpb24oKXt9LF9hZGp1c3RQYW46ZnVuY3Rpb24oKXt9LF9zZXRQb3NpdGlvbjpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAsZT10aGlzLl9jb250YWluZXIsbj1pLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoaS5nZXRDZW50ZXIoKSksbz1pLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHQpLHM9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixyPWUub2Zmc2V0V2lkdGgsYT1lLm9mZnNldEhlaWdodCxoPXcodGhpcy5vcHRpb25zLm9mZnNldCksdT10aGlzLl9nZXRBbmNob3IoKTtcInRvcFwiPT09cz90PXQuYWRkKHcoLXIvMitoLngsLWEraC55K3UueSwhMCkpOlwiYm90dG9tXCI9PT1zP3Q9dC5zdWJ0cmFjdCh3KHIvMi1oLngsLWgueSwhMCkpOlwiY2VudGVyXCI9PT1zP3Q9dC5zdWJ0cmFjdCh3KHIvMitoLngsYS8yLXUueStoLnksITApKTpcInJpZ2h0XCI9PT1zfHxcImF1dG9cIj09PXMmJm8ueDxuLng/KHM9XCJyaWdodFwiLHQ9dC5hZGQodyhoLngrdS54LHUueS1hLzIraC55LCEwKSkpOihzPVwibGVmdFwiLHQ9dC5zdWJ0cmFjdCh3KHIrdS54LWgueCxhLzItdS55LWgueSwhMCkpKSx0dChlLFwibGVhZmxldC10b29sdGlwLXJpZ2h0XCIpLHR0KGUsXCJsZWFmbGV0LXRvb2x0aXAtbGVmdFwiKSx0dChlLFwibGVhZmxldC10b29sdGlwLXRvcFwiKSx0dChlLFwibGVhZmxldC10b29sdGlwLWJvdHRvbVwiKSxRKGUsXCJsZWFmbGV0LXRvb2x0aXAtXCIrcyksYXQoZSx0KX0sX3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO3RoaXMuX3NldFBvc2l0aW9uKHQpfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucy5vcGFjaXR5PXQsdGhpcy5fY29udGFpbmVyJiZudCh0aGlzLl9jb250YWluZXIsdCl9LF9hbmltYXRlWm9vbTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsdC56b29tLHQuY2VudGVyKTt0aGlzLl9zZXRQb3NpdGlvbihpKX0sX2dldEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB3KHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yJiYhdGhpcy5vcHRpb25zLnN0aWNreT90aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKTpbMCwwXSl9fSk7YmUuaW5jbHVkZSh7b3BlblRvb2x0aXA6ZnVuY3Rpb24odCxpLGUpe3JldHVybiB0IGluc3RhbmNlb2YgX258fCh0PW5ldyBfbihlKS5zZXRDb250ZW50KHQpKSxpJiZ0LnNldExhdExuZyhpKSx0aGlzLmhhc0xheWVyKHQpP3RoaXM6dGhpcy5hZGRMYXllcih0KX0sY2xvc2VUb29sdGlwOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLnJlbW92ZUxheWVyKHQpLHRoaXN9fSkscWUuaW5jbHVkZSh7YmluZFRvb2x0aXA6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdCBpbnN0YW5jZW9mIF9uPyhsKHQsaSksdGhpcy5fdG9vbHRpcD10LHQuX3NvdXJjZT10aGlzKToodGhpcy5fdG9vbHRpcCYmIWl8fCh0aGlzLl90b29sdGlwPW5ldyBfbihpLHRoaXMpKSx0aGlzLl90b29sdGlwLnNldENvbnRlbnQodCkpLHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCksdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCYmdGhpcy5fbWFwJiZ0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykmJnRoaXMub3BlblRvb2x0aXAoKSx0aGlzfSx1bmJpbmRUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJih0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyghMCksdGhpcy5jbG9zZVRvb2x0aXAoKSx0aGlzLl90b29sdGlwPW51bGwpLHRoaXN9LF9pbml0VG9vbHRpcEludGVyYWN0aW9uczpmdW5jdGlvbih0KXtpZih0fHwhdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpe3ZhciBpPXQ/XCJvZmZcIjpcIm9uXCIsZT17cmVtb3ZlOnRoaXMuY2xvc2VUb29sdGlwLG1vdmU6dGhpcy5fbW92ZVRvb2x0aXB9O3RoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQ/ZS5hZGQ9dGhpcy5fb3BlblRvb2x0aXA6KGUubW91c2VvdmVyPXRoaXMuX29wZW5Ub29sdGlwLGUubW91c2VvdXQ9dGhpcy5jbG9zZVRvb2x0aXAsdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSYmKGUubW91c2Vtb3ZlPXRoaXMuX21vdmVUb29sdGlwKSxxaSYmKGUuY2xpY2s9dGhpcy5fb3BlblRvb2x0aXApKSx0aGlzW2ldKGUpLHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkPSF0fX0sb3BlblRvb2x0aXA6ZnVuY3Rpb24odCxpKXtpZih0IGluc3RhbmNlb2YgcWV8fChpPXQsdD10aGlzKSx0IGluc3RhbmNlb2YgS2UpZm9yKHZhciBlIGluIHRoaXMuX2xheWVycyl7dD10aGlzLl9sYXllcnNbZV07YnJlYWt9cmV0dXJuIGl8fChpPXQuZ2V0Q2VudGVyP3QuZ2V0Q2VudGVyKCk6dC5nZXRMYXRMbmcoKSksdGhpcy5fdG9vbHRpcCYmdGhpcy5fbWFwJiYodGhpcy5fdG9vbHRpcC5fc291cmNlPXQsdGhpcy5fdG9vbHRpcC51cGRhdGUoKSx0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCxpKSx0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUmJnRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciYmKFEodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLFwibGVhZmxldC1jbGlja2FibGVcIiksdGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpKSksdGhpc30sY2xvc2VUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJih0aGlzLl90b29sdGlwLl9jbG9zZSgpLHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSYmdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyJiYodHQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLFwibGVhZmxldC1jbGlja2FibGVcIiksdGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpKSksdGhpc30sdG9nZ2xlVG9vbHRpcDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmKHRoaXMuX3Rvb2x0aXAuX21hcD90aGlzLmNsb3NlVG9vbHRpcCgpOnRoaXMub3BlblRvb2x0aXAodCkpLHRoaXN9LGlzVG9vbHRpcE9wZW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKX0sc2V0VG9vbHRpcENvbnRlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJnRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudCh0KSx0aGlzfSxnZXRUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXB9LF9vcGVuVG9vbHRpcDpmdW5jdGlvbih0KXt2YXIgaT10LmxheWVyfHx0LnRhcmdldDt0aGlzLl90b29sdGlwJiZ0aGlzLl9tYXAmJnRoaXMub3BlblRvb2x0aXAoaSx0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5P3QubGF0bG5nOnZvaWQgMCl9LF9tb3ZlVG9vbHRpcDpmdW5jdGlvbih0KXt2YXIgaSxlLG49dC5sYXRsbmc7dGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSYmdC5vcmlnaW5hbEV2ZW50JiYoaT10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC5vcmlnaW5hbEV2ZW50KSxlPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChpKSxuPXRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoZSkpLHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKG4pfX0pO3ZhciBkbj1ZZS5leHRlbmQoe29wdGlvbnM6e2ljb25TaXplOlsxMiwxMl0saHRtbDohMSxiZ1BvczpudWxsLGNsYXNzTmFtZTpcImxlYWZsZXQtZGl2LWljb25cIn0sY3JlYXRlSWNvbjpmdW5jdGlvbih0KXt2YXIgaT10JiZcIkRJVlwiPT09dC50YWdOYW1lP3Q6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxlPXRoaXMub3B0aW9ucztpZihpLmlubmVySFRNTD0hMSE9PWUuaHRtbD9lLmh0bWw6XCJcIixlLmJnUG9zKXt2YXIgbj13KGUuYmdQb3MpO2kuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPS1uLngrXCJweCBcIistbi55K1wicHhcIn1yZXR1cm4gdGhpcy5fc2V0SWNvblN0eWxlcyhpLFwiaWNvblwiKSxpfSxjcmVhdGVTaGFkb3c6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19KTtZZS5EZWZhdWx0PVhlO3ZhciBwbj1xZS5leHRlbmQoe29wdGlvbnM6e3RpbGVTaXplOjI1NixvcGFjaXR5OjEsdXBkYXRlV2hlbklkbGU6V2ksdXBkYXRlV2hlblpvb21pbmc6ITAsdXBkYXRlSW50ZXJ2YWw6MjAwLHpJbmRleDoxLGJvdW5kczpudWxsLG1pblpvb206MCxtYXhab29tOnZvaWQgMCxtYXhOYXRpdmVab29tOnZvaWQgMCxtaW5OYXRpdmVab29tOnZvaWQgMCxub1dyYXA6ITEscGFuZTpcInRpbGVQYW5lXCIsY2xhc3NOYW1lOlwiXCIsa2VlcEJ1ZmZlcjoyfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe2wodGhpcyx0KX0sb25BZGQ6ZnVuY3Rpb24oKXt0aGlzLl9pbml0Q29udGFpbmVyKCksdGhpcy5fbGV2ZWxzPXt9LHRoaXMuX3RpbGVzPXt9LHRoaXMuX3Jlc2V0VmlldygpLHRoaXMuX3VwZGF0ZSgpfSxiZWZvcmVBZGQ6ZnVuY3Rpb24odCl7dC5fYWRkWm9vbUxpbWl0KHRoaXMpfSxvblJlbW92ZTpmdW5jdGlvbih0KXt0aGlzLl9yZW1vdmVBbGxUaWxlcygpLEsodGhpcy5fY29udGFpbmVyKSx0Ll9yZW1vdmVab29tTGltaXQodGhpcyksdGhpcy5fY29udGFpbmVyPW51bGwsdGhpcy5fdGlsZVpvb209dm9pZCAwfSxicmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYoWCh0aGlzLl9jb250YWluZXIpLHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpKSx0aGlzfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJihKKHRoaXMuX2NvbnRhaW5lciksdGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbikpLHRoaXN9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXJ9LHNldE9wYWNpdHk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5vcGFjaXR5PXQsdGhpcy5fdXBkYXRlT3BhY2l0eSgpLHRoaXN9LHNldFpJbmRleDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnpJbmRleD10LHRoaXMuX3VwZGF0ZVpJbmRleCgpLHRoaXN9LGlzTG9hZGluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sb2FkaW5nfSxyZWRyYXc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYodGhpcy5fcmVtb3ZlQWxsVGlsZXMoKSx0aGlzLl91cGRhdGUoKSksdGhpc30sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9e3ZpZXdwcmVyZXNldDp0aGlzLl9pbnZhbGlkYXRlQWxsLHZpZXdyZXNldDp0aGlzLl9yZXNldFZpZXcsem9vbTp0aGlzLl9yZXNldFZpZXcsbW92ZWVuZDp0aGlzLl9vbk1vdmVFbmR9O3JldHVybiB0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGV8fCh0aGlzLl9vbk1vdmV8fCh0aGlzLl9vbk1vdmU9byh0aGlzLl9vbk1vdmVFbmQsdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLHRoaXMpKSx0Lm1vdmU9dGhpcy5fb25Nb3ZlKSx0aGlzLl96b29tQW5pbWF0ZWQmJih0Lnpvb21hbmltPXRoaXMuX2FuaW1hdGVab29tKSx0fSxjcmVhdGVUaWxlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9LGdldFRpbGVTaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zLnRpbGVTaXplO3JldHVybiB0IGluc3RhbmNlb2YgeD90Om5ldyB4KHQsdCl9LF91cGRhdGVaSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXImJnZvaWQgMCE9PXRoaXMub3B0aW9ucy56SW5kZXgmJm51bGwhPT10aGlzLm9wdGlvbnMuekluZGV4JiYodGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleD10aGlzLm9wdGlvbnMuekluZGV4KX0sX3NldEF1dG9aSW5kZXg6ZnVuY3Rpb24odCl7Zm9yKHZhciBpLGU9dGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sbj0tdCgtMS8wLDEvMCksbz0wLHM9ZS5sZW5ndGg7bzxzO28rKylpPWVbb10uc3R5bGUuekluZGV4LGVbb10hPT10aGlzLl9jb250YWluZXImJmkmJihuPXQobiwraSkpO2lzRmluaXRlKG4pJiYodGhpcy5vcHRpb25zLnpJbmRleD1uK3QoLTEsMSksdGhpcy5fdXBkYXRlWkluZGV4KCkpfSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe2lmKHRoaXMuX21hcCYmIUxpKXtudCh0aGlzLl9jb250YWluZXIsdGhpcy5vcHRpb25zLm9wYWNpdHkpO3ZhciB0PStuZXcgRGF0ZSxpPSExLGU9ITE7Zm9yKHZhciBuIGluIHRoaXMuX3RpbGVzKXt2YXIgbz10aGlzLl90aWxlc1tuXTtpZihvLmN1cnJlbnQmJm8ubG9hZGVkKXt2YXIgcz1NYXRoLm1pbigxLCh0LW8ubG9hZGVkKS8yMDApO250KG8uZWwscyksczwxP2k9ITA6KG8uYWN0aXZlP2U9ITA6dGhpcy5fb25PcGFxdWVUaWxlKG8pLG8uYWN0aXZlPSEwKX19ZSYmIXRoaXMuX25vUHJ1bmUmJnRoaXMuX3BydW5lVGlsZXMoKSxpJiYoZyh0aGlzLl9mYWRlRnJhbWUpLHRoaXMuX2ZhZGVGcmFtZT1mKHRoaXMuX3VwZGF0ZU9wYWNpdHksdGhpcykpfX0sX29uT3BhcXVlVGlsZTpyLF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dGhpcy5fY29udGFpbmVyfHwodGhpcy5fY29udGFpbmVyPUcoXCJkaXZcIixcImxlYWZsZXQtbGF5ZXIgXCIrKHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpKSx0aGlzLl91cGRhdGVaSW5kZXgoKSx0aGlzLm9wdGlvbnMub3BhY2l0eTwxJiZ0aGlzLl91cGRhdGVPcGFjaXR5KCksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKSl9LF91cGRhdGVMZXZlbHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90aWxlWm9vbSxpPXRoaXMub3B0aW9ucy5tYXhab29tO2lmKHZvaWQgMCE9PXQpe2Zvcih2YXIgZSBpbiB0aGlzLl9sZXZlbHMpdGhpcy5fbGV2ZWxzW2VdLmVsLmNoaWxkcmVuLmxlbmd0aHx8ZT09PXQ/KHRoaXMuX2xldmVsc1tlXS5lbC5zdHlsZS56SW5kZXg9aS1NYXRoLmFicyh0LWUpLHRoaXMuX29uVXBkYXRlTGV2ZWwoZSkpOihLKHRoaXMuX2xldmVsc1tlXS5lbCksdGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oZSksdGhpcy5fb25SZW1vdmVMZXZlbChlKSxkZWxldGUgdGhpcy5fbGV2ZWxzW2VdKTt2YXIgbj10aGlzLl9sZXZlbHNbdF0sbz10aGlzLl9tYXA7cmV0dXJuIG58fCgobj10aGlzLl9sZXZlbHNbdF09e30pLmVsPUcoXCJkaXZcIixcImxlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkXCIsdGhpcy5fY29udGFpbmVyKSxuLmVsLnN0eWxlLnpJbmRleD1pLG4ub3JpZ2luPW8ucHJvamVjdChvLnVucHJvamVjdChvLmdldFBpeGVsT3JpZ2luKCkpLHQpLnJvdW5kKCksbi56b29tPXQsdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShuLG8uZ2V0Q2VudGVyKCksby5nZXRab29tKCkpLG4uZWwub2Zmc2V0V2lkdGgsdGhpcy5fb25DcmVhdGVMZXZlbChuKSksdGhpcy5fbGV2ZWw9bixufX0sX29uVXBkYXRlTGV2ZWw6cixfb25SZW1vdmVMZXZlbDpyLF9vbkNyZWF0ZUxldmVsOnIsX3BydW5lVGlsZXM6ZnVuY3Rpb24oKXtpZih0aGlzLl9tYXApe3ZhciB0LGksZT10aGlzLl9tYXAuZ2V0Wm9vbSgpO2lmKGU+dGhpcy5vcHRpb25zLm1heFpvb218fGU8dGhpcy5vcHRpb25zLm1pblpvb20pdGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtlbHNle2Zvcih0IGluIHRoaXMuX3RpbGVzKShpPXRoaXMuX3RpbGVzW3RdKS5yZXRhaW49aS5jdXJyZW50O2Zvcih0IGluIHRoaXMuX3RpbGVzKWlmKChpPXRoaXMuX3RpbGVzW3RdKS5jdXJyZW50JiYhaS5hY3RpdmUpe3ZhciBuPWkuY29vcmRzO3RoaXMuX3JldGFpblBhcmVudChuLngsbi55LG4ueixuLnotNSl8fHRoaXMuX3JldGFpbkNoaWxkcmVuKG4ueCxuLnksbi56LG4ueisyKX1mb3IodCBpbiB0aGlzLl90aWxlcyl0aGlzLl90aWxlc1t0XS5yZXRhaW58fHRoaXMuX3JlbW92ZVRpbGUodCl9fX0sX3JlbW92ZVRpbGVzQXRab29tOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaSBpbiB0aGlzLl90aWxlcyl0aGlzLl90aWxlc1tpXS5jb29yZHMuej09PXQmJnRoaXMuX3JlbW92ZVRpbGUoaSl9LF9yZW1vdmVBbGxUaWxlczpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl90aWxlcyl0aGlzLl9yZW1vdmVUaWxlKHQpfSxfaW52YWxpZGF0ZUFsbDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9sZXZlbHMpSyh0aGlzLl9sZXZlbHNbdF0uZWwpLHRoaXMuX29uUmVtb3ZlTGV2ZWwodCksZGVsZXRlIHRoaXMuX2xldmVsc1t0XTt0aGlzLl9yZW1vdmVBbGxUaWxlcygpLHRoaXMuX3RpbGVab29tPXZvaWQgMH0sX3JldGFpblBhcmVudDpmdW5jdGlvbih0LGksZSxuKXt2YXIgbz1NYXRoLmZsb29yKHQvMikscz1NYXRoLmZsb29yKGkvMikscj1lLTEsYT1uZXcgeCgrbywrcyk7YS56PStyO3ZhciBoPXRoaXMuX3RpbGVDb29yZHNUb0tleShhKSx1PXRoaXMuX3RpbGVzW2hdO3JldHVybiB1JiZ1LmFjdGl2ZT8odS5yZXRhaW49ITAsITApOih1JiZ1LmxvYWRlZCYmKHUucmV0YWluPSEwKSxyPm4mJnRoaXMuX3JldGFpblBhcmVudChvLHMscixuKSl9LF9yZXRhaW5DaGlsZHJlbjpmdW5jdGlvbih0LGksZSxuKXtmb3IodmFyIG89Mip0O288Mip0KzI7bysrKWZvcih2YXIgcz0yKmk7czwyKmkrMjtzKyspe3ZhciByPW5ldyB4KG8scyk7ci56PWUrMTt2YXIgYT10aGlzLl90aWxlQ29vcmRzVG9LZXkociksaD10aGlzLl90aWxlc1thXTtoJiZoLmFjdGl2ZT9oLnJldGFpbj0hMDooaCYmaC5sb2FkZWQmJihoLnJldGFpbj0hMCksZSsxPG4mJnRoaXMuX3JldGFpbkNoaWxkcmVuKG8scyxlKzEsbikpfX0sX3Jlc2V0VmlldzpmdW5jdGlvbih0KXt2YXIgaT10JiYodC5waW5jaHx8dC5mbHlUbyk7dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksdGhpcy5fbWFwLmdldFpvb20oKSxpLGkpfSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCl7dGhpcy5fc2V0Vmlldyh0LmNlbnRlcix0Lnpvb20sITAsdC5ub1VwZGF0ZSl9LF9jbGFtcFpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5vcHRpb25zO3JldHVybiB2b2lkIDAhPT1pLm1pbk5hdGl2ZVpvb20mJnQ8aS5taW5OYXRpdmVab29tP2kubWluTmF0aXZlWm9vbTp2b2lkIDAhPT1pLm1heE5hdGl2ZVpvb20mJmkubWF4TmF0aXZlWm9vbTx0P2kubWF4TmF0aXZlWm9vbTp0fSxfc2V0VmlldzpmdW5jdGlvbih0LGksZSxuKXt2YXIgbz10aGlzLl9jbGFtcFpvb20oTWF0aC5yb3VuZChpKSk7KHZvaWQgMCE9PXRoaXMub3B0aW9ucy5tYXhab29tJiZvPnRoaXMub3B0aW9ucy5tYXhab29tfHx2b2lkIDAhPT10aGlzLm9wdGlvbnMubWluWm9vbSYmbzx0aGlzLm9wdGlvbnMubWluWm9vbSkmJihvPXZvaWQgMCk7dmFyIHM9dGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nJiZvIT09dGhpcy5fdGlsZVpvb207biYmIXN8fCh0aGlzLl90aWxlWm9vbT1vLHRoaXMuX2Fib3J0TG9hZGluZyYmdGhpcy5fYWJvcnRMb2FkaW5nKCksdGhpcy5fdXBkYXRlTGV2ZWxzKCksdGhpcy5fcmVzZXRHcmlkKCksdm9pZCAwIT09byYmdGhpcy5fdXBkYXRlKHQpLGV8fHRoaXMuX3BydW5lVGlsZXMoKSx0aGlzLl9ub1BydW5lPSEhZSksdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXModCxpKX0sX3NldFpvb21UcmFuc2Zvcm1zOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlIGluIHRoaXMuX2xldmVscyl0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tlXSx0LGkpfSxfc2V0Wm9vbVRyYW5zZm9ybTpmdW5jdGlvbih0LGksZSl7dmFyIG49dGhpcy5fbWFwLmdldFpvb21TY2FsZShlLHQuem9vbSksbz10Lm9yaWdpbi5tdWx0aXBseUJ5KG4pLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oaSxlKSkucm91bmQoKTtqaT9ydCh0LmVsLG8sbik6YXQodC5lbCxvKX0sX3Jlc2V0R3JpZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCxpPXQub3B0aW9ucy5jcnMsZT10aGlzLl90aWxlU2l6ZT10aGlzLmdldFRpbGVTaXplKCksbj10aGlzLl90aWxlWm9vbSxvPXRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtvJiYodGhpcy5fZ2xvYmFsVGlsZVJhbmdlPXRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UobykpLHRoaXMuX3dyYXBYPWkud3JhcExuZyYmIXRoaXMub3B0aW9ucy5ub1dyYXAmJltNYXRoLmZsb29yKHQucHJvamVjdChbMCxpLndyYXBMbmdbMF1dLG4pLngvZS54KSxNYXRoLmNlaWwodC5wcm9qZWN0KFswLGkud3JhcExuZ1sxXV0sbikueC9lLnkpXSx0aGlzLl93cmFwWT1pLndyYXBMYXQmJiF0aGlzLm9wdGlvbnMubm9XcmFwJiZbTWF0aC5mbG9vcih0LnByb2plY3QoW2kud3JhcExhdFswXSwwXSxuKS55L2UueCksTWF0aC5jZWlsKHQucHJvamVjdChbaS53cmFwTGF0WzFdLDBdLG4pLnkvZS55KV19LF9vbk1vdmVFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJiF0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20mJnRoaXMuX3VwZGF0ZSgpfSxfZ2V0VGlsZWRQaXhlbEJvdW5kczpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAsZT1pLl9hbmltYXRpbmdab29tP01hdGgubWF4KGkuX2FuaW1hdGVUb1pvb20saS5nZXRab29tKCkpOmkuZ2V0Wm9vbSgpLG49aS5nZXRab29tU2NhbGUoZSx0aGlzLl90aWxlWm9vbSksbz1pLnByb2plY3QodCx0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxzPWkuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIqbik7cmV0dXJuIG5ldyBQKG8uc3VidHJhY3Qocyksby5hZGQocykpfSxfdXBkYXRlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcDtpZihpKXt2YXIgZT10aGlzLl9jbGFtcFpvb20oaS5nZXRab29tKCkpO2lmKHZvaWQgMD09PXQmJih0PWkuZ2V0Q2VudGVyKCkpLHZvaWQgMCE9PXRoaXMuX3RpbGVab29tKXt2YXIgbj10aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKHQpLG89dGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShuKSxzPW8uZ2V0Q2VudGVyKCkscj1bXSxhPXRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLGg9bmV3IFAoby5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW2EsLWFdKSxvLmdldFRvcFJpZ2h0KCkuYWRkKFthLC1hXSkpO2lmKCEoaXNGaW5pdGUoby5taW4ueCkmJmlzRmluaXRlKG8ubWluLnkpJiZpc0Zpbml0ZShvLm1heC54KSYmaXNGaW5pdGUoby5tYXgueSkpKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlc1wiKTtmb3IodmFyIHUgaW4gdGhpcy5fdGlsZXMpe3ZhciBsPXRoaXMuX3RpbGVzW3VdLmNvb3JkcztsLno9PT10aGlzLl90aWxlWm9vbSYmaC5jb250YWlucyhuZXcgeChsLngsbC55KSl8fCh0aGlzLl90aWxlc1t1XS5jdXJyZW50PSExKX1pZihNYXRoLmFicyhlLXRoaXMuX3RpbGVab29tKT4xKXRoaXMuX3NldFZpZXcodCxlKTtlbHNle2Zvcih2YXIgYz1vLm1pbi55O2M8PW8ubWF4Lnk7YysrKWZvcih2YXIgXz1vLm1pbi54O188PW8ubWF4Lng7XysrKXt2YXIgZD1uZXcgeChfLGMpO2lmKGQuej10aGlzLl90aWxlWm9vbSx0aGlzLl9pc1ZhbGlkVGlsZShkKSl7dmFyIHA9dGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGQpXTtwP3AuY3VycmVudD0hMDpyLnB1c2goZCl9fWlmKHIuc29ydChmdW5jdGlvbih0LGkpe3JldHVybiB0LmRpc3RhbmNlVG8ocyktaS5kaXN0YW5jZVRvKHMpfSksMCE9PXIubGVuZ3RoKXt0aGlzLl9sb2FkaW5nfHwodGhpcy5fbG9hZGluZz0hMCx0aGlzLmZpcmUoXCJsb2FkaW5nXCIpKTt2YXIgbT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7Zm9yKF89MDtfPHIubGVuZ3RoO18rKyl0aGlzLl9hZGRUaWxlKHJbX10sbSk7dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQobSl9fX19fSxfaXNWYWxpZFRpbGU6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwLm9wdGlvbnMuY3JzO2lmKCFpLmluZmluaXRlKXt2YXIgZT10aGlzLl9nbG9iYWxUaWxlUmFuZ2U7aWYoIWkud3JhcExuZyYmKHQueDxlLm1pbi54fHx0Lng+ZS5tYXgueCl8fCFpLndyYXBMYXQmJih0Lnk8ZS5taW4ueXx8dC55PmUubWF4LnkpKXJldHVybiExfWlmKCF0aGlzLm9wdGlvbnMuYm91bmRzKXJldHVybiEwO3ZhciBuPXRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0KTtyZXR1cm4geih0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyhuKX0sX2tleVRvQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKHQpKX0sX3RpbGVDb29yZHNUb053U2U6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwLGU9dGhpcy5nZXRUaWxlU2l6ZSgpLG49dC5zY2FsZUJ5KGUpLG89bi5hZGQoZSk7cmV0dXJuW2kudW5wcm9qZWN0KG4sdC56KSxpLnVucHJvamVjdChvLHQueildfSxfdGlsZUNvb3Jkc1RvQm91bmRzOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX3RpbGVDb29yZHNUb053U2UodCksZT1uZXcgVChpWzBdLGlbMV0pO3JldHVybiB0aGlzLm9wdGlvbnMubm9XcmFwfHwoZT10aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhlKSksZX0sX3RpbGVDb29yZHNUb0tleTpmdW5jdGlvbih0KXtyZXR1cm4gdC54K1wiOlwiK3QueStcIjpcIit0Lnp9LF9rZXlUb1RpbGVDb29yZHM6ZnVuY3Rpb24odCl7dmFyIGk9dC5zcGxpdChcIjpcIiksZT1uZXcgeCgraVswXSwraVsxXSk7cmV0dXJuIGUuej0raVsyXSxlfSxfcmVtb3ZlVGlsZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl90aWxlc1t0XTtpJiYoSyhpLmVsKSxkZWxldGUgdGhpcy5fdGlsZXNbdF0sdGhpcy5maXJlKFwidGlsZXVubG9hZFwiLHt0aWxlOmkuZWwsY29vcmRzOnRoaXMuX2tleVRvVGlsZUNvb3Jkcyh0KX0pKX0sX2luaXRUaWxlOmZ1bmN0aW9uKHQpe1EodCxcImxlYWZsZXQtdGlsZVwiKTt2YXIgaT10aGlzLmdldFRpbGVTaXplKCk7dC5zdHlsZS53aWR0aD1pLngrXCJweFwiLHQuc3R5bGUuaGVpZ2h0PWkueStcInB4XCIsdC5vbnNlbGVjdHN0YXJ0PXIsdC5vbm1vdXNlbW92ZT1yLExpJiZ0aGlzLm9wdGlvbnMub3BhY2l0eTwxJiZudCh0LHRoaXMub3B0aW9ucy5vcGFjaXR5KSx6aSYmIU1pJiYodC5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHk9XCJoaWRkZW5cIil9LF9hZGRUaWxlOmZ1bmN0aW9uKHQsaSl7dmFyIG49dGhpcy5fZ2V0VGlsZVBvcyh0KSxvPXRoaXMuX3RpbGVDb29yZHNUb0tleSh0KSxzPXRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKHQpLGUodGhpcy5fdGlsZVJlYWR5LHRoaXMsdCkpO3RoaXMuX2luaXRUaWxlKHMpLHRoaXMuY3JlYXRlVGlsZS5sZW5ndGg8MiYmZihlKHRoaXMuX3RpbGVSZWFkeSx0aGlzLHQsbnVsbCxzKSksYXQocyxuKSx0aGlzLl90aWxlc1tvXT17ZWw6cyxjb29yZHM6dCxjdXJyZW50OiEwfSxpLmFwcGVuZENoaWxkKHMpLHRoaXMuZmlyZShcInRpbGVsb2Fkc3RhcnRcIix7dGlsZTpzLGNvb3Jkczp0fSl9LF90aWxlUmVhZHk6ZnVuY3Rpb24odCxpLG4pe2kmJnRoaXMuZmlyZShcInRpbGVlcnJvclwiLHtlcnJvcjppLHRpbGU6bixjb29yZHM6dH0pO3ZhciBvPXRoaXMuX3RpbGVDb29yZHNUb0tleSh0KTsobj10aGlzLl90aWxlc1tvXSkmJihuLmxvYWRlZD0rbmV3IERhdGUsdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQ/KG50KG4uZWwsMCksZyh0aGlzLl9mYWRlRnJhbWUpLHRoaXMuX2ZhZGVGcmFtZT1mKHRoaXMuX3VwZGF0ZU9wYWNpdHksdGhpcykpOihuLmFjdGl2ZT0hMCx0aGlzLl9wcnVuZVRpbGVzKCkpLGl8fChRKG4uZWwsXCJsZWFmbGV0LXRpbGUtbG9hZGVkXCIpLHRoaXMuZmlyZShcInRpbGVsb2FkXCIse3RpbGU6bi5lbCxjb29yZHM6dH0pKSx0aGlzLl9ub1RpbGVzVG9Mb2FkKCkmJih0aGlzLl9sb2FkaW5nPSExLHRoaXMuZmlyZShcImxvYWRcIiksTGl8fCF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZD9mKHRoaXMuX3BydW5lVGlsZXMsdGhpcyk6c2V0VGltZW91dChlKHRoaXMuX3BydW5lVGlsZXMsdGhpcyksMjUwKSkpfSxfZ2V0VGlsZVBvczpmdW5jdGlvbih0KXtyZXR1cm4gdC5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKX0sX3dyYXBDb29yZHM6ZnVuY3Rpb24odCl7dmFyIGk9bmV3IHgodGhpcy5fd3JhcFg/cyh0LngsdGhpcy5fd3JhcFgpOnQueCx0aGlzLl93cmFwWT9zKHQueSx0aGlzLl93cmFwWSk6dC55KTtyZXR1cm4gaS56PXQueixpfSxfcHhCb3VuZHNUb1RpbGVSYW5nZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLmdldFRpbGVTaXplKCk7cmV0dXJuIG5ldyBQKHQubWluLnVuc2NhbGVCeShpKS5mbG9vcigpLHQubWF4LnVuc2NhbGVCeShpKS5jZWlsKCkuc3VidHJhY3QoWzEsMV0pKX0sX25vVGlsZXNUb0xvYWQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fdGlsZXMpaWYoIXRoaXMuX3RpbGVzW3RdLmxvYWRlZClyZXR1cm4hMTtyZXR1cm4hMH19KSxtbj1wbi5leHRlbmQoe29wdGlvbnM6e21pblpvb206MCxtYXhab29tOjE4LHN1YmRvbWFpbnM6XCJhYmNcIixlcnJvclRpbGVVcmw6XCJcIix6b29tT2Zmc2V0OjAsdG1zOiExLHpvb21SZXZlcnNlOiExLGRldGVjdFJldGluYTohMSxjcm9zc09yaWdpbjohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe3RoaXMuX3VybD10LChpPWwodGhpcyxpKSkuZGV0ZWN0UmV0aW5hJiZZaSYmaS5tYXhab29tPjAmJihpLnRpbGVTaXplPU1hdGguZmxvb3IoaS50aWxlU2l6ZS8yKSxpLnpvb21SZXZlcnNlPyhpLnpvb21PZmZzZXQtLSxpLm1pblpvb20rKyk6KGkuem9vbU9mZnNldCsrLGkubWF4Wm9vbS0tKSxpLm1pblpvb209TWF0aC5tYXgoMCxpLm1pblpvb20pKSxcInN0cmluZ1wiPT10eXBlb2YgaS5zdWJkb21haW5zJiYoaS5zdWJkb21haW5zPWkuc3ViZG9tYWlucy5zcGxpdChcIlwiKSkseml8fHRoaXMub24oXCJ0aWxldW5sb2FkXCIsdGhpcy5fb25UaWxlUmVtb3ZlKX0sc2V0VXJsOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMuX3VybD09PXQmJnZvaWQgMD09PWkmJihpPSEwKSx0aGlzLl91cmw9dCxpfHx0aGlzLnJlZHJhdygpLHRoaXN9LGNyZWF0ZVRpbGU6ZnVuY3Rpb24odCxpKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO3JldHVybiBtdChuLFwibG9hZFwiLGUodGhpcy5fdGlsZU9uTG9hZCx0aGlzLGksbikpLG10KG4sXCJlcnJvclwiLGUodGhpcy5fdGlsZU9uRXJyb3IsdGhpcyxpLG4pKSwodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2lufHxcIlwiPT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSYmKG4uY3Jvc3NPcmlnaW49ITA9PT10aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4/XCJcIjp0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pLG4uYWx0PVwiXCIsbi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsXCJwcmVzZW50YXRpb25cIiksbi5zcmM9dGhpcy5nZXRUaWxlVXJsKHQpLG59LGdldFRpbGVVcmw6ZnVuY3Rpb24odCl7dmFyIGU9e3I6WWk/XCJAMnhcIjpcIlwiLHM6dGhpcy5fZ2V0U3ViZG9tYWluKHQpLHg6dC54LHk6dC55LHo6dGhpcy5fZ2V0Wm9vbUZvclVybCgpfTtpZih0aGlzLl9tYXAmJiF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpe3ZhciBuPXRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueS10Lnk7dGhpcy5vcHRpb25zLnRtcyYmKGUueT1uKSxlW1wiLXlcIl09bn1yZXR1cm4gXyh0aGlzLl91cmwsaShlLHRoaXMub3B0aW9ucykpfSxfdGlsZU9uTG9hZDpmdW5jdGlvbih0LGkpe0xpP3NldFRpbWVvdXQoZSh0LHRoaXMsbnVsbCxpKSwwKTp0KG51bGwsaSl9LF90aWxlT25FcnJvcjpmdW5jdGlvbih0LGksZSl7dmFyIG49dGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtuJiZpLmdldEF0dHJpYnV0ZShcInNyY1wiKSE9PW4mJihpLnNyYz1uKSx0KGUsaSl9LF9vblRpbGVSZW1vdmU6ZnVuY3Rpb24odCl7dC50aWxlLm9ubG9hZD1udWxsfSxfZ2V0Wm9vbUZvclVybDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3RpbGVab29tLGk9dGhpcy5vcHRpb25zLm1heFpvb20sZT10aGlzLm9wdGlvbnMuem9vbVJldmVyc2Usbj10aGlzLm9wdGlvbnMuem9vbU9mZnNldDtyZXR1cm4gZSYmKHQ9aS10KSx0K259LF9nZXRTdWJkb21haW46ZnVuY3Rpb24odCl7dmFyIGk9TWF0aC5hYnModC54K3QueSkldGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO3JldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpXX0sX2Fib3J0TG9hZGluZzpmdW5jdGlvbigpe3ZhciB0LGk7Zm9yKHQgaW4gdGhpcy5fdGlsZXMpdGhpcy5fdGlsZXNbdF0uY29vcmRzLnohPT10aGlzLl90aWxlWm9vbSYmKChpPXRoaXMuX3RpbGVzW3RdLmVsKS5vbmxvYWQ9cixpLm9uZXJyb3I9cixpLmNvbXBsZXRlfHwoaS5zcmM9c2ksSyhpKSxkZWxldGUgdGhpcy5fdGlsZXNbdF0pKX0sX3JlbW92ZVRpbGU6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fdGlsZXNbdF07aWYoaSlyZXR1cm4gU2l8fGkuZWwuc2V0QXR0cmlidXRlKFwic3JjXCIsc2kpLHBuLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsdCl9LF90aWxlUmVhZHk6ZnVuY3Rpb24odCxpLGUpe2lmKHRoaXMuX21hcCYmKCFlfHxlLmdldEF0dHJpYnV0ZShcInNyY1wiKSE9PXNpKSlyZXR1cm4gcG4ucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLHQsaSxlKX19KSxmbj1tbi5leHRlbmQoe2RlZmF1bHRXbXNQYXJhbXM6e3NlcnZpY2U6XCJXTVNcIixyZXF1ZXN0OlwiR2V0TWFwXCIsbGF5ZXJzOlwiXCIsc3R5bGVzOlwiXCIsZm9ybWF0OlwiaW1hZ2UvanBlZ1wiLHRyYW5zcGFyZW50OiExLHZlcnNpb246XCIxLjEuMVwifSxvcHRpb25zOntjcnM6bnVsbCx1cHBlcmNhc2U6ITF9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxlKXt0aGlzLl91cmw9dDt2YXIgbj1pKHt9LHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7Zm9yKHZhciBvIGluIGUpbyBpbiB0aGlzLm9wdGlvbnN8fChuW29dPWVbb10pO3ZhciBzPShlPWwodGhpcyxlKSkuZGV0ZWN0UmV0aW5hJiZZaT8yOjEscj10aGlzLmdldFRpbGVTaXplKCk7bi53aWR0aD1yLngqcyxuLmhlaWdodD1yLnkqcyx0aGlzLndtc1BhcmFtcz1ufSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl9jcnM9dGhpcy5vcHRpb25zLmNyc3x8dC5vcHRpb25zLmNycyx0aGlzLl93bXNWZXJzaW9uPXBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7dmFyIGk9dGhpcy5fd21zVmVyc2lvbj49MS4zP1wiY3JzXCI6XCJzcnNcIjt0aGlzLndtc1BhcmFtc1tpXT10aGlzLl9jcnMuY29kZSxtbi5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLHQpfSxnZXRUaWxlVXJsOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX3RpbGVDb29yZHNUb053U2UodCksZT10aGlzLl9jcnMsbj1iKGUucHJvamVjdChpWzBdKSxlLnByb2plY3QoaVsxXSkpLG89bi5taW4scz1uLm1heCxyPSh0aGlzLl93bXNWZXJzaW9uPj0xLjMmJnRoaXMuX2Nycz09PVVlP1tvLnksby54LHMueSxzLnhdOltvLngsby55LHMueCxzLnldKS5qb2luKFwiLFwiKSxhPW1uLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcyx0KTtyZXR1cm4gYStjKHRoaXMud21zUGFyYW1zLGEsdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkrKHRoaXMub3B0aW9ucy51cHBlcmNhc2U/XCImQkJPWD1cIjpcIiZiYm94PVwiKStyfSxzZXRQYXJhbXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gaSh0aGlzLndtc1BhcmFtcyx0KSxlfHx0aGlzLnJlZHJhdygpLHRoaXN9fSk7bW4uV01TPWZuLEp0Lndtcz1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcgZm4odCxpKX07dmFyIGduPXFlLmV4dGVuZCh7b3B0aW9uczp7cGFkZGluZzouMSx0b2xlcmFuY2U6MH0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXtsKHRoaXMsdCksbih0aGlzKSx0aGlzLl9sYXllcnM9dGhpcy5fbGF5ZXJzfHx7fX0sb25BZGQ6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXJ8fCh0aGlzLl9pbml0Q29udGFpbmVyKCksdGhpcy5fem9vbUFuaW1hdGVkJiZRKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKSx0aGlzLl91cGRhdGUoKSx0aGlzLm9uKFwidXBkYXRlXCIsdGhpcy5fdXBkYXRlUGF0aHMsdGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5vZmYoXCJ1cGRhdGVcIix0aGlzLl91cGRhdGVQYXRocyx0aGlzKSx0aGlzLl9kZXN0cm95Q29udGFpbmVyKCl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PXt2aWV3cmVzZXQ6dGhpcy5fcmVzZXQsem9vbTp0aGlzLl9vblpvb20sbW92ZWVuZDp0aGlzLl91cGRhdGUsem9vbWVuZDp0aGlzLl9vblpvb21FbmR9O3JldHVybiB0aGlzLl96b29tQW5pbWF0ZWQmJih0Lnpvb21hbmltPXRoaXMuX29uQW5pbVpvb20pLHR9LF9vbkFuaW1ab29tOmZ1bmN0aW9uKHQpe3RoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0LmNlbnRlcix0Lnpvb20pfSxfb25ab29tOmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSx0aGlzLl9tYXAuZ2V0Wm9vbSgpKX0sX3VwZGF0ZVRyYW5zZm9ybTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX21hcC5nZXRab29tU2NhbGUoaSx0aGlzLl96b29tKSxuPWh0KHRoaXMuX2NvbnRhaW5lciksbz10aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoLjUrdGhpcy5vcHRpb25zLnBhZGRpbmcpLHM9dGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLGkpLHI9dGhpcy5fbWFwLnByb2plY3QodCxpKS5zdWJ0cmFjdChzKSxhPW8ubXVsdGlwbHlCeSgtZSkuYWRkKG4pLmFkZChvKS5zdWJ0cmFjdChyKTtqaT9ydCh0aGlzLl9jb250YWluZXIsYSxlKTphdCh0aGlzLl9jb250YWluZXIsYSl9LF9yZXNldDpmdW5jdGlvbigpe3RoaXMuX3VwZGF0ZSgpLHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsdGhpcy5fem9vbSk7Zm9yKHZhciB0IGluIHRoaXMuX2xheWVycyl0aGlzLl9sYXllcnNbdF0uX3Jlc2V0KCl9LF9vblpvb21FbmQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fcHJvamVjdCgpfSxfdXBkYXRlUGF0aHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fdXBkYXRlKCl9LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMucGFkZGluZyxpPXRoaXMuX21hcC5nZXRTaXplKCksZT10aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoaS5tdWx0aXBseUJ5KC10KSkucm91bmQoKTt0aGlzLl9ib3VuZHM9bmV3IFAoZSxlLmFkZChpLm11bHRpcGx5QnkoMSsyKnQpKS5yb3VuZCgpKSx0aGlzLl9jZW50ZXI9dGhpcy5fbWFwLmdldENlbnRlcigpLHRoaXMuX3pvb209dGhpcy5fbWFwLmdldFpvb20oKX19KSx2bj1nbi5leHRlbmQoe2dldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWduLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdC52aWV3cHJlcmVzZXQ9dGhpcy5fb25WaWV3UHJlUmVzZXQsdH0sX29uVmlld1ByZVJlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocz0hMH0sb25BZGQ6ZnVuY3Rpb24oKXtnbi5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKSx0aGlzLl9kcmF3KCl9LF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7bXQodCxcIm1vdXNlbW92ZVwiLG8odGhpcy5fb25Nb3VzZU1vdmUsMzIsdGhpcyksdGhpcyksbXQodCxcImNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51XCIsdGhpcy5fb25DbGljayx0aGlzKSxtdCh0LFwibW91c2VvdXRcIix0aGlzLl9oYW5kbGVNb3VzZU91dCx0aGlzKSx0aGlzLl9jdHg9dC5nZXRDb250ZXh0KFwiMmRcIil9LF9kZXN0cm95Q29udGFpbmVyOmZ1bmN0aW9uKCl7Zyh0aGlzLl9yZWRyYXdSZXF1ZXN0KSxkZWxldGUgdGhpcy5fY3R4LEsodGhpcy5fY29udGFpbmVyKSxmdCh0aGlzLl9jb250YWluZXIpLGRlbGV0ZSB0aGlzLl9jb250YWluZXJ9LF91cGRhdGVQYXRoczpmdW5jdGlvbigpe2lmKCF0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKXt0aGlzLl9yZWRyYXdCb3VuZHM9bnVsbDtmb3IodmFyIHQgaW4gdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fdXBkYXRlKCk7dGhpcy5fcmVkcmF3KCl9fSxfdXBkYXRlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbXx8IXRoaXMuX2JvdW5kcyl7Z24ucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTt2YXIgdD10aGlzLl9ib3VuZHMsaT10aGlzLl9jb250YWluZXIsZT10LmdldFNpemUoKSxuPVlpPzI6MTthdChpLHQubWluKSxpLndpZHRoPW4qZS54LGkuaGVpZ2h0PW4qZS55LGkuc3R5bGUud2lkdGg9ZS54K1wicHhcIixpLnN0eWxlLmhlaWdodD1lLnkrXCJweFwiLFlpJiZ0aGlzLl9jdHguc2NhbGUoMiwyKSx0aGlzLl9jdHgudHJhbnNsYXRlKC10Lm1pbi54LC10Lm1pbi55KSx0aGlzLmZpcmUoXCJ1cGRhdGVcIil9fSxfcmVzZXQ6ZnVuY3Rpb24oKXtnbi5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyksdGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyYmKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHM9ITEsdGhpcy5fdXBkYXRlUGF0aHMoKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt0aGlzLl91cGRhdGVEYXNoQXJyYXkodCksdGhpcy5fbGF5ZXJzW24odCldPXQ7dmFyIGk9dC5fb3JkZXI9e2xheWVyOnQscHJldjp0aGlzLl9kcmF3TGFzdCxuZXh0Om51bGx9O3RoaXMuX2RyYXdMYXN0JiYodGhpcy5fZHJhd0xhc3QubmV4dD1pKSx0aGlzLl9kcmF3TGFzdD1pLHRoaXMuX2RyYXdGaXJzdD10aGlzLl9kcmF3Rmlyc3R8fHRoaXMuX2RyYXdMYXN0fSxfYWRkUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpfSxfcmVtb3ZlUGF0aDpmdW5jdGlvbih0KXt2YXIgaT10Ll9vcmRlcixlPWkubmV4dCxvPWkucHJldjtlP2UucHJldj1vOnRoaXMuX2RyYXdMYXN0PW8sbz9vLm5leHQ9ZTp0aGlzLl9kcmF3Rmlyc3Q9ZSxkZWxldGUgdC5fb3JkZXIsZGVsZXRlIHRoaXMuX2xheWVyc1tuKHQpXSx0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpfSxfdXBkYXRlUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHModCksdC5fcHJvamVjdCgpLHQuX3VwZGF0ZSgpLHRoaXMuX3JlcXVlc3RSZWRyYXcodCl9LF91cGRhdGVTdHlsZTpmdW5jdGlvbih0KXt0aGlzLl91cGRhdGVEYXNoQXJyYXkodCksdGhpcy5fcmVxdWVzdFJlZHJhdyh0KX0sX3VwZGF0ZURhc2hBcnJheTpmdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdC5vcHRpb25zLmRhc2hBcnJheSl7dmFyIGksZSxuPXQub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksbz1bXTtmb3IoZT0wO2U8bi5sZW5ndGg7ZSsrKXtpZihpPU51bWJlcihuW2VdKSxpc05hTihpKSlyZXR1cm47by5wdXNoKGkpfXQub3B0aW9ucy5fZGFzaEFycmF5PW99ZWxzZSB0Lm9wdGlvbnMuX2Rhc2hBcnJheT10Lm9wdGlvbnMuZGFzaEFycmF5fSxfcmVxdWVzdFJlZHJhdzpmdW5jdGlvbih0KXt0aGlzLl9tYXAmJih0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHModCksdGhpcy5fcmVkcmF3UmVxdWVzdD10aGlzLl9yZWRyYXdSZXF1ZXN0fHxmKHRoaXMuX3JlZHJhdyx0aGlzKSl9LF9leHRlbmRSZWRyYXdCb3VuZHM6ZnVuY3Rpb24odCl7aWYodC5fcHhCb3VuZHMpe3ZhciBpPSh0Lm9wdGlvbnMud2VpZ2h0fHwwKSsxO3RoaXMuX3JlZHJhd0JvdW5kcz10aGlzLl9yZWRyYXdCb3VuZHN8fG5ldyBQLHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQodC5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtpLGldKSksdGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZCh0Ll9weEJvdW5kcy5tYXguYWRkKFtpLGldKSl9fSxfcmVkcmF3OmZ1bmN0aW9uKCl7dGhpcy5fcmVkcmF3UmVxdWVzdD1udWxsLHRoaXMuX3JlZHJhd0JvdW5kcyYmKHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCksdGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpKSx0aGlzLl9jbGVhcigpLHRoaXMuX2RyYXcoKSx0aGlzLl9yZWRyYXdCb3VuZHM9bnVsbH0sX2NsZWFyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmVkcmF3Qm91bmRzO2lmKHQpe3ZhciBpPXQuZ2V0U2l6ZSgpO3RoaXMuX2N0eC5jbGVhclJlY3QodC5taW4ueCx0Lm1pbi55LGkueCxpLnkpfWVsc2UgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5fY29udGFpbmVyLndpZHRoLHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpfSxfZHJhdzpmdW5jdGlvbigpe3ZhciB0LGk9dGhpcy5fcmVkcmF3Qm91bmRzO2lmKHRoaXMuX2N0eC5zYXZlKCksaSl7dmFyIGU9aS5nZXRTaXplKCk7dGhpcy5fY3R4LmJlZ2luUGF0aCgpLHRoaXMuX2N0eC5yZWN0KGkubWluLngsaS5taW4ueSxlLngsZS55KSx0aGlzLl9jdHguY2xpcCgpfXRoaXMuX2RyYXdpbmc9ITA7Zm9yKHZhciBuPXRoaXMuX2RyYXdGaXJzdDtuO249bi5uZXh0KXQ9bi5sYXllciwoIWl8fHQuX3B4Qm91bmRzJiZ0Ll9weEJvdW5kcy5pbnRlcnNlY3RzKGkpKSYmdC5fdXBkYXRlUGF0aCgpO3RoaXMuX2RyYXdpbmc9ITEsdGhpcy5fY3R4LnJlc3RvcmUoKX0sX3VwZGF0ZVBvbHk6ZnVuY3Rpb24odCxpKXtpZih0aGlzLl9kcmF3aW5nKXt2YXIgZSxuLG8scyxyPXQuX3BhcnRzLGE9ci5sZW5ndGgsaD10aGlzLl9jdHg7aWYoYSl7Zm9yKGguYmVnaW5QYXRoKCksZT0wO2U8YTtlKyspe2ZvcihuPTAsbz1yW2VdLmxlbmd0aDtuPG87bisrKXM9cltlXVtuXSxoW24/XCJsaW5lVG9cIjpcIm1vdmVUb1wiXShzLngscy55KTtpJiZoLmNsb3NlUGF0aCgpfXRoaXMuX2ZpbGxTdHJva2UoaCx0KX19fSxfdXBkYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX2RyYXdpbmcmJiF0Ll9lbXB0eSgpKXt2YXIgaT10Ll9wb2ludCxlPXRoaXMuX2N0eCxuPU1hdGgubWF4KE1hdGgucm91bmQodC5fcmFkaXVzKSwxKSxvPShNYXRoLm1heChNYXRoLnJvdW5kKHQuX3JhZGl1c1kpLDEpfHxuKS9uOzEhPT1vJiYoZS5zYXZlKCksZS5zY2FsZSgxLG8pKSxlLmJlZ2luUGF0aCgpLGUuYXJjKGkueCxpLnkvbyxuLDAsMipNYXRoLlBJLCExKSwxIT09byYmZS5yZXN0b3JlKCksdGhpcy5fZmlsbFN0cm9rZShlLHQpfX0sX2ZpbGxTdHJva2U6ZnVuY3Rpb24odCxpKXt2YXIgZT1pLm9wdGlvbnM7ZS5maWxsJiYodC5nbG9iYWxBbHBoYT1lLmZpbGxPcGFjaXR5LHQuZmlsbFN0eWxlPWUuZmlsbENvbG9yfHxlLmNvbG9yLHQuZmlsbChlLmZpbGxSdWxlfHxcImV2ZW5vZGRcIikpLGUuc3Ryb2tlJiYwIT09ZS53ZWlnaHQmJih0LnNldExpbmVEYXNoJiZ0LnNldExpbmVEYXNoKGkub3B0aW9ucyYmaS5vcHRpb25zLl9kYXNoQXJyYXl8fFtdKSx0Lmdsb2JhbEFscGhhPWUub3BhY2l0eSx0LmxpbmVXaWR0aD1lLndlaWdodCx0LnN0cm9rZVN0eWxlPWUuY29sb3IsdC5saW5lQ2FwPWUubGluZUNhcCx0LmxpbmVKb2luPWUubGluZUpvaW4sdC5zdHJva2UoKSl9LF9vbkNsaWNrOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaSxlLG49dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodCksbz10aGlzLl9kcmF3Rmlyc3Q7bztvPW8ubmV4dCkoaT1vLmxheWVyKS5vcHRpb25zLmludGVyYWN0aXZlJiZpLl9jb250YWluc1BvaW50KG4pJiYhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChpKSYmKGU9aSk7ZSYmKHp0KHQpLHRoaXMuX2ZpcmVFdmVudChbZV0sdCkpfSxfb25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7aWYodGhpcy5fbWFwJiYhdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpJiYhdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKXt2YXIgaT10aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0KTt0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKHQsaSl9fSxfaGFuZGxlTW91c2VPdXQ6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5faG92ZXJlZExheWVyO2kmJih0dCh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuX2ZpcmVFdmVudChbaV0sdCxcIm1vdXNlb3V0XCIpLHRoaXMuX2hvdmVyZWRMYXllcj1udWxsKX0sX2hhbmRsZU1vdXNlSG92ZXI6ZnVuY3Rpb24odCxpKXtmb3IodmFyIGUsbixvPXRoaXMuX2RyYXdGaXJzdDtvO289by5uZXh0KShlPW8ubGF5ZXIpLm9wdGlvbnMuaW50ZXJhY3RpdmUmJmUuX2NvbnRhaW5zUG9pbnQoaSkmJihuPWUpO24hPT10aGlzLl9ob3ZlcmVkTGF5ZXImJih0aGlzLl9oYW5kbGVNb3VzZU91dCh0KSxuJiYoUSh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuX2ZpcmVFdmVudChbbl0sdCxcIm1vdXNlb3ZlclwiKSx0aGlzLl9ob3ZlcmVkTGF5ZXI9bikpLHRoaXMuX2hvdmVyZWRMYXllciYmdGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLHQpfSxfZmlyZUV2ZW50OmZ1bmN0aW9uKHQsaSxlKXt0aGlzLl9tYXAuX2ZpcmVET01FdmVudChpLGV8fGkudHlwZSx0KX0sX2JyaW5nVG9Gcm9udDpmdW5jdGlvbih0KXt2YXIgaT10Ll9vcmRlcjtpZihpKXt2YXIgZT1pLm5leHQsbj1pLnByZXY7ZSYmKGUucHJldj1uLG4/bi5uZXh0PWU6ZSYmKHRoaXMuX2RyYXdGaXJzdD1lKSxpLnByZXY9dGhpcy5fZHJhd0xhc3QsdGhpcy5fZHJhd0xhc3QubmV4dD1pLGkubmV4dD1udWxsLHRoaXMuX2RyYXdMYXN0PWksdGhpcy5fcmVxdWVzdFJlZHJhdyh0KSl9fSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7dmFyIGk9dC5fb3JkZXI7aWYoaSl7dmFyIGU9aS5uZXh0LG49aS5wcmV2O24mJihuLm5leHQ9ZSxlP2UucHJldj1uOm4mJih0aGlzLl9kcmF3TGFzdD1uKSxpLnByZXY9bnVsbCxpLm5leHQ9dGhpcy5fZHJhd0ZpcnN0LHRoaXMuX2RyYXdGaXJzdC5wcmV2PWksdGhpcy5fZHJhd0ZpcnN0PWksdGhpcy5fcmVxdWVzdFJlZHJhdyh0KSl9fX0pLHluPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBkb2N1bWVudC5uYW1lc3BhY2VzLmFkZChcImx2bWxcIixcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIpLGZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiPGx2bWw6XCIrdCsnIGNsYXNzPVwibHZtbFwiPicpfX1jYXRjaCh0KXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCI8XCIrdCsnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKX19fSgpLHhuPXtfaW5pdENvbnRhaW5lcjpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcj1HKFwiZGl2XCIsXCJsZWFmbGV0LXZtbC1jb250YWluZXJcIil9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb218fChnbi5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpLHRoaXMuZmlyZShcInVwZGF0ZVwiKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt2YXIgaT10Ll9jb250YWluZXI9eW4oXCJzaGFwZVwiKTtRKGksXCJsZWFmbGV0LXZtbC1zaGFwZSBcIisodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikpLGkuY29vcmRzaXplPVwiMSAxXCIsdC5fcGF0aD15bihcInBhdGhcIiksaS5hcHBlbmRDaGlsZCh0Ll9wYXRoKSx0aGlzLl91cGRhdGVTdHlsZSh0KSx0aGlzLl9sYXllcnNbbih0KV09dH0sX2FkZFBhdGg6ZnVuY3Rpb24odCl7dmFyIGk9dC5fY29udGFpbmVyO3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChpKSx0Lm9wdGlvbnMuaW50ZXJhY3RpdmUmJnQuYWRkSW50ZXJhY3RpdmVUYXJnZXQoaSl9LF9yZW1vdmVQYXRoOmZ1bmN0aW9uKHQpe3ZhciBpPXQuX2NvbnRhaW5lcjtLKGkpLHQucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoaSksZGVsZXRlIHRoaXMuX2xheWVyc1tuKHQpXX0sX3VwZGF0ZVN0eWxlOmZ1bmN0aW9uKHQpe3ZhciBpPXQuX3N0cm9rZSxlPXQuX2ZpbGwsbj10Lm9wdGlvbnMsbz10Ll9jb250YWluZXI7by5zdHJva2VkPSEhbi5zdHJva2Usby5maWxsZWQ9ISFuLmZpbGwsbi5zdHJva2U/KGl8fChpPXQuX3N0cm9rZT15bihcInN0cm9rZVwiKSksby5hcHBlbmRDaGlsZChpKSxpLndlaWdodD1uLndlaWdodCtcInB4XCIsaS5jb2xvcj1uLmNvbG9yLGkub3BhY2l0eT1uLm9wYWNpdHksbi5kYXNoQXJyYXk/aS5kYXNoU3R5bGU9b2kobi5kYXNoQXJyYXkpP24uZGFzaEFycmF5LmpvaW4oXCIgXCIpOm4uZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZyxcIiBcIik6aS5kYXNoU3R5bGU9XCJcIixpLmVuZGNhcD1uLmxpbmVDYXAucmVwbGFjZShcImJ1dHRcIixcImZsYXRcIiksaS5qb2luc3R5bGU9bi5saW5lSm9pbik6aSYmKG8ucmVtb3ZlQ2hpbGQoaSksdC5fc3Ryb2tlPW51bGwpLG4uZmlsbD8oZXx8KGU9dC5fZmlsbD15bihcImZpbGxcIikpLG8uYXBwZW5kQ2hpbGQoZSksZS5jb2xvcj1uLmZpbGxDb2xvcnx8bi5jb2xvcixlLm9wYWNpdHk9bi5maWxsT3BhY2l0eSk6ZSYmKG8ucmVtb3ZlQ2hpbGQoZSksdC5fZmlsbD1udWxsKX0sX3VwZGF0ZUNpcmNsZTpmdW5jdGlvbih0KXt2YXIgaT10Ll9wb2ludC5yb3VuZCgpLGU9TWF0aC5yb3VuZCh0Ll9yYWRpdXMpLG49TWF0aC5yb3VuZCh0Ll9yYWRpdXNZfHxlKTt0aGlzLl9zZXRQYXRoKHQsdC5fZW1wdHkoKT9cIk0wIDBcIjpcIkFMIFwiK2kueCtcIixcIitpLnkrXCIgXCIrZStcIixcIituK1wiIDAsMjM1OTI2MDBcIil9LF9zZXRQYXRoOmZ1bmN0aW9uKHQsaSl7dC5fcGF0aC52PWl9LF9icmluZ1RvRnJvbnQ6ZnVuY3Rpb24odCl7WCh0Ll9jb250YWluZXIpfSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7Sih0Ll9jb250YWluZXIpfX0sd249JGk/eW46RSxQbj1nbi5leHRlbmQoe2dldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWduLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdC56b29tc3RhcnQ9dGhpcy5fb25ab29tU3RhcnQsdH0sX2luaXRDb250YWluZXI6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXI9d24oXCJzdmdcIiksdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpLHRoaXMuX3Jvb3RHcm91cD13bihcImdcIiksdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCl9LF9kZXN0cm95Q29udGFpbmVyOmZ1bmN0aW9uKCl7Syh0aGlzLl9jb250YWluZXIpLGZ0KHRoaXMuX2NvbnRhaW5lciksZGVsZXRlIHRoaXMuX2NvbnRhaW5lcixkZWxldGUgdGhpcy5fcm9vdEdyb3VwLGRlbGV0ZSB0aGlzLl9zdmdTaXplfSxfb25ab29tU3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGUoKX0sX3VwZGF0ZTpmdW5jdGlvbigpe2lmKCF0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb218fCF0aGlzLl9ib3VuZHMpe2duLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7dmFyIHQ9dGhpcy5fYm91bmRzLGk9dC5nZXRTaXplKCksZT10aGlzLl9jb250YWluZXI7dGhpcy5fc3ZnU2l6ZSYmdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoaSl8fCh0aGlzLl9zdmdTaXplPWksZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLGkueCksZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixpLnkpKSxhdChlLHQubWluKSxlLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIixbdC5taW4ueCx0Lm1pbi55LGkueCxpLnldLmpvaW4oXCIgXCIpKSx0aGlzLmZpcmUoXCJ1cGRhdGVcIil9fSxfaW5pdFBhdGg6ZnVuY3Rpb24odCl7dmFyIGk9dC5fcGF0aD13bihcInBhdGhcIik7dC5vcHRpb25zLmNsYXNzTmFtZSYmUShpLHQub3B0aW9ucy5jbGFzc05hbWUpLHQub3B0aW9ucy5pbnRlcmFjdGl2ZSYmUShpLFwibGVhZmxldC1pbnRlcmFjdGl2ZVwiKSx0aGlzLl91cGRhdGVTdHlsZSh0KSx0aGlzLl9sYXllcnNbbih0KV09dH0sX2FkZFBhdGg6ZnVuY3Rpb24odCl7dGhpcy5fcm9vdEdyb3VwfHx0aGlzLl9pbml0Q29udGFpbmVyKCksdGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKHQuX3BhdGgpLHQuYWRkSW50ZXJhY3RpdmVUYXJnZXQodC5fcGF0aCl9LF9yZW1vdmVQYXRoOmZ1bmN0aW9uKHQpe0sodC5fcGF0aCksdC5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0Ll9wYXRoKSxkZWxldGUgdGhpcy5fbGF5ZXJzW24odCldfSxfdXBkYXRlUGF0aDpmdW5jdGlvbih0KXt0Ll9wcm9qZWN0KCksdC5fdXBkYXRlKCl9LF91cGRhdGVTdHlsZTpmdW5jdGlvbih0KXt2YXIgaT10Ll9wYXRoLGU9dC5vcHRpb25zO2kmJihlLnN0cm9rZT8oaS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIixlLmNvbG9yKSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsZS5vcGFjaXR5KSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLGUud2VpZ2h0KSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsZS5saW5lQ2FwKSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLGUubGluZUpvaW4pLGUuZGFzaEFycmF5P2kuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGUuZGFzaEFycmF5KTppLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiksZS5kYXNoT2Zmc2V0P2kuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hvZmZzZXRcIixlLmRhc2hPZmZzZXQpOmkucmVtb3ZlQXR0cmlidXRlKFwic3Ryb2tlLWRhc2hvZmZzZXRcIikpOmkuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsXCJub25lXCIpLGUuZmlsbD8oaS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsZS5maWxsQ29sb3J8fGUuY29sb3IpLGkuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsZS5maWxsT3BhY2l0eSksaS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIixlLmZpbGxSdWxlfHxcImV2ZW5vZGRcIikpOmkuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwibm9uZVwiKSl9LF91cGRhdGVQb2x5OmZ1bmN0aW9uKHQsaSl7dGhpcy5fc2V0UGF0aCh0LGsodC5fcGFydHMsaSkpfSxfdXBkYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe3ZhciBpPXQuX3BvaW50LGU9TWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXMpLDEpLG49XCJhXCIrZStcIixcIisoTWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXNZKSwxKXx8ZSkrXCIgMCAxLDAgXCIsbz10Ll9lbXB0eSgpP1wiTTAgMFwiOlwiTVwiKyhpLngtZSkrXCIsXCIraS55K24rMiplK1wiLDAgXCIrbisyKi1lK1wiLDAgXCI7dGhpcy5fc2V0UGF0aCh0LG8pfSxfc2V0UGF0aDpmdW5jdGlvbih0LGkpe3QuX3BhdGguc2V0QXR0cmlidXRlKFwiZFwiLGkpfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKHQpe1godC5fcGF0aCl9LF9icmluZ1RvQmFjazpmdW5jdGlvbih0KXtKKHQuX3BhdGgpfX0pOyRpJiZQbi5pbmNsdWRlKHhuKSxiZS5pbmNsdWRlKHtnZXRSZW5kZXJlcjpmdW5jdGlvbih0KXt2YXIgaT10Lm9wdGlvbnMucmVuZGVyZXJ8fHRoaXMuX2dldFBhbmVSZW5kZXJlcih0Lm9wdGlvbnMucGFuZSl8fHRoaXMub3B0aW9ucy5yZW5kZXJlcnx8dGhpcy5fcmVuZGVyZXI7cmV0dXJuIGl8fChpPXRoaXMuX3JlbmRlcmVyPXRoaXMuX2NyZWF0ZVJlbmRlcmVyKCkpLHRoaXMuaGFzTGF5ZXIoaSl8fHRoaXMuYWRkTGF5ZXIoaSksaX0sX2dldFBhbmVSZW5kZXJlcjpmdW5jdGlvbih0KXtpZihcIm92ZXJsYXlQYW5lXCI9PT10fHx2b2lkIDA9PT10KXJldHVybiExO3ZhciBpPXRoaXMuX3BhbmVSZW5kZXJlcnNbdF07cmV0dXJuIHZvaWQgMD09PWkmJihpPXRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOnR9KSx0aGlzLl9wYW5lUmVuZGVyZXJzW3RdPWkpLGl9LF9jcmVhdGVSZW5kZXJlcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyYmJHQodCl8fFF0KHQpfX0pO3ZhciBMbj1vbi5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCxpKXtvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdGhpcy5fYm91bmRzVG9MYXRMbmdzKHQpLGkpfSxzZXRCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3ModCkpfSxfYm91bmRzVG9MYXRMbmdzOmZ1bmN0aW9uKHQpe3JldHVybiB0PXoodCksW3QuZ2V0U291dGhXZXN0KCksdC5nZXROb3J0aFdlc3QoKSx0LmdldE5vcnRoRWFzdCgpLHQuZ2V0U291dGhFYXN0KCldfX0pO1BuLmNyZWF0ZT13bixQbi5wb2ludHNUb1BhdGg9ayxzbi5nZW9tZXRyeVRvTGF5ZXI9RnQsc24uY29vcmRzVG9MYXRMbmc9VXQsc24uY29vcmRzVG9MYXRMbmdzPVZ0LHNuLmxhdExuZ1RvQ29vcmRzPXF0LHNuLmxhdExuZ3NUb0Nvb3Jkcz1HdCxzbi5nZXRGZWF0dXJlPUt0LHNuLmFzRmVhdHVyZT1ZdCxiZS5tZXJnZU9wdGlvbnMoe2JveFpvb206ITB9KTt2YXIgYm49RWUuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX2NvbnRhaW5lcj10Ll9jb250YWluZXIsdGhpcy5fcGFuZT10Ll9wYW5lcy5vdmVybGF5UGFuZSx0aGlzLl9yZXNldFN0YXRlVGltZW91dD0wLHQub24oXCJ1bmxvYWRcIix0aGlzLl9kZXN0cm95LHRoaXMpfSxhZGRIb29rczpmdW5jdGlvbigpe210KHRoaXMuX2NvbnRhaW5lcixcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe2Z0KHRoaXMuX2NvbnRhaW5lcixcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpfSxtb3ZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tb3ZlZH0sX2Rlc3Ryb3k6ZnVuY3Rpb24oKXtLKHRoaXMuX3BhbmUpLGRlbGV0ZSB0aGlzLl9wYW5lfSxfcmVzZXRTdGF0ZTpmdW5jdGlvbigpe3RoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0PTAsdGhpcy5fbW92ZWQ9ITF9LF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTpmdW5jdGlvbigpezAhPT10aGlzLl9yZXNldFN0YXRlVGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCksdGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQ9MCl9LF9vbk1vdXNlRG93bjpmdW5jdGlvbih0KXtpZighdC5zaGlmdEtleXx8MSE9PXQud2hpY2gmJjEhPT10LmJ1dHRvbilyZXR1cm4hMTt0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpLHRoaXMuX3Jlc2V0U3RhdGUoKSxmaSgpLHV0KCksdGhpcy5fc3RhcnRQb2ludD10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCksbXQoZG9jdW1lbnQse2NvbnRleHRtZW51Okx0LG1vdXNlbW92ZTp0aGlzLl9vbk1vdXNlTW92ZSxtb3VzZXVwOnRoaXMuX29uTW91c2VVcCxrZXlkb3duOnRoaXMuX29uS2V5RG93bn0sdGhpcyl9LF9vbk1vdXNlTW92ZTpmdW5jdGlvbih0KXt0aGlzLl9tb3ZlZHx8KHRoaXMuX21vdmVkPSEwLHRoaXMuX2JveD1HKFwiZGl2XCIsXCJsZWFmbGV0LXpvb20tYm94XCIsdGhpcy5fY29udGFpbmVyKSxRKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtY3Jvc3NoYWlyXCIpLHRoaXMuX21hcC5maXJlKFwiYm94em9vbXN0YXJ0XCIpKSx0aGlzLl9wb2ludD10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCk7dmFyIGk9bmV3IFAodGhpcy5fcG9pbnQsdGhpcy5fc3RhcnRQb2ludCksZT1pLmdldFNpemUoKTthdCh0aGlzLl9ib3gsaS5taW4pLHRoaXMuX2JveC5zdHlsZS53aWR0aD1lLngrXCJweFwiLHRoaXMuX2JveC5zdHlsZS5oZWlnaHQ9ZS55K1wicHhcIn0sX2ZpbmlzaDpmdW5jdGlvbigpe3RoaXMuX21vdmVkJiYoSyh0aGlzLl9ib3gpLHR0KHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtY3Jvc3NoYWlyXCIpKSxnaSgpLGx0KCksZnQoZG9jdW1lbnQse2NvbnRleHRtZW51Okx0LG1vdXNlbW92ZTp0aGlzLl9vbk1vdXNlTW92ZSxtb3VzZXVwOnRoaXMuX29uTW91c2VVcCxrZXlkb3duOnRoaXMuX29uS2V5RG93bn0sdGhpcyl9LF9vbk1vdXNlVXA6ZnVuY3Rpb24odCl7aWYoKDE9PT10LndoaWNofHwxPT09dC5idXR0b24pJiYodGhpcy5fZmluaXNoKCksdGhpcy5fbW92ZWQpKXt0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpLHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0PXNldFRpbWVvdXQoZSh0aGlzLl9yZXNldFN0YXRlLHRoaXMpLDApO3ZhciBpPW5ldyBUKHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7dGhpcy5fbWFwLmZpdEJvdW5kcyhpKS5maXJlKFwiYm94em9vbWVuZFwiLHtib3hab29tQm91bmRzOml9KX19LF9vbktleURvd246ZnVuY3Rpb24odCl7Mjc9PT10LmtleUNvZGUmJnRoaXMuX2ZpbmlzaCgpfX0pO2JlLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiYm94Wm9vbVwiLGJuKSxiZS5tZXJnZU9wdGlvbnMoe2RvdWJsZUNsaWNrWm9vbTohMH0pO3ZhciBUbj1FZS5leHRlbmQoe2FkZEhvb2tzOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLm9uKFwiZGJsY2xpY2tcIix0aGlzLl9vbkRvdWJsZUNsaWNrLHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX21hcC5vZmYoXCJkYmxjbGlja1wiLHRoaXMuX29uRG91YmxlQ2xpY2ssdGhpcyl9LF9vbkRvdWJsZUNsaWNrOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcCxlPWkuZ2V0Wm9vbSgpLG49aS5vcHRpb25zLnpvb21EZWx0YSxvPXQub3JpZ2luYWxFdmVudC5zaGlmdEtleT9lLW46ZStuO1wiY2VudGVyXCI9PT1pLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tP2kuc2V0Wm9vbShvKTppLnNldFpvb21Bcm91bmQodC5jb250YWluZXJQb2ludCxvKX19KTtiZS5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcImRvdWJsZUNsaWNrWm9vbVwiLFRuKSxiZS5tZXJnZU9wdGlvbnMoe2RyYWdnaW5nOiEwLGluZXJ0aWE6IU1pLGluZXJ0aWFEZWNlbGVyYXRpb246MzQwMCxpbmVydGlhTWF4U3BlZWQ6MS8wLGVhc2VMaW5lYXJpdHk6LjIsd29ybGRDb3B5SnVtcDohMSxtYXhCb3VuZHNWaXNjb3NpdHk6MH0pO3ZhciB6bj1FZS5leHRlbmQoe2FkZEhvb2tzOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX2RyYWdnYWJsZSl7dmFyIHQ9dGhpcy5fbWFwO3RoaXMuX2RyYWdnYWJsZT1uZXcgUmUodC5fbWFwUGFuZSx0Ll9jb250YWluZXIpLHRoaXMuX2RyYWdnYWJsZS5vbih7ZHJhZ3N0YXJ0OnRoaXMuX29uRHJhZ1N0YXJ0LGRyYWc6dGhpcy5fb25EcmFnLGRyYWdlbmQ6dGhpcy5fb25EcmFnRW5kfSx0aGlzKSx0aGlzLl9kcmFnZ2FibGUub24oXCJwcmVkcmFnXCIsdGhpcy5fb25QcmVEcmFnTGltaXQsdGhpcyksdC5vcHRpb25zLndvcmxkQ29weUp1bXAmJih0aGlzLl9kcmFnZ2FibGUub24oXCJwcmVkcmFnXCIsdGhpcy5fb25QcmVEcmFnV3JhcCx0aGlzKSx0Lm9uKFwiem9vbWVuZFwiLHRoaXMuX29uWm9vbUVuZCx0aGlzKSx0LndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsdGhpcykpfVEodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnXCIpLHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKSx0aGlzLl9wb3NpdGlvbnM9W10sdGhpcy5fdGltZXM9W119LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7dHQodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LWdyYWJcIiksdHQodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LXRvdWNoLWRyYWdcIiksdGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKX0sbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlJiZ0aGlzLl9kcmFnZ2FibGUuX21vdmVkfSxtb3Zpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlJiZ0aGlzLl9kcmFnZ2FibGUuX21vdmluZ30sX29uRHJhZ1N0YXJ0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwO2lmKHQuX3N0b3AoKSx0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMmJnRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSl7dmFyIGk9eih0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO3RoaXMuX29mZnNldExpbWl0PWIodGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoaS5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoaS5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSkuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKSx0aGlzLl92aXNjb3NpdHk9TWF0aC5taW4oMSxNYXRoLm1heCgwLHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpfWVsc2UgdGhpcy5fb2Zmc2V0TGltaXQ9bnVsbDt0LmZpcmUoXCJtb3Zlc3RhcnRcIikuZmlyZShcImRyYWdzdGFydFwiKSx0Lm9wdGlvbnMuaW5lcnRpYSYmKHRoaXMuX3Bvc2l0aW9ucz1bXSx0aGlzLl90aW1lcz1bXSl9LF9vbkRyYWc6ZnVuY3Rpb24odCl7aWYodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSl7dmFyIGk9dGhpcy5fbGFzdFRpbWU9K25ldyBEYXRlLGU9dGhpcy5fbGFzdFBvcz10aGlzLl9kcmFnZ2FibGUuX2Fic1Bvc3x8dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7dGhpcy5fcG9zaXRpb25zLnB1c2goZSksdGhpcy5fdGltZXMucHVzaChpKSx0aGlzLl9wcnVuZVBvc2l0aW9ucyhpKX10aGlzLl9tYXAuZmlyZShcIm1vdmVcIix0KS5maXJlKFwiZHJhZ1wiLHQpfSxfcHJ1bmVQb3NpdGlvbnM6ZnVuY3Rpb24odCl7Zm9yKDt0aGlzLl9wb3NpdGlvbnMubGVuZ3RoPjEmJnQtdGhpcy5fdGltZXNbMF0+NTA7KXRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpLHRoaXMuX3RpbWVzLnNoaWZ0KCl9LF9vblpvb21FbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLGk9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwwXSk7dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0PWkuc3VidHJhY3QodCkueCx0aGlzLl93b3JsZFdpZHRoPXRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLnh9LF92aXNjb3VzTGltaXQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC0odC1pKSp0aGlzLl92aXNjb3NpdHl9LF9vblByZURyYWdMaW1pdDpmdW5jdGlvbigpe2lmKHRoaXMuX3Zpc2Nvc2l0eSYmdGhpcy5fb2Zmc2V0TGltaXQpe3ZhciB0PXRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpLGk9dGhpcy5fb2Zmc2V0TGltaXQ7dC54PGkubWluLngmJih0Lng9dGhpcy5fdmlzY291c0xpbWl0KHQueCxpLm1pbi54KSksdC55PGkubWluLnkmJih0Lnk9dGhpcy5fdmlzY291c0xpbWl0KHQueSxpLm1pbi55KSksdC54PmkubWF4LngmJih0Lng9dGhpcy5fdmlzY291c0xpbWl0KHQueCxpLm1heC54KSksdC55PmkubWF4LnkmJih0Lnk9dGhpcy5fdmlzY291c0xpbWl0KHQueSxpLm1heC55KSksdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M9dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQodCl9fSxfb25QcmVEcmFnV3JhcDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3dvcmxkV2lkdGgsaT1NYXRoLnJvdW5kKHQvMiksZT10aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsbj10aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LG89KG4taStlKSV0K2ktZSxzPShuK2krZSkldC1pLWUscj1NYXRoLmFicyhvK2UpPE1hdGguYWJzKHMrZSk/bzpzO3RoaXMuX2RyYWdnYWJsZS5fYWJzUG9zPXRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCksdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueD1yfSxfb25EcmFnRW5kOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcCxlPWkub3B0aW9ucyxuPSFlLmluZXJ0aWF8fHRoaXMuX3RpbWVzLmxlbmd0aDwyO2lmKGkuZmlyZShcImRyYWdlbmRcIix0KSxuKWkuZmlyZShcIm1vdmVlbmRcIik7ZWxzZXt0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUpO3ZhciBvPXRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxzPSh0aGlzLl9sYXN0VGltZS10aGlzLl90aW1lc1swXSkvMWUzLHI9ZS5lYXNlTGluZWFyaXR5LGE9by5tdWx0aXBseUJ5KHIvcyksaD1hLmRpc3RhbmNlVG8oWzAsMF0pLHU9TWF0aC5taW4oZS5pbmVydGlhTWF4U3BlZWQsaCksbD1hLm11bHRpcGx5QnkodS9oKSxjPXUvKGUuaW5lcnRpYURlY2VsZXJhdGlvbipyKSxfPWwubXVsdGlwbHlCeSgtYy8yKS5yb3VuZCgpO18ueHx8Xy55PyhfPWkuX2xpbWl0T2Zmc2V0KF8saS5vcHRpb25zLm1heEJvdW5kcyksZihmdW5jdGlvbigpe2kucGFuQnkoXyx7ZHVyYXRpb246YyxlYXNlTGluZWFyaXR5OnIsbm9Nb3ZlU3RhcnQ6ITAsYW5pbWF0ZTohMH0pfSkpOmkuZmlyZShcIm1vdmVlbmRcIil9fX0pO2JlLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiZHJhZ2dpbmdcIix6biksYmUubWVyZ2VPcHRpb25zKHtrZXlib2FyZDohMCxrZXlib2FyZFBhbkRlbHRhOjgwfSk7dmFyIE1uPUVlLmV4dGVuZCh7a2V5Q29kZXM6e2xlZnQ6WzM3XSxyaWdodDpbMzldLGRvd246WzQwXSx1cDpbMzhdLHpvb21JbjpbMTg3LDEwNyw2MSwxNzFdLHpvb21PdXQ6WzE4OSwxMDksNTQsMTczXX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zZXRQYW5EZWx0YSh0Lm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSksdGhpcy5fc2V0Wm9vbURlbHRhKHQub3B0aW9ucy56b29tRGVsdGEpfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcC5fY29udGFpbmVyO3QudGFiSW5kZXg8PTAmJih0LnRhYkluZGV4PVwiMFwiKSxtdCh0LHtmb2N1czp0aGlzLl9vbkZvY3VzLGJsdXI6dGhpcy5fb25CbHVyLG1vdXNlZG93bjp0aGlzLl9vbk1vdXNlRG93bn0sdGhpcyksdGhpcy5fbWFwLm9uKHtmb2N1czp0aGlzLl9hZGRIb29rcyxibHVyOnRoaXMuX3JlbW92ZUhvb2tzfSx0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXt0aGlzLl9yZW1vdmVIb29rcygpLGZ0KHRoaXMuX21hcC5fY29udGFpbmVyLHtmb2N1czp0aGlzLl9vbkZvY3VzLGJsdXI6dGhpcy5fb25CbHVyLG1vdXNlZG93bjp0aGlzLl9vbk1vdXNlRG93bn0sdGhpcyksdGhpcy5fbWFwLm9mZih7Zm9jdXM6dGhpcy5fYWRkSG9va3MsYmx1cjp0aGlzLl9yZW1vdmVIb29rc30sdGhpcyl9LF9vbk1vdXNlRG93bjpmdW5jdGlvbigpe2lmKCF0aGlzLl9mb2N1c2VkKXt2YXIgdD1kb2N1bWVudC5ib2R5LGk9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGU9dC5zY3JvbGxUb3B8fGkuc2Nyb2xsVG9wLG49dC5zY3JvbGxMZWZ0fHxpLnNjcm9sbExlZnQ7dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKSx3aW5kb3cuc2Nyb2xsVG8obixlKX19LF9vbkZvY3VzOmZ1bmN0aW9uKCl7dGhpcy5fZm9jdXNlZD0hMCx0aGlzLl9tYXAuZmlyZShcImZvY3VzXCIpfSxfb25CbHVyOmZ1bmN0aW9uKCl7dGhpcy5fZm9jdXNlZD0hMSx0aGlzLl9tYXAuZmlyZShcImJsdXJcIil9LF9zZXRQYW5EZWx0YTpmdW5jdGlvbih0KXt2YXIgaSxlLG49dGhpcy5fcGFuS2V5cz17fSxvPXRoaXMua2V5Q29kZXM7Zm9yKGk9MCxlPW8ubGVmdC5sZW5ndGg7aTxlO2krKyluW28ubGVmdFtpXV09Wy0xKnQsMF07Zm9yKGk9MCxlPW8ucmlnaHQubGVuZ3RoO2k8ZTtpKyspbltvLnJpZ2h0W2ldXT1bdCwwXTtmb3IoaT0wLGU9by5kb3duLmxlbmd0aDtpPGU7aSsrKW5bby5kb3duW2ldXT1bMCx0XTtmb3IoaT0wLGU9by51cC5sZW5ndGg7aTxlO2krKyluW28udXBbaV1dPVswLC0xKnRdfSxfc2V0Wm9vbURlbHRhOmZ1bmN0aW9uKHQpe3ZhciBpLGUsbj10aGlzLl96b29tS2V5cz17fSxvPXRoaXMua2V5Q29kZXM7Zm9yKGk9MCxlPW8uem9vbUluLmxlbmd0aDtpPGU7aSsrKW5bby56b29tSW5baV1dPXQ7Zm9yKGk9MCxlPW8uem9vbU91dC5sZW5ndGg7aTxlO2krKyluW28uem9vbU91dFtpXV09LXR9LF9hZGRIb29rczpmdW5jdGlvbigpe210KGRvY3VtZW50LFwia2V5ZG93blwiLHRoaXMuX29uS2V5RG93bix0aGlzKX0sX3JlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7ZnQoZG9jdW1lbnQsXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duLHRoaXMpfSxfb25LZXlEb3duOmZ1bmN0aW9uKHQpe2lmKCEodC5hbHRLZXl8fHQuY3RybEtleXx8dC5tZXRhS2V5KSl7dmFyIGksZT10LmtleUNvZGUsbj10aGlzLl9tYXA7aWYoZSBpbiB0aGlzLl9wYW5LZXlzKW4uX3BhbkFuaW0mJm4uX3BhbkFuaW0uX2luUHJvZ3Jlc3N8fChpPXRoaXMuX3BhbktleXNbZV0sdC5zaGlmdEtleSYmKGk9dyhpKS5tdWx0aXBseUJ5KDMpKSxuLnBhbkJ5KGkpLG4ub3B0aW9ucy5tYXhCb3VuZHMmJm4ucGFuSW5zaWRlQm91bmRzKG4ub3B0aW9ucy5tYXhCb3VuZHMpKTtlbHNlIGlmKGUgaW4gdGhpcy5fem9vbUtleXMpbi5zZXRab29tKG4uZ2V0Wm9vbSgpKyh0LnNoaWZ0S2V5PzM6MSkqdGhpcy5fem9vbUtleXNbZV0pO2Vsc2V7aWYoMjchPT1lfHwhbi5fcG9wdXB8fCFuLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpcmV0dXJuO24uY2xvc2VQb3B1cCgpfUx0KHQpfX19KTtiZS5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcImtleWJvYXJkXCIsTW4pLGJlLm1lcmdlT3B0aW9ucyh7c2Nyb2xsV2hlZWxab29tOiEwLHdoZWVsRGVib3VuY2VUaW1lOjQwLHdoZWVsUHhQZXJab29tTGV2ZWw6NjB9KTt2YXIgQ249RWUuZXh0ZW5kKHthZGRIb29rczpmdW5jdGlvbigpe210KHRoaXMuX21hcC5fY29udGFpbmVyLFwibW91c2V3aGVlbFwiLHRoaXMuX29uV2hlZWxTY3JvbGwsdGhpcyksdGhpcy5fZGVsdGE9MH0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXtmdCh0aGlzLl9tYXAuX2NvbnRhaW5lcixcIm1vdXNld2hlZWxcIix0aGlzLl9vbldoZWVsU2Nyb2xsLHRoaXMpfSxfb25XaGVlbFNjcm9sbDpmdW5jdGlvbih0KXt2YXIgaT1UdCh0KSxuPXRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO3RoaXMuX2RlbHRhKz1pLHRoaXMuX2xhc3RNb3VzZVBvcz10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCksdGhpcy5fc3RhcnRUaW1lfHwodGhpcy5fc3RhcnRUaW1lPStuZXcgRGF0ZSk7dmFyIG89TWF0aC5tYXgobi0oK25ldyBEYXRlLXRoaXMuX3N0YXJ0VGltZSksMCk7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSx0aGlzLl90aW1lcj1zZXRUaW1lb3V0KGUodGhpcy5fcGVyZm9ybVpvb20sdGhpcyksbyksTHQodCl9LF9wZXJmb3JtWm9vbTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCxpPXQuZ2V0Wm9vbSgpLGU9dGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXB8fDA7dC5fc3RvcCgpO3ZhciBuPXRoaXMuX2RlbHRhLyg0KnRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwpLG89NCpNYXRoLmxvZygyLygxK01hdGguZXhwKC1NYXRoLmFicyhuKSkpKS9NYXRoLkxOMixzPWU/TWF0aC5jZWlsKG8vZSkqZTpvLHI9dC5fbGltaXRab29tKGkrKHRoaXMuX2RlbHRhPjA/czotcykpLWk7dGhpcy5fZGVsdGE9MCx0aGlzLl9zdGFydFRpbWU9bnVsbCxyJiYoXCJjZW50ZXJcIj09PXQub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20/dC5zZXRab29tKGkrcik6dC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcyxpK3IpKX19KTtiZS5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcInNjcm9sbFdoZWVsWm9vbVwiLENuKSxiZS5tZXJnZU9wdGlvbnMoe3RhcDohMCx0YXBUb2xlcmFuY2U6MTV9KTt2YXIgU249RWUuZXh0ZW5kKHthZGRIb29rczpmdW5jdGlvbigpe210KHRoaXMuX21hcC5fY29udGFpbmVyLFwidG91Y2hzdGFydFwiLHRoaXMuX29uRG93bix0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXtmdCh0aGlzLl9tYXAuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vbkRvd24sdGhpcyl9LF9vbkRvd246ZnVuY3Rpb24odCl7aWYodC50b3VjaGVzKXtpZihQdCh0KSx0aGlzLl9maXJlQ2xpY2s9ITAsdC50b3VjaGVzLmxlbmd0aD4xKXJldHVybiB0aGlzLl9maXJlQ2xpY2s9ITEsdm9pZCBjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO3ZhciBpPXQudG91Y2hlc1swXSxuPWkudGFyZ2V0O3RoaXMuX3N0YXJ0UG9zPXRoaXMuX25ld1Bvcz1uZXcgeChpLmNsaWVudFgsaS5jbGllbnRZKSxuLnRhZ05hbWUmJlwiYVwiPT09bi50YWdOYW1lLnRvTG93ZXJDYXNlKCkmJlEobixcImxlYWZsZXQtYWN0aXZlXCIpLHRoaXMuX2hvbGRUaW1lb3V0PXNldFRpbWVvdXQoZShmdW5jdGlvbigpe3RoaXMuX2lzVGFwVmFsaWQoKSYmKHRoaXMuX2ZpcmVDbGljaz0hMSx0aGlzLl9vblVwKCksdGhpcy5fc2ltdWxhdGVFdmVudChcImNvbnRleHRtZW51XCIsaSkpfSx0aGlzKSwxZTMpLHRoaXMuX3NpbXVsYXRlRXZlbnQoXCJtb3VzZWRvd25cIixpKSxtdChkb2N1bWVudCx7dG91Y2htb3ZlOnRoaXMuX29uTW92ZSx0b3VjaGVuZDp0aGlzLl9vblVwfSx0aGlzKX19LF9vblVwOmZ1bmN0aW9uKHQpe2lmKGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCksZnQoZG9jdW1lbnQse3RvdWNobW92ZTp0aGlzLl9vbk1vdmUsdG91Y2hlbmQ6dGhpcy5fb25VcH0sdGhpcyksdGhpcy5fZmlyZUNsaWNrJiZ0JiZ0LmNoYW5nZWRUb3VjaGVzKXt2YXIgaT10LmNoYW5nZWRUb3VjaGVzWzBdLGU9aS50YXJnZXQ7ZSYmZS50YWdOYW1lJiZcImFcIj09PWUudGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZ0dChlLFwibGVhZmxldC1hY3RpdmVcIiksdGhpcy5fc2ltdWxhdGVFdmVudChcIm1vdXNldXBcIixpKSx0aGlzLl9pc1RhcFZhbGlkKCkmJnRoaXMuX3NpbXVsYXRlRXZlbnQoXCJjbGlja1wiLGkpfX0sX2lzVGFwVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpPD10aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2V9LF9vbk1vdmU6ZnVuY3Rpb24odCl7dmFyIGk9dC50b3VjaGVzWzBdO3RoaXMuX25ld1Bvcz1uZXcgeChpLmNsaWVudFgsaS5jbGllbnRZKSx0aGlzLl9zaW11bGF0ZUV2ZW50KFwibW91c2Vtb3ZlXCIsaSl9LF9zaW11bGF0ZUV2ZW50OmZ1bmN0aW9uKHQsaSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtlLl9zaW11bGF0ZWQ9ITAsaS50YXJnZXQuX3NpbXVsYXRlZENsaWNrPSEwLGUuaW5pdE1vdXNlRXZlbnQodCwhMCwhMCx3aW5kb3csMSxpLnNjcmVlblgsaS5zY3JlZW5ZLGkuY2xpZW50WCxpLmNsaWVudFksITEsITEsITEsITEsMCxudWxsKSxpLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpfX0pO3FpJiYhVmkmJmJlLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwidGFwXCIsU24pLGJlLm1lcmdlT3B0aW9ucyh7dG91Y2hab29tOnFpJiYhTWksYm91bmNlQXRab29tTGltaXRzOiEwfSk7dmFyIFpuPUVlLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXtRKHRoaXMuX21hcC5fY29udGFpbmVyLFwibGVhZmxldC10b3VjaC16b29tXCIpLG10KHRoaXMuX21hcC5fY29udGFpbmVyLFwidG91Y2hzdGFydFwiLHRoaXMuX29uVG91Y2hTdGFydCx0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXt0dCh0aGlzLl9tYXAuX2NvbnRhaW5lcixcImxlYWZsZXQtdG91Y2gtem9vbVwiKSxmdCh0aGlzLl9tYXAuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vblRvdWNoU3RhcnQsdGhpcyl9LF9vblRvdWNoU3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwO2lmKHQudG91Y2hlcyYmMj09PXQudG91Y2hlcy5sZW5ndGgmJiFpLl9hbmltYXRpbmdab29tJiYhdGhpcy5fem9vbWluZyl7dmFyIGU9aS5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMF0pLG49aS5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMV0pO3RoaXMuX2NlbnRlclBvaW50PWkuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSx0aGlzLl9zdGFydExhdExuZz1pLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpLFwiY2VudGVyXCIhPT1pLm9wdGlvbnMudG91Y2hab29tJiYodGhpcy5fcGluY2hTdGFydExhdExuZz1pLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoZS5hZGQobikuX2RpdmlkZUJ5KDIpKSksdGhpcy5fc3RhcnREaXN0PWUuZGlzdGFuY2VUbyhuKSx0aGlzLl9zdGFydFpvb209aS5nZXRab29tKCksdGhpcy5fbW92ZWQ9ITEsdGhpcy5fem9vbWluZz0hMCxpLl9zdG9wKCksbXQoZG9jdW1lbnQsXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKSxtdChkb2N1bWVudCxcInRvdWNoZW5kXCIsdGhpcy5fb25Ub3VjaEVuZCx0aGlzKSxQdCh0KX19LF9vblRvdWNoTW92ZTpmdW5jdGlvbih0KXtpZih0LnRvdWNoZXMmJjI9PT10LnRvdWNoZXMubGVuZ3RoJiZ0aGlzLl96b29taW5nKXt2YXIgaT10aGlzLl9tYXAsbj1pLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQudG91Y2hlc1swXSksbz1pLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQudG91Y2hlc1sxXSkscz1uLmRpc3RhbmNlVG8obykvdGhpcy5fc3RhcnREaXN0O2lmKHRoaXMuX3pvb209aS5nZXRTY2FsZVpvb20ocyx0aGlzLl9zdGFydFpvb20pLCFpLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzJiYodGhpcy5fem9vbTxpLmdldE1pblpvb20oKSYmczwxfHx0aGlzLl96b29tPmkuZ2V0TWF4Wm9vbSgpJiZzPjEpJiYodGhpcy5fem9vbT1pLl9saW1pdFpvb20odGhpcy5fem9vbSkpLFwiY2VudGVyXCI9PT1pLm9wdGlvbnMudG91Y2hab29tKXtpZih0aGlzLl9jZW50ZXI9dGhpcy5fc3RhcnRMYXRMbmcsMT09PXMpcmV0dXJufWVsc2V7dmFyIHI9bi5fYWRkKG8pLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO2lmKDE9PT1zJiYwPT09ci54JiYwPT09ci55KXJldHVybjt0aGlzLl9jZW50ZXI9aS51bnByb2plY3QoaS5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsdGhpcy5fem9vbSkuc3VidHJhY3QociksdGhpcy5fem9vbSl9dGhpcy5fbW92ZWR8fChpLl9tb3ZlU3RhcnQoITAsITEpLHRoaXMuX21vdmVkPSEwKSxnKHRoaXMuX2FuaW1SZXF1ZXN0KTt2YXIgYT1lKGkuX21vdmUsaSx0aGlzLl9jZW50ZXIsdGhpcy5fem9vbSx7cGluY2g6ITAscm91bmQ6ITF9KTt0aGlzLl9hbmltUmVxdWVzdD1mKGEsdGhpcywhMCksUHQodCl9fSxfb25Ub3VjaEVuZDpmdW5jdGlvbigpe3RoaXMuX21vdmVkJiZ0aGlzLl96b29taW5nPyh0aGlzLl96b29taW5nPSExLGcodGhpcy5fYW5pbVJlcXVlc3QpLGZ0KGRvY3VtZW50LFwidG91Y2htb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUpLGZ0KGRvY3VtZW50LFwidG91Y2hlbmRcIix0aGlzLl9vblRvdWNoRW5kKSx0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uP3RoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCEwLHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTp0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpKTp0aGlzLl96b29taW5nPSExfX0pO2JlLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwidG91Y2hab29tXCIsWm4pLGJlLkJveFpvb209Ym4sYmUuRG91YmxlQ2xpY2tab29tPVRuLGJlLkRyYWc9em4sYmUuS2V5Ym9hcmQ9TW4sYmUuU2Nyb2xsV2hlZWxab29tPUNuLGJlLlRhcD1TbixiZS5Ub3VjaFpvb209Wm4sT2JqZWN0LmZyZWV6ZT10aSx0LnZlcnNpb249XCIxLjQuMFwiLHQuQ29udHJvbD1UZSx0LmNvbnRyb2w9emUsdC5Ccm93c2VyPVFpLHQuRXZlbnRlZD1jaSx0Lk1peGluPUJlLHQuVXRpbD11aSx0LkNsYXNzPXYsdC5IYW5kbGVyPUVlLHQuZXh0ZW5kPWksdC5iaW5kPWUsdC5zdGFtcD1uLHQuc2V0T3B0aW9ucz1sLHQuRG9tRXZlbnQ9UGUsdC5Eb21VdGlsPXZlLHQuUG9zQW5pbWF0aW9uPUxlLHQuRHJhZ2dhYmxlPVJlLHQuTGluZVV0aWw9TmUsdC5Qb2x5VXRpbD1EZSx0LlBvaW50PXgsdC5wb2ludD13LHQuQm91bmRzPVAsdC5ib3VuZHM9Yix0LlRyYW5zZm9ybWF0aW9uPVMsdC50cmFuc2Zvcm1hdGlvbj1aLHQuUHJvamVjdGlvbj1IZSx0LkxhdExuZz1NLHQubGF0TG5nPUMsdC5MYXRMbmdCb3VuZHM9VCx0LmxhdExuZ0JvdW5kcz16LHQuQ1JTPWRpLHQuR2VvSlNPTj1zbix0Lmdlb0pTT049WHQsdC5nZW9Kc29uPWFuLHQuTGF5ZXI9cWUsdC5MYXllckdyb3VwPUdlLHQubGF5ZXJHcm91cD1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcgR2UodCxpKX0sdC5GZWF0dXJlR3JvdXA9S2UsdC5mZWF0dXJlR3JvdXA9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBLZSh0KX0sdC5JbWFnZU92ZXJsYXk9aG4sdC5pbWFnZU92ZXJsYXk9ZnVuY3Rpb24odCxpLGUpe3JldHVybiBuZXcgaG4odCxpLGUpfSx0LlZpZGVvT3ZlcmxheT11bix0LnZpZGVvT3ZlcmxheT1mdW5jdGlvbih0LGksZSl7cmV0dXJuIG5ldyB1bih0LGksZSl9LHQuRGl2T3ZlcmxheT1sbix0LlBvcHVwPWNuLHQucG9wdXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IGNuKHQsaSl9LHQuVG9vbHRpcD1fbix0LnRvb2x0aXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IF9uKHQsaSl9LHQuSWNvbj1ZZSx0Lmljb249ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBZZSh0KX0sdC5EaXZJY29uPWRuLHQuZGl2SWNvbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGRuKHQpfSx0Lk1hcmtlcj0kZSx0Lm1hcmtlcj1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcgJGUodCxpKX0sdC5UaWxlTGF5ZXI9bW4sdC50aWxlTGF5ZXI9SnQsdC5HcmlkTGF5ZXI9cG4sdC5ncmlkTGF5ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBwbih0KX0sdC5TVkc9UG4sdC5zdmc9UXQsdC5SZW5kZXJlcj1nbix0LkNhbnZhcz12bix0LmNhbnZhcz0kdCx0LlBhdGg9UWUsdC5DaXJjbGVNYXJrZXI9dG4sdC5jaXJjbGVNYXJrZXI9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IHRuKHQsaSl9LHQuQ2lyY2xlPWVuLHQuY2lyY2xlPWZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gbmV3IGVuKHQsaSxlKX0sdC5Qb2x5bGluZT1ubix0LnBvbHlsaW5lPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBubih0LGkpfSx0LlBvbHlnb249b24sdC5wb2x5Z29uPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBvbih0LGkpfSx0LlJlY3RhbmdsZT1Mbix0LnJlY3RhbmdsZT1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcgTG4odCxpKX0sdC5NYXA9YmUsdC5tYXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IGJlKHQsaSl9O3ZhciBFbj13aW5kb3cuTDt0Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93Lkw9RW4sdGhpc30sd2luZG93Lkw9dH0pOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8qIVxuICogT09VSSB2MC4zMC4yXG4gKiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSVxuICpcbiAqIENvcHlyaWdodCAyMDEx4oCTMjAxOSBPT1VJIFRlYW0gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL29vanMubWl0LWxpY2Vuc2Uub3JnXG4gKlxuICogRGF0ZTogMjAxOS0wMS0yM1QwMToxNDoyMFpcbiAqL1xuKCBmdW5jdGlvbiAoIE9PICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5UaGVtZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5PTy51aS5XaWtpbWVkaWFVSVRoZW1lID0gZnVuY3Rpb24gT29VaVdpa2ltZWRpYVVJVGhlbWUoKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5XaWtpbWVkaWFVSVRoZW1lLnBhcmVudC5jYWxsKCB0aGlzICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLldpa2ltZWRpYVVJVGhlbWUsIE9PLnVpLlRoZW1lICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5XaWtpbWVkaWFVSVRoZW1lLnByb3RvdHlwZS5nZXRFbGVtZW50Q2xhc3NlcyA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblx0Ly8gUGFyZW50IG1ldGhvZFxuXHR2YXIgdmFyaWFudCwgaXNGcmFtZWQsIGlzQWN0aXZlLCBpc1Rvb2xPckdyb3VwLFxuXHRcdHZhcmlhbnRzID0ge1xuXHRcdFx0d2FybmluZzogZmFsc2UsXG5cdFx0XHRpbnZlcnQ6IGZhbHNlLFxuXHRcdFx0cHJvZ3Jlc3NpdmU6IGZhbHNlLFxuXHRcdFx0ZGVzdHJ1Y3RpdmU6IGZhbHNlXG5cdFx0fSxcblx0XHQvLyBQYXJlbnQgbWV0aG9kXG5cdFx0Y2xhc3NlcyA9IE9PLnVpLldpa2ltZWRpYVVJVGhlbWUucGFyZW50LnByb3RvdHlwZS5nZXRFbGVtZW50Q2xhc3Nlcy5jYWxsKCB0aGlzLCBlbGVtZW50ICk7XG5cblx0aWYgKFxuXHRcdGVsZW1lbnQgaW5zdGFuY2VvZiBPTy51aS5JY29uV2lkZ2V0ICYmXG5cdFx0ZWxlbWVudC4kZWxlbWVudC5oYXNDbGFzcyggJ29vLXVpLWNoZWNrYm94SW5wdXRXaWRnZXQtY2hlY2tJY29uJyApXG5cdCkge1xuXHRcdC8vIEljb24gb24gQ2hlY2tib3hJbnB1dFdpZGdldFxuXHRcdHZhcmlhbnRzLmludmVydCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoIGVsZW1lbnQuc3VwcG9ydHMoIFsgJ2hhc0ZsYWcnIF0gKSApIHtcblx0XHRpc0ZyYW1lZCA9IGVsZW1lbnQuc3VwcG9ydHMoIFsgJ2lzRnJhbWVkJyBdICkgJiYgZWxlbWVudC5pc0ZyYW1lZCgpO1xuXHRcdGlzQWN0aXZlID0gZWxlbWVudC5zdXBwb3J0cyggWyAnaXNBY3RpdmUnIF0gKSAmJiBlbGVtZW50LmlzQWN0aXZlKCk7XG5cdFx0aXNUb29sT3JHcm91cCA9XG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgY2xhc3MgZXhpc3RzLCBhcyBjbGFzc2VzIHRoYXQgYXJlIG5vdCBpbiB0aGUgJ2NvcmUnIG1vZHVsZSBtYXkgbm90IGJlIGxvYWRlZFxuXHRcdFx0KCBPTy51aS5Ub29sICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBPTy51aS5Ub29sICkgfHxcblx0XHRcdCggT08udWkuVG9vbEdyb3VwICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBPTy51aS5Ub29sR3JvdXAgKTtcblx0XHRpZiAoXG5cdFx0XHQvLyBCdXR0b24gd2l0aCBhIGRhcmsgYmFja2dyb3VuZFxuXHRcdFx0aXNGcmFtZWQgJiYgKCBpc0FjdGl2ZSB8fCBlbGVtZW50LmlzRGlzYWJsZWQoKSB8fCBlbGVtZW50Lmhhc0ZsYWcoICdwcmltYXJ5JyApICkgfHxcblx0XHRcdC8vIFRvb2xiYXIgd2l0aCBhIGRhcmsgYmFja2dyb3VuZFxuXHRcdFx0aXNUb29sT3JHcm91cCAmJiBlbGVtZW50Lmhhc0ZsYWcoICdwcmltYXJ5JyApXG5cdFx0KSB7XG5cdFx0XHQvLyDigKYgdXNlIHdoaXRlIGljb24gLyBpbmRpY2F0b3IsIHJlZ2FyZGxlc3Mgb2Ygb3RoZXIgZmxhZ3Ncblx0XHRcdHZhcmlhbnRzLmludmVydCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmICggIWlzRnJhbWVkICYmIGVsZW1lbnQuaXNEaXNhYmxlZCgpICkge1xuXHRcdFx0Ly8gRnJhbWVsZXNzIGRpc2FibGVkIGJ1dHRvbiwgYWx3YXlzIHVzZSBibGFjayBpY29uIC8gaW5kaWNhdG9yIHJlZ2FyZGxlc3Mgb2Ygb3RoZXIgZmxhZ3Ncblx0XHRcdHZhcmlhbnRzLmludmVydCA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoICFlbGVtZW50LmlzRGlzYWJsZWQoKSApIHtcblx0XHRcdC8vIEFueSBvdGhlciBraW5kIG9mIGJ1dHRvbiwgdXNlIHRoZSByaWdodCBjb2xvcmVkIGljb24gLyBpbmRpY2F0b3IgaWYgYXZhaWxhYmxlXG5cdFx0XHR2YXJpYW50cy5wcm9ncmVzc2l2ZSA9IGVsZW1lbnQuaGFzRmxhZyggJ3Byb2dyZXNzaXZlJyApIHx8XG5cdFx0XHRcdC8vIEFjdGl2ZSB0b29scy90b29sZ3JvdXBzXG5cdFx0XHRcdCggaXNUb29sT3JHcm91cCAmJiBpc0FjdGl2ZSApIHx8XG5cdFx0XHRcdC8vIFByZXNzZWQgb3Igc2VsZWN0ZWQgb3V0bGluZS9tZW51IG9wdGlvbiB3aWRnZXRzXG5cdFx0XHRcdChcblx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHRlbGVtZW50IGluc3RhbmNlb2YgT08udWkuTWVudU9wdGlvbldpZGdldCB8fFxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIGNsYXNzIGV4aXN0cywgYXMgY2xhc3NlcyB0aGF0IGFyZSBub3QgaW4gdGhlICdjb3JlJyBtb2R1bGUgbWF5IG5vdCBiZSBsb2FkZWRcblx0XHRcdFx0XHRcdCggT08udWkuT3V0bGluZU9wdGlvbldpZGdldCAmJiBlbGVtZW50IGluc3RhbmNlb2YgT08udWkuT3V0bGluZU9wdGlvbldpZGdldCApXG5cdFx0XHRcdFx0KSAmJlxuXHRcdFx0XHRcdCggZWxlbWVudC5pc1ByZXNzZWQoKSB8fCBlbGVtZW50LmlzU2VsZWN0ZWQoKSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdHZhcmlhbnRzLmRlc3RydWN0aXZlID0gZWxlbWVudC5oYXNGbGFnKCAnZGVzdHJ1Y3RpdmUnICk7XG5cdFx0XHR2YXJpYW50cy53YXJuaW5nID0gZWxlbWVudC5oYXNGbGFnKCAnd2FybmluZycgKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKCB2YXJpYW50IGluIHZhcmlhbnRzICkge1xuXHRcdGNsYXNzZXNbIHZhcmlhbnRzWyB2YXJpYW50IF0gPyAnb24nIDogJ29mZicgXS5wdXNoKCAnb28tdWktaW1hZ2UtJyArIHZhcmlhbnQgKTtcblx0fVxuXG5cdHJldHVybiBjbGFzc2VzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5XaWtpbWVkaWFVSVRoZW1lLnByb3RvdHlwZS5nZXREaWFsb2dUcmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAyNTA7XG59O1xuXG4vKiBJbnN0YW50aWF0aW9uICovXG5cbk9PLnVpLnRoZW1lID0gbmV3IE9PLnVpLldpa2ltZWRpYVVJVGhlbWUoKTtcblxufSggT08gKSApO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vb2pzLXVpLXdpa2ltZWRpYXVpLmpzLm1hcC5qc29uIiwiLyohXG4gKiBPT1VJIHYwLjMwLjJcbiAqIGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJXG4gKlxuICogQ29weXJpZ2h0IDIwMTHigJMyMDE5IE9PVUkgVGVhbSBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vb29qcy5taXQtbGljZW5zZS5vcmdcbiAqXG4gKiBEYXRlOiAyMDE5LTAxLTIzVDAxOjE0OjIwWlxuICovXG4oIGZ1bmN0aW9uICggT08gKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIGFsbCBjbGFzc2VzLCBzdGF0aWMgbWV0aG9kcyBhbmQgc3RhdGljIHByb3BlcnRpZXMuXG4gKlxuICogQGNsYXNzXG4gKiBAc2luZ2xldG9uXG4gKi9cbk9PLnVpID0ge307XG5cbk9PLnVpLmJpbmQgPSAkLnByb3h5O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICovXG5PTy51aS5LZXlzID0ge1xuXHRVTkRFRklORUQ6IDAsXG5cdEJBQ0tTUEFDRTogOCxcblx0REVMRVRFOiA0Nixcblx0TEVGVDogMzcsXG5cdFJJR0hUOiAzOSxcblx0VVA6IDM4LFxuXHRET1dOOiA0MCxcblx0RU5URVI6IDEzLFxuXHRFTkQ6IDM1LFxuXHRIT01FOiAzNixcblx0VEFCOiA5LFxuXHRQQUdFVVA6IDMzLFxuXHRQQUdFRE9XTjogMzQsXG5cdEVTQ0FQRTogMjcsXG5cdFNISUZUOiAxNixcblx0U1BBQ0U6IDMyXG59O1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgTW91c2VFdmVudC53aGljaFxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICovXG5PTy51aS5Nb3VzZUJ1dHRvbnMgPSB7XG5cdExFRlQ6IDEsXG5cdE1JRERMRTogMixcblx0UklHSFQ6IDNcbn07XG5cbi8qKlxuICogQHByb3BlcnR5IHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5lbGVtZW50SWQgPSAwO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBlbGVtZW50XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBJRFxuICovXG5PTy51aS5nZW5lcmF0ZUVsZW1lbnRJZCA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkuZWxlbWVudElkKys7XG5cdHJldHVybiAnb291aS0nICsgT08udWkuZWxlbWVudElkO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGZvY3VzYWJsZS5cbiAqIEluc3BpcmVkIGJ5IDpmb2N1c2FibGUgaW4galF1ZXJ5VUkgdjEuMTEuNCAtIDIwMTUtMDQtMTRcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgRWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBFbGVtZW50IGlzIGZvY3VzYWJsZVxuICovXG5PTy51aS5pc0ZvY3VzYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoICRlbGVtZW50ICkge1xuXHR2YXIgbm9kZU5hbWUsXG5cdFx0ZWxlbWVudCA9ICRlbGVtZW50WyAwIF07XG5cblx0Ly8gQW55dGhpbmcgZGlzYWJsZWQgaXMgbm90IGZvY3VzYWJsZVxuXHRpZiAoIGVsZW1lbnQuZGlzYWJsZWQgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZVxuXHRpZiAoICEoXG5cdFx0Ly8gVGhpcyBpcyBxdWlja2VyIHRoYW4gY2FsbGluZyAkZWxlbWVudC5pcyggJzp2aXNpYmxlJyApXG5cdFx0JC5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbWVudCApICYmXG5cdFx0Ly8gQ2hlY2sgdGhhdCBhbGwgcGFyZW50cyBhcmUgdmlzaWJsZVxuXHRcdCEkZWxlbWVudC5wYXJlbnRzKCkuYWRkQmFjaygpLmZpbHRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCAndmlzaWJpbGl0eScgKSA9PT0gJ2hpZGRlbic7XG5cdFx0fSApLmxlbmd0aFxuXHQpICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIENvbnRlbnRFZGl0YWJsZSwgd2hpY2ggaXMgdGhlIHN0cmluZyAndHJ1ZSdcblx0aWYgKCBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQW55dGhpbmcgd2l0aCBhIG5vbi1uZWdhdGl2ZSBudW1lcmljIHRhYkluZGV4IGlzIGZvY3VzYWJsZS5cblx0Ly8gVXNlIC5wcm9wIHRvIGF2b2lkIGJyb3dzZXIgYnVnc1xuXHRpZiAoICRlbGVtZW50LnByb3AoICd0YWJJbmRleCcgKSA+PSAwICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gU29tZSBlbGVtZW50IHR5cGVzIGFyZSBuYXR1cmFsbHkgZm9jdXNhYmxlXG5cdC8vIChpbmRleE9mIGlzIG11Y2ggZmFzdGVyIHRoYW4gcmVnZXggaW4gQ2hyb21lIGFuZCBhYm91dCB0aGVcblx0Ly8gc2FtZSBpbiBGRjogaHR0cHM6Ly9qc3BlcmYuY29tL3JlZ2V4LXZzLWluZGV4b2YtYXJyYXkyKVxuXHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0aWYgKCBbICdpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnYnV0dG9uJywgJ29iamVjdCcgXS5pbmRleE9mKCBub2RlTmFtZSApICE9PSAtMSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIExpbmtzIGFuZCBhcmVhcyBhcmUgZm9jdXNhYmxlIGlmIHRoZXkgaGF2ZSBhbiBocmVmXG5cdGlmICggKCBub2RlTmFtZSA9PT0gJ2EnIHx8IG5vZGVOYW1lID09PSAnYXJlYScgKSAmJiAkZWxlbWVudC5hdHRyKCAnaHJlZicgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBGaW5kIGEgZm9jdXNhYmxlIGNoaWxkXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICRjb250YWluZXIgQ29udGFpbmVyIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHtib29sZWFufSBbYmFja3dhcmRzXSBTZWFyY2ggYmFja3dhcmRzXG4gKiBAcmV0dXJuIHtqUXVlcnl9IEZvY3VzYWJsZSBjaGlsZCwgb3IgYW4gZW1wdHkgalF1ZXJ5IG9iamVjdCBpZiBub25lIGZvdW5kXG4gKi9cbk9PLnVpLmZpbmRGb2N1c2FibGUgPSBmdW5jdGlvbiAoICRjb250YWluZXIsIGJhY2t3YXJkcyApIHtcblx0dmFyICRmb2N1c2FibGUgPSAkKCBbXSApLFxuXHRcdC8vICRmb2N1c2FibGVDYW5kaWRhdGVzIGlzIGEgc3VwZXJzZXQgb2YgdGhpbmdzIHRoYXRcblx0XHQvLyBjb3VsZCBnZXQgbWF0Y2hlZCBieSBpc0ZvY3VzYWJsZUVsZW1lbnRcblx0XHQkZm9jdXNhYmxlQ2FuZGlkYXRlcyA9ICRjb250YWluZXJcblx0XHRcdC5maW5kKCAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwgb2JqZWN0LCBhLCBhcmVhLCBbY29udGVudGVkaXRhYmxlXSwgW3RhYmluZGV4XScgKTtcblxuXHRpZiAoIGJhY2t3YXJkcyApIHtcblx0XHQkZm9jdXNhYmxlQ2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoICRmb2N1c2FibGVDYW5kaWRhdGVzICk7XG5cdH1cblxuXHQkZm9jdXNhYmxlQ2FuZGlkYXRlcy5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyICR0aGlzID0gJCggdGhpcyApO1xuXHRcdGlmICggT08udWkuaXNGb2N1c2FibGVFbGVtZW50KCAkdGhpcyApICkge1xuXHRcdFx0JGZvY3VzYWJsZSA9ICR0aGlzO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSApO1xuXHRyZXR1cm4gJGZvY3VzYWJsZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB1c2VyJ3MgbGFuZ3VhZ2UgYW5kIGFueSBmYWxsYmFjayBsYW5ndWFnZXMuXG4gKlxuICogVGhlc2UgbGFuZ3VhZ2UgY29kZXMgYXJlIHVzZWQgdG8gbG9jYWxpemUgdXNlciBpbnRlcmZhY2UgZWxlbWVudHMgaW4gdGhlIHVzZXIncyBsYW5ndWFnZS5cbiAqXG4gKiBJbiBlbnZpcm9ubWVudHMgdGhhdCBwcm92aWRlIGEgbG9jYWxpemF0aW9uIHN5c3RlbSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbiB0b1xuICogcmV0dXJuIHRoZSB1c2VyJ3MgbGFuZ3VhZ2UocykuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgRW5nbGlzaCAoZW4pIG9ubHkuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119IExhbmd1YWdlIGNvZGVzLCBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHByaW9yaXR5XG4gKi9cbk9PLnVpLmdldFVzZXJMYW5ndWFnZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBbICdlbicgXTtcbn07XG5cbi8qKlxuICogR2V0IGEgdmFsdWUgaW4gYW4gb2JqZWN0IGtleWVkIGJ5IGxhbmd1YWdlIGNvZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxNaXhlZD59IG9iaiBPYmplY3Qga2V5ZWQgYnkgbGFuZ3VhZ2UgY29kZVxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2xhbmddIExhbmd1YWdlIGNvZGUsIGlmIG9taXR0ZWQgb3IgbnVsbCBkZWZhdWx0cyB0byBhbnkgdXNlciBsYW5ndWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtmYWxsYmFja10gRmFsbGJhY2sgY29kZSwgdXNlZCBpZiBubyBtYXRjaGluZyBsYW5ndWFnZSBjYW4gYmUgZm91bmRcbiAqIEByZXR1cm4ge01peGVkfSBMb2NhbCB2YWx1ZVxuICovXG5PTy51aS5nZXRMb2NhbFZhbHVlID0gZnVuY3Rpb24gKCBvYmosIGxhbmcsIGZhbGxiYWNrICkge1xuXHR2YXIgaSwgbGVuLCBsYW5ncztcblxuXHQvLyBSZXF1ZXN0ZWQgbGFuZ3VhZ2Vcblx0aWYgKCBvYmpbIGxhbmcgXSApIHtcblx0XHRyZXR1cm4gb2JqWyBsYW5nIF07XG5cdH1cblx0Ly8gS25vd24gdXNlciBsYW5ndWFnZVxuXHRsYW5ncyA9IE9PLnVpLmdldFVzZXJMYW5ndWFnZXMoKTtcblx0Zm9yICggaSA9IDAsIGxlbiA9IGxhbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGxhbmcgPSBsYW5nc1sgaSBdO1xuXHRcdGlmICggb2JqWyBsYW5nIF0gKSB7XG5cdFx0XHRyZXR1cm4gb2JqWyBsYW5nIF07XG5cdFx0fVxuXHR9XG5cdC8vIEZhbGxiYWNrIGxhbmd1YWdlXG5cdGlmICggb2JqWyBmYWxsYmFjayBdICkge1xuXHRcdHJldHVybiBvYmpbIGZhbGxiYWNrIF07XG5cdH1cblx0Ly8gRmlyc3QgZXhpc3RpbmcgbGFuZ3VhZ2Vcblx0Zm9yICggbGFuZyBpbiBvYmogKSB7XG5cdFx0cmV0dXJuIG9ialsgbGFuZyBdO1xuXHR9XG5cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlciBub2RlXG4gKlxuICogU2ltaWxhciB0byBqUXVlcnkjY29udGFpbnMgZXhjZXB0IGEgbGlzdCBvZiBjb250YWluZXJzIGNhbiBiZSBzdXBwbGllZFxuICogYW5kIGEgYm9vbGVhbiBhcmd1bWVudCBhbGxvd3MgeW91IHRvIGluY2x1ZGUgdGhlIGNvbnRhaW5lciBpbiB0aGUgbWF0Y2ggbGlzdFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTEVsZW1lbnRbXX0gY29udGFpbmVycyBDb250YWluZXIgbm9kZShzKSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lZCBOb2RlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGNoQ29udGFpbmVyc10gSW5jbHVkZSB0aGUgY29udGFpbmVyKHMpIGluIHRoZSBsaXN0IG9mIG5vZGVzIHRvIG1hdGNoLCBvdGhlcndpc2Ugb25seSBtYXRjaCBkZXNjZW5kYW50c1xuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG5vZGUgaXMgaW4gdGhlIGxpc3Qgb2YgdGFyZ2V0IG5vZGVzXG4gKi9cbk9PLnVpLmNvbnRhaW5zID0gZnVuY3Rpb24gKCBjb250YWluZXJzLCBjb250YWluZWQsIG1hdGNoQ29udGFpbmVycyApIHtcblx0dmFyIGk7XG5cdGlmICggIUFycmF5LmlzQXJyYXkoIGNvbnRhaW5lcnMgKSApIHtcblx0XHRjb250YWluZXJzID0gWyBjb250YWluZXJzIF07XG5cdH1cblx0Zm9yICggaSA9IGNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0aWYgKCAoIG1hdGNoQ29udGFpbmVycyAmJiBjb250YWluZWQgPT09IGNvbnRhaW5lcnNbIGkgXSApIHx8ICQuY29udGFpbnMoIGNvbnRhaW5lcnNbIGkgXSwgY29udGFpbmVkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAqXG4gKiBQb3J0ZWQgZnJvbTogaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvdW5kZXJzY29yZS5qc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gZGVib3VuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBXYWl0IHBlcmlvZCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZV0gVHJpZ2dlciBvbiBsZWFkaW5nIGVkZ2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBEZWJvdW5jZWQgZnVuY3Rpb25cbiAqL1xuT08udWkuZGVib3VuY2UgPSBmdW5jdGlvbiAoIGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSApIHtcblx0dmFyIHRpbWVvdXQ7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzLFxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKCAhaW1tZWRpYXRlICkge1xuXHRcdFx0XHRcdGZ1bmMuYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRpZiAoIGltbWVkaWF0ZSAmJiAhdGltZW91dCApIHtcblx0XHRcdGZ1bmMuYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblx0XHR9XG5cdFx0aWYgKCAhdGltZW91dCB8fCB3YWl0ICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCggbGF0ZXIsIHdhaXQgKTtcblx0XHR9XG5cdH07XG59O1xuXG4vKipcbiAqIFB1dHMgYSBjb25zb2xlIHdhcm5pbmcgd2l0aCBwcm92aWRlZCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIE1lc3NhZ2VcbiAqL1xuT08udWkud2FybkRlcHJlY2F0aW9uID0gZnVuY3Rpb24gKCBtZXNzYWdlICkge1xuXHRpZiAoIE9PLmdldFByb3AoIHdpbmRvdywgJ2NvbnNvbGUnLCAnd2FybicgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cdH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gKiBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gSWYgY2FsbGVkIGFnYWluIGR1cmluZyB0aGF0IHdpbmRvdywgaXQgd2lsbFxuICogd2FpdCB1bnRpbCB0aGUgd2luZG93IGVuZHMgYW5kIHRoZW4gdHJpZ2dlciBpdHNlbGYgYWdhaW4uXG4gKlxuICogQXMgaXQncyBub3Qga25vd2FibGUgdG8gdGhlIGNhbGxlciB3aGV0aGVyIHRoZSBmdW5jdGlvbiB3aWxsIGFjdHVhbGx5IHJ1blxuICogd2hlbiB0aGUgd3JhcHBlciBpcyBjYWxsZWQsIHJldHVybiB2YWx1ZXMgZnJvbSB0aGUgZnVuY3Rpb24gYXJlIGVudGlyZWx5XG4gKiBkaXNjYXJkZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB0byB0aHJvdHRsZVxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhyb3R0bGUgd2luZG93IGxlbmd0aCwgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhyb3R0bGVkIGZ1bmN0aW9uXG4gKi9cbk9PLnVpLnRocm90dGxlID0gZnVuY3Rpb24gKCBmdW5jLCB3YWl0ICkge1xuXHR2YXIgY29udGV4dCwgYXJncywgdGltZW91dCxcblx0XHRwcmV2aW91cyA9IDAsXG5cdFx0cnVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRwcmV2aW91cyA9IE9PLnVpLm5vdygpO1xuXHRcdFx0ZnVuYy5hcHBseSggY29udGV4dCwgYXJncyApO1xuXHRcdH07XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hlY2sgaG93IGxvbmcgaXQncyBiZWVuIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGZ1bmN0aW9uIHdhc1xuXHRcdC8vIGNhbGxlZCwgYW5kIHdoZXRoZXIgaXQncyBtb3JlIG9yIGxlc3MgdGhhbiB0aGUgcmVxdWVzdGVkIHRocm90dGxlXG5cdFx0Ly8gcGVyaW9kLiBJZiBpdCdzIGxlc3MsIHJ1biB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuIElmIGl0J3MgbW9yZSxcblx0XHQvLyBzZXQgYSB0aW1lb3V0IGZvciB0aGUgcmVtYWluaW5nIHRpbWUgLS0gYnV0IGRvbid0IHJlcGxhY2UgYW5cblx0XHQvLyBleGlzdGluZyB0aW1lb3V0LCBzaW5jZSB0aGF0J2QgaW5kZWZpbml0ZWx5IHByb2xvbmcgdGhlIHdhaXQuXG5cdFx0dmFyIHJlbWFpbmluZyA9IHdhaXQgLSAoIE9PLnVpLm5vdygpIC0gcHJldmlvdXMgKTtcblx0XHRjb250ZXh0ID0gdGhpcztcblx0XHRhcmdzID0gYXJndW1lbnRzO1xuXHRcdGlmICggcmVtYWluaW5nIDw9IDAgKSB7XG5cdFx0XHQvLyBOb3RlOiB1bmxlc3Mgd2FpdCB3YXMgcmlkaWN1bG91c2x5IGxhcmdlLCB0aGlzIG1lYW5zIHdlJ2xsXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IHJ1biB0aGUgZmlyc3QgdGltZSB0aGUgZnVuY3Rpb24gd2FzIGNhbGxlZCBpbiBhXG5cdFx0XHQvLyBnaXZlbiBwZXJpb2QuIChJZiB5b3UgcHJvdmlkZSBhIHdhaXQgcGVyaW9kIGxhcmdlciB0aGFuIHRoZVxuXHRcdFx0Ly8gY3VycmVudCBVbml4IHRpbWVzdGFtcCwgeW91ICpkZXNlcnZlKiB1bmV4cGVjdGVkIGJlaGF2aW9yLilcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdFx0cnVuKCk7XG5cdFx0fSBlbHNlIGlmICggIXRpbWVvdXQgKSB7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCggcnVuLCByZW1haW5pbmcgKTtcblx0XHR9XG5cdH07XG59O1xuXG4vKipcbiAqIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlclxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gQ3VycmVudCB0aW1lc3RhbXAsIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICovXG5PTy51aS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5cbi8qKlxuICogUmVjb25zdGl0dXRlIGEgSmF2YVNjcmlwdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byBhIHdpZGdldCBjcmVhdGVkIGJ5XG4gKiB0aGUgUEhQIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIGBPTy51aS5FbGVtZW50LnN0YXRpYy5pbmZ1c2UoKWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8alF1ZXJ5fSBpZE9yTm9kZVxuICogICBBIERPTSBpZCAoaWYgYSBzdHJpbmcpIG9yIG5vZGUgZm9yIHRoZSB3aWRnZXQgdG8gaW5mdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7T08udWkuRWxlbWVudH1cbiAqICAgVGhlIGBPTy51aS5FbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgKGluZnVzYWJsZSkgZG9jdW1lbnQgbm9kZS5cbiAqL1xuT08udWkuaW5mdXNlID0gZnVuY3Rpb24gKCBpZE9yTm9kZSwgY29uZmlnICkge1xuXHRyZXR1cm4gT08udWkuRWxlbWVudC5zdGF0aWMuaW5mdXNlKCBpZE9yTm9kZSwgY29uZmlnICk7XG59O1xuXG4oIGZ1bmN0aW9uICgpIHtcblx0LyoqXG5cdCAqIE1lc3NhZ2Ugc3RvcmUgZm9yIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIE9PLnVpLm1zZ1xuXHQgKlxuXHQgKiBFbnZpcm9ubWVudHMgdGhhdCBwcm92aWRlIGEgbG9jYWxpemF0aW9uIHN5c3RlbSBzaG91bGQgbm90IHVzZSB0aGlzLCBidXQgc2hvdWxkIG92ZXJyaWRlXG5cdCAqIE9PLnVpLm1zZyBhbHRvZ2V0aGVyLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIG1lc3NhZ2VzID0ge1xuXHRcdC8vIFRvb2wgdGlwIGZvciBhIGJ1dHRvbiB0aGF0IG1vdmVzIGl0ZW1zIGluIGEgbGlzdCBkb3duIG9uZSBwbGFjZVxuXHRcdCdvb3VpLW91dGxpbmUtY29udHJvbC1tb3ZlLWRvd24nOiAnTW92ZSBpdGVtIGRvd24nLFxuXHRcdC8vIFRvb2wgdGlwIGZvciBhIGJ1dHRvbiB0aGF0IG1vdmVzIGl0ZW1zIGluIGEgbGlzdCB1cCBvbmUgcGxhY2Vcblx0XHQnb291aS1vdXRsaW5lLWNvbnRyb2wtbW92ZS11cCc6ICdNb3ZlIGl0ZW0gdXAnLFxuXHRcdC8vIFRvb2wgdGlwIGZvciBhIGJ1dHRvbiB0aGF0IHJlbW92ZXMgaXRlbXMgZnJvbSBhIGxpc3Rcblx0XHQnb291aS1vdXRsaW5lLWNvbnRyb2wtcmVtb3ZlJzogJ1JlbW92ZSBpdGVtJyxcblx0XHQvLyBMYWJlbCBmb3IgdGhlIHRvb2xiYXIgZ3JvdXAgdGhhdCBjb250YWlucyBhIGxpc3Qgb2YgYWxsIG90aGVyIGF2YWlsYWJsZSB0b29sc1xuXHRcdCdvb3VpLXRvb2xiYXItbW9yZSc6ICdNb3JlJyxcblx0XHQvLyBMYWJlbCBmb3IgdGhlIGZha2UgdG9vbCB0aGF0IGV4cGFuZHMgdGhlIGZ1bGwgbGlzdCBvZiB0b29scyBpbiBhIHRvb2xiYXIgZ3JvdXBcblx0XHQnb291aS10b29sZ3JvdXAtZXhwYW5kJzogJ01vcmUnLFxuXHRcdC8vIExhYmVsIGZvciB0aGUgZmFrZSB0b29sIHRoYXQgY29sbGFwc2VzIHRoZSBmdWxsIGxpc3Qgb2YgdG9vbHMgaW4gYSB0b29sYmFyIGdyb3VwXG5cdFx0J29vdWktdG9vbGdyb3VwLWNvbGxhcHNlJzogJ0Zld2VyJyxcblx0XHQvLyBEZWZhdWx0IGxhYmVsIGZvciB0aGUgdG9vbHRpcCBmb3IgdGhlIGJ1dHRvbiB0aGF0IHJlbW92ZXMgYSB0YWcgaXRlbVxuXHRcdCdvb3VpLWl0ZW0tcmVtb3ZlJzogJ1JlbW92ZScsXG5cdFx0Ly8gRGVmYXVsdCBsYWJlbCBmb3IgdGhlIGFjY2VwdCBidXR0b24gb2YgYSBjb25maXJtYXRpb24gZGlhbG9nXG5cdFx0J29vdWktZGlhbG9nLW1lc3NhZ2UtYWNjZXB0JzogJ09LJyxcblx0XHQvLyBEZWZhdWx0IGxhYmVsIGZvciB0aGUgcmVqZWN0IGJ1dHRvbiBvZiBhIGNvbmZpcm1hdGlvbiBkaWFsb2dcblx0XHQnb291aS1kaWFsb2ctbWVzc2FnZS1yZWplY3QnOiAnQ2FuY2VsJyxcblx0XHQvLyBUaXRsZSBmb3IgcHJvY2VzcyBkaWFsb2cgZXJyb3IgZGVzY3JpcHRpb25cblx0XHQnb291aS1kaWFsb2ctcHJvY2Vzcy1lcnJvcic6ICdTb21ldGhpbmcgd2VudCB3cm9uZycsXG5cdFx0Ly8gTGFiZWwgZm9yIHByb2Nlc3MgZGlhbG9nIGRpc21pc3MgZXJyb3IgYnV0dG9uLCB2aXNpYmxlIHdoZW4gZGVzY3JpYmluZyBlcnJvcnNcblx0XHQnb291aS1kaWFsb2ctcHJvY2Vzcy1kaXNtaXNzJzogJ0Rpc21pc3MnLFxuXHRcdC8vIExhYmVsIGZvciBwcm9jZXNzIGRpYWxvZyByZXRyeSBhY3Rpb24gYnV0dG9uLCB2aXNpYmxlIHdoZW4gZGVzY3JpYmluZyBvbmx5IHJlY292ZXJhYmxlIGVycm9yc1xuXHRcdCdvb3VpLWRpYWxvZy1wcm9jZXNzLXJldHJ5JzogJ1RyeSBhZ2FpbicsXG5cdFx0Ly8gTGFiZWwgZm9yIHByb2Nlc3MgZGlhbG9nIHJldHJ5IGFjdGlvbiBidXR0b24sIHZpc2libGUgd2hlbiBkZXNjcmliaW5nIG9ubHkgd2FybmluZ3Ncblx0XHQnb291aS1kaWFsb2ctcHJvY2Vzcy1jb250aW51ZSc6ICdDb250aW51ZScsXG5cdFx0Ly8gTGFiZWwgZm9yIGJ1dHRvbiBpbiBjb21ib2JveCBpbnB1dCB0aGF0IHRyaWdnZXJzIGl0cyBkcm9wZG93blxuXHRcdCdvb3VpLWNvbWJvYm94LWJ1dHRvbi1sYWJlbCc6ICdEcm9wZG93biBmb3IgY29tYm9ib3gnLFxuXHRcdC8vIExhYmVsIGZvciB0aGUgZmlsZSBzZWxlY3Rpb24gd2lkZ2V0J3Mgc2VsZWN0IGZpbGUgYnV0dG9uXG5cdFx0J29vdWktc2VsZWN0ZmlsZS1idXR0b24tc2VsZWN0JzogJ1NlbGVjdCBhIGZpbGUnLFxuXHRcdC8vIExhYmVsIGZvciB0aGUgZmlsZSBzZWxlY3Rpb24gd2lkZ2V0IGlmIGZpbGUgc2VsZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHQnb291aS1zZWxlY3RmaWxlLW5vdC1zdXBwb3J0ZWQnOiAnRmlsZSBzZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZCcsXG5cdFx0Ly8gTGFiZWwgZm9yIHRoZSBmaWxlIHNlbGVjdGlvbiB3aWRnZXQgd2hlbiBubyBmaWxlIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuXHRcdCdvb3VpLXNlbGVjdGZpbGUtcGxhY2Vob2xkZXInOiAnTm8gZmlsZSBpcyBzZWxlY3RlZCcsXG5cdFx0Ly8gTGFiZWwgZm9yIHRoZSBmaWxlIHNlbGVjdGlvbiB3aWRnZXQncyBkcm9wIHRhcmdldFxuXHRcdCdvb3VpLXNlbGVjdGZpbGUtZHJhZ2Ryb3AtcGxhY2Vob2xkZXInOiAnRHJvcCBmaWxlIGhlcmUnLFxuXHRcdC8vIExhYmVsIGZvciB0aGUgaGVscCBpY29uIGF0dGFjaGVkIHRvIGEgZm9ybSBmaWVsZFxuXHRcdCdvb3VpLWZpZWxkLWhlbHAnOiAnSGVscCdcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgbG9jYWxpemVkIG1lc3NhZ2UuXG5cdCAqXG5cdCAqIEFmdGVyIHRoZSBtZXNzYWdlIGtleSwgbWVzc2FnZSBwYXJhbWV0ZXJzIG1heSBvcHRpb25hbGx5IGJlIHBhc3NlZC4gSW4gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sXG5cdCAqIGFueSBvY2N1cnJlbmNlcyBvZiAkMSBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgcGFyYW1ldGVyLCAkMiB3aXRoIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCBldGMuXG5cdCAqIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9ucyBvZiBPTy51aS5tc2cgbWF5IHVzZSBhbnkgc3Vic3RpdHV0aW9uIHN5c3RlbSB0aGV5IGxpa2UsIGFzIGxvbmcgYXNcblx0ICogdGhleSBzdXBwb3J0IHVubmFtZWQsIG9yZGVyZWQgbWVzc2FnZSBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBJbiBlbnZpcm9ubWVudHMgdGhhdCBwcm92aWRlIGEgbG9jYWxpemF0aW9uIHN5c3RlbSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbiB0b1xuXHQgKiByZXR1cm4gdGhlIG1lc3NhZ2UgdHJhbnNsYXRlZCBpbiB0aGUgdXNlcidzIGxhbmd1YWdlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBhbHdheXMgcmV0dXJuc1xuXHQgKiBFbmdsaXNoIG1lc3NhZ2VzLiBBbiBleGFtcGxlIG9mIGRvaW5nIHRoaXMgd2l0aCBbalF1ZXJ5LmkxOG5dKGh0dHBzOi8vZ2l0aHViLmNvbS93aWtpbWVkaWEvanF1ZXJ5LmkxOG4pXG5cdCAqIGZvbGxvd3MuXG5cdCAqXG5cdCAqICAgICBAZXhhbXBsZVxuXHQgKiAgICAgdmFyIGksIGlMZW4sIGJ1dHRvbixcblx0ICogICAgICAgICBtZXNzYWdlUGF0aCA9ICdvb2pzLXVpL2Rpc3QvaTE4bi8nLFxuXHQgKiAgICAgICAgIGxhbmd1YWdlcyA9IFsgJC5pMThuKCkubG9jYWxlLCAndXInLCAnZW4nIF0sXG5cdCAqICAgICAgICAgbGFuZ3VhZ2VNYXAgPSB7fTtcblx0ICpcblx0ICogICAgIGZvciAoIGkgPSAwLCBpTGVuID0gbGFuZ3VhZ2VzLmxlbmd0aDsgaSA8IGlMZW47IGkrKyApIHtcblx0ICogICAgICAgICBsYW5ndWFnZU1hcFsgbGFuZ3VhZ2VzWyBpIF0gXSA9IG1lc3NhZ2VQYXRoICsgbGFuZ3VhZ2VzWyBpIF0udG9Mb3dlckNhc2UoKSArICcuanNvbic7XG5cdCAqICAgICB9XG5cdCAqXG5cdCAqICAgICAkLmkxOG4oKS5sb2FkKCBsYW5ndWFnZU1hcCApLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGJ1aWx0LWluIGBtc2dgIG9ubHkgb25jZSB3ZSd2ZSBsb2FkZWQgdGhlIGludGVybmF0aW9uYWxpemF0aW9uLlxuXHQgKiAgICAgICAgIC8vIE9PVUkgdXNlcyBgT08udWkuZGVmZXJNc2dgIGZvciBhbGwgaW5pdGlhbGx5LWxvYWRlZCBtZXNzYWdlcy4gU28gbG9uZyBhc1xuXHQgKiAgICAgICAgIC8vIHlvdSBwdXQgb2ZmIGNyZWF0aW5nIGFueSB3aWRnZXRzIHVudGlsIHRoaXMgcHJvbWlzZSBpcyBjb21wbGV0ZSwgbm8gRW5nbGlzaFxuXHQgKiAgICAgICAgIC8vIHdpbGwgYmUgZGlzcGxheWVkLlxuXHQgKiAgICAgICAgIE9PLnVpLm1zZyA9ICQuaTE4bjtcblx0ICpcblx0ICogICAgICAgICAvLyBBIGJ1dHRvbiBkaXNwbGF5aW5nIFwiT0tcIiBpbiB0aGUgZGVmYXVsdCBsb2NhbGVcblx0ICogICAgICAgICBidXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG5cdCAqICAgICAgICAgICAgIGxhYmVsOiBPTy51aS5tc2coICdvb3VpLWRpYWxvZy1tZXNzYWdlLWFjY2VwdCcgKSxcblx0ICogICAgICAgICAgICAgaWNvbjogJ2NoZWNrJ1xuXHQgKiAgICAgICAgIH0gKTtcblx0ICogICAgICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBidXR0b24uJGVsZW1lbnQgKTtcblx0ICpcblx0ICogICAgICAgICAvLyBBIGJ1dHRvbiBkaXNwbGF5aW5nIFwiT0tcIiBpbiBVcmR1XG5cdCAqICAgICAgICAgJC5pMThuKCkubG9jYWxlID0gJ3VyJztcblx0ICogICAgICAgICBidXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG5cdCAqICAgICAgICAgICAgIGxhYmVsOiBPTy51aS5tc2coICdvb3VpLWRpYWxvZy1tZXNzYWdlLWFjY2VwdCcgKSxcblx0ICogICAgICAgICAgICAgaWNvbjogJ2NoZWNrJ1xuXHQgKiAgICAgICAgIH0gKTtcblx0ICogICAgICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBidXR0b24uJGVsZW1lbnQgKTtcblx0ICogICAgIH0gKTtcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBNZXNzYWdlIGtleVxuXHQgKiBAcGFyYW0gey4uLk1peGVkfSBbcGFyYW1zXSBNZXNzYWdlIHBhcmFtZXRlcnNcblx0ICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2xhdGVkIG1lc3NhZ2Ugd2l0aCBwYXJhbWV0ZXJzIHN1YnN0aXR1dGVkXG5cdCAqL1xuXHRPTy51aS5tc2cgPSBmdW5jdGlvbiAoIGtleSApIHtcblx0XHR2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzWyBrZXkgXSxcblx0XHRcdHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRpZiAoIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIFBlcmZvcm0gJDEgc3Vic3RpdHV0aW9uXG5cdFx0XHRtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKCAvXFwkKFxcZCspL2csIGZ1bmN0aW9uICggdW51c2VkLCBuICkge1xuXHRcdFx0XHR2YXIgaSA9IHBhcnNlSW50KCBuLCAxMCApO1xuXHRcdFx0XHRyZXR1cm4gcGFyYW1zWyBpIC0gMSBdICE9PSB1bmRlZmluZWQgPyBwYXJhbXNbIGkgLSAxIF0gOiAnJCcgKyBuO1xuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBSZXR1cm4gcGxhY2Vob2xkZXIgaWYgbWVzc2FnZSBub3QgZm91bmRcblx0XHRcdG1lc3NhZ2UgPSAnWycgKyBrZXkgKyAnXSc7XG5cdFx0fVxuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9O1xufSgpICk7XG5cbi8qKlxuICogUGFja2FnZSBhIG1lc3NhZ2UgYW5kIGFyZ3VtZW50cyBmb3IgZGVmZXJyZWQgcmVzb2x1dGlvbi5cbiAqXG4gKiBVc2UgdGhpcyB3aGVuIHlvdSBhcmUgc3RhdGljYWxseSBzcGVjaWZ5aW5nIGEgbWVzc2FnZSBhbmQgdGhlIG1lc3NhZ2UgbWF5IG5vdCB5ZXQgYmUgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IE1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gey4uLk1peGVkfSBbcGFyYW1zXSBNZXNzYWdlIHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc29sdmVkIG1lc3NhZ2Ugd2hlbiBleGVjdXRlZFxuICovXG5PTy51aS5kZWZlck1zZyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIE9PLnVpLm1zZy5hcHBseSggT08udWksIGFyZ3MgKTtcblx0fTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIG1lc3NhZ2UuXG4gKlxuICogSWYgdGhlIG1lc3NhZ2UgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIGJlIGV4ZWN1dGVkLCBvdGhlcndpc2UgaXQgd2lsbCBwYXNzIHRocm91Z2ggZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1zZyBEZWZlcnJlZCBtZXNzYWdlLCBvciBtZXNzYWdlIHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzb2x2ZWQgbWVzc2FnZVxuICovXG5PTy51aS5yZXNvbHZlTXNnID0gZnVuY3Rpb24gKCBtc2cgKSB7XG5cdGlmICggdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gbXNnKCk7XG5cdH1cblx0cmV0dXJuIG1zZztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT08udWkuaXNTYWZlVXJsID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cdC8vIEtlZXAgdGhpcyBmdW5jdGlvbiBpbiBzeW5jIHdpdGggcGhwL1RhZy5waHBcblx0dmFyIGksIHByb3RvY29sV2hpdGVsaXN0O1xuXG5cdGZ1bmN0aW9uIHN0cmluZ1N0YXJ0c1dpdGgoIGhheXN0YWNrLCBuZWVkbGUgKSB7XG5cdFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0ciggMCwgbmVlZGxlLmxlbmd0aCApID09PSBuZWVkbGU7XG5cdH1cblxuXHRwcm90b2NvbFdoaXRlbGlzdCA9IFtcblx0XHQnYml0Y29pbicsICdmdHAnLCAnZnRwcycsICdnZW8nLCAnZ2l0JywgJ2dvcGhlcicsICdodHRwJywgJ2h0dHBzJywgJ2lyYycsICdpcmNzJyxcblx0XHQnbWFnbmV0JywgJ21haWx0bycsICdtbXMnLCAnbmV3cycsICdubnRwJywgJ3JlZGlzJywgJ3NmdHAnLCAnc2lwJywgJ3NpcHMnLCAnc21zJywgJ3NzaCcsXG5cdFx0J3N2bicsICd0ZWwnLCAndGVsbmV0JywgJ3VybicsICd3b3JsZHdpbmQnLCAneG1wcCdcblx0XTtcblxuXHRpZiAoIHVybCA9PT0gJycgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IHByb3RvY29sV2hpdGVsaXN0Lmxlbmd0aDsgaSsrICkge1xuXHRcdGlmICggc3RyaW5nU3RhcnRzV2l0aCggdXJsLCBwcm90b2NvbFdoaXRlbGlzdFsgaSBdICsgJzonICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvLyBUaGlzIG1hdGNoZXMgJy8vJyB0b29cblx0aWYgKCBzdHJpbmdTdGFydHNXaXRoKCB1cmwsICcvJyApIHx8IHN0cmluZ1N0YXJ0c1dpdGgoIHVybCwgJy4vJyApICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICggc3RyaW5nU3RhcnRzV2l0aCggdXJsLCAnPycgKSB8fCBzdHJpbmdTdGFydHNXaXRoKCB1cmwsICcjJyApICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdXNlciBoYXMgYSAnbW9iaWxlJyBkZXZpY2UuXG4gKlxuICogRm9yIG91ciBwdXJwb3NlcyB0aGlzIG1lYW5zIHRoZSB1c2VyIGlzIHByaW1hcmlseSB1c2luZyBhblxuICogb24tc2NyZWVuIGtleWJvYXJkLCB0b3VjaCBpbnB1dCBpbnN0ZWFkIG9mIGEgbW91c2UgYW5kIG1heVxuICogaGF2ZSBhIHBoeXNpY2FsbHkgc21hbGwgZGlzcGxheS5cbiAqXG4gKiBJdCBpcyBsZWZ0IHVwIHRvIGltcGxlbWVudG9ycyB0byBkZWNpZGUgaG93IHRvIGNvbXB1dGUgdGhpc1xuICogc28gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJldHVybnMgZmFsc2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVXNlciBpcyBvbiBhIG1vYmlsZSBkZXZpY2VcbiAqL1xuT08udWkuaXNNb2JpbGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhZGRpdGlvbmFsIHNwYWNpbmcgdGhhdCBzaG91bGQgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gZGlzcGxheWluZyBlbGVtZW50cyB0aGF0IGFyZVxuICogY2xpcHBlZCB0byB0aGUgdmlld3BvcnQsIGUuZy4gZHJvcGRvd24gbWVudXMgYW5kIHBvcHVwcy4gVGhpcyBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIHRvIGF2b2lkXG4gKiBzdWNoIG1lbnVzIG92ZXJsYXBwaW5nIGFueSBmaXhlZCBoZWFkZXJzL3Rvb2xiYXJzL25hdmlnYXRpb24gdXNlZCBieSB0aGUgc2l0ZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCBlYWNoIHJlcHJlc2VudGluZ1xuICogICAgIHRoZSBleHRyYSBzcGFjaW5nIGZyb20gdGhhdCBlZGdlIG9mIHZpZXdwb3J0IChpbiBwaXhlbHMpXG4gKi9cbk9PLnVpLmdldFZpZXdwb3J0U3BhY2luZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHtcblx0XHR0b3A6IDAsXG5cdFx0cmlnaHQ6IDAsXG5cdFx0Ym90dG9tOiAwLFxuXHRcdGxlZnQ6IDBcblx0fTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IG92ZXJsYXksIHdoaWNoIGlzIHVzZWQgYnkgdmFyaW91cyB3aWRnZXRzIHdoZW4gdGhleSBhcmUgcGFzc2VkIGAkb3ZlcmxheTogdHJ1ZWAuXG4gKiBTZWUgPGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL0NvbmNlcHRzI092ZXJsYXlzPi5cbiAqXG4gKiBAcmV0dXJuIHtqUXVlcnl9IERlZmF1bHQgb3ZlcmxheSBub2RlXG4gKi9cbk9PLnVpLmdldERlZmF1bHRPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICFPTy51aS4kZGVmYXVsdE92ZXJsYXkgKSB7XG5cdFx0T08udWkuJGRlZmF1bHRPdmVybGF5ID0gJCggJzxkaXY+JyApLmFkZENsYXNzKCAnb28tdWktZGVmYXVsdE92ZXJsYXknICk7XG5cdFx0JCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggT08udWkuJGRlZmF1bHRPdmVybGF5ICk7XG5cdH1cblx0cmV0dXJuIE9PLnVpLiRkZWZhdWx0T3ZlcmxheTtcbn07XG5cbi8qIVxuICogTWl4aW4gbmFtZXNwYWNlLlxuICovXG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBPT1VJIG1peGlucy5cbiAqXG4gKiBNaXhpbnMgYXJlIG5hbWVkIGFjY29yZGluZyB0byB0aGUgdHlwZSBvZiBvYmplY3QgdGhleSBhcmUgaW50ZW5kZWQgdG9cbiAqIGJlIG1peGVkIGluIHRvLiAgRm9yIGV4YW1wbGUsIE9PLnVpLm1peGluLkdyb3VwRWxlbWVudCBpcyBpbnRlbmRlZCB0byBiZVxuICogbWl4ZWQgaW4gdG8gYW4gaW5zdGFuY2Ugb2YgT08udWkuRWxlbWVudCwgYW5kIE9PLnVpLm1peGluLkdyb3VwV2lkZ2V0XG4gKiBpcyBpbnRlbmRlZCB0byBiZSBtaXhlZCBpbiB0byBhbiBpbnN0YW5jZSBvZiBPTy51aS5XaWRnZXQuXG4gKlxuICogQGNsYXNzXG4gKiBAc2luZ2xldG9uXG4gKi9cbk9PLnVpLm1peGluID0ge307XG5cbi8qKlxuICogRWFjaCBFbGVtZW50IHJlcHJlc2VudHMgYSByZW5kZXJpbmcgaW4gdGhlIERPTeKAlGEgYnV0dG9uIG9yIGFuIGljb24sIGZvciBleGFtcGxlLCBvciBhbnl0aGluZ1xuICogdGhhdCBpcyB2aXNpYmxlIHRvIGEgdXNlci4gVW5saWtlIHtAbGluayBPTy51aS5XaWRnZXQgd2lkZ2V0c30sIHBsYWluIGVsZW1lbnRzIHVzdWFsbHkgZG8gbm90IGhhdmUgZXZlbnRzXG4gKiBjb25uZWN0ZWQgdG8gdGhlbSBhbmQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtzdHJpbmdbXX0gW2NsYXNzZXNdIFRoZSBuYW1lcyBvZiB0aGUgQ1NTIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuIENTUyBzdHlsZXMgYXJlIGFkZGVkXG4gKiAgdG8gdGhlIHRvcCBsZXZlbCAoZS5nLiwgdGhlIG91dGVybW9zdCBkaXYpIG9mIHRoZSBlbGVtZW50LiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsyXVxuICogIGZvciBhbiBleGFtcGxlLlxuICogIFsyXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9CdXR0b25zX2FuZF9Td2l0Y2hlcyNjc3NFeGFtcGxlXG4gKiBAY2ZnIHtzdHJpbmd9IFtpZF0gVGhlIEhUTUwgaWQgYXR0cmlidXRlIHVzZWQgaW4gdGhlIHJlbmRlcmVkIHRhZy5cbiAqIEBjZmcge3N0cmluZ30gW3RleHRdIFRleHQgdG8gaW5zZXJ0XG4gKiBAY2ZnIHtBcnJheX0gW2NvbnRlbnRdIEFuIGFycmF5IG9mIGNvbnRlbnQgZWxlbWVudHMgdG8gYXBwZW5kIChhZnRlciAjdGV4dCkuXG4gKiAgU3RyaW5ncyB3aWxsIGJlIGh0bWwtZXNjYXBlZDsgdXNlIGFuIE9PLnVpLkh0bWxTbmlwcGV0IHRvIGFwcGVuZCByYXcgSFRNTC5cbiAqICBJbnN0YW5jZXMgb2YgT08udWkuRWxlbWVudCB3aWxsIGhhdmUgdGhlaXIgJGVsZW1lbnQgYXBwZW5kZWQuXG4gKiBAY2ZnIHtqUXVlcnl9IFskY29udGVudF0gQ29udGVudCBlbGVtZW50cyB0byBhcHBlbmQgKGFmdGVyICN0ZXh0KS5cbiAqIEBjZmcge2pRdWVyeX0gWyRlbGVtZW50XSBXcmFwcGVyIGVsZW1lbnQuIERlZmF1bHRzIHRvIGEgbmV3IGVsZW1lbnQgd2l0aCAjZ2V0VGFnTmFtZS5cbiAqIEBjZmcge01peGVkfSBbZGF0YV0gQ3VzdG9tIGRhdGEgb2YgYW55IHR5cGUgb3IgY29tYmluYXRpb24gb2YgdHlwZXMgKGUuZy4sIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0KS5cbiAqICBEYXRhIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aXRoIHRoZSAjc2V0RGF0YSBtZXRob2QuXG4gKi9cbk9PLnVpLkVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpRWxlbWVudCggY29uZmlnICkge1xuXHRpZiAoIE9PLnVpLmlzRGVtbyApIHtcblx0XHR0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG5cdH1cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiQgPSAkO1xuXHR0aGlzLmVsZW1lbnRJZCA9IG51bGw7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdHRoaXMuZGF0YSA9IGNvbmZpZy5kYXRhO1xuXHR0aGlzLiRlbGVtZW50ID0gY29uZmlnLiRlbGVtZW50IHx8XG5cdFx0JCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdGhpcy5nZXRUYWdOYW1lKCkgKSApO1xuXHR0aGlzLmVsZW1lbnRHcm91cCA9IG51bGw7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb25maWcuY2xhc3NlcyApICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoIGNvbmZpZy5jbGFzc2VzICk7XG5cdH1cblx0aWYgKCBjb25maWcuaWQgKSB7XG5cdFx0dGhpcy5zZXRFbGVtZW50SWQoIGNvbmZpZy5pZCApO1xuXHR9XG5cdGlmICggY29uZmlnLnRleHQgKSB7XG5cdFx0dGhpcy4kZWxlbWVudC50ZXh0KCBjb25maWcudGV4dCApO1xuXHR9XG5cdGlmICggY29uZmlnLmNvbnRlbnQgKSB7XG5cdFx0Ly8gVGhlIGBjb250ZW50YCBwcm9wZXJ0eSB0cmVhdHMgcGxhaW4gc3RyaW5ncyBhcyB0ZXh0OyB1c2UgYW5cblx0XHQvLyBIdG1sU25pcHBldCB0byBhcHBlbmQgSFRNTCBjb250ZW50LiAgYE9PLnVpLkVsZW1lbnRgcyBnZXQgdGhlaXJcblx0XHQvLyBhcHByb3ByaWF0ZSAkZWxlbWVudCBhcHBlbmRlZC5cblx0XHR0aGlzLiRlbGVtZW50LmFwcGVuZCggY29uZmlnLmNvbnRlbnQubWFwKCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB2ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gRXNjYXBlIHN0cmluZyBzbyBpdCBpcyBwcm9wZXJseSByZXByZXNlbnRlZCBpbiBIVE1MLlxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHYgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHYgaW5zdGFuY2VvZiBPTy51aS5IdG1sU25pcHBldCApIHtcblx0XHRcdFx0Ly8gQnlwYXNzIGVzY2FwaW5nLlxuXHRcdFx0XHRyZXR1cm4gdi50b1N0cmluZygpO1xuXHRcdFx0fSBlbHNlIGlmICggdiBpbnN0YW5jZW9mIE9PLnVpLkVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiB2LiRlbGVtZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fSApICk7XG5cdH1cblx0aWYgKCBjb25maWcuJGNvbnRlbnQgKSB7XG5cdFx0Ly8gVGhlIGAkY29udGVudGAgcHJvcGVydHkgdHJlYXRzIHBsYWluIHN0cmluZ3MgYXMgSFRNTC5cblx0XHR0aGlzLiRlbGVtZW50LmFwcGVuZCggY29uZmlnLiRjb250ZW50ICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaXRDbGFzcyggT08udWkuRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBIVE1MIHRhZyB1c2VkIGJ5IHRoZSBlbGVtZW50LlxuICpcbiAqIFRoZSBzdGF0aWMgdmFsdWUgbWF5IGJlIGlnbm9yZWQgaWYgdGhlICNnZXRUYWdOYW1lIG1ldGhvZCBpcyBvdmVycmlkZGVuLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLnRhZ05hbWUgPSAnZGl2JztcblxuLyogU3RhdGljIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBSZWNvbnN0aXR1dGUgYSBKYXZhU2NyaXB0IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIGEgd2lkZ2V0IGNyZWF0ZWRcbiAqIGJ5IHRoZSBQSFAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8alF1ZXJ5fSBpZE9yTm9kZVxuICogICBBIERPTSBpZCAoaWYgYSBzdHJpbmcpIG9yIG5vZGUgZm9yIHRoZSB3aWRnZXQgdG8gaW5mdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7T08udWkuRWxlbWVudH1cbiAqICAgVGhlIGBPTy51aS5FbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgKGluZnVzYWJsZSkgZG9jdW1lbnQgbm9kZS5cbiAqICAgRm9yIGBUYWdgIG9iamVjdHMgZW1pdHRlZCBvbiB0aGUgSFRNTCBzaWRlICh1c2VkIG9jY2FzaW9uYWxseSBmb3IgY29udGVudClcbiAqICAgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgbmV3bHktY3JlYXRlZCBFbGVtZW50IHdyYXBwaW5nIGFyb3VuZCB0aGUgZXhpc3RpbmdcbiAqICAgRE9NIG5vZGUuXG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLmluZnVzZSA9IGZ1bmN0aW9uICggaWRPck5vZGUsIGNvbmZpZyApIHtcblx0dmFyIG9iaiA9IE9PLnVpLkVsZW1lbnQuc3RhdGljLnVuc2FmZUluZnVzZSggaWRPck5vZGUsIGNvbmZpZywgZmFsc2UgKTtcblxuXHRpZiAoIHR5cGVvZiBpZE9yTm9kZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0Ly8gSURzIGRlcHJlY2F0ZWQgc2luY2UgMC4yOS43XG5cdFx0T08udWkud2FybkRlcHJlY2F0aW9uKFxuXHRcdFx0J1Bhc3NpbmcgYSBzdHJpbmcgSUQgdG8gaW5mdXNlIGlzIGRlcHJlY2F0ZWQuIFVzZSBhbiBIVE1MRWxlbWVudCBvciBqUXVlcnkgY29sbGVjdGlvbiBpbnN0ZWFkLidcblx0XHQpO1xuXHR9XG5cdC8vIFZlcmlmeSB0aGF0IHRoZSB0eXBlIG1hdGNoZXMgdXAuXG5cdC8vIEZJWE1FOiB1bmNvbW1lbnQgYWZ0ZXIgVDg5NzIxIGlzIGZpeGVkLCBzZWUgVDkwOTI5LlxuXHQvKlxuXHRpZiAoICEoIG9iaiBpbnN0YW5jZW9mIHRoaXNbJ2NsYXNzJ10gKSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbmZ1c2lvbiB0eXBlIG1pc21hdGNoIScgKTtcblx0fVxuXHQqL1xuXHRyZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBoZWxwZXIgZm9yIGBpbmZ1c2VgOyBza2lwcyB0aGUgdHlwZSBjaGVjayBhbmQgaGFzIGFuXG4gKiBleHRyYSBwcm9wZXJ0eSBzbyB0aGF0IG9ubHkgdGhlIHRvcC1sZXZlbCBpbnZvY2F0aW9uIHRvdWNoZXMgdGhlIERPTS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8alF1ZXJ5fSBpZE9yTm9kZVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtqUXVlcnkuUHJvbWlzZX0gW2RvbVByb21pc2VdIEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcbiAqICAgICB3aGVuIHRoZSB0b3AtbGV2ZWwgd2lkZ2V0IG9mIHRoaXMgaW5mdXNpb24gaXMgaW5zZXJ0ZWQgaW50byBET00sXG4gKiAgICAgcmVwbGFjaW5nIHRoZSBvcmlnaW5hbCBub2RlOyBvbmx5IHVzZWQgaW50ZXJuYWxseS5cbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9XG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLnVuc2FmZUluZnVzZSA9IGZ1bmN0aW9uICggaWRPck5vZGUsIGNvbmZpZywgZG9tUHJvbWlzZSApIHtcblx0Ly8gbG9vayBmb3IgYSBjYWNoZWQgcmVzdWx0IG9mIGEgcHJldmlvdXMgaW5mdXNpb24uXG5cdHZhciBpZCwgJGVsZW0sIGVycm9yLCBkYXRhLCBjbHMsIHBhcnRzLCBwYXJlbnQsIG9iaiwgdG9wLCBzdGF0ZSwgaW5mdXNlZENoaWxkcmVuO1xuXHRpZiAoIHR5cGVvZiBpZE9yTm9kZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0aWQgPSBpZE9yTm9kZTtcblx0XHQkZWxlbSA9ICQoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpZCApICk7XG5cdH0gZWxzZSB7XG5cdFx0JGVsZW0gPSAkKCBpZE9yTm9kZSApO1xuXHRcdGlkID0gJGVsZW0uYXR0ciggJ2lkJyApO1xuXHR9XG5cdGlmICggISRlbGVtLmxlbmd0aCApIHtcblx0XHRpZiAoIHR5cGVvZiBpZE9yTm9kZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRlcnJvciA9ICdXaWRnZXQgbm90IGZvdW5kOiAnICsgaWRPck5vZGU7XG5cdFx0fSBlbHNlIGlmICggaWRPck5vZGUgJiYgaWRPck5vZGUuc2VsZWN0b3IgKSB7XG5cdFx0XHRlcnJvciA9ICdXaWRnZXQgbm90IGZvdW5kOiAnICsgaWRPck5vZGUuc2VsZWN0b3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yID0gJ1dpZGdldCBub3QgZm91bmQnO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yICk7XG5cdH1cblx0aWYgKCAkZWxlbVsgMCBdLm9vdWlJbmZ1c2VkICkge1xuXHRcdCRlbGVtID0gJGVsZW1bIDAgXS5vb3VpSW5mdXNlZDtcblx0fVxuXHRkYXRhID0gJGVsZW0uZGF0YSggJ29vdWktaW5mdXNlZCcgKTtcblx0aWYgKCBkYXRhICkge1xuXHRcdC8vIGNhY2hlZCFcblx0XHRpZiAoIGRhdGEgPT09IHRydWUgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDaXJjdWxhciBkZXBlbmRlbmN5ISAnICsgaWQgKTtcblx0XHR9XG5cdFx0aWYgKCBkb21Qcm9taXNlICkge1xuXHRcdFx0Ly8gcGljayB1cCBkeW5hbWljIHN0YXRlLCBsaWtlIGZvY3VzLCB2YWx1ZSBvZiBmb3JtIGlucHV0cywgc2Nyb2xsIHBvc2l0aW9uLCBldGMuXG5cdFx0XHRzdGF0ZSA9IGRhdGEuY29uc3RydWN0b3Iuc3RhdGljLmdhdGhlclByZUluZnVzZVN0YXRlKCAkZWxlbSwgZGF0YSApO1xuXHRcdFx0Ly8gcmVzdG9yZSBkeW5hbWljIHN0YXRlIGFmdGVyIHRoZSBuZXcgZWxlbWVudCBpcyByZS1pbnNlcnRlZCBpbnRvIERPTSB1bmRlciBpbmZ1c2VkIHBhcmVudFxuXHRcdFx0ZG9tUHJvbWlzZS5kb25lKCBkYXRhLnJlc3RvcmVQcmVJbmZ1c2VTdGF0ZS5iaW5kKCBkYXRhLCBzdGF0ZSApICk7XG5cdFx0XHRpbmZ1c2VkQ2hpbGRyZW4gPSAkZWxlbS5kYXRhKCAnb291aS1pbmZ1c2VkLWNoaWxkcmVuJyApO1xuXHRcdFx0aWYgKCBpbmZ1c2VkQ2hpbGRyZW4gJiYgaW5mdXNlZENoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0aW5mdXNlZENoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggZGF0YSApIHtcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSBkYXRhLmNvbnN0cnVjdG9yLnN0YXRpYy5nYXRoZXJQcmVJbmZ1c2VTdGF0ZSggJGVsZW0sIGRhdGEgKTtcblx0XHRcdFx0XHRkb21Qcm9taXNlLmRvbmUoIGRhdGEucmVzdG9yZVByZUluZnVzZVN0YXRlLmJpbmQoIGRhdGEsIHN0YXRlICkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRkYXRhID0gJGVsZW0uYXR0ciggJ2RhdGEtb291aScgKTtcblx0aWYgKCAhZGF0YSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdObyBpbmZ1c2lvbiBkYXRhIGZvdW5kOiAnICsgaWQgKTtcblx0fVxuXHR0cnkge1xuXHRcdGRhdGEgPSBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH0gY2F0Y2ggKCBfICkge1xuXHRcdGRhdGEgPSBudWxsO1xuXHR9XG5cdGlmICggISggZGF0YSAmJiBkYXRhLl8gKSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdObyB2YWxpZCBpbmZ1c2lvbiBkYXRhIGZvdW5kOiAnICsgaWQgKTtcblx0fVxuXHRpZiAoIGRhdGEuXyA9PT0gJ1RhZycgKSB7XG5cdFx0Ly8gU3BlY2lhbCBjYXNlOiB0aGlzIGlzIGEgcmF3IFRhZzsgd3JhcCBleGlzdGluZyBub2RlLCBkb24ndCByZWJ1aWxkLlxuXHRcdHJldHVybiBuZXcgT08udWkuRWxlbWVudCggJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJGVsZW1lbnQ6ICRlbGVtIH0gKSApO1xuXHR9XG5cdHBhcnRzID0gZGF0YS5fLnNwbGl0KCAnLicgKTtcblx0Y2xzID0gT08uZ2V0UHJvcC5hcHBseSggT08sIFsgd2luZG93IF0uY29uY2F0KCBwYXJ0cyApICk7XG5cdGlmICggY2xzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biB3aWRnZXQgdHlwZTogaWQ6ICcgKyBpZCArICcsIGNsYXNzOiAnICsgZGF0YS5fICk7XG5cdH1cblxuXHQvLyBWZXJpZnkgdGhhdCB3ZSdyZSBjcmVhdGluZyBhbiBPTy51aS5FbGVtZW50IGluc3RhbmNlXG5cdHBhcmVudCA9IGNscy5wYXJlbnQ7XG5cblx0d2hpbGUgKCBwYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIHBhcmVudCA9PT0gT08udWkuRWxlbWVudCApIHtcblx0XHRcdC8vIFNhZmVcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdH1cblxuXHRpZiAoIHBhcmVudCAhPT0gT08udWkuRWxlbWVudCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIHdpZGdldCB0eXBlOiBpZDogJyArIGlkICsgJywgY2xhc3M6ICcgKyBkYXRhLl8gKTtcblx0fVxuXG5cdGlmICggIWRvbVByb21pc2UgKSB7XG5cdFx0dG9wID0gJC5EZWZlcnJlZCgpO1xuXHRcdGRvbVByb21pc2UgPSB0b3AucHJvbWlzZSgpO1xuXHR9XG5cdCRlbGVtLmRhdGEoICdvb3VpLWluZnVzZWQnLCB0cnVlICk7IC8vIHByZXZlbnQgbG9vcHNcblx0ZGF0YS5pZCA9IGlkOyAvLyBpbXBsaWNpdFxuXHRpbmZ1c2VkQ2hpbGRyZW4gPSBbXTtcblx0ZGF0YSA9IE9PLmNvcHkoIGRhdGEsIG51bGwsIGZ1bmN0aW9uIGRlc2VyaWFsaXplKCB2YWx1ZSApIHtcblx0XHR2YXIgaW5mdXNlZDtcblx0XHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRpZiAoIHZhbHVlLnRhZyApIHtcblx0XHRcdFx0aW5mdXNlZCA9IE9PLnVpLkVsZW1lbnQuc3RhdGljLnVuc2FmZUluZnVzZSggdmFsdWUudGFnLCBjb25maWcsIGRvbVByb21pc2UgKTtcblx0XHRcdFx0aW5mdXNlZENoaWxkcmVuLnB1c2goIGluZnVzZWQgKTtcblx0XHRcdFx0Ly8gRmxhdHRlbiB0aGUgc3RydWN0dXJlXG5cdFx0XHRcdGluZnVzZWRDaGlsZHJlbi5wdXNoLmFwcGx5KCBpbmZ1c2VkQ2hpbGRyZW4sIGluZnVzZWQuJGVsZW1lbnQuZGF0YSggJ29vdWktaW5mdXNlZC1jaGlsZHJlbicgKSB8fCBbXSApO1xuXHRcdFx0XHRpbmZ1c2VkLiRlbGVtZW50LnJlbW92ZURhdGEoICdvb3VpLWluZnVzZWQtY2hpbGRyZW4nICk7XG5cdFx0XHRcdHJldHVybiBpbmZ1c2VkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZS5odG1sICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgT08udWkuSHRtbFNuaXBwZXQoIHZhbHVlLmh0bWwgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0Ly8gYWxsb3cgd2lkZ2V0cyB0byByZXVzZSBwYXJ0cyBvZiB0aGUgRE9NXG5cdGRhdGEgPSBjbHMuc3RhdGljLnJldXNlUHJlSW5mdXNlRE9NKCAkZWxlbVsgMCBdLCBkYXRhICk7XG5cdC8vIHBpY2sgdXAgZHluYW1pYyBzdGF0ZSwgbGlrZSBmb2N1cywgdmFsdWUgb2YgZm9ybSBpbnB1dHMsIHNjcm9sbCBwb3NpdGlvbiwgZXRjLlxuXHRzdGF0ZSA9IGNscy5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUoICRlbGVtWyAwIF0sIGRhdGEgKTtcblx0Ly8gcmVidWlsZCB3aWRnZXRcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcblx0b2JqID0gbmV3IGNscyggJC5leHRlbmQoIHt9LCBjb25maWcsIGRhdGEgKSApO1xuXHQvLyBJZiBhbnlvbmUgaXMgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGUgb2xkIERPTSBlbGVtZW50LFxuXHQvLyBsZXQncyBhbGxvdyB0aGVtIHRvIE9PLnVpLmluZnVzZSgpIGl0IGFuZCBkbyB3aGF0IHRoZXkgZXhwZWN0LCBzZWUgVDEwNTgyOC5cblx0Ly8gRG8gbm90IHVzZSBqUXVlcnkuZGF0YSgpLCBhcyB1c2luZyBpdCBvbiBkZXRhY2hlZCBub2RlcyBsZWFrcyBtZW1vcnkgaW4gMS54IGxpbmUgYnkgZGVzaWduLlxuXHQkZWxlbVsgMCBdLm9vdWlJbmZ1c2VkID0gb2JqLiRlbGVtZW50O1xuXHQvLyBub3cgcmVwbGFjZSBvbGQgRE9NIHdpdGggdGhpcyBuZXcgRE9NLlxuXHRpZiAoIHRvcCApIHtcblx0XHQvLyBBbiBlZmZpY2llbnQgY29uc3RydWN0b3IgbWlnaHQgYmUgYWJsZSB0byByZXVzZSB0aGUgZW50aXJlIERPTSB0cmVlIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50LFxuXHRcdC8vIHNvIG9ubHkgbXV0YXRlIHRoZSBET00gaWYgd2UgbmVlZCB0by5cblx0XHRpZiAoICRlbGVtWyAwIF0gIT09IG9iai4kZWxlbWVudFsgMCBdICkge1xuXHRcdFx0JGVsZW0ucmVwbGFjZVdpdGgoIG9iai4kZWxlbWVudCApO1xuXHRcdH1cblx0XHR0b3AucmVzb2x2ZSgpO1xuXHR9XG5cdG9iai4kZWxlbWVudC5kYXRhKCAnb291aS1pbmZ1c2VkJywgb2JqICk7XG5cdG9iai4kZWxlbWVudC5kYXRhKCAnb291aS1pbmZ1c2VkLWNoaWxkcmVuJywgaW5mdXNlZENoaWxkcmVuICk7XG5cdC8vIHNldCB0aGUgJ2RhdGEtb291aScgYXR0cmlidXRlIHNvIHdlIGNhbiBpZGVudGlmeSBpbmZ1c2VkIHdpZGdldHNcblx0b2JqLiRlbGVtZW50LmF0dHIoICdkYXRhLW9vdWknLCAnJyApO1xuXHQvLyByZXN0b3JlIGR5bmFtaWMgc3RhdGUgYWZ0ZXIgdGhlIG5ldyBlbGVtZW50IGlzIGluc2VydGVkIGludG8gRE9NXG5cdGRvbVByb21pc2UuZG9uZSggb2JqLnJlc3RvcmVQcmVJbmZ1c2VTdGF0ZS5iaW5kKCBvYmosIHN0YXRlICkgKTtcblx0cmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUGljayBvdXQgcGFydHMgb2YgYG5vZGVgJ3MgRE9NIHRvIGJlIHJldXNlZCB3aGVuIGluZnVzaW5nIGEgd2lkZ2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kICoqbXVzdCBub3QqKiBtYWtlIGFueSBjaGFuZ2VzIHRvIHRoZSBET00sIG9ubHkgZmluZCBpbnRlcmVzdGluZyBwaWVjZXMgYW5kIGFkZCB0aGVtXG4gKiB0byBgY29uZmlnYCAod2hpY2ggc2hvdWxkIHRoZW4gYmUgcmV0dXJuZWQpLiBBY3R1YWwgRE9NIGp1Z2dsaW5nIHNob3VsZCB0aGVuIGJlIGRvbmUgYnkgdGhlXG4gKiBjb25zdHJ1Y3Rvciwgd2hpY2ggd2lsbCBiZSBnaXZlbiB0aGUgZW5oYW5jZWQgY29uZmlnLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMucmV1c2VQcmVJbmZ1c2VET00gPSBmdW5jdGlvbiAoIG5vZGUsIGNvbmZpZyApIHtcblx0cmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogR2F0aGVyIHRoZSBkeW5hbWljIHN0YXRlIChmb2N1cywgdmFsdWUgb2YgZm9ybSBpbnB1dHMsIHNjcm9sbCBwb3NpdGlvbiwgZXRjLikgb2YgYW4gSFRNTCBET00gbm9kZVxuICogKGFuZCBpdHMgY2hpbGRyZW4pIHRoYXQgcmVwcmVzZW50IGFuIEVsZW1lbnQgb2YgdGhlIHNhbWUgY2xhc3MgYW5kIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLFxuICogZ2VuZXJhdGVkIGJ5IHRoZSBQSFAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIGBub2RlYCBpcyBkZXRhY2hlZCBmcm9tIHRoZSBET00uIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpc1xuICogZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgdG8gI3Jlc3RvcmVQcmVJbmZ1c2VTdGF0ZSBhZnRlciB0aGUgbmV3bHkgY3JlYXRlZCB3aWRnZXQncyAjJGVsZW1lbnRcbiAqIGlzIGluc2VydGVkIGludG8gRE9NIHRvIHJlcGxhY2UgYG5vZGVgLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB7fTtcbn07XG5cbi8qKlxuICogR2V0IGEgalF1ZXJ5IGZ1bmN0aW9uIHdpdGhpbiBhIHNwZWNpZmljIGRvY3VtZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7alF1ZXJ5fEhUTUxFbGVtZW50fEhUTUxEb2N1bWVudHxXaW5kb3d9IGNvbnRleHQgQ29udGV4dCB0byBiaW5kIHRoZSBmdW5jdGlvbiB0b1xuICogQHBhcmFtIHtqUXVlcnl9IFskaWZyYW1lXSBIVE1MIGlmcmFtZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGRvY3VtZW50LCBvbWl0IGlmIGRvY3VtZW50IGlzXG4gKiAgIG5vdCBpbiBhbiBpZnJhbWVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBCb3VuZCBqUXVlcnkgZnVuY3Rpb25cbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0SlF1ZXJ5ID0gZnVuY3Rpb24gKCBjb250ZXh0LCAkaWZyYW1lICkge1xuXHRmdW5jdGlvbiB3cmFwcGVyKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gJCggc2VsZWN0b3IsIHdyYXBwZXIuY29udGV4dCApO1xuXHR9XG5cblx0d3JhcHBlci5jb250ZXh0ID0gdGhpcy5nZXREb2N1bWVudCggY29udGV4dCApO1xuXG5cdGlmICggJGlmcmFtZSApIHtcblx0XHR3cmFwcGVyLiRpZnJhbWUgPSAkaWZyYW1lO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZXI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZG9jdW1lbnQgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge2pRdWVyeXxIVE1MRWxlbWVudHxIVE1MRG9jdW1lbnR8V2luZG93fSBvYmogT2JqZWN0IHRvIGdldCB0aGUgZG9jdW1lbnQgZm9yXG4gKiBAcmV0dXJuIHtIVE1MRG9jdW1lbnR8bnVsbH0gRG9jdW1lbnQgb2JqZWN0XG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCBvYmogKSB7XG5cdC8vIGpRdWVyeSAtIHNlbGVjdGlvbnMgY3JlYXRlZCBcIm9mZnNjcmVlblwiIHdvbid0IGhhdmUgYSBjb250ZXh0LCBzbyAuY29udGV4dCBpc24ndCByZWxpYWJsZVxuXHRyZXR1cm4gKCBvYmpbIDAgXSAmJiBvYmpbIDAgXS5vd25lckRvY3VtZW50ICkgfHxcblx0XHQvLyBFbXB0eSBqUXVlcnkgc2VsZWN0aW9ucyBtaWdodCBoYXZlIGEgY29udGV4dFxuXHRcdG9iai5jb250ZXh0IHx8XG5cdFx0Ly8gSFRNTEVsZW1lbnRcblx0XHRvYmoub3duZXJEb2N1bWVudCB8fFxuXHRcdC8vIFdpbmRvd1xuXHRcdG9iai5kb2N1bWVudCB8fFxuXHRcdC8vIEhUTUxEb2N1bWVudFxuXHRcdCggb2JqLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUgJiYgb2JqICkgfHxcblx0XHRudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBvZiBhbiBlbGVtZW50IG9yIGRvY3VtZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7alF1ZXJ5fEhUTUxFbGVtZW50fEhUTUxEb2N1bWVudHxXaW5kb3d9IG9iaiBDb250ZXh0IHRvIGdldCB0aGUgd2luZG93IGZvclxuICogQHJldHVybiB7V2luZG93fSBXaW5kb3cgb2JqZWN0XG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLmdldFdpbmRvdyA9IGZ1bmN0aW9uICggb2JqICkge1xuXHR2YXIgZG9jID0gdGhpcy5nZXREb2N1bWVudCggb2JqICk7XG5cdHJldHVybiBkb2MuZGVmYXVsdFZpZXc7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGlyZWN0aW9uIG9mIGFuIGVsZW1lbnQgb3IgZG9jdW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtqUXVlcnl8SFRNTEVsZW1lbnR8SFRNTERvY3VtZW50fFdpbmRvd30gb2JqIENvbnRleHQgdG8gZ2V0IHRoZSBkaXJlY3Rpb24gZm9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQgZGlyZWN0aW9uLCBlaXRoZXIgJ2x0cicgb3IgJ3J0bCdcbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RGlyID0gZnVuY3Rpb24gKCBvYmogKSB7XG5cdHZhciBpc0RvYywgaXNXaW47XG5cblx0aWYgKCBvYmogaW5zdGFuY2VvZiAkICkge1xuXHRcdG9iaiA9IG9ialsgMCBdO1xuXHR9XG5cdGlzRG9jID0gb2JqLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREU7XG5cdGlzV2luID0gb2JqLmRvY3VtZW50ICE9PSB1bmRlZmluZWQ7XG5cdGlmICggaXNEb2MgfHwgaXNXaW4gKSB7XG5cdFx0aWYgKCBpc1dpbiApIHtcblx0XHRcdG9iaiA9IG9iai5kb2N1bWVudDtcblx0XHR9XG5cdFx0b2JqID0gb2JqLmJvZHk7XG5cdH1cblx0cmV0dXJuICQoIG9iaiApLmNzcyggJ2RpcmVjdGlvbicgKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvZmZzZXQgYmV0d2VlbiB0d28gZnJhbWVzLlxuICpcbiAqIFRPRE86IE1ha2UgdGhpcyBmdW5jdGlvbiBub3QgdXNlIHJlY3Vyc2lvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1dpbmRvd30gZnJvbSBXaW5kb3cgb2YgdGhlIGNoaWxkIGZyYW1lXG4gKiBAcGFyYW0ge1dpbmRvd30gW3RvPXdpbmRvd10gV2luZG93IG9mIHRoZSBwYXJlbnQgZnJhbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2Zmc2V0XSBPZmZzZXQgdG8gc3RhcnQgd2l0aCwgdXNlZCBpbnRlcm5hbGx5XG4gKiBAcmV0dXJuIHtPYmplY3R9IE9mZnNldCBvYmplY3QsIGNvbnRhaW5pbmcgbGVmdCBhbmQgdG9wIHByb3BlcnRpZXNcbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RnJhbWVPZmZzZXQgPSBmdW5jdGlvbiAoIGZyb20sIHRvLCBvZmZzZXQgKSB7XG5cdHZhciBpLCBsZW4sIGZyYW1lcywgZnJhbWUsIHJlY3Q7XG5cblx0aWYgKCAhdG8gKSB7XG5cdFx0dG8gPSB3aW5kb3c7XG5cdH1cblx0aWYgKCAhb2Zmc2V0ICkge1xuXHRcdG9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdH1cblx0aWYgKCBmcm9tLnBhcmVudCA9PT0gZnJvbSApIHtcblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9XG5cblx0Ly8gR2V0IGlmcmFtZSBlbGVtZW50XG5cdGZyYW1lcyA9IGZyb20ucGFyZW50LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaWZyYW1lJyApO1xuXHRmb3IgKCBpID0gMCwgbGVuID0gZnJhbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggZnJhbWVzWyBpIF0uY29udGVudFdpbmRvdyA9PT0gZnJvbSApIHtcblx0XHRcdGZyYW1lID0gZnJhbWVzWyBpIF07XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZWN1cnNpdmVseSBhY2N1bXVsYXRlIG9mZnNldCB2YWx1ZXNcblx0aWYgKCBmcmFtZSApIHtcblx0XHRyZWN0ID0gZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0b2Zmc2V0LmxlZnQgKz0gcmVjdC5sZWZ0O1xuXHRcdG9mZnNldC50b3AgKz0gcmVjdC50b3A7XG5cdFx0aWYgKCBmcm9tICE9PSB0byApIHtcblx0XHRcdHRoaXMuZ2V0RnJhbWVPZmZzZXQoIGZyb20ucGFyZW50LCBvZmZzZXQgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG9mZnNldDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvZmZzZXQgYmV0d2VlbiB0d28gZWxlbWVudHMuXG4gKlxuICogVGhlIHR3byBlbGVtZW50cyBtYXkgYmUgaW4gYSBkaWZmZXJlbnQgZnJhbWUsIGJ1dCBpbiB0aGF0IGNhc2UgdGhlIGZyYW1lICRlbGVtZW50IGlzIGluIG11c3RcbiAqIGJlIGNvbnRhaW5lZCBpbiB0aGUgZnJhbWUgJGFuY2hvciBpcyBpbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgRWxlbWVudCB3aG9zZSBwb3NpdGlvbiB0byBnZXRcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkYW5jaG9yIEVsZW1lbnQgdG8gZ2V0ICRlbGVtZW50J3MgcG9zaXRpb24gcmVsYXRpdmUgdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVHJhbnNsYXRlZCBwb3NpdGlvbiBjb29yZGluYXRlcywgY29udGFpbmluZyB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICovXG5PTy51aS5FbGVtZW50LnN0YXRpYy5nZXRSZWxhdGl2ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCAkZWxlbWVudCwgJGFuY2hvciApIHtcblx0dmFyIGlmcmFtZSwgaWZyYW1lUG9zLFxuXHRcdHBvcyA9ICRlbGVtZW50Lm9mZnNldCgpLFxuXHRcdGFuY2hvclBvcyA9ICRhbmNob3Iub2Zmc2V0KCksXG5cdFx0ZWxlbWVudERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCggJGVsZW1lbnQgKSxcblx0XHRhbmNob3JEb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoICRhbmNob3IgKTtcblxuXHQvLyBJZiAkZWxlbWVudCBpc24ndCBpbiB0aGUgc2FtZSBkb2N1bWVudCBhcyAkYW5jaG9yLCB0cmF2ZXJzZSB1cFxuXHR3aGlsZSAoIGVsZW1lbnREb2N1bWVudCAhPT0gYW5jaG9yRG9jdW1lbnQgKSB7XG5cdFx0aWZyYW1lID0gZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmZyYW1lRWxlbWVudDtcblx0XHRpZiAoICFpZnJhbWUgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICckZWxlbWVudCBmcmFtZSBpcyBub3QgY29udGFpbmVkIGluICRhbmNob3IgZnJhbWUnICk7XG5cdFx0fVxuXHRcdGlmcmFtZVBvcyA9ICQoIGlmcmFtZSApLm9mZnNldCgpO1xuXHRcdHBvcy5sZWZ0ICs9IGlmcmFtZVBvcy5sZWZ0O1xuXHRcdHBvcy50b3AgKz0gaWZyYW1lUG9zLnRvcDtcblx0XHRlbGVtZW50RG9jdW1lbnQgPSBpZnJhbWUub3duZXJEb2N1bWVudDtcblx0fVxuXHRwb3MubGVmdCAtPSBhbmNob3JQb3MubGVmdDtcblx0cG9zLnRvcCAtPSBhbmNob3JQb3MudG9wO1xuXHRyZXR1cm4gcG9zO1xufTtcblxuLyoqXG4gKiBHZXQgZWxlbWVudCBib3JkZXIgc2l6ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCB0byBtZWFzdXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9IERpbWVuc2lvbnMgb2JqZWN0IHdpdGggYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICovXG5PTy51aS5FbGVtZW50LnN0YXRpYy5nZXRCb3JkZXJzID0gZnVuY3Rpb24gKCBlbCApIHtcblx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0d2luID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdHN0eWxlID0gd2luLmdldENvbXB1dGVkU3R5bGUoIGVsLCBudWxsICksXG5cdFx0JGVsID0gJCggZWwgKSxcblx0XHR0b3AgPSBwYXJzZUZsb2F0KCBzdHlsZSA/IHN0eWxlLmJvcmRlclRvcFdpZHRoIDogJGVsLmNzcyggJ2JvcmRlclRvcFdpZHRoJyApICkgfHwgMCxcblx0XHRsZWZ0ID0gcGFyc2VGbG9hdCggc3R5bGUgPyBzdHlsZS5ib3JkZXJMZWZ0V2lkdGggOiAkZWwuY3NzKCAnYm9yZGVyTGVmdFdpZHRoJyApICkgfHwgMCxcblx0XHRib3R0b20gPSBwYXJzZUZsb2F0KCBzdHlsZSA/IHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIDogJGVsLmNzcyggJ2JvcmRlckJvdHRvbVdpZHRoJyApICkgfHwgMCxcblx0XHRyaWdodCA9IHBhcnNlRmxvYXQoIHN0eWxlID8gc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA6ICRlbC5jc3MoICdib3JkZXJSaWdodFdpZHRoJyApICkgfHwgMDtcblxuXHRyZXR1cm4ge1xuXHRcdHRvcDogdG9wLFxuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0Ym90dG9tOiBib3R0b20sXG5cdFx0cmlnaHQ6IHJpZ2h0XG5cdH07XG59O1xuXG4vKipcbiAqIEdldCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8V2luZG93fSBlbCBFbGVtZW50IHRvIG1lYXN1cmVcbiAqIEByZXR1cm4ge09iamVjdH0gRGltZW5zaW9ucyBvYmplY3Qgd2l0aCBgYm9yZGVyc2AsIGBzY3JvbGxgLCBgc2Nyb2xsYmFyYCBhbmQgYHJlY3RgIHByb3BlcnRpZXNcbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICggZWwgKSB7XG5cdHZhciAkZWwsICR3aW4sXG5cdFx0ZG9jID0gZWwub3duZXJEb2N1bWVudCB8fCBlbC5kb2N1bWVudCxcblx0XHR3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0aWYgKCB3aW4gPT09IGVsIHx8IGVsID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdCR3aW4gPSAkKCB3aW4gKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Ym9yZGVyczogeyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAgfSxcblx0XHRcdHNjcm9sbDoge1xuXHRcdFx0XHR0b3A6ICR3aW4uc2Nyb2xsVG9wKCksXG5cdFx0XHRcdGxlZnQ6ICR3aW4uc2Nyb2xsTGVmdCgpXG5cdFx0XHR9LFxuXHRcdFx0c2Nyb2xsYmFyOiB7IHJpZ2h0OiAwLCBib3R0b206IDAgfSxcblx0XHRcdHJlY3Q6IHtcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRib3R0b206ICR3aW4uaW5uZXJIZWlnaHQoKSxcblx0XHRcdFx0cmlnaHQ6ICR3aW4uaW5uZXJXaWR0aCgpXG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQkZWwgPSAkKCBlbCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHRib3JkZXJzOiB0aGlzLmdldEJvcmRlcnMoIGVsICksXG5cdFx0XHRzY3JvbGw6IHtcblx0XHRcdFx0dG9wOiAkZWwuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdGxlZnQ6ICRlbC5zY3JvbGxMZWZ0KClcblx0XHRcdH0sXG5cdFx0XHRzY3JvbGxiYXI6IHtcblx0XHRcdFx0cmlnaHQ6ICRlbC5pbm5lcldpZHRoKCkgLSBlbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0Ym90dG9tOiAkZWwuaW5uZXJIZWlnaHQoKSAtIGVsLmNsaWVudEhlaWdodFxuXHRcdFx0fSxcblx0XHRcdHJlY3Q6IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdFx0fTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCBhbiBlbGVtZW50J3MgY29udGVudCBpcyBzY3JvbGxlZCB0byB0aGUgbGVmdC5cbiAqXG4gKiBBZGFwdGVkIGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS9vdGhyZWUvanF1ZXJ5LnJ0bC1zY3JvbGwtdHlwZT4uXG4gKiBPcmlnaW5hbCBjb2RlIGNvcHlyaWdodCAyMDEyIFdlaS1LbyBLYW8sIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNtb290aHMgb3V0IGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIChuaWNlbHkgZGVzY3JpYmVkIGluIHRoZSBSRUFETUUgYXRcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vb3RocmVlL2pxdWVyeS5ydGwtc2Nyb2xsLXR5cGU+KSBhbmQgcHJvZHVjZXMgYSByZXN1bHQgY29uc2lzdGVudFxuICogd2l0aCBGaXJlZm94J3MgJ3Njcm9sbExlZnQnLCB3aGljaCBzZWVtcyB0aGUgc2FuZXN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8V2luZG93fSBlbCBFbGVtZW50IHRvIG1lYXN1cmVcbiAqIEByZXR1cm4ge251bWJlcn0gU2Nyb2xsIHBvc2l0aW9uIGZyb20gdGhlIGxlZnQuXG4gKiAgSWYgdGhlIGVsZW1lbnQncyBkaXJlY3Rpb24gaXMgTFRSLCB0aGlzIGlzIGEgcG9zaXRpdmUgbnVtYmVyIGJldHdlZW4gYDBgIChpbml0aWFsIHNjcm9sbCBwb3NpdGlvbilcbiAqICBhbmQgYGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGhgIChmdXJ0aGVzdCBwb3NzaWJsZSBzY3JvbGwgcG9zaXRpb24pLlxuICogIElmIHRoZSBlbGVtZW50J3MgZGlyZWN0aW9uIGlzIFJUTCwgdGhpcyBpcyBhIG5lZ2F0aXZlIG51bWJlciBiZXR3ZWVuIGAwYCAoaW5pdGlhbCBzY3JvbGwgcG9zaXRpb24pXG4gKiAgYW5kIGAtZWwuc2Nyb2xsV2lkdGggKyBlbC5jbGllbnRXaWR0aGAgKGZ1cnRoZXN0IHBvc3NpYmxlIHNjcm9sbCBwb3NpdGlvbikuXG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLmdldFNjcm9sbExlZnQgPSAoIGZ1bmN0aW9uICgpIHtcblx0dmFyIHJ0bFNjcm9sbFR5cGUgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIHRlc3QoKSB7XG5cdFx0dmFyICRkZWZpbmVyID0gJCggJzxkaXY+JyApLmF0dHIoIHtcblx0XHRcdFx0ZGlyOiAncnRsJyxcblx0XHRcdFx0c3R5bGU6ICdmb250LXNpemU6IDE0cHg7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDBweDsgb3ZlcmZsb3c6IHNjcm9sbDsnXG5cdFx0XHR9ICkudGV4dCggJ0EnICksXG5cdFx0XHRkZWZpbmVyID0gJGRlZmluZXJbIDAgXTtcblxuXHRcdCRkZWZpbmVyLmFwcGVuZFRvKCAnYm9keScgKTtcblx0XHRpZiAoIGRlZmluZXIuc2Nyb2xsTGVmdCA+IDAgKSB7XG5cdFx0XHQvLyBTYWZhcmksIENocm9tZVxuXHRcdFx0cnRsU2Nyb2xsVHlwZSA9ICdkZWZhdWx0Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lci5zY3JvbGxMZWZ0ID0gMTtcblx0XHRcdGlmICggZGVmaW5lci5zY3JvbGxMZWZ0ID09PSAwICkge1xuXHRcdFx0XHQvLyBGaXJlZm94LCBvbGQgT3BlcmFcblx0XHRcdFx0cnRsU2Nyb2xsVHlwZSA9ICduZWdhdGl2ZSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnRlcm5ldCBFeHBsb3JlciwgRWRnZVxuXHRcdFx0XHRydGxTY3JvbGxUeXBlID0gJ3JldmVyc2UnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQkZGVmaW5lci5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KCBlbCApIHtcblx0XHR2YXIgaXNSb290ID0gZWwud2luZG93ID09PSBlbCB8fFxuXHRcdFx0XHRlbCA9PT0gZWwub3duZXJEb2N1bWVudC5ib2R5IHx8XG5cdFx0XHRcdGVsID09PSBlbC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdHNjcm9sbExlZnQgPSBpc1Jvb3QgPyAkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgOiBlbC5zY3JvbGxMZWZ0LFxuXHRcdFx0Ly8gQWxsIGJyb3dzZXJzIHVzZSB0aGUgY29ycmVjdCBzY3JvbGwgdHlwZSAoJ25lZ2F0aXZlJykgb24gdGhlIHJvb3QsIHNvIGRvbid0XG5cdFx0XHQvLyBkbyBhbnkgZml4dXBzIHdoZW4gbG9va2luZyBhdCB0aGUgcm9vdCBlbGVtZW50XG5cdFx0XHRkaXJlY3Rpb24gPSBpc1Jvb3QgPyAnbHRyJyA6ICQoIGVsICkuY3NzKCAnZGlyZWN0aW9uJyApO1xuXG5cdFx0aWYgKCBkaXJlY3Rpb24gPT09ICdydGwnICkge1xuXHRcdFx0aWYgKCBydGxTY3JvbGxUeXBlID09PSBudWxsICkge1xuXHRcdFx0XHR0ZXN0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJ0bFNjcm9sbFR5cGUgPT09ICdyZXZlcnNlJyApIHtcblx0XHRcdFx0c2Nyb2xsTGVmdCA9IC1zY3JvbGxMZWZ0O1xuXHRcdFx0fSBlbHNlIGlmICggcnRsU2Nyb2xsVHlwZSA9PT0gJ2RlZmF1bHQnICkge1xuXHRcdFx0XHRzY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCAtIGVsLnNjcm9sbFdpZHRoICsgZWwuY2xpZW50V2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNjcm9sbExlZnQ7XG5cdH07XG59KCkgKTtcblxuLyoqXG4gKiBHZXQgdGhlIHJvb3Qgc2Nyb2xsYWJsZSBlbGVtZW50IG9mIGdpdmVuIGVsZW1lbnQncyBkb2N1bWVudC5cbiAqXG4gKiBPbiBCbGluay1iYXNlZCBicm93c2VycyAoQ2hyb21lIGV0Yy4pLCBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50YCBjYW4ndCBiZSB1c2VkIHRvIGdldCBvciBzZXRcbiAqIHRoZSBzY3JvbGxUb3AgcHJvcGVydHk7IGluc3RlYWQgd2UgaGF2ZSB0byB1c2UgYGRvY3VtZW50LmJvZHlgLiBDaGFuZ2luZyBhbmQgdGVzdGluZyB0aGUgdmFsdWVcbiAqIGxldHMgdXMgdXNlICdib2R5JyBvciAnZG9jdW1lbnRFbGVtZW50JyBiYXNlZCBvbiB3aGF0IGlzIHdvcmtpbmcuXG4gKlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMwMzEzMVxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgdG8gZmluZCByb290IHNjcm9sbGFibGUgcGFyZW50IGZvclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFNjcm9sbGFibGUgcGFyZW50LCBgZG9jdW1lbnQuYm9keWAgb3IgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGBcbiAqICAgICBkZXBlbmRpbmcgb24gYnJvd3NlclxuICovXG5PTy51aS5FbGVtZW50LnN0YXRpYy5nZXRSb290U2Nyb2xsYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoIGVsICkge1xuXHR2YXIgc2Nyb2xsVG9wLCBib2R5O1xuXG5cdGlmICggT08udWkuc2Nyb2xsYWJsZUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRib2R5ID0gZWwub3duZXJEb2N1bWVudC5ib2R5O1xuXHRcdHNjcm9sbFRvcCA9IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdGJvZHkuc2Nyb2xsVG9wID0gMTtcblxuXHRcdC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ic2VydmVkIGluIENocm9tZSA1NiBvbiBMaW51eCBNaW50IDE4LjEpLFxuXHRcdC8vIGJvZHkuc2Nyb2xsVG9wIGRvZXNuJ3QgYmVjb21lIGV4YWN0bHkgMSwgYnV0IGEgZnJhY3Rpb25hbCB2YWx1ZSBsaWtlIDAuNzZcblx0XHRpZiAoIE1hdGgucm91bmQoIGJvZHkuc2Nyb2xsVG9wICkgPT09IDEgKSB7XG5cdFx0XHRib2R5LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblx0XHRcdE9PLnVpLnNjcm9sbGFibGVFbGVtZW50ID0gJ2JvZHknO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRPTy51aS5zY3JvbGxhYmxlRWxlbWVudCA9ICdkb2N1bWVudEVsZW1lbnQnO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbC5vd25lckRvY3VtZW50WyBPTy51aS5zY3JvbGxhYmxlRWxlbWVudCBdO1xufTtcblxuLyoqXG4gKiBHZXQgY2xvc2VzdCBzY3JvbGxhYmxlIGNvbnRhaW5lci5cbiAqXG4gKiBUcmF2ZXJzZXMgdXAgdW50aWwgZWl0aGVyIGEgc2Nyb2xsYWJsZSBlbGVtZW50IG9yIHRoZSByb290IGlzIHJlYWNoZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJvb3RcbiAqIHNjcm9sbGFibGUgZWxlbWVudCB3aWxsIGJlIHJldHVybmVkIChzZWUgI2dldFJvb3RTY3JvbGxhYmxlRWxlbWVudCkuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCB0byBmaW5kIHNjcm9sbGFibGUgY29udGFpbmVyIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IFtkaW1lbnNpb25dIERpbWVuc2lvbiBvZiBzY3JvbGxpbmcgdG8gbG9vayBmb3I7IGB4YCwgYHlgIG9yIG9taXQgZm9yIGVpdGhlclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IENsb3Nlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXJcbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0Q2xvc2VzdFNjcm9sbGFibGVDb250YWluZXIgPSBmdW5jdGlvbiAoIGVsLCBkaW1lbnNpb24gKSB7XG5cdHZhciBpLCB2YWwsXG5cdFx0Ly8gQnJvd3NlcnMgZG8gbm90IGNvcnJlY3RseSByZXR1cm4gdGhlIGNvbXB1dGVkIHZhbHVlIG9mICdvdmVyZmxvdycgd2hlbiAnb3ZlcmZsb3cteCcgYW5kXG5cdFx0Ly8gJ292ZXJmbG93LXknIGhhdmUgZGlmZmVyZW50IHZhbHVlcywgc28gd2UgbmVlZCB0byBjaGVjayB0aGUgc2VwYXJhdGUgcHJvcGVydGllcy5cblx0XHRwcm9wcyA9IFsgJ292ZXJmbG93LXgnLCAnb3ZlcmZsb3cteScgXSxcblx0XHQkcGFyZW50ID0gJCggZWwgKS5wYXJlbnQoKTtcblxuXHRpZiAoIGRpbWVuc2lvbiA9PT0gJ3gnIHx8IGRpbWVuc2lvbiA9PT0gJ3knICkge1xuXHRcdHByb3BzID0gWyAnb3ZlcmZsb3ctJyArIGRpbWVuc2lvbiBdO1xuXHR9XG5cblx0Ly8gU3BlY2lhbCBjYXNlIGZvciB0aGUgZG9jdW1lbnQgcm9vdCAod2hpY2ggZG9lc24ndCByZWFsbHkgaGF2ZSBhbnkgc2Nyb2xsYWJsZSBjb250YWluZXIsIHNpbmNlXG5cdC8vIGl0IGlzIHRoZSB1bHRpbWF0ZSBzY3JvbGxhYmxlIGNvbnRhaW5lciwgYnV0IHRoaXMgaXMgcHJvYmFibHkgc2FuZXIgdGhhbiBudWxsIG9yIGV4Y2VwdGlvbilcblx0aWYgKCAkKCBlbCApLmlzKCAnaHRtbCwgYm9keScgKSApIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRSb290U2Nyb2xsYWJsZUVsZW1lbnQoIGVsICk7XG5cdH1cblxuXHR3aGlsZSAoICRwYXJlbnQubGVuZ3RoICkge1xuXHRcdGlmICggJHBhcmVudFsgMCBdID09PSB0aGlzLmdldFJvb3RTY3JvbGxhYmxlRWxlbWVudCggZWwgKSApIHtcblx0XHRcdHJldHVybiAkcGFyZW50WyAwIF07XG5cdFx0fVxuXHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR2YWwgPSAkcGFyZW50LmNzcyggcHJvcHNbIGkgXSApO1xuXHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgZWxlbWVudHMgd2l0aCAnb3ZlcmZsb3cnIChpbiBhbnkgZGlyZWN0aW9uKSBzZXQgdG8gJ2hpZGRlbicgd2lsbCBuZXZlciBiZVxuXHRcdFx0Ly8gc2Nyb2xsZWQgaW4gdGhhdCBkaXJlY3Rpb24sIGJ1dCB0aGV5IGNhbiBhY3R1YWxseSBiZSBzY3JvbGxlZCBwcm9ncmFtYXRpY2FsbHkuIFRoZSB1c2VyIGNhblxuXHRcdFx0Ly8gdW5pbnRlbnRpb25hbGx5IHBlcmZvcm0gYSBzY3JvbGwgaW4gc3VjaCBjYXNlIGV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIGRvZXNuJ3Qgc2Nyb2xsXG5cdFx0XHQvLyBwcm9ncmFtYXRpY2FsbHksIGUuZy4gd2hlbiBqdW1waW5nIHRvIGFuIGFuY2hvciwgb3Igd2hlbiB1c2luZyBidWlsdC1pbiBmaW5kIGZ1bmN0aW9uYWxpdHkuXG5cdFx0XHQvLyBUaGlzIGNvdWxkIGNhdXNlIGZ1bm55IGlzc3Vlcy4uLlxuXHRcdFx0aWYgKCB2YWwgPT09ICdhdXRvJyB8fCB2YWwgPT09ICdzY3JvbGwnICkge1xuXHRcdFx0XHRyZXR1cm4gJHBhcmVudFsgMCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQkcGFyZW50ID0gJHBhcmVudC5wYXJlbnQoKTtcblx0fVxuXHQvLyBUaGUgZWxlbWVudCBpcyB1bmF0dGFjaGVkLi4uIHJldHVybiBzb21ldGhpbmcgbW9zdGx5IHNhbmVcblx0cmV0dXJuIHRoaXMuZ2V0Um9vdFNjcm9sbGFibGVFbGVtZW50KCBlbCApO1xufTtcblxuLyoqXG4gKiBTY3JvbGwgZWxlbWVudCBpbnRvIHZpZXcuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCB0byBzY3JvbGwgaW50byB2aWV3XG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5kdXJhdGlvbj0nZmFzdCddIGpRdWVyeSBhbmltYXRpb24gZHVyYXRpb24gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmRpcmVjdGlvbl0gU2Nyb2xsIGluIG9ubHkgb25lIGRpcmVjdGlvbiwgZS5nLiAneCcgb3IgJ3knLCBvbWl0XG4gKiAgdG8gc2Nyb2xsIGluIGJvdGggZGlyZWN0aW9uc1xuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgc2Nyb2xsIGlzIGNvbXBsZXRlXG4gKi9cbk9PLnVpLkVsZW1lbnQuc3RhdGljLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24gKCBlbCwgY29uZmlnICkge1xuXHR2YXIgcG9zaXRpb24sIGFuaW1hdGlvbnMsIGNvbnRhaW5lciwgJGNvbnRhaW5lciwgZWxlbWVudERpbWVuc2lvbnMsIGNvbnRhaW5lckRpbWVuc2lvbnMsICR3aW5kb3csXG5cdFx0ZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0YW5pbWF0aW9ucyA9IHt9O1xuXHRjb250YWluZXIgPSB0aGlzLmdldENsb3Nlc3RTY3JvbGxhYmxlQ29udGFpbmVyKCBlbCwgY29uZmlnLmRpcmVjdGlvbiApO1xuXHQkY29udGFpbmVyID0gJCggY29udGFpbmVyICk7XG5cdGVsZW1lbnREaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCBlbCApO1xuXHRjb250YWluZXJEaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCBjb250YWluZXIgKTtcblx0JHdpbmRvdyA9ICQoIHRoaXMuZ2V0V2luZG93KCBlbCApICk7XG5cblx0Ly8gQ29tcHV0ZSB0aGUgZWxlbWVudCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXJcblx0aWYgKCAkY29udGFpbmVyLmlzKCAnaHRtbCwgYm9keScgKSApIHtcblx0XHQvLyBJZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgdGhlIHJvb3QsIHRoaXMgaXMgZWFzeVxuXHRcdHBvc2l0aW9uID0ge1xuXHRcdFx0dG9wOiBlbGVtZW50RGltZW5zaW9ucy5yZWN0LnRvcCxcblx0XHRcdGJvdHRvbTogJHdpbmRvdy5pbm5lckhlaWdodCgpIC0gZWxlbWVudERpbWVuc2lvbnMucmVjdC5ib3R0b20sXG5cdFx0XHRsZWZ0OiBlbGVtZW50RGltZW5zaW9ucy5yZWN0LmxlZnQsXG5cdFx0XHRyaWdodDogJHdpbmRvdy5pbm5lcldpZHRoKCkgLSBlbGVtZW50RGltZW5zaW9ucy5yZWN0LnJpZ2h0XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBPdGhlcndpc2UsIHdlIGhhdmUgdG8gc3VidHJhY3QgZWwncyBjb29yZGluYXRlcyBmcm9tIGNvbnRhaW5lcidzIGNvb3JkaW5hdGVzXG5cdFx0cG9zaXRpb24gPSB7XG5cdFx0XHR0b3A6IGVsZW1lbnREaW1lbnNpb25zLnJlY3QudG9wIC0gKCBjb250YWluZXJEaW1lbnNpb25zLnJlY3QudG9wICsgY29udGFpbmVyRGltZW5zaW9ucy5ib3JkZXJzLnRvcCApLFxuXHRcdFx0Ym90dG9tOiBjb250YWluZXJEaW1lbnNpb25zLnJlY3QuYm90dG9tIC0gY29udGFpbmVyRGltZW5zaW9ucy5ib3JkZXJzLmJvdHRvbSAtIGNvbnRhaW5lckRpbWVuc2lvbnMuc2Nyb2xsYmFyLmJvdHRvbSAtIGVsZW1lbnREaW1lbnNpb25zLnJlY3QuYm90dG9tLFxuXHRcdFx0bGVmdDogZWxlbWVudERpbWVuc2lvbnMucmVjdC5sZWZ0IC0gKCBjb250YWluZXJEaW1lbnNpb25zLnJlY3QubGVmdCArIGNvbnRhaW5lckRpbWVuc2lvbnMuYm9yZGVycy5sZWZ0ICksXG5cdFx0XHRyaWdodDogY29udGFpbmVyRGltZW5zaW9ucy5yZWN0LnJpZ2h0IC0gY29udGFpbmVyRGltZW5zaW9ucy5ib3JkZXJzLnJpZ2h0IC0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGxiYXIucmlnaHQgLSBlbGVtZW50RGltZW5zaW9ucy5yZWN0LnJpZ2h0XG5cdFx0fTtcblx0fVxuXG5cdGlmICggIWNvbmZpZy5kaXJlY3Rpb24gfHwgY29uZmlnLmRpcmVjdGlvbiA9PT0gJ3knICkge1xuXHRcdGlmICggcG9zaXRpb24udG9wIDwgMCApIHtcblx0XHRcdGFuaW1hdGlvbnMuc2Nyb2xsVG9wID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGwudG9wICsgcG9zaXRpb24udG9wO1xuXHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uLnRvcCA+IDAgJiYgcG9zaXRpb24uYm90dG9tIDwgMCApIHtcblx0XHRcdGFuaW1hdGlvbnMuc2Nyb2xsVG9wID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGwudG9wICsgTWF0aC5taW4oIHBvc2l0aW9uLnRvcCwgLXBvc2l0aW9uLmJvdHRvbSApO1xuXHRcdH1cblx0fVxuXHRpZiAoICFjb25maWcuZGlyZWN0aW9uIHx8IGNvbmZpZy5kaXJlY3Rpb24gPT09ICd4JyApIHtcblx0XHRpZiAoIHBvc2l0aW9uLmxlZnQgPCAwICkge1xuXHRcdFx0YW5pbWF0aW9ucy5zY3JvbGxMZWZ0ID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGwubGVmdCArIHBvc2l0aW9uLmxlZnQ7XG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24ubGVmdCA+IDAgJiYgcG9zaXRpb24ucmlnaHQgPCAwICkge1xuXHRcdFx0YW5pbWF0aW9ucy5zY3JvbGxMZWZ0ID0gY29udGFpbmVyRGltZW5zaW9ucy5zY3JvbGwubGVmdCArIE1hdGgubWluKCBwb3NpdGlvbi5sZWZ0LCAtcG9zaXRpb24ucmlnaHQgKTtcblx0XHR9XG5cdH1cblx0aWYgKCAhJC5pc0VtcHR5T2JqZWN0KCBhbmltYXRpb25zICkgKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpxdWVyeS9uby1hbmltYXRlXG5cdFx0JGNvbnRhaW5lci5zdG9wKCB0cnVlICkuYW5pbWF0ZSggYW5pbWF0aW9ucywgY29uZmlnLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAnZmFzdCcgOiBjb25maWcuZHVyYXRpb24gKTtcblx0XHQkY29udGFpbmVyLnF1ZXVlKCBmdW5jdGlvbiAoIG5leHQgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlKCk7XG5cdFx0XHRuZXh0KCk7XG5cdFx0fSApO1xuXHR9IGVsc2Uge1xuXHRcdGRlZmVycmVkLnJlc29sdmUoKTtcblx0fVxuXHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xufTtcblxuLyoqXG4gKiBGb3JjZSB0aGUgYnJvd3NlciB0byByZWNvbnNpZGVyIHdoZXRoZXIgaXQgcmVhbGx5IG5lZWRzIHRvIHJlbmRlciBzY3JvbGxiYXJzIGluc2lkZSB0aGUgZWxlbWVudFxuICogYW5kIHJlc2VydmUgc3BhY2UgZm9yIHRoZW0sIGJlY2F1c2UgaXQgcHJvYmFibHkgZG9lc24ndC5cbiAqXG4gKiBXb3JrYXJvdW5kIHByaW1hcmlseSBmb3IgPGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zODcyOTA+LCBidXQgYWxzb1xuICogc2ltaWxhciBidWdzIGluIG90aGVyIGJyb3dzZXJzLiBcIkp1c3RcIiBmb3JjaW5nIGEgcmVmbG93IGlzIG5vdCBzdWZmaWNpZW50IGluIGFsbCBjYXNlcywgd2UgbmVlZFxuICogdG8gZmlyc3QgYWN0dWFsbHkgZGV0YWNoIChvciBoaWRlLCBidXQgZGV0YWNoaW5nIGlzIHNpbXBsZXIpIGFsbCBjaGlsZHJlbiwgKnRoZW4qIGZvcmNlIGEgcmVmbG93LFxuICogYW5kIHRoZW4gcmVhdHRhY2ggKG9yIHNob3cpIHRoZW0gYmFjay5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IHRvIHJlY29uc2lkZXIgdGhlIHNjcm9sbGJhcnMgb25cbiAqL1xuT08udWkuRWxlbWVudC5zdGF0aWMucmVjb25zaWRlclNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoIGVsICkge1xuXHR2YXIgaSwgbGVuLCBzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIG5vZGVzID0gW107XG5cdC8vIFNhdmUgc2Nyb2xsIHBvc2l0aW9uXG5cdHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuXHRzY3JvbGxUb3AgPSBlbC5zY3JvbGxUb3A7XG5cdC8vIERldGFjaCBhbGwgY2hpbGRyZW5cblx0d2hpbGUgKCBlbC5maXJzdENoaWxkICkge1xuXHRcdG5vZGVzLnB1c2goIGVsLmZpcnN0Q2hpbGQgKTtcblx0XHRlbC5yZW1vdmVDaGlsZCggZWwuZmlyc3RDaGlsZCApO1xuXHR9XG5cdC8vIEZvcmNlIHJlZmxvd1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdm9pZFxuXHR2b2lkIGVsLm9mZnNldEhlaWdodDtcblx0Ly8gUmVhdHRhY2ggYWxsIGNoaWxkcmVuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggbm9kZXNbIGkgXSApO1xuXHR9XG5cdC8vIFJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIChuby1vcCBpZiBzY3JvbGxiYXJzIGRpc2FwcGVhcmVkKVxuXHRlbC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0ZWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xufTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd10gTWFrZSBlbGVtZW50IHZpc2libGUsIG9taXQgdG8gdG9nZ2xlIHZpc2liaWxpdHlcbiAqIEBmaXJlcyB2aXNpYmxlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICggc2hvdyApIHtcblx0c2hvdyA9IHNob3cgPT09IHVuZGVmaW5lZCA/ICF0aGlzLnZpc2libGUgOiAhIXNob3c7XG5cblx0aWYgKCBzaG93ICE9PSB0aGlzLmlzVmlzaWJsZSgpICkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHNob3c7XG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJywgIXRoaXMudmlzaWJsZSApO1xuXHRcdHRoaXMuZW1pdCggJ3RvZ2dsZScsIHNob3cgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBlbGVtZW50IGlzIHZpc2libGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gZWxlbWVudCBpcyB2aXNpYmxlXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMudmlzaWJsZTtcbn07XG5cbi8qKlxuICogR2V0IGVsZW1lbnQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH0gRWxlbWVudCBkYXRhXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmRhdGE7XG59O1xuXG4vKipcbiAqIFNldCBlbGVtZW50IGRhdGEuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gZGF0YSBFbGVtZW50IGRhdGFcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuRWxlbWVudC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0dGhpcy5kYXRhID0gZGF0YTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZWxlbWVudCBoYXMgYW4gJ2lkJyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnNldEVsZW1lbnRJZCA9IGZ1bmN0aW9uICggaWQgKSB7XG5cdHRoaXMuZWxlbWVudElkID0gaWQ7XG5cdHRoaXMuJGVsZW1lbnQuYXR0ciggJ2lkJywgaWQgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGhhcyBhbiAnaWQnIGF0dHJpYnV0ZSwgc2V0dGluZyBpdCB0byBhbiB1bmlxdWUgdmFsdWUgaWYgaXQncyBtaXNzaW5nLFxuICogYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5PTy51aS5FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50SWQgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy5lbGVtZW50SWQgPT09IG51bGwgKSB7XG5cdFx0dGhpcy5zZXRFbGVtZW50SWQoIE9PLnVpLmdlbmVyYXRlRWxlbWVudElkKCkgKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5lbGVtZW50SWQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGVsZW1lbnQgc3VwcG9ydHMgb25lIG9yIG1vcmUgbWV0aG9kcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbWV0aG9kcyBNZXRob2Qgb3IgbGlzdCBvZiBtZXRob2RzIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBBbGwgbWV0aG9kcyBhcmUgc3VwcG9ydGVkXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKCBtZXRob2RzICkge1xuXHR2YXIgaSwgbGVuLFxuXHRcdHN1cHBvcnQgPSAwO1xuXG5cdG1ldGhvZHMgPSBBcnJheS5pc0FycmF5KCBtZXRob2RzICkgPyBtZXRob2RzIDogWyBtZXRob2RzIF07XG5cdGZvciAoIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggdHlwZW9mIHRoaXNbIG1ldGhvZHNbIGkgXSBdID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0c3VwcG9ydCsrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtZXRob2RzLmxlbmd0aCA9PT0gc3VwcG9ydDtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSB0aGVtZS1wcm92aWRlZCBjbGFzc2VzLlxuICpcbiAqIEBsb2NhbGRvYyBUaGlzIGlzIGNhbGxlZCBpbiBlbGVtZW50IG1peGlucyBhbmQgd2lkZ2V0IGNsYXNzZXMgYW55IHRpbWUgc3RhdGUgY2hhbmdlcy5cbiAqICAgVXBkYXRpbmcgaXMgZGVib3VuY2VkLCBtaW5pbWl6aW5nIG92ZXJoZWFkIG9mIGNoYW5naW5nIG11bHRpcGxlIGF0dHJpYnV0ZXMgYW5kXG4gKiAgIGd1YXJhbnRlZWluZyB0aGF0IHRoZW1lIHVwZGF0ZXMgZG8gbm90IG9jY3VyIHdpdGhpbiBhbiBlbGVtZW50J3MgY29uc3RydWN0b3JcbiAqL1xuT08udWkuRWxlbWVudC5wcm90b3R5cGUudXBkYXRlVGhlbWVDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS50aGVtZS5xdWV1ZVVwZGF0ZUVsZW1lbnRDbGFzc2VzKCB0aGlzICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgSFRNTCB0YWcgbmFtZS5cbiAqXG4gKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBiYXNlIHRoZSByZXN1bHQgb24gaW5zdGFuY2UgaW5mb3JtYXRpb24uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHRhZyBuYW1lXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLmdldFRhZ05hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy50YWdOYW1lO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTVxuICovXG5PTy51aS5FbGVtZW50LnByb3RvdHlwZS5pc0VsZW1lbnRBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICQuY29udGFpbnMoIHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCksIHRoaXMuJGVsZW1lbnRbIDAgXSApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIERPTSBkb2N1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHtIVE1MRG9jdW1lbnR9IERvY3VtZW50IG9iamVjdFxuICovXG5PTy51aS5FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50RG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIERvbid0IGNhY2hlIHRoaXMgaW4gb3RoZXIgd2F5cyBlaXRoZXIgYmVjYXVzZSBzdWJjbGFzc2VzIGNvdWxkIGNhbiBjaGFuZ2UgdGhpcy4kZWxlbWVudFxuXHRyZXR1cm4gT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RG9jdW1lbnQoIHRoaXMuJGVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBET00gd2luZG93LlxuICpcbiAqIEByZXR1cm4ge1dpbmRvd30gV2luZG93IG9iamVjdFxuICovXG5PTy51aS5FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50V2luZG93ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0V2luZG93KCB0aGlzLiRlbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIEdldCBjbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyLlxuICpcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLmdldENsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldENsb3Nlc3RTY3JvbGxhYmxlQ29udGFpbmVyKCB0aGlzLiRlbGVtZW50WyAwIF0gKTtcbn07XG5cbi8qKlxuICogR2V0IGdyb3VwIGVsZW1lbnQgaXMgaW4uXG4gKlxuICogQHJldHVybiB7T08udWkubWl4aW4uR3JvdXBFbGVtZW50fG51bGx9IEdyb3VwIGVsZW1lbnQsIG51bGwgaWYgbm9uZVxuICovXG5PTy51aS5FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmVsZW1lbnRHcm91cDtcbn07XG5cbi8qKlxuICogU2V0IGdyb3VwIGVsZW1lbnQgaXMgaW4uXG4gKlxuICogQHBhcmFtIHtPTy51aS5taXhpbi5Hcm91cEVsZW1lbnR8bnVsbH0gZ3JvdXAgR3JvdXAgZWxlbWVudCwgbnVsbCBpZiBub25lXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnNldEVsZW1lbnRHcm91cCA9IGZ1bmN0aW9uICggZ3JvdXAgKSB7XG5cdHRoaXMuZWxlbWVudEdyb3VwID0gZ3JvdXA7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTY3JvbGwgZWxlbWVudCBpbnRvIHZpZXcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgc2Nyb2xsIGlzIGNvbXBsZXRlXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEVsZW1lbnRJbnRvVmlldyA9IGZ1bmN0aW9uICggY29uZmlnICkge1xuXHRpZiAoXG5cdFx0IXRoaXMuaXNFbGVtZW50QXR0YWNoZWQoKSB8fFxuXHRcdCF0aGlzLmlzVmlzaWJsZSgpIHx8XG5cdFx0KCB0aGlzLmdldEVsZW1lbnRHcm91cCgpICYmICF0aGlzLmdldEVsZW1lbnRHcm91cCgpLmlzVmlzaWJsZSgpIClcblx0KSB7XG5cdFx0cmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKCk7XG5cdH1cblx0cmV0dXJuIE9PLnVpLkVsZW1lbnQuc3RhdGljLnNjcm9sbEludG9WaWV3KCB0aGlzLiRlbGVtZW50WyAwIF0sIGNvbmZpZyApO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIHRoZSBwcmUtaW5mdXNpb24gZHluYW1pYyBzdGF0ZSBmb3IgdGhpcyB3aWRnZXQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyICMkZWxlbWVudCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTS4gVGhlIHBhcmFtZXRlciBpcyB0aGUgcmV0dXJuXG4gKiB2YWx1ZSBvZiAjZ2F0aGVyUHJlSW5mdXNlU3RhdGUuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKi9cbk9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnJlc3RvcmVQcmVJbmZ1c2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogV3JhcHMgYW4gSFRNTCBzbmlwcGV0IGZvciB1c2Ugd2l0aCBjb25maWd1cmF0aW9uIHZhbHVlcyB3aGljaCBkZWZhdWx0XG4gKiB0byBzdHJpbmdzLiAgVGhpcyBieXBhc3NlcyB0aGUgZGVmYXVsdCBodG1sLWVzY2FwaW5nIGRvbmUgdG8gc3RyaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRlbnRdIEhUTUwgY29udGVudFxuICovXG5PTy51aS5IdG1sU25pcHBldCA9IGZ1bmN0aW9uIE9vVWlIdG1sU25pcHBldCggY29udGVudCApIHtcblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5pdENsYXNzKCBPTy51aS5IdG1sU25pcHBldCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogUmVuZGVyIGludG8gSFRNTC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFVuY2hhbmdlZCBIVE1MIHNuaXBwZXQuXG4gKi9cbk9PLnVpLkh0bWxTbmlwcGV0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuY29udGVudDtcbn07XG5cbi8qKlxuICogTGF5b3V0cyBhcmUgY29udGFpbmVycyBmb3IgZWxlbWVudHMgYW5kIGFyZSB1c2VkIHRvIGFycmFuZ2Ugb3RoZXIgd2lkZ2V0cyBvZiBhcmJpdHJhcnkgdHlwZSBpbiBhIHdheVxuICogdGhhdCBpcyBjZW50cmFsbHkgY29udHJvbGxlZCBhbmQgY2FuIGJlIHVwZGF0ZWQgZHluYW1pY2FsbHkuIExheW91dHMgY2FuIGJlLCBhbmQgdXN1YWxseSBhcmUsIGNvbWJpbmVkLlxuICogU2VlIHtAbGluayBPTy51aS5GaWVsZHNldExheW91dCBGaWVsZHNldExheW91dH0sIHtAbGluayBPTy51aS5GaWVsZExheW91dCBGaWVsZExheW91dH0sIHtAbGluayBPTy51aS5Gb3JtTGF5b3V0IEZvcm1MYXlvdXR9LFxuICoge0BsaW5rIE9PLnVpLlBhbmVsTGF5b3V0IFBhbmVsTGF5b3V0fSwge0BsaW5rIE9PLnVpLlN0YWNrTGF5b3V0IFN0YWNrTGF5b3V0fSwge0BsaW5rIE9PLnVpLlBhZ2VMYXlvdXQgUGFnZUxheW91dH0sXG4gKiB7QGxpbmsgT08udWkuSG9yaXpvbnRhbExheW91dCBIb3Jpem9udGFsTGF5b3V0fSwgYW5kIHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IEJvb2tsZXRMYXlvdXR9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuRWxlbWVudFxuICogQG1peGlucyBPTy5FdmVudEVtaXR0ZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuTGF5b3V0ID0gZnVuY3Rpb24gT29VaUxheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuTGF5b3V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08uRXZlbnRFbWl0dGVyLmNhbGwoIHRoaXMgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktbGF5b3V0JyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5MYXlvdXQsIE9PLnVpLkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkxheW91dCwgT08uRXZlbnRFbWl0dGVyICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBSZXNldCBzY3JvbGwgb2Zmc2V0c1xuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkxheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkxheW91dC5wcm90b3R5cGUucmVzZXRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuJGVsZW1lbnRbIDAgXS5zY3JvbGxUb3AgPSAwO1xuXHQvLyBUT0RPOiBSZXNldCBzY3JvbGxMZWZ0IGluIGFuIFJUTC1hd2FyZSBtYW5uZXIsIHNlZSBPTy51aS5FbGVtZW50LnN0YXRpYy5nZXRTY3JvbGxMZWZ0LlxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXaWRnZXRzIGFyZSBjb21wb3NpdGlvbnMgb2Ygb25lIG9yIG1vcmUgT09VSSBlbGVtZW50cyB0aGF0IHVzZXJzIGNhbiBib3RoIHZpZXdcbiAqIGFuZCBpbnRlcmFjdCB3aXRoLiBBbGwgd2lkZ2V0cyBjYW4gYmUgY29uZmlndXJlZCBhbmQgbW9kaWZpZWQgdmlhIGEgc3RhbmRhcmQgQVBJLFxuICogYW5kIHRoZWlyIHN0YXRlIGNhbiBjaGFuZ2UgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIGEgbW9kZWwuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkVsZW1lbnRcbiAqIEBtaXhpbnMgT08uRXZlbnRFbWl0dGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbZGlzYWJsZWQ9ZmFsc2VdIERpc2FibGUgdGhlIHdpZGdldC4gRGlzYWJsZWQgd2lkZ2V0cyBjYW5ub3QgYmUgdXNlZCBhbmQgdGhlaXJcbiAqICBhcHBlYXJhbmNlIHJlZmxlY3RzIHRoaXMgc3RhdGUuXG4gKi9cbk9PLnVpLldpZGdldCA9IGZ1bmN0aW9uIE9vVWlXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gSW5pdGlhbGl6ZSBjb25maWdcblx0Y29uZmlnID0gJC5leHRlbmQoIHsgZGlzYWJsZWQ6IGZhbHNlIH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy5FdmVudEVtaXR0ZXIuY2FsbCggdGhpcyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5kaXNhYmxlZCA9IG51bGw7XG5cdHRoaXMud2FzRGlzYWJsZWQgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS13aWRnZXQnICk7XG5cdHRoaXMuc2V0RGlzYWJsZWQoICEhY29uZmlnLmRpc2FibGVkICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLldpZGdldCwgT08udWkuRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuV2lkZ2V0LCBPTy5FdmVudEVtaXR0ZXIgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGRpc2FibGVcbiAqXG4gKiBBICdkaXNhYmxlJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSB3aWRnZXQgY2hhbmdlc1xuICogKGkuZS4gb24gZGlzYWJsZSAqKmFuZCoqIGVuYWJsZSkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCBXaWRnZXQgaXMgZGlzYWJsZWRcbiAqL1xuXG4vKipcbiAqIEBldmVudCB0b2dnbGVcbiAqXG4gKiBBICd0b2dnbGUnIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgd2lkZ2V0IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIFdpZGdldCBpcyB2aXNpYmxlXG4gKi9cblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB3aWRnZXQgaXMgZGlzYWJsZWQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2lkZ2V0IGlzIGRpc2FibGVkXG4gKi9cbk9PLnVpLldpZGdldC5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ2Rpc2FibGVkJyBzdGF0ZSBvZiB0aGUgd2lkZ2V0LlxuICpcbiAqIFdoZW4gYSB3aWRnZXQgaXMgZGlzYWJsZWQsIGl0IGNhbm5vdCBiZSB1c2VkIGFuZCBpdHMgYXBwZWFyYW5jZSBpcyB1cGRhdGVkIHRvIHJlZmxlY3QgdGhpcyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIERpc2FibGUgd2lkZ2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5XaWRnZXQucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24gKCBkaXNhYmxlZCApIHtcblx0dmFyIGlzRGlzYWJsZWQ7XG5cblx0dGhpcy5kaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG5cdGlzRGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKTtcblx0aWYgKCBpc0Rpc2FibGVkICE9PSB0aGlzLndhc0Rpc2FibGVkICkge1xuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS13aWRnZXQtZGlzYWJsZWQnLCBpc0Rpc2FibGVkICk7XG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLXdpZGdldC1lbmFibGVkJywgIWlzRGlzYWJsZWQgKTtcblx0XHR0aGlzLiRlbGVtZW50LmF0dHIoICdhcmlhLWRpc2FibGVkJywgaXNEaXNhYmxlZC50b1N0cmluZygpICk7XG5cdFx0dGhpcy5lbWl0KCAnZGlzYWJsZScsIGlzRGlzYWJsZWQgKTtcblx0XHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXHR9XG5cdHRoaXMud2FzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGRpc2FibGVkIHN0YXRlLCBpbiBjYXNlIG9mIGNoYW5nZXMgaW4gcGFyZW50IHdpZGdldC5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5XaWRnZXQucHJvdG90eXBlLnVwZGF0ZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnNldERpc2FibGVkKCB0aGlzLmRpc2FibGVkICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gSUQgb2YgYSBsYWJlbGFibGUgbm9kZSB3aGljaCBpcyBwYXJ0IG9mIHRoaXMgd2lkZ2V0LCBpZiBhbnksIHRvIGJlIHVzZWQgZm9yIGA8bGFiZWwgZm9yPmBcbiAqIHZhbHVlLlxuICpcbiAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsLCB0aGUgd2lkZ2V0IHNob3VsZCBoYXZlIGEgbWVhbmluZ2Z1bCAjc2ltdWxhdGVMYWJlbENsaWNrIG1ldGhvZFxuICogaW5zdGVhZC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gVGhlIElEIG9mIHRoZSBsYWJlbGFibGUgZWxlbWVudFxuICovXG5PTy51aS5XaWRnZXQucHJvdG90eXBlLmdldElucHV0SWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBTaW11bGF0ZSB0aGUgYmVoYXZpb3Igb2YgY2xpY2tpbmcgb24gYSBsYWJlbCAoYSBIVE1MIGA8bGFiZWw+YCBlbGVtZW50KSBib3VuZCB0byB0aGlzIGlucHV0LlxuICogSFRNTCBvbmx5IGFsbG93cyBgPGxhYmVsPmAgdG8gYWN0IG9uIHNwZWNpZmljIFwibGFiZWxhYmxlXCIgZWxlbWVudHM7IGNvbXBsZXggd2lkZ2V0cyBtaWdodCBuZWVkIHRvXG4gKiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGludHVpdGl2ZSwgYWNjZXNzaWJsZSBiZWhhdmlvci5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGRvZXMgbm90aGluZy4gT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQgb3ZlcnJpZGVzIGl0IGZvciBmb2N1c2FibGUgd2lkZ2V0cy5cbiAqIEluZGl2aWR1YWwgd2lkZ2V0cyBtYXkgb3ZlcnJpZGUgaXQgdG9vLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBPTy51aS5MYWJlbFdpZGdldCBhbmQgT08udWkuRmllbGRMYXlvdXQuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkXG4gKiBkaXJlY3RseS5cbiAqL1xuT08udWkuV2lkZ2V0LnByb3RvdHlwZS5zaW11bGF0ZUxhYmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIFRoZW1lIGxvZ2ljLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbk9PLnVpLlRoZW1lID0gZnVuY3Rpb24gT29VaVRoZW1lKCkge1xuXHR0aGlzLmVsZW1lbnRDbGFzc2VzUXVldWUgPSBbXTtcblx0dGhpcy5kZWJvdW5jZWRVcGRhdGVRdWV1ZWRFbGVtZW50Q2xhc3NlcyA9IE9PLnVpLmRlYm91bmNlKCB0aGlzLnVwZGF0ZVF1ZXVlZEVsZW1lbnRDbGFzc2VzICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbml0Q2xhc3MoIE9PLnVpLlRoZW1lICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGNsYXNzZXMgdG8gYmUgYXBwbGllZCB0byBhIHdpZGdldC5cbiAqXG4gKiBUaGUgJ29uJyBhbmQgJ29mZicgbGlzdHMgY29tYmluZWQgTVVTVCBjb250YWluIGtleXMgZm9yIGFsbCBjbGFzc2VzIHRoZSB0aGVtZSBhZGRzIG9yIHJlbW92ZXMsXG4gKiBvdGhlcndpc2Ugc3RhdGUgdHJhbnNpdGlvbnMgd2lsbCBub3Qgd29yayBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IGNsYXNzZXNcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLHN0cmluZ1tdPn0gQ2F0ZWdvcml6ZWQgY2xhc3MgbmFtZXMgd2l0aCBgb25gIGFuZCBgb2ZmYCBsaXN0c1xuICovXG5PTy51aS5UaGVtZS5wcm90b3R5cGUuZ2V0RWxlbWVudENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB7IG9uOiBbXSwgb2ZmOiBbXSB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgQ1NTIGNsYXNzZXMgcHJvdmlkZWQgYnkgdGhlIHRoZW1lLlxuICpcbiAqIEZvciBlbGVtZW50cyB3aXRoIHRoZW1lIGxvZ2ljIGhvb2tzLCB0aGlzIHNob3VsZCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlcmUncyBhIHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCBmb3Igd2hpY2ggdG8gdXBkYXRlIGNsYXNzZXNcbiAqL1xuT08udWkuVGhlbWUucHJvdG90eXBlLnVwZGF0ZUVsZW1lbnRDbGFzc2VzID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXHR2YXIgJGVsZW1lbnRzID0gJCggW10gKSxcblx0XHRjbGFzc2VzID0gdGhpcy5nZXRFbGVtZW50Q2xhc3NlcyggZWxlbWVudCApO1xuXG5cdGlmICggZWxlbWVudC4kaWNvbiApIHtcblx0XHQkZWxlbWVudHMgPSAkZWxlbWVudHMuYWRkKCBlbGVtZW50LiRpY29uICk7XG5cdH1cblx0aWYgKCBlbGVtZW50LiRpbmRpY2F0b3IgKSB7XG5cdFx0JGVsZW1lbnRzID0gJGVsZW1lbnRzLmFkZCggZWxlbWVudC4kaW5kaWNhdG9yICk7XG5cdH1cblxuXHQkZWxlbWVudHNcblx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMub2ZmIClcblx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMub24gKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuVGhlbWUucHJvdG90eXBlLnVwZGF0ZVF1ZXVlZEVsZW1lbnRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaTtcblx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRDbGFzc2VzUXVldWUubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGhpcy51cGRhdGVFbGVtZW50Q2xhc3NlcyggdGhpcy5lbGVtZW50Q2xhc3Nlc1F1ZXVlWyBpIF0gKTtcblx0fVxuXHQvLyBDbGVhciB0aGUgcXVldWVcblx0dGhpcy5lbGVtZW50Q2xhc3Nlc1F1ZXVlID0gW107XG59O1xuXG4vKipcbiAqIFF1ZXVlICN1cGRhdGVFbGVtZW50Q2xhc3NlcyB0byBiZSBjYWxsZWQgZm9yIHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAbG9jYWxkb2MgUVVuaXQgdGVzdHMgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZGlyZWN0bHkgY2FsbCAjcXVldWVVcGRhdGVFbGVtZW50Q2xhc3NlcyxcbiAqICAgdG8gbWFrZSB0aGVtIHN5bmNocm9ub3VzLlxuICpcbiAqIEBwYXJhbSB7T08udWkuRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IGZvciB3aGljaCB0byB1cGRhdGUgY2xhc3Nlc1xuICovXG5PTy51aS5UaGVtZS5wcm90b3R5cGUucXVldWVVcGRhdGVFbGVtZW50Q2xhc3NlcyA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblx0Ly8gS2VlcCBpdGVtcyBpbiB0aGUgcXVldWUgdW5pcXVlLiBVc2UgbGFzdEluZGV4T2YgdG8gc3RhcnQgY2hlY2tpbmcgZnJvbSB0aGUgZW5kIGJlY2F1c2UgdGhhdCdzXG5cdC8vIHRoZSBtb3N0IGNvbW1vbiBjYXNlICh0aGlzIG1ldGhvZCBpcyBvZnRlbiBjYWxsZWQgcmVwZWF0ZWRseSBmb3IgdGhlIHNhbWUgZWxlbWVudCkuXG5cdGlmICggdGhpcy5lbGVtZW50Q2xhc3Nlc1F1ZXVlLmxhc3RJbmRleE9mKCBlbGVtZW50ICkgIT09IC0xICkge1xuXHRcdHJldHVybjtcblx0fVxuXHR0aGlzLmVsZW1lbnRDbGFzc2VzUXVldWUucHVzaCggZWxlbWVudCApO1xuXHR0aGlzLmRlYm91bmNlZFVwZGF0ZVF1ZXVlZEVsZW1lbnRDbGFzc2VzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgZm9yIGRpYWxvZ3Mgb3BlbmluZy9jbG9zaW5nXG4gKlxuICogVGhlIGRpYWxvZyBzaG91bGQgYmUgZnVsbHkgcmVuZGVyZWQgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBhZnRlciB0aGVcbiAqIHJlYWR5IHByb2Nlc3MgaGFzIGV4ZWN1dGVkLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqL1xuT08udWkuVGhlbWUucHJvdG90eXBlLmdldERpYWxvZ1RyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIFRoZSBUYWJJbmRleGVkRWxlbWVudCBjbGFzcyBpcyBhbiBhdHRyaWJ1dGUgbWl4aW4gdXNlZCB0byBhZGQgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IHRvIGFuXG4gKiBlbGVtZW50IGNyZWF0ZWQgYnkgYW5vdGhlciBjbGFzcy4gVGhlIG1peGluIHByb3ZpZGVzIGEg4oCYdGFiSW5kZXjigJkgcHJvcGVydHksIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAqIG9yZGVyIGluIHdoaWNoIHVzZXJzIHdpbGwgbmF2aWdhdGUgdGhyb3VnaCB0aGUgZm9jdXNhYmxlIGVsZW1lbnRzIHZpYSB0aGUg4oCcdGFi4oCdIGtleS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBUYWJJbmRleGVkRWxlbWVudCBpcyBtaXhlZCBpbnRvIHRoZSBCdXR0b25XaWRnZXQgY2xhc3NcbiAqICAgICAvLyB0byBwcm92aWRlIGEgdGFiSW5kZXggcHJvcGVydHkuXG4gKiAgICAgdmFyIGJ1dHRvbjEgPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ2ZvdXJ0aCcsXG4gKiAgICAgICAgICAgICB0YWJJbmRleDogNFxuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIGJ1dHRvbjIgPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ3NlY29uZCcsXG4gKiAgICAgICAgICAgICB0YWJJbmRleDogMlxuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIGJ1dHRvbjMgPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ3RoaXJkJyxcbiAqICAgICAgICAgICAgIHRhYkluZGV4OiAzXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgYnV0dG9uNCA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnZmlyc3QnLFxuICogICAgICAgICAgICAgdGFiSW5kZXg6IDFcbiAqICAgICAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGJ1dHRvbjEuJGVsZW1lbnQsIGJ1dHRvbjIuJGVsZW1lbnQsIGJ1dHRvbjMuJGVsZW1lbnQsIGJ1dHRvbjQuJGVsZW1lbnQgKTtcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJHRhYkluZGV4ZWRdIFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIHVzZSB0aGUgdGFiaW5kZXggZnVuY3Rpb25hbGl0eS4gQnkgZGVmYXVsdCxcbiAqICB0aGUgZnVuY3Rpb25hbGl0eSBpcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNsYXNzICgkZWxlbWVudCkuIElmIGEgZGlmZmVyZW50IGVsZW1lbnQgaXMgc3BlY2lmaWVkLCB0aGUgdGFiaW5kZXhcbiAqICBmdW5jdGlvbmFsaXR5IHdpbGwgYmUgYXBwbGllZCB0byBpdCBpbnN0ZWFkLlxuICogQGNmZyB7c3RyaW5nfG51bWJlcnxudWxsfSBbdGFiSW5kZXg9MF0gTnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBlbGVtZW504oCZcyBwb3NpdGlvbiBpbiB0aGUgdGFiLW5hdmlnYXRpb25cbiAqICBvcmRlciAoZS5nLiwgMSBmb3IgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50KS4gVXNlIDAgdG8gdXNlIHRoZSBkZWZhdWx0IG5hdmlnYXRpb24gb3JkZXI7IHVzZSAtMVxuICogIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSB0YWItbmF2aWdhdGlvbiBmbG93LlxuICovXG5PTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCA9IGZ1bmN0aW9uIE9vVWlNaXhpblRhYkluZGV4ZWRFbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgdGFiSW5kZXg6IDAgfSwgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiR0YWJJbmRleGVkID0gbnVsbDtcblx0dGhpcy50YWJJbmRleCA9IG51bGw7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuY29ubmVjdCggdGhpcywgeyBkaXNhYmxlOiAnb25UYWJJbmRleGVkRWxlbWVudERpc2FibGUnIH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnNldFRhYkluZGV4KCBjb25maWcudGFiSW5kZXggKTtcblx0dGhpcy5zZXRUYWJJbmRleGVkRWxlbWVudCggY29uZmlnLiR0YWJJbmRleGVkIHx8IHRoaXMuJGVsZW1lbnQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaXRDbGFzcyggT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFNldCB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCB1c2UgdGhlIHRhYmluZGV4IGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byByZXRhcmdldCBhIHRhYmluZGV4IG1peGluIHNvIHRoYXQgaXRzIGZ1bmN0aW9uYWxpdHkgYXBwbGllc1xuICogdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LiBJZiBhbiBlbGVtZW50IGlzIGN1cnJlbnRseSB1c2luZyB0aGUgZnVuY3Rpb25hbGl0eSwgdGhlIG1peGlu4oCZc1xuICogZWZmZWN0IG9uIHRoYXQgZWxlbWVudCBpcyByZW1vdmVkIGJlZm9yZSB0aGUgbmV3IGVsZW1lbnQgaXMgc2V0IHVwLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFiSW5kZXhlZCBFbGVtZW50IHRoYXQgc2hvdWxkIHVzZSB0aGUgdGFiaW5kZXggZnVuY3Rpb25hbGl0eVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5wcm90b3R5cGUuc2V0VGFiSW5kZXhlZEVsZW1lbnQgPSBmdW5jdGlvbiAoICR0YWJJbmRleGVkICkge1xuXHR2YXIgdGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuXHQvLyBSZW1vdmUgYXR0cmlidXRlcyBmcm9tIG9sZCAkdGFiSW5kZXhlZFxuXHR0aGlzLnNldFRhYkluZGV4KCBudWxsICk7XG5cdC8vIEZvcmNlIHVwZGF0ZSBvZiBuZXcgJHRhYkluZGV4ZWRcblx0dGhpcy4kdGFiSW5kZXhlZCA9ICR0YWJJbmRleGVkO1xuXHR0aGlzLnRhYkluZGV4ID0gdGFiSW5kZXg7XG5cdHJldHVybiB0aGlzLnVwZGF0ZVRhYkluZGV4KCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHRhYmluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxudWxsfSB0YWJJbmRleCBUYWJpbmRleCB2YWx1ZSwgb3IgYG51bGxgIGZvciBubyB0YWJpbmRleFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5wcm90b3R5cGUuc2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoIHRhYkluZGV4ICkge1xuXHR0YWJJbmRleCA9IC9eLT9cXGQrJC8udGVzdCggdGFiSW5kZXggKSA/IE51bWJlciggdGFiSW5kZXggKSA6IG51bGw7XG5cblx0aWYgKCB0aGlzLnRhYkluZGV4ICE9PSB0YWJJbmRleCApIHtcblx0XHR0aGlzLnRhYkluZGV4ID0gdGFiSW5kZXg7XG5cdFx0dGhpcy51cGRhdGVUYWJJbmRleCgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUsIGluIGNhc2Ugb2YgY2hhbmdlcyB0byB0YWIgaW5kZXggb3JcbiAqIGRpc2FibGVkIHN0YXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50LnByb3RvdHlwZS51cGRhdGVUYWJJbmRleCA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLiR0YWJJbmRleGVkICkge1xuXHRcdGlmICggdGhpcy50YWJJbmRleCAhPT0gbnVsbCApIHtcblx0XHRcdC8vIERvIG5vdCBpbmRleCBvdmVyIGRpc2FibGVkIGVsZW1lbnRzXG5cdFx0XHR0aGlzLiR0YWJJbmRleGVkLmF0dHIoIHtcblx0XHRcdFx0dGFiaW5kZXg6IHRoaXMuaXNEaXNhYmxlZCgpID8gLTEgOiB0aGlzLnRhYkluZGV4LFxuXHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWVWb3ggYW5kIE5WREFcblx0XHRcdFx0Ly8gVGhlc2UgZG8gbm90IHNlZW0gdG8gaW5oZXJpdCBhcmlhLWRpc2FibGVkIGZyb20gcGFyZW50IGVsZW1lbnRzXG5cdFx0XHRcdCdhcmlhLWRpc2FibGVkJzogdGhpcy5pc0Rpc2FibGVkKCkudG9TdHJpbmcoKVxuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiR0YWJJbmRleGVkLnJlbW92ZUF0dHIoICd0YWJpbmRleCBhcmlhLWRpc2FibGVkJyApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGFuZGxlIGRpc2FibGUgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIEVsZW1lbnQgaXMgZGlzYWJsZWRcbiAqL1xuT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQucHJvdG90eXBlLm9uVGFiSW5kZXhlZEVsZW1lbnREaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnVwZGF0ZVRhYkluZGV4KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRhYmluZGV4LlxuICpcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSBUYWJpbmRleCB2YWx1ZVxuICovXG5PTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5wcm90b3R5cGUuZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnRhYkluZGV4O1xufTtcblxuLyoqXG4gKiBHZXQgYW4gSUQgb2YgYSBmb2N1c2FibGUgZWxlbWVudCBvZiB0aGlzIHdpZGdldCwgaWYgYW55LCB0byBiZSB1c2VkIGZvciBgPGxhYmVsIGZvcj5gIHZhbHVlLlxuICpcbiAqIElmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGFuIElEIHRoZW4gdGhhdCBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIHVuaXF1ZSBJRCBpc1xuICogZ2VuZXJhdGVkLCBzZXQgb24gdGhlIGVsZW1lbnQsIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gVGhlIElEIG9mIHRoZSBmb2N1c2FibGUgZWxlbWVudFxuICovXG5PTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5wcm90b3R5cGUuZ2V0SW5wdXRJZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGlkO1xuXG5cdGlmICggIXRoaXMuJHRhYkluZGV4ZWQgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCAhdGhpcy5pc0xhYmVsYWJsZU5vZGUoIHRoaXMuJHRhYkluZGV4ZWQgKSApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlkID0gdGhpcy4kdGFiSW5kZXhlZC5hdHRyKCAnaWQnICk7XG5cdGlmICggaWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRpZCA9IE9PLnVpLmdlbmVyYXRlRWxlbWVudElkKCk7XG5cdFx0dGhpcy4kdGFiSW5kZXhlZC5hdHRyKCAnaWQnLCBpZCApO1xuXHR9XG5cblx0cmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBub2RlIGlzICdsYWJlbGFibGUnIGFjY29yZGluZyB0byB0aGUgSFRNTCBzcGVjXG4gKiAoaS5lLiwgd2hldGhlciBpdCBjYW4gYmUgaW50ZXJhY3RlZCB3aXRoIHRocm91Z2ggYSBgPGxhYmVsIGZvcj1cIuKAplwiPmApLlxuICogU2VlOiA8aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbD4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQucHJvdG90eXBlLmlzTGFiZWxhYmxlTm9kZSA9IGZ1bmN0aW9uICggJG5vZGUgKSB7XG5cdHZhclxuXHRcdGxhYmVsYWJsZVRhZ3MgPSBbICdidXR0b24nLCAnbWV0ZXInLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3NlbGVjdCcsICd0ZXh0YXJlYScgXSxcblx0XHR0YWdOYW1lID0gJG5vZGUucHJvcCggJ3RhZ05hbWUnICkudG9Mb3dlckNhc2UoKTtcblxuXHRpZiAoIHRhZ05hbWUgPT09ICdpbnB1dCcgJiYgJG5vZGUuYXR0ciggJ3R5cGUnICkgIT09ICdoaWRkZW4nICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICggbGFiZWxhYmxlVGFncy5pbmRleE9mKCB0YWdOYW1lICkgIT09IC0xICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRm9jdXMgdGhpcyBlbGVtZW50LlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHR0aGlzLiR0YWJJbmRleGVkLmZvY3VzKCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEJsdXIgdGhpcyBlbGVtZW50LlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuJHRhYkluZGV4ZWQuYmx1cigpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2MgT08udWkuV2lkZ2V0XG4gKi9cbk9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50LnByb3RvdHlwZS5zaW11bGF0ZUxhYmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuZm9jdXMoKTtcbn07XG5cbi8qKlxuICogQnV0dG9uRWxlbWVudCBpcyBvZnRlbiBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXMgdG8gZ2VuZXJhdGUgYSBidXR0b24sIHdoaWNoIGlzIGEgY2xpY2thYmxlXG4gKiBpbnRlcmZhY2UgZWxlbWVudCB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHdpdGggYWNjZXNzIGtleXMgZm9yIGtleWJvYXJkIGludGVyYWN0aW9uLlxuICogU2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBleGFtcGxlcy5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvQnV0dG9uc19hbmRfU3dpdGNoZXMjQnV0dG9uc1xuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtqUXVlcnl9IFskYnV0dG9uXSBUaGUgYnV0dG9uIGVsZW1lbnQgY3JlYXRlZCBieSB0aGUgY2xhc3MuXG4gKiAgSWYgdGhpcyBjb25maWd1cmF0aW9uIGlzIG9taXR0ZWQsIHRoZSBidXR0b24gZWxlbWVudCB3aWxsIHVzZSBhIGdlbmVyYXRlZCBgPGE+YC5cbiAqIEBjZmcge2Jvb2xlYW59IFtmcmFtZWQ9dHJ1ZV0gUmVuZGVyIHRoZSBidXR0b24gd2l0aCBhIGZyYW1lXG4gKi9cbk9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpTWl4aW5CdXR0b25FbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kYnV0dG9uID0gbnVsbDtcblx0dGhpcy5mcmFtZWQgPSBudWxsO1xuXHR0aGlzLmFjdGl2ZSA9IGNvbmZpZy5hY3RpdmUgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuYWN0aXZlO1xuXHR0aGlzLm9uRG9jdW1lbnRNb3VzZVVwSGFuZGxlciA9IHRoaXMub25Eb2N1bWVudE1vdXNlVXAuYmluZCggdGhpcyApO1xuXHR0aGlzLm9uTW91c2VEb3duSGFuZGxlciA9IHRoaXMub25Nb3VzZURvd24uYmluZCggdGhpcyApO1xuXHR0aGlzLm9uRG9jdW1lbnRLZXlVcEhhbmRsZXIgPSB0aGlzLm9uRG9jdW1lbnRLZXlVcC5iaW5kKCB0aGlzICk7XG5cdHRoaXMub25LZXlEb3duSGFuZGxlciA9IHRoaXMub25LZXlEb3duLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5vbkNsaWNrSGFuZGxlciA9IHRoaXMub25DbGljay5iaW5kKCB0aGlzICk7XG5cdHRoaXMub25LZXlQcmVzc0hhbmRsZXIgPSB0aGlzLm9uS2V5UHJlc3MuYmluZCggdGhpcyApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1idXR0b25FbGVtZW50JyApO1xuXHR0aGlzLnRvZ2dsZUZyYW1lZCggY29uZmlnLmZyYW1lZCA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5mcmFtZWQgKTtcblx0dGhpcy5zZXRCdXR0b25FbGVtZW50KCBjb25maWcuJGJ1dHRvbiB8fCAkKCAnPGE+JyApICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbml0Q2xhc3MoIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBDYW5jZWwgbW91c2UgZG93biBldmVudHMuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyB1c3VhbGx5IHNldCB0byBgdHJ1ZWAgdG8gcHJldmVudCB0aGUgZm9jdXMgZnJvbSBjaGFuZ2luZyB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZC5cbiAqIENsYXNzZXMgc3VjaCBhcyB7QGxpbmsgT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudCBEcmFnZ2FibGVFbGVtZW50fSBhbmQge0BsaW5rIE9PLnVpLkJ1dHRvbk9wdGlvbldpZGdldCBCdXR0b25PcHRpb25XaWRnZXR9XG4gKiB1c2UgYSB2YWx1ZSBvZiBgZmFsc2VgIHNvIHRoYXQgZHJhZ2dpbmcgYmVoYXZpb3IgaXMgcG9zc2libGUgYW5kIG1vdXNlZG93biBldmVudHMgY2FuIGJlIGhhbmRsZWQgYnkgYVxuICogcGFyZW50IHdpZGdldC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5zdGF0aWMuY2FuY2VsQnV0dG9uTW91c2VEb3duRXZlbnRzID0gdHJ1ZTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQSAnY2xpY2snIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgYnV0dG9uIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAqXG4gKiBAZXZlbnQgY2xpY2tcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU2V0IHRoZSBidXR0b24gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJldGFyZ2V0IGEgYnV0dG9uIG1peGluIHNvIHRoYXQgaXRzIGZ1bmN0aW9uYWxpdHkgYXBwbGllcyB0b1xuICogdGhlIHNwZWNpZmllZCBidXR0b24gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBvbmUgY3JlYXRlZCBieSB0aGUgY2xhc3MuIElmIGEgYnV0dG9uIGVsZW1lbnRcbiAqIGlzIGFscmVhZHkgc2V0LCB0aGUgbWV0aG9kIHdpbGwgcmVtb3ZlIHRoZSBtaXhpbuKAmXMgZWZmZWN0IG9uIHRoYXQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGJ1dHRvbiBFbGVtZW50IHRvIHVzZSBhcyBidXR0b25cbiAqL1xuT08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5wcm90b3R5cGUuc2V0QnV0dG9uRWxlbWVudCA9IGZ1bmN0aW9uICggJGJ1dHRvbiApIHtcblx0aWYgKCB0aGlzLiRidXR0b24gKSB7XG5cdFx0dGhpcy4kYnV0dG9uXG5cdFx0XHQucmVtb3ZlQ2xhc3MoICdvby11aS1idXR0b25FbGVtZW50LWJ1dHRvbicgKVxuXHRcdFx0LnJlbW92ZUF0dHIoICdyb2xlIGFjY2Vzc2tleScgKVxuXHRcdFx0Lm9mZigge1xuXHRcdFx0XHRtb3VzZWRvd246IHRoaXMub25Nb3VzZURvd25IYW5kbGVyLFxuXHRcdFx0XHRrZXlkb3duOiB0aGlzLm9uS2V5RG93bkhhbmRsZXIsXG5cdFx0XHRcdGNsaWNrOiB0aGlzLm9uQ2xpY2tIYW5kbGVyLFxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5vbktleVByZXNzSGFuZGxlclxuXHRcdFx0fSApO1xuXHR9XG5cblx0dGhpcy4kYnV0dG9uID0gJGJ1dHRvblxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWJ1dHRvbkVsZW1lbnQtYnV0dG9uJyApXG5cdFx0Lm9uKCB7XG5cdFx0XHRtb3VzZWRvd246IHRoaXMub25Nb3VzZURvd25IYW5kbGVyLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5vbktleURvd25IYW5kbGVyLFxuXHRcdFx0Y2xpY2s6IHRoaXMub25DbGlja0hhbmRsZXIsXG5cdFx0XHRrZXlwcmVzczogdGhpcy5vbktleVByZXNzSGFuZGxlclxuXHRcdH0gKTtcblxuXHQvLyBBZGQgYHJvbGU9XCJidXR0b25cImAgb24gYDxhPmAgZWxlbWVudHMsIHdoZXJlIGl0J3MgbmVlZGVkXG5cdC8vIGB0b1VwcGVyQ2FzZSgpYCBpcyBhZGRlZCBmb3IgWEhUTUwgZG9jdW1lbnRzXG5cdGlmICggdGhpcy4kYnV0dG9uLnByb3AoICd0YWdOYW1lJyApLnRvVXBwZXJDYXNlKCkgPT09ICdBJyApIHtcblx0XHR0aGlzLiRidXR0b24uYXR0ciggJ3JvbGUnLCAnYnV0dG9uJyApO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgbW91c2UgZG93biBldmVudHMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgTW91c2UgZG93biBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoIHRoaXMuaXNEaXNhYmxlZCgpIHx8IGUud2hpY2ggIT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUICkge1xuXHRcdHJldHVybjtcblx0fVxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYnV0dG9uRWxlbWVudC1wcmVzc2VkJyApO1xuXHQvLyBSdW4gdGhlIG1vdXNldXAgaGFuZGxlciBubyBtYXR0ZXIgd2hlcmUgdGhlIG1vdXNlIGlzIHdoZW4gdGhlIGJ1dHRvbiBpcyBsZXQgZ28sIHNvIHdlIGNhblxuXHQvLyByZWxpYWJseSByZW1vdmUgdGhlIHByZXNzZWQgY2xhc3Ncblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHRoaXMub25Eb2N1bWVudE1vdXNlVXBIYW5kbGVyLCB0cnVlICk7XG5cdC8vIFByZXZlbnQgY2hhbmdlIG9mIGZvY3VzIHVubGVzcyBzcGVjaWZpY2FsbHkgY29uZmlndXJlZCBvdGhlcndpc2Vcblx0aWYgKCB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5jYW5jZWxCdXR0b25Nb3VzZURvd25FdmVudHMgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgZG9jdW1lbnQgbW91c2UgdXAgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBNb3VzZSB1cCBldmVudFxuICovXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5vbkRvY3VtZW50TW91c2VVcCA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCB0aGlzLmlzRGlzYWJsZWQoKSB8fCBlLndoaWNoICE9PSBPTy51aS5Nb3VzZUJ1dHRvbnMuTEVGVCApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLWJ1dHRvbkVsZW1lbnQtcHJlc3NlZCcgKTtcblx0Ly8gU3RvcCBsaXN0ZW5pbmcgZm9yIG1vdXNldXAsIHNpbmNlIHdlIG9ubHkgbmVlZGVkIHRoaXMgb25jZVxuXHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdGhpcy5vbkRvY3VtZW50TW91c2VVcEhhbmRsZXIsIHRydWUgKTtcbn07XG5cbi8vIERlcHJlY2F0ZWQgYWxpYXMgc2luY2UgMC4yOC4zXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ29uTW91c2VVcCBpcyBkZXByZWNhdGVkLCB1c2Ugb25Eb2N1bWVudE1vdXNlVXAgaW5zdGVhZCcgKTtcblx0dGhpcy5vbkRvY3VtZW50TW91c2VVcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgbW91c2UgY2xpY2sgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGNsaWNrIGV2ZW50XG4gKiBAZmlyZXMgY2xpY2tcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSAmJiBlLndoaWNoID09PSBPTy51aS5Nb3VzZUJ1dHRvbnMuTEVGVCApIHtcblx0XHRpZiAoIHRoaXMuZW1pdCggJ2NsaWNrJyApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGtleSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBLZXkgZG93biBldmVudFxuICovXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5vbktleURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGlmICggdGhpcy5pc0Rpc2FibGVkKCkgfHwgKCBlLndoaWNoICE9PSBPTy51aS5LZXlzLlNQQUNFICYmIGUud2hpY2ggIT09IE9PLnVpLktleXMuRU5URVIgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWJ1dHRvbkVsZW1lbnQtcHJlc3NlZCcgKTtcblx0Ly8gUnVuIHRoZSBrZXl1cCBoYW5kbGVyIG5vIG1hdHRlciB3aGVyZSB0aGUga2V5IGlzIHdoZW4gdGhlIGJ1dHRvbiBpcyBsZXQgZ28sIHNvIHdlIGNhblxuXHQvLyByZWxpYWJseSByZW1vdmUgdGhlIHByZXNzZWQgY2xhc3Ncblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCB0aGlzLm9uRG9jdW1lbnRLZXlVcEhhbmRsZXIsIHRydWUgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBkb2N1bWVudCBrZXkgdXAgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSBLZXkgdXAgZXZlbnRcbiAqL1xuT08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5wcm90b3R5cGUub25Eb2N1bWVudEtleVVwID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoIHRoaXMuaXNEaXNhYmxlZCgpIHx8ICggZS53aGljaCAhPT0gT08udWkuS2V5cy5TUEFDRSAmJiBlLndoaWNoICE9PSBPTy51aS5LZXlzLkVOVEVSICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS1idXR0b25FbGVtZW50LXByZXNzZWQnICk7XG5cdC8vIFN0b3AgbGlzdGVuaW5nIGZvciBrZXl1cCwgc2luY2Ugd2Ugb25seSBuZWVkZWQgdGhpcyBvbmNlXG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5vbkRvY3VtZW50S2V5VXBIYW5kbGVyLCB0cnVlICk7XG59O1xuXG4vLyBEZXByZWNhdGVkIGFsaWFzIHNpbmNlIDAuMjguM1xuT08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5wcm90b3R5cGUub25LZXlVcCA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnb25LZXlVcCBpcyBkZXByZWNhdGVkLCB1c2Ugb25Eb2N1bWVudEtleVVwIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudEtleVVwLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBrZXkgcHJlc3MgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBwcmVzcyBldmVudFxuICogQGZpcmVzIGNsaWNrXG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgKCBlLndoaWNoID09PSBPTy51aS5LZXlzLlNQQUNFIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuRU5URVIgKSApIHtcblx0XHRpZiAoIHRoaXMuZW1pdCggJ2NsaWNrJyApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBidXR0b24gaGFzIGEgZnJhbWUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gQnV0dG9uIGlzIGZyYW1lZFxuICovXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5pc0ZyYW1lZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZnJhbWVkO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGJ1dHRvbiB3aXRoIG9yIHdpdGhvdXQgYSBmcmFtZS4gT21pdCB0aGUgYGZyYW1lZGAgcGFyYW1ldGVyIHRvIHRvZ2dsZSB0aGUgYnV0dG9uIGZyYW1lIG9uIGFuZCBvZmYuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbZnJhbWVkXSBNYWtlIGJ1dHRvbiBmcmFtZWQsIG9taXQgdG8gdG9nZ2xlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQucHJvdG90eXBlLnRvZ2dsZUZyYW1lZCA9IGZ1bmN0aW9uICggZnJhbWVkICkge1xuXHRmcmFtZWQgPSBmcmFtZWQgPT09IHVuZGVmaW5lZCA/ICF0aGlzLmZyYW1lZCA6ICEhZnJhbWVkO1xuXHRpZiAoIGZyYW1lZCAhPT0gdGhpcy5mcmFtZWQgKSB7XG5cdFx0dGhpcy5mcmFtZWQgPSBmcmFtZWQ7XG5cdFx0dGhpcy4kZWxlbWVudFxuXHRcdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktYnV0dG9uRWxlbWVudC1mcmFtZWxlc3MnLCAhZnJhbWVkIClcblx0XHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLWJ1dHRvbkVsZW1lbnQtZnJhbWVkJywgZnJhbWVkICk7XG5cdFx0dGhpcy51cGRhdGVUaGVtZUNsYXNzZXMoKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGJ1dHRvbidzIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKiBUaGUgYWN0aXZlIHN0YXRlIGNhbiBiZSBzZXQgb246XG4gKlxuICogIC0ge0BsaW5rIE9PLnVpLkJ1dHRvbk9wdGlvbldpZGdldCBCdXR0b25PcHRpb25XaWRnZXR9IHdoZW4gaXQgaXMgc2VsZWN0ZWRcbiAqICAtIHtAbGluayBPTy51aS5Ub2dnbGVCdXR0b25XaWRnZXQgVG9nZ2xlQnV0dG9uV2lkZ2V0fSB3aGVuIGl0IGlzIHRvZ2dsZSBvblxuICogIC0ge0BsaW5rIE9PLnVpLkJ1dHRvbldpZGdldCBCdXR0b25XaWRnZXR9IHdoZW4gY2xpY2tpbmcgdGhlIGJ1dHRvbiB3b3VsZCBvbmx5IHJlZnJlc2ggdGhlIHBhZ2VcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIE1ha2UgYnV0dG9uIGFjdGl2ZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR0aGlzLmFjdGl2ZSA9ICEhdmFsdWU7XG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1idXR0b25FbGVtZW50LWFjdGl2ZScsIHRoaXMuYWN0aXZlICk7XG5cdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYnV0dG9uIGlzIGFjdGl2ZVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBidXR0b24gaXMgYWN0aXZlXG4gKi9cbk9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5hY3RpdmU7XG59O1xuXG4vKipcbiAqIEFueSBPT1VJIHdpZGdldCB0aGF0IGNvbnRhaW5zIG90aGVyIHdpZGdldHMgKHN1Y2ggYXMge0BsaW5rIE9PLnVpLkJ1dHRvbldpZGdldCBidXR0b25zfSBvclxuICoge0BsaW5rIE9PLnVpLk9wdGlvbldpZGdldCBvcHRpb25zfSkgbWl4ZXMgaW4gR3JvdXBFbGVtZW50LiBBZGRpbmcsIHJlbW92aW5nLCBhbmQgY2xlYXJpbmdcbiAqIGl0ZW1zIGZyb20gdGhlIGdyb3VwIGlzIGRvbmUgdGhyb3VnaCB0aGUgaW50ZXJmYWNlIHRoZSBjbGFzcyBwcm92aWRlcy5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvRWxlbWVudHMvR3JvdXBzXG4gKlxuICogQGFic3RyYWN0XG4gKiBAbWl4aW5zIE9PLkVtaXR0ZXJMaXN0XG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2pRdWVyeX0gWyRncm91cF0gVGhlIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNsYXNzLiBJZiB0aGlzIGNvbmZpZ3VyYXRpb25cbiAqICBpcyBvbWl0dGVkLCB0aGUgZ3JvdXAgZWxlbWVudCB3aWxsIHVzZSBhIGdlbmVyYXRlZCBgPGRpdj5gLlxuICovXG5PTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpTWl4aW5Hcm91cEVsZW1lbnQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLkVtaXR0ZXJMaXN0LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kZ3JvdXAgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuc2V0R3JvdXBFbGVtZW50KCBjb25maWcuJGdyb3VwIHx8ICQoICc8ZGl2PicgKSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08ubWl4aW5DbGFzcyggT08udWkubWl4aW4uR3JvdXBFbGVtZW50LCBPTy5FbWl0dGVyTGlzdCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBAZXZlbnQgY2hhbmdlXG4gKlxuICogQSBjaGFuZ2UgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBzZXQgb2Ygc2VsZWN0ZWQgaXRlbXMgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkVsZW1lbnRbXX0gaXRlbXMgSXRlbXMgY3VycmVudGx5IGluIHRoZSBncm91cFxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgdGhlIGdyb3VwIGVsZW1lbnQuXG4gKlxuICogSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgaXRlbXMgd2lsbCBiZSBtb3ZlZCB0byB0aGUgbmV3IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICRncm91cCBFbGVtZW50IHRvIHVzZSBhcyBncm91cFxuICovXG5PTy51aS5taXhpbi5Hcm91cEVsZW1lbnQucHJvdG90eXBlLnNldEdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uICggJGdyb3VwICkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdHRoaXMuJGdyb3VwID0gJGdyb3VwO1xuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR0aGlzLiRncm91cC5hcHBlbmQoIHRoaXMuaXRlbXNbIGkgXS4kZWxlbWVudCApO1xuXHR9XG59O1xuXG4vKipcbiAqIEZpbmQgYW4gaXRlbSBieSBpdHMgZGF0YS5cbiAqXG4gKiBPbmx5IHRoZSBmaXJzdCBpdGVtIHdpdGggbWF0Y2hpbmcgZGF0YSB3aWxsIGJlIHJldHVybmVkLiBUbyByZXR1cm4gYWxsIG1hdGNoaW5nIGl0ZW1zLFxuICogdXNlIHRoZSAjZmluZEl0ZW1zRnJvbURhdGEgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEl0ZW0gZGF0YSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fG51bGx9IEl0ZW0gd2l0aCBlcXVpdmFsZW50IGRhdGEsIGBudWxsYCBpZiBub25lIGV4aXN0c1xuICovXG5PTy51aS5taXhpbi5Hcm91cEVsZW1lbnQucHJvdG90eXBlLmZpbmRJdGVtRnJvbURhdGEgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdHZhciBpLCBsZW4sIGl0ZW0sXG5cdFx0aGFzaCA9IE9PLmdldEhhc2goIGRhdGEgKTtcblxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdGlmICggaGFzaCA9PT0gT08uZ2V0SGFzaCggaXRlbS5nZXREYXRhKCkgKSApIHtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGaW5kIGl0ZW1zIGJ5IHRoZWlyIGRhdGEuXG4gKlxuICogQWxsIGl0ZW1zIHdpdGggbWF0Y2hpbmcgZGF0YSB3aWxsIGJlIHJldHVybmVkLiBUbyByZXR1cm4gb25seSB0aGUgZmlyc3QgbWF0Y2gsIHVzZSB0aGUgI2ZpbmRJdGVtRnJvbURhdGEgbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSXRlbSBkYXRhIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnRbXX0gSXRlbXMgd2l0aCBlcXVpdmFsZW50IGRhdGFcbiAqL1xuT08udWkubWl4aW4uR3JvdXBFbGVtZW50LnByb3RvdHlwZS5maW5kSXRlbXNGcm9tRGF0YSA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGksIGxlbiwgaXRlbSxcblx0XHRoYXNoID0gT08uZ2V0SGFzaCggZGF0YSApLFxuXHRcdGl0ZW1zID0gW107XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRpZiAoIGhhc2ggPT09IE9PLmdldEhhc2goIGl0ZW0uZ2V0RGF0YSgpICkgKSB7XG5cdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiBBZGQgaXRlbXMgdG8gdGhlIGdyb3VwLlxuICpcbiAqIEl0ZW1zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgZ3JvdXAgYXJyYXkgdW5sZXNzIHRoZSBvcHRpb25hbCBgaW5kZXhgIHBhcmFtZXRlciBzcGVjaWZpZXNcbiAqIGEgZGlmZmVyZW50IGluc2VydGlvbiBwb2ludC4gQWRkaW5nIGFuIGV4aXN0aW5nIGl0ZW0gd2lsbCBtb3ZlIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IG9yIHRoZSBwb2ludCBzcGVjaWZpZWQgYnkgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtPTy51aS5FbGVtZW50W119IGl0ZW1zIEFuIGFycmF5IG9mIGl0ZW1zIHRvIGFkZCB0byB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIEluZGV4IG9mIHRoZSBpbnNlcnRpb24gcG9pbnRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uR3JvdXBFbGVtZW50LnByb3RvdHlwZS5hZGRJdGVtcyA9IGZ1bmN0aW9uICggaXRlbXMsIGluZGV4ICkge1xuXG5cdGlmICggaXRlbXMubGVuZ3RoID09PSAwICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gTWl4aW4gbWV0aG9kXG5cdE9PLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5hZGRJdGVtcy5jYWxsKCB0aGlzLCBpdGVtcywgaW5kZXggKTtcblxuXHR0aGlzLmVtaXQoICdjaGFuZ2UnLCB0aGlzLmdldEl0ZW1zKCkgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5wcm90b3R5cGUubW92ZUl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW1zLCBuZXdJbmRleCApIHtcblx0Ly8gaW5zZXJ0SXRlbUVsZW1lbnRzIGV4cGVjdHMgdGhpcy5pdGVtcyB0byBub3QgaGF2ZSBiZWVuIG1vZGlmaWVkIHlldCwgc28gY2FsbCBiZWZvcmUgdGhlIG1peGluXG5cdHRoaXMuaW5zZXJ0SXRlbUVsZW1lbnRzKCBpdGVtcywgbmV3SW5kZXggKTtcblxuXHQvLyBNaXhpbiBtZXRob2Rcblx0bmV3SW5kZXggPSBPTy5FbWl0dGVyTGlzdC5wcm90b3R5cGUubW92ZUl0ZW0uY2FsbCggdGhpcywgaXRlbXMsIG5ld0luZGV4ICk7XG5cblx0cmV0dXJuIG5ld0luZGV4O1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5taXhpbi5Hcm91cEVsZW1lbnQucHJvdG90eXBlLmluc2VydEl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0sIGluZGV4ICkge1xuXHRpdGVtLnNldEVsZW1lbnRHcm91cCggdGhpcyApO1xuXHR0aGlzLmluc2VydEl0ZW1FbGVtZW50cyggaXRlbSwgaW5kZXggKTtcblxuXHQvLyBNaXhpbiBtZXRob2Rcblx0aW5kZXggPSBPTy5FbWl0dGVyTGlzdC5wcm90b3R5cGUuaW5zZXJ0SXRlbS5jYWxsKCB0aGlzLCBpdGVtLCBpbmRleCApO1xuXG5cdHJldHVybiBpbmRleDtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGVsZW1lbnRzIGludG8gdGhlIGdyb3VwXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T08udWkuRWxlbWVudH0gaXRlbVdpZGdldCBJdGVtIHRvIGluc2VydFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluc2VydGlvbiBpbmRleFxuICovXG5PTy51aS5taXhpbi5Hcm91cEVsZW1lbnQucHJvdG90eXBlLmluc2VydEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uICggaXRlbVdpZGdldCwgaW5kZXggKSB7XG5cdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5pdGVtcy5sZW5ndGggKSB7XG5cdFx0dGhpcy4kZ3JvdXAuYXBwZW5kKCBpdGVtV2lkZ2V0LiRlbGVtZW50ICk7XG5cdH0gZWxzZSBpZiAoIGluZGV4ID09PSAwICkge1xuXHRcdHRoaXMuJGdyb3VwLnByZXBlbmQoIGl0ZW1XaWRnZXQuJGVsZW1lbnQgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLml0ZW1zWyBpbmRleCBdLiRlbGVtZW50LmJlZm9yZSggaXRlbVdpZGdldC4kZWxlbWVudCApO1xuXHR9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIGl0ZW1zIGZyb20gYSBncm91cC5cbiAqXG4gKiBSZW1vdmVkIGl0ZW1zIGFyZSBkZXRhY2hlZCAobm90IHJlbW92ZWQpIGZyb20gdGhlIERPTSBzbyB0aGF0IHRoZXkgbWF5IGJlIHJldXNlZC5cbiAqIFRvIHJlbW92ZSBhbGwgaXRlbXMgZnJvbSBhIGdyb3VwLCB5b3UgbWF5IHdpc2ggdG8gdXNlIHRoZSAjY2xlYXJJdGVtcyBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkVsZW1lbnRbXX0gaXRlbXMgQW4gYXJyYXkgb2YgaXRlbXMgdG8gcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlSXRlbXMgPSBmdW5jdGlvbiAoIGl0ZW1zICkge1xuXHR2YXIgaSwgbGVuLCBpdGVtLCBpbmRleDtcblxuXHRpZiAoIGl0ZW1zLmxlbmd0aCA9PT0gMCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIFJlbW92ZSBzcGVjaWZpYyBpdGVtcyBlbGVtZW50c1xuXHRmb3IgKCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0aW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGl0ZW0uc2V0RWxlbWVudEdyb3VwKCBudWxsICk7XG5cdFx0XHRpdGVtLiRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIE1peGluIG1ldGhvZFxuXHRPTy5FbWl0dGVyTGlzdC5wcm90b3R5cGUucmVtb3ZlSXRlbXMuY2FsbCggdGhpcywgaXRlbXMgKTtcblxuXHR0aGlzLmVtaXQoICdjaGFuZ2UnLCB0aGlzLmdldEl0ZW1zKCkgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFyIGFsbCBpdGVtcyBmcm9tIHRoZSBncm91cC5cbiAqXG4gKiBDbGVhcmVkIGl0ZW1zIGFyZSBkZXRhY2hlZCBmcm9tIHRoZSBET00sIG5vdCByZW1vdmVkLCBzbyB0aGF0IHRoZXkgbWF5IGJlIHJldXNlZC5cbiAqIFRvIHJlbW92ZSBvbmx5IGEgc3Vic2V0IG9mIGl0ZW1zIGZyb20gYSBncm91cCwgdXNlIHRoZSAjcmVtb3ZlSXRlbXMgbWV0aG9kLlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uR3JvdXBFbGVtZW50LnByb3RvdHlwZS5jbGVhckl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdC8vIFJlbW92ZSBhbGwgaXRlbSBlbGVtZW50c1xuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR0aGlzLml0ZW1zWyBpIF0uc2V0RWxlbWVudEdyb3VwKCBudWxsICk7XG5cdFx0dGhpcy5pdGVtc1sgaSBdLiRlbGVtZW50LmRldGFjaCgpO1xuXHR9XG5cblx0Ly8gTWl4aW4gbWV0aG9kXG5cdE9PLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5jbGVhckl0ZW1zLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmVtaXQoICdjaGFuZ2UnLCB0aGlzLmdldEl0ZW1zKCkgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExhYmVsRWxlbWVudCBpcyBvZnRlbiBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXMgdG8gZ2VuZXJhdGUgYSBsYWJlbCwgd2hpY2hcbiAqIGhlbHBzIGlkZW50aWZ5IHRoZSBmdW5jdGlvbiBvZiBhbiBpbnRlcmZhY2UgZWxlbWVudC5cbiAqIFNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSWNvbnMsX0luZGljYXRvcnMsX2FuZF9MYWJlbHMjTGFiZWxzXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2pRdWVyeX0gWyRsYWJlbF0gVGhlIGxhYmVsIGVsZW1lbnQgY3JlYXRlZCBieSB0aGUgY2xhc3MuIElmIHRoaXNcbiAqICBjb25maWd1cmF0aW9uIGlzIG9taXR0ZWQsIHRoZSBsYWJlbCBlbGVtZW50IHdpbGwgdXNlIGEgZ2VuZXJhdGVkIGA8c3Bhbj5gLlxuICogQGNmZyB7alF1ZXJ5fHN0cmluZ3xGdW5jdGlvbnxPTy51aS5IdG1sU25pcHBldH0gW2xhYmVsXSBUaGUgbGFiZWwgdGV4dC4gVGhlIGxhYmVsIGNhbiBiZSBzcGVjaWZpZWRcbiAqICBhcyBhIHBsYWludGV4dCBzdHJpbmcsIGEgalF1ZXJ5IHNlbGVjdGlvbiBvZiBlbGVtZW50cywgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvZHVjZSBhIHN0cmluZ1xuICogIGluIHRoZSBmdXR1cmUuIFNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsyXSBmb3IgZXhhbXBsZXMuXG4gKiAgWzJdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0ljb25zLF9JbmRpY2F0b3JzLF9hbmRfTGFiZWxzI0xhYmVsc1xuICogQGNmZyB7Ym9vbGVhbn0gW2ludmlzaWJsZUxhYmVsXSBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgdmlzdWFsbHkgaGlkZGVuIChidXQgc3RpbGwgYWNjZXNzaWJsZVxuICogIHRvIHNjcmVlbi1yZWFkZXJzKS5cbiAqL1xuT08udWkubWl4aW4uTGFiZWxFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluTGFiZWxFbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kbGFiZWwgPSBudWxsO1xuXHR0aGlzLmxhYmVsID0gbnVsbDtcblx0dGhpcy5pbnZpc2libGVMYWJlbCA9IG51bGw7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy5zZXRMYWJlbCggY29uZmlnLmxhYmVsIHx8IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmxhYmVsICk7XG5cdHRoaXMuc2V0TGFiZWxFbGVtZW50KCBjb25maWcuJGxhYmVsIHx8ICQoICc8c3Bhbj4nICkgKTtcblx0dGhpcy5zZXRJbnZpc2libGVMYWJlbCggY29uZmlnLmludmlzaWJsZUxhYmVsICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbml0Q2xhc3MoIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBAZXZlbnQgbGFiZWxDaGFuZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogVGhlIGxhYmVsIHRleHQuIFRoZSBsYWJlbCBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgcGxhaW50ZXh0IHN0cmluZywgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAqIHByb2R1Y2UgYSBzdHJpbmcgaW4gdGhlIGZ1dHVyZSwgb3IgYG51bGxgIGZvciBubyBsYWJlbC4gVGhlIHN0YXRpYyB2YWx1ZSB3aWxsXG4gKiBiZSBvdmVycmlkZGVuIGlmIGEgbGFiZWwgaXMgc3BlY2lmaWVkIHdpdGggdGhlICNsYWJlbCBjb25maWcgb3B0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd8RnVuY3Rpb258bnVsbH1cbiAqL1xuT08udWkubWl4aW4uTGFiZWxFbGVtZW50LnN0YXRpYy5sYWJlbCA9IG51bGw7XG5cbi8qIFN0YXRpYyBtZXRob2RzICovXG5cbi8qKlxuICogSGlnaGxpZ2h0IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBxdWVyeSBpbiB0aGUgZ2l2ZW4gdGV4dFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBRdWVyeSB0byBmaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgc3RyaW5nIGNvbXBhcmF0b3IsIGUuZy4gSW50bC5Db2xsYXRvcigpLmNvbXBhcmVcbiAqIEByZXR1cm4ge2pRdWVyeX0gVGV4dCB3aXRoIHRoZSBmaXJzdCBtYXRjaCBvZiB0aGUgcXVlcnlcbiAqICBzdWItc3RyaW5nIHdyYXBwZWQgaW4gaGlnaGxpZ2h0ZWQgc3BhblxuICovXG5PTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuc3RhdGljLmhpZ2hsaWdodFF1ZXJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBxdWVyeSwgY29tcGFyZSApIHtcblx0dmFyIGksIHRMZW4sIHFMZW4sXG5cdFx0b2Zmc2V0ID0gLTEsXG5cdFx0JHJlc3VsdCA9ICQoICc8c3Bhbj4nICk7XG5cblx0aWYgKCBjb21wYXJlICkge1xuXHRcdHRMZW4gPSB0ZXh0Lmxlbmd0aDtcblx0XHRxTGVuID0gcXVlcnkubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBvZmZzZXQgPT09IC0xICYmIGkgPD0gdExlbiAtIHFMZW47IGkrKyApIHtcblx0XHRcdGlmICggY29tcGFyZSggcXVlcnksIHRleHQuc2xpY2UoIGksIGkgKyBxTGVuICkgKSA9PT0gMCApIHtcblx0XHRcdFx0b2Zmc2V0ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0b2Zmc2V0ID0gdGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoIHF1ZXJ5LnRvTG93ZXJDYXNlKCkgKTtcblx0fVxuXG5cdGlmICggIXF1ZXJ5Lmxlbmd0aCB8fCBvZmZzZXQgPT09IC0xICkge1xuXHRcdCRyZXN1bHQudGV4dCggdGV4dCApO1xuXHR9IGVsc2Uge1xuXHRcdCRyZXN1bHQuYXBwZW5kKFxuXHRcdFx0ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRleHQuc2xpY2UoIDAsIG9mZnNldCApICksXG5cdFx0XHQkKCAnPHNwYW4+JyApXG5cdFx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLWxhYmVsRWxlbWVudC1sYWJlbC1oaWdobGlnaHQnIClcblx0XHRcdFx0LnRleHQoIHRleHQuc2xpY2UoIG9mZnNldCwgb2Zmc2V0ICsgcXVlcnkubGVuZ3RoICkgKSxcblx0XHRcdGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0ZXh0LnNsaWNlKCBvZmZzZXQgKyBxdWVyeS5sZW5ndGggKSApXG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gJHJlc3VsdC5jb250ZW50cygpO1xufTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFNldCB0aGUgbGFiZWwgZWxlbWVudC5cbiAqXG4gKiBJZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgc2V0LCBpdCB3aWxsIGJlIGNsZWFuZWQgdXAgYmVmb3JlIHNldHRpbmcgdXAgdGhlIG5ldyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkbGFiZWwgRWxlbWVudCB0byB1c2UgYXMgbGFiZWxcbiAqL1xuT08udWkubWl4aW4uTGFiZWxFbGVtZW50LnByb3RvdHlwZS5zZXRMYWJlbEVsZW1lbnQgPSBmdW5jdGlvbiAoICRsYWJlbCApIHtcblx0aWYgKCB0aGlzLiRsYWJlbCApIHtcblx0XHR0aGlzLiRsYWJlbC5yZW1vdmVDbGFzcyggJ29vLXVpLWxhYmVsRWxlbWVudC1sYWJlbCcgKS5lbXB0eSgpO1xuXHR9XG5cblx0dGhpcy4kbGFiZWwgPSAkbGFiZWwuYWRkQ2xhc3MoICdvby11aS1sYWJlbEVsZW1lbnQtbGFiZWwnICk7XG5cdHRoaXMuc2V0TGFiZWxDb250ZW50KCB0aGlzLmxhYmVsICk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGFiZWwuXG4gKlxuICogQW4gZW1wdHkgc3RyaW5nIHdpbGwgcmVzdWx0IGluIHRoZSBsYWJlbCBiZWluZyBoaWRkZW4uIEEgc3RyaW5nIGNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIHdpbGxcbiAqIGJlIGNvbnZlcnRlZCB0byBhIHNpbmdsZSBgJm5ic3A7YC5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeXxzdHJpbmd8T08udWkuSHRtbFNuaXBwZXR8RnVuY3Rpb258bnVsbH0gbGFiZWwgTGFiZWwgbm9kZXM7IHRleHQ7IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGVzIG9yXG4gKiAgdGV4dDsgb3IgbnVsbCBmb3Igbm8gbGFiZWxcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uTGFiZWxFbGVtZW50LnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwgKSB7XG5cdGxhYmVsID0gdHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nID8gT08udWkucmVzb2x2ZU1zZyggbGFiZWwgKSA6IGxhYmVsO1xuXHRsYWJlbCA9ICggKCB0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnIHx8IGxhYmVsIGluc3RhbmNlb2YgJCApICYmIGxhYmVsLmxlbmd0aCApIHx8ICggbGFiZWwgaW5zdGFuY2VvZiBPTy51aS5IdG1sU25pcHBldCAmJiBsYWJlbC50b1N0cmluZygpLmxlbmd0aCApID8gbGFiZWwgOiBudWxsO1xuXG5cdGlmICggdGhpcy5sYWJlbCAhPT0gbGFiZWwgKSB7XG5cdFx0aWYgKCB0aGlzLiRsYWJlbCApIHtcblx0XHRcdHRoaXMuc2V0TGFiZWxDb250ZW50KCBsYWJlbCApO1xuXHRcdH1cblx0XHR0aGlzLmxhYmVsID0gbGFiZWw7XG5cdFx0dGhpcy5lbWl0KCAnbGFiZWxDaGFuZ2UnICk7XG5cdH1cblxuXHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCAnb28tdWktbGFiZWxFbGVtZW50JywgISF0aGlzLmxhYmVsICYmICF0aGlzLmludmlzaWJsZUxhYmVsICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB3aGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgdmlzdWFsbHkgaGlkZGVuIChidXQgc3RpbGwgYWNjZXNzaWJsZSB0byBzY3JlZW4tcmVhZGVycykuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBpbnZpc2libGVMYWJlbFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5MYWJlbEVsZW1lbnQucHJvdG90eXBlLnNldEludmlzaWJsZUxhYmVsID0gZnVuY3Rpb24gKCBpbnZpc2libGVMYWJlbCApIHtcblx0aW52aXNpYmxlTGFiZWwgPSAhIWludmlzaWJsZUxhYmVsO1xuXG5cdGlmICggdGhpcy5pbnZpc2libGVMYWJlbCAhPT0gaW52aXNpYmxlTGFiZWwgKSB7XG5cdFx0dGhpcy5pbnZpc2libGVMYWJlbCA9IGludmlzaWJsZUxhYmVsO1xuXHRcdHRoaXMuZW1pdCggJ2xhYmVsQ2hhbmdlJyApO1xuXHR9XG5cblx0dGhpcy4kbGFiZWwudG9nZ2xlQ2xhc3MoICdvby11aS1sYWJlbEVsZW1lbnQtaW52aXNpYmxlJywgdGhpcy5pbnZpc2libGVMYWJlbCApO1xuXHQvLyBQcmV0ZW5kIHRoYXQgdGhlcmUgaXMgbm8gbGFiZWwsIGEgbG90IG9mIENTUyBoYXMgYmVlbiB3cml0dGVuIHdpdGggdGhpcyBhc3N1bXB0aW9uXG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1sYWJlbEVsZW1lbnQnLCAhIXRoaXMubGFiZWwgJiYgIXRoaXMuaW52aXNpYmxlTGFiZWwgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsYWJlbCBhcyBwbGFpbiB0ZXh0IHdpdGggYSBoaWdobGlnaHRlZCBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgbGFiZWwgdG8gc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgU3Vic3RyaW5nIG9mIHRleHQgdG8gaGlnaGxpZ2h0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgc3RyaW5nIGNvbXBhcmF0b3IsIGUuZy4gSW50bC5Db2xsYXRvcigpLmNvbXBhcmVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uTGFiZWxFbGVtZW50LnByb3RvdHlwZS5zZXRIaWdobGlnaHRlZFF1ZXJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBxdWVyeSwgY29tcGFyZSApIHtcblx0cmV0dXJuIHRoaXMuc2V0TGFiZWwoIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmhpZ2hsaWdodFF1ZXJ5KCB0ZXh0LCBxdWVyeSwgY29tcGFyZSApICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFiZWwuXG4gKlxuICogQHJldHVybiB7alF1ZXJ5fHN0cmluZ3xGdW5jdGlvbnxudWxsfSBMYWJlbCBub2RlczsgdGV4dDsgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm9kZXMgb3JcbiAqICB0ZXh0OyBvciBudWxsIGZvciBubyBsYWJlbFxuICovXG5PTy51aS5taXhpbi5MYWJlbEVsZW1lbnQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5sYWJlbDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZW50IG9mIHRoZSBsYWJlbC5cbiAqXG4gKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCB1bnRpbCBhZnRlciB0aGUgbGFiZWwgZWxlbWVudCBoYXMgYmVlbiBzZXQgYnkgI3NldExhYmVsRWxlbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9IGxhYmVsIExhYmVsIG5vZGVzOyB0ZXh0OyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlcyBvclxuICogIHRleHQ7IG9yIG51bGwgZm9yIG5vIGxhYmVsXG4gKi9cbk9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5wcm90b3R5cGUuc2V0TGFiZWxDb250ZW50ID0gZnVuY3Rpb24gKCBsYWJlbCApIHtcblx0aWYgKCB0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnICkge1xuXHRcdGlmICggbGFiZWwubWF0Y2goIC9eXFxzKiQvICkgKSB7XG5cdFx0XHQvLyBDb252ZXJ0IHdoaXRlc3BhY2Ugb25seSBzdHJpbmcgdG8gYSBzaW5nbGUgbm9uLWJyZWFraW5nIHNwYWNlXG5cdFx0XHR0aGlzLiRsYWJlbC5odG1sKCAnJm5ic3A7JyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRsYWJlbC50ZXh0KCBsYWJlbCApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbGFiZWwgaW5zdGFuY2VvZiBPTy51aS5IdG1sU25pcHBldCApIHtcblx0XHR0aGlzLiRsYWJlbC5odG1sKCBsYWJlbC50b1N0cmluZygpICk7XG5cdH0gZWxzZSBpZiAoIGxhYmVsIGluc3RhbmNlb2YgJCApIHtcblx0XHR0aGlzLiRsYWJlbC5lbXB0eSgpLmFwcGVuZCggbGFiZWwgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRsYWJlbC5lbXB0eSgpO1xuXHR9XG59O1xuXG4vKipcbiAqIEljb25FbGVtZW50IGlzIG9mdGVuIG1peGVkIGludG8gb3RoZXIgY2xhc3NlcyB0byBnZW5lcmF0ZSBhbiBpY29uLlxuICogSWNvbnMgYXJlIGdyYXBoaWNzLCBhYm91dCB0aGUgc2l6ZSBvZiBub3JtYWwgdGV4dC4gVGhleSBhcmUgdXNlZCB0byBhaWQgdGhlIHVzZXJcbiAqIGluIGxvY2F0aW5nIGEgY29udHJvbCBvciB0byBjb252ZXkgaW5mb3JtYXRpb24gaW4gYSBzcGFjZS1lZmZpY2llbnQgd2F5LiBTZWUgdGhlXG4gKiBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBhIGxpc3Qgb2YgaWNvbnNcbiAqIGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9JY29ucyxfSW5kaWNhdG9ycyxfYW5kX0xhYmVscyNJY29uc1xuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtqUXVlcnl9IFskaWNvbl0gVGhlIGljb24gZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBjbGFzcy4gSWYgdGhpcyBjb25maWd1cmF0aW9uIGlzIG9taXR0ZWQsXG4gKiAgdGhlIGljb24gZWxlbWVudCB3aWxsIHVzZSBhIGdlbmVyYXRlZCBgPHNwYW4+YC4gVG8gdXNlIGEgZGlmZmVyZW50IEhUTUwgdGFnLCBvciB0byBzcGVjaWZ5IHRoYXRcbiAqICB0aGUgaWNvbiBlbGVtZW50IGJlIHNldCB0byBhbiBleGlzdGluZyBpY29uIGluc3RlYWQgb2YgdGhlIG9uZSBnZW5lcmF0ZWQgYnkgdGhpcyBjbGFzcywgc2V0IGFcbiAqICB2YWx1ZSB1c2luZyBhIGpRdWVyeSBzZWxlY3Rpb24uIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAgLy8gVXNlIGEgPGRpdj4gdGFnIGluc3RlYWQgb2YgYSA8c3Bhbj5cbiAqICAgICAkaWNvbjogJCggJzxkaXY+JyApXG4gKiAgICAgLy8gVXNlIGFuIGV4aXN0aW5nIGljb24gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBvbmUgZ2VuZXJhdGVkIGJ5IHRoZSBjbGFzc1xuICogICAgICRpY29uOiB0aGlzLiRlbGVtZW50XG4gKiAgICAgLy8gVXNlIGFuIGljb24gZWxlbWVudCBmcm9tIGEgY2hpbGQgd2lkZ2V0XG4gKiAgICAgJGljb246IHRoaXMuY2hpbGR3aWRnZXQuJGVsZW1lbnRcbiAqIEBjZmcge09iamVjdHxzdHJpbmd9IFtpY29uPScnXSBUaGUgc3ltYm9saWMgbmFtZSBvZiB0aGUgaWNvbiAoZS5nLiwg4oCYcmVtb3Zl4oCZIG9yIOKAmG1lbnXigJkpLCBvciBhIG1hcCBvZlxuICogIHN5bWJvbGljIG5hbWVzLiAgQSBtYXAgaXMgdXNlZCBmb3IgaTE4biBwdXJwb3NlcyBhbmQgY29udGFpbnMgYSBgZGVmYXVsdGAgaWNvblxuICogIG5hbWUgYW5kIGFkZGl0aW9uYWwgbmFtZXMga2V5ZWQgYnkgbGFuZ3VhZ2UgY29kZS4gVGhlIGBkZWZhdWx0YCBuYW1lIGlzIHVzZWQgd2hlbiBubyBpY29uIGlzIGtleWVkXG4gKiAgYnkgdGhlIHVzZXIncyBsYW5ndWFnZS5cbiAqXG4gKiAgRXhhbXBsZSBvZiBhbiBpMThuIG1hcDpcbiAqXG4gKiAgICAgeyBkZWZhdWx0OiAnYm9sZC1hJywgZW46ICdib2xkLWInLCBkZTogJ2JvbGQtZicgfVxuICogIFNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsyXSBmb3IgYSBsaXN0IG9mIGljb25zIGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICogWzJdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0ljb25zLF9JbmRpY2F0b3JzLF9hbmRfTGFiZWxzI0ljb25zXG4gKiBAY2ZnIHtzdHJpbmd8RnVuY3Rpb259IFtpY29uVGl0bGVdIEEgdGV4dCBzdHJpbmcgdXNlZCBhcyB0aGUgaWNvbiB0aXRsZSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGl0bGVcbiAqICB0ZXh0LiBUaGUgaWNvbiB0aXRsZSBpcyBkaXNwbGF5ZWQgd2hlbiB1c2VycyBtb3ZlIHRoZSBtb3VzZSBvdmVyIHRoZSBpY29uLlxuICovXG5PTy51aS5taXhpbi5JY29uRWxlbWVudCA9IGZ1bmN0aW9uIE9vVWlNaXhpbkljb25FbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kaWNvbiA9IG51bGw7XG5cdHRoaXMuaWNvbiA9IG51bGw7XG5cdHRoaXMuaWNvblRpdGxlID0gbnVsbDtcblxuXHQvLyBgaWNvblRpdGxlYHMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgMC4zMC4wXG5cdGlmICggY29uZmlnLmljb25UaXRsZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ0ljb25FbGVtZW50OiBXaWRnZXRzIHdpdGggaWNvblRpdGxlIHNldCBhcmUgZGVwcmVjYXRlZCwgdXNlIHRpdGxlIGluc3RlYWQuIFNlZSBUNzY2MzggZm9yIGRldGFpbHMuJyApO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy5zZXRJY29uKCBjb25maWcuaWNvbiB8fCB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5pY29uICk7XG5cdHRoaXMuc2V0SWNvblRpdGxlKCBjb25maWcuaWNvblRpdGxlIHx8IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmljb25UaXRsZSApO1xuXHR0aGlzLnNldEljb25FbGVtZW50KCBjb25maWcuJGljb24gfHwgJCggJzxzcGFuPicgKSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5pdENsYXNzKCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIFRoZSBzeW1ib2xpYyBuYW1lIG9mIHRoZSBpY29uIChlLmcuLCDigJhyZW1vdmXigJkgb3Ig4oCYbWVudeKAmSksIG9yIGEgbWFwIG9mIHN5bWJvbGljIG5hbWVzLiBBIG1hcCBpcyB1c2VkXG4gKiBmb3IgaTE4biBwdXJwb3NlcyBhbmQgY29udGFpbnMgYSBgZGVmYXVsdGAgaWNvbiBuYW1lIGFuZCBhZGRpdGlvbmFsIG5hbWVzIGtleWVkIGJ5XG4gKiBsYW5ndWFnZSBjb2RlLiBUaGUgYGRlZmF1bHRgIG5hbWUgaXMgdXNlZCB3aGVuIG5vIGljb24gaXMga2V5ZWQgYnkgdGhlIHVzZXIncyBsYW5ndWFnZS5cbiAqXG4gKiBFeGFtcGxlIG9mIGFuIGkxOG4gbWFwOlxuICpcbiAqICAgICB7IGRlZmF1bHQ6ICdib2xkLWEnLCBlbjogJ2JvbGQtYicsIGRlOiAnYm9sZC1mJyB9XG4gKlxuICogTm90ZTogdGhlIHN0YXRpYyBwcm9wZXJ0eSB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGhlICNpY29uIGNvbmZpZ3VyYXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHN0cmluZ31cbiAqL1xuT08udWkubWl4aW4uSWNvbkVsZW1lbnQuc3RhdGljLmljb24gPSBudWxsO1xuXG4vKipcbiAqIFRoZSBpY29uIHRpdGxlLCBkaXNwbGF5ZWQgd2hlbiB1c2VycyBtb3ZlIHRoZSBtb3VzZSBvdmVyIHRoZSBpY29uLiBUaGUgdmFsdWUgY2FuIGJlIHRleHQsIGFcbiAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aXRsZSB0ZXh0LCBvciBgbnVsbGAgZm9yIG5vIHRpdGxlLlxuICpcbiAqIFRoZSBzdGF0aWMgcHJvcGVydHkgd2lsbCBiZSBvdmVycmlkZGVuIGlmIHRoZSAjaWNvblRpdGxlIGNvbmZpZ3VyYXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gKi9cbk9PLnVpLm1peGluLkljb25FbGVtZW50LnN0YXRpYy5pY29uVGl0bGUgPSBudWxsO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU2V0IHRoZSBpY29uIGVsZW1lbnQuIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gcmV0YXJnZXQgYW4gaWNvbiBtaXhpbiBzbyB0aGF0IGl0cyBmdW5jdGlvbmFsaXR5XG4gKiBhcHBsaWVzIHRvIHRoZSBzcGVjaWZpZWQgaWNvbiBlbGVtZW50IGluc3RlYWQgb2YgdGhlIG9uZSBjcmVhdGVkIGJ5IHRoZSBjbGFzcy4gSWYgYW4gaWNvblxuICogZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgdGhlIG1peGlu4oCZcyBlZmZlY3Qgb24gdGhhdCBlbGVtZW50IGlzIHJlbW92ZWQuIEdlbmVyYXRlZCBDU1MgY2xhc3Nlc1xuICogYW5kIG1peGluIG1ldGhvZHMgd2lsbCBubyBsb25nZXIgYWZmZWN0IHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkaWNvbiBFbGVtZW50IHRvIHVzZSBhcyBpY29uXG4gKi9cbk9PLnVpLm1peGluLkljb25FbGVtZW50LnByb3RvdHlwZS5zZXRJY29uRWxlbWVudCA9IGZ1bmN0aW9uICggJGljb24gKSB7XG5cdGlmICggdGhpcy4kaWNvbiApIHtcblx0XHR0aGlzLiRpY29uXG5cdFx0XHQucmVtb3ZlQ2xhc3MoICdvby11aS1pY29uRWxlbWVudC1pY29uIG9vLXVpLWljb24tJyArIHRoaXMuaWNvbiApXG5cdFx0XHQucmVtb3ZlQXR0ciggJ3RpdGxlJyApO1xuXHR9XG5cblx0dGhpcy4kaWNvbiA9ICRpY29uXG5cdFx0LmFkZENsYXNzKCAnb28tdWktaWNvbkVsZW1lbnQtaWNvbicgKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLWljb25FbGVtZW50LW5vSWNvbicsICF0aGlzLmljb24gKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLWljb24tJyArIHRoaXMuaWNvbiwgISF0aGlzLmljb24gKTtcblx0aWYgKCB0aGlzLmljb25UaXRsZSAhPT0gbnVsbCApIHtcblx0XHR0aGlzLiRpY29uLmF0dHIoICd0aXRsZScsIHRoaXMuaWNvblRpdGxlICk7XG5cdH1cblxuXHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xufTtcblxuLyoqXG4gKiBTZXQgaWNvbiBieSBzeW1ib2xpYyBuYW1lIChlLmcuLCDigJhyZW1vdmXigJkgb3Ig4oCYbWVudeKAmSkuIFVzZSBgbnVsbGAgdG8gcmVtb3ZlIGFuIGljb24uXG4gKiBUaGUgaWNvbiBwYXJhbWV0ZXIgY2FuIGFsc28gYmUgc2V0IHRvIGEgbWFwIG9mIGljb24gbmFtZXMuIFNlZSB0aGUgI2ljb24gY29uZmlnIHNldHRpbmdcbiAqIGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ3xudWxsfSBpY29uIEEgc3ltYm9saWMgaWNvbiBuYW1lLCBhIHtAbGluayAjaWNvbiBtYXAgb2YgaWNvbiBuYW1lc30ga2V5ZWRcbiAqICBieSBsYW5ndWFnZSBjb2RlLCBvciBgbnVsbGAgdG8gcmVtb3ZlIHRoZSBpY29uLlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5JY29uRWxlbWVudC5wcm90b3R5cGUuc2V0SWNvbiA9IGZ1bmN0aW9uICggaWNvbiApIHtcblx0aWNvbiA9IE9PLmlzUGxhaW5PYmplY3QoIGljb24gKSA/IE9PLnVpLmdldExvY2FsVmFsdWUoIGljb24sIG51bGwsICdkZWZhdWx0JyApIDogaWNvbjtcblx0aWNvbiA9IHR5cGVvZiBpY29uID09PSAnc3RyaW5nJyAmJiBpY29uLnRyaW0oKS5sZW5ndGggPyBpY29uLnRyaW0oKSA6IG51bGw7XG5cblx0aWYgKCB0aGlzLmljb24gIT09IGljb24gKSB7XG5cdFx0aWYgKCB0aGlzLiRpY29uICkge1xuXHRcdFx0aWYgKCB0aGlzLmljb24gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMuJGljb24ucmVtb3ZlQ2xhc3MoICdvby11aS1pY29uLScgKyB0aGlzLmljb24gKTtcblx0XHRcdH1cblx0XHRcdGlmICggaWNvbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dGhpcy4kaWNvbi5hZGRDbGFzcyggJ29vLXVpLWljb24tJyArIGljb24gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5pY29uID0gaWNvbjtcblx0fVxuXG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1pY29uRWxlbWVudCcsICEhdGhpcy5pY29uICk7XG5cdGlmICggdGhpcy4kaWNvbiApIHtcblx0XHR0aGlzLiRpY29uLnRvZ2dsZUNsYXNzKCAnb28tdWktaWNvbkVsZW1lbnQtbm9JY29uJywgIXRoaXMuaWNvbiApO1xuXHR9XG5cdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaWNvbiB0aXRsZS4gVXNlIGBudWxsYCB0byByZW1vdmUgdGhlIHRpdGxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufG51bGx9IGljb25UaXRsZSBBIHRleHQgc3RyaW5nIHVzZWQgYXMgdGhlIGljb24gdGl0bGUsXG4gKiAgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGl0bGUgdGV4dCwgb3IgYG51bGxgIGZvciBubyB0aXRsZS5cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk9PLnVpLm1peGluLkljb25FbGVtZW50LnByb3RvdHlwZS5zZXRJY29uVGl0bGUgPSBmdW5jdGlvbiAoIGljb25UaXRsZSApIHtcblx0aWNvblRpdGxlID1cblx0XHQoIHR5cGVvZiBpY29uVGl0bGUgPT09ICdmdW5jdGlvbicgfHwgKCB0eXBlb2YgaWNvblRpdGxlID09PSAnc3RyaW5nJyAmJiBpY29uVGl0bGUubGVuZ3RoICkgKSA/XG5cdFx0XHRPTy51aS5yZXNvbHZlTXNnKCBpY29uVGl0bGUgKSA6IG51bGw7XG5cblx0aWYgKCB0aGlzLmljb25UaXRsZSAhPT0gaWNvblRpdGxlICkge1xuXHRcdHRoaXMuaWNvblRpdGxlID0gaWNvblRpdGxlO1xuXHRcdGlmICggdGhpcy4kaWNvbiApIHtcblx0XHRcdGlmICggdGhpcy5pY29uVGl0bGUgIT09IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMuJGljb24uYXR0ciggJ3RpdGxlJywgaWNvblRpdGxlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiRpY29uLnJlbW92ZUF0dHIoICd0aXRsZScgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBgc2V0SWNvblRpdGxlIGlzIGRlcHJlY2F0ZWQgc2luY2UgMC4zMC4wXG5cdGlmICggaWNvblRpdGxlICE9PSBudWxsICkge1xuXHRcdC8vIEF2b2lkIGEgd2FybmluZyB3aGVuIHRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIHdpdGggbm8gaWNvblRpdGxlIHNldFxuXHRcdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ0ljb25FbGVtZW50OiBzZXRJY29uVGl0bGUgaXMgZGVwcmVjYXRlZCwgdXNlIHNldFRpdGxlIG9mIFRpdGxlZEVsZW1lbnQgaW5zdGVhZC4gU2VlIFQ3NjYzOCBmb3IgZGV0YWlscy4nICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpYyBuYW1lIG9mIHRoZSBpY29uLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gSWNvbiBuYW1lXG4gKi9cbk9PLnVpLm1peGluLkljb25FbGVtZW50LnByb3RvdHlwZS5nZXRJY29uID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pY29uO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGljb24gdGl0bGUuIFRoZSB0aXRsZSB0ZXh0IGlzIGRpc3BsYXllZCB3aGVuIGEgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgaWNvbi5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEljb24gdGl0bGUgdGV4dFxuICovXG5PTy51aS5taXhpbi5JY29uRWxlbWVudC5wcm90b3R5cGUuZ2V0SWNvblRpdGxlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pY29uVGl0bGU7XG59O1xuXG4vKipcbiAqIEluZGljYXRvckVsZW1lbnQgaXMgb2Z0ZW4gbWl4ZWQgaW50byBvdGhlciBjbGFzc2VzIHRvIGdlbmVyYXRlIGFuIGluZGljYXRvci5cbiAqIEluZGljYXRvcnMgYXJlIHNtYWxsIGdyYXBoaWNzIHRoYXQgYXJlIGdlbmVyYWxseSB1c2VkIGluIHR3byB3YXlzOlxuICpcbiAqIC0gVG8gZHJhdyBhdHRlbnRpb24gdG8gdGhlIHN0YXR1cyBvZiBhbiBpdGVtLiBGb3IgZXhhbXBsZSwgYW4gaW5kaWNhdG9yIG1pZ2h0IGJlXG4gKiAgIHVzZWQgdG8gc2hvdyB0aGF0IGFuIGl0ZW0gaW4gYSBsaXN0IGhhcyBlcnJvcnMgdGhhdCBuZWVkIHRvIGJlIHJlc29sdmVkLlxuICogLSBUbyBjbGFyaWZ5IHRoZSBmdW5jdGlvbiBvZiBhIGNvbnRyb2wgdGhhdCBhY3RzIGluIGFuIGV4Y2VwdGlvbmFsIHdheSAoYSBidXR0b25cbiAqICAgdGhhdCBvcGVucyBhIG1lbnUgaW5zdGVhZCBvZiBwZXJmb3JtaW5nIGFuIGFjdGlvbiBkaXJlY3RseSwgZm9yIGV4YW1wbGUpLlxuICpcbiAqIEZvciBhIGxpc3Qgb2YgaW5kaWNhdG9ycyBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeSwgcGxlYXNlIHNlZSB0aGVcbiAqIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0ljb25zLF9JbmRpY2F0b3JzLF9hbmRfTGFiZWxzI0luZGljYXRvcnNcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJGluZGljYXRvcl0gVGhlIGluZGljYXRvciBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNsYXNzLiBJZiB0aGlzXG4gKiAgY29uZmlndXJhdGlvbiBpcyBvbWl0dGVkLCB0aGUgaW5kaWNhdG9yIGVsZW1lbnQgd2lsbCB1c2UgYSBnZW5lcmF0ZWQgYDxzcGFuPmAuXG4gKiBAY2ZnIHtzdHJpbmd9IFtpbmRpY2F0b3JdIFN5bWJvbGljIG5hbWUgb2YgdGhlIGluZGljYXRvciAoZS5nLiwg4oCYY2xlYXLigJkgb3Ig4oCYZG93buKAmSkuXG4gKiAgU2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMl0gZm9yIGEgbGlzdCBvZiBpbmRpY2F0b3JzIGluY2x1ZGVkXG4gKiAgaW4gdGhlIGxpYnJhcnkuXG4gKiBbMl06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSWNvbnMsX0luZGljYXRvcnMsX2FuZF9MYWJlbHMjSW5kaWNhdG9yc1xuICogQGNmZyB7c3RyaW5nfEZ1bmN0aW9ufSBbaW5kaWNhdG9yVGl0bGVdIEEgdGV4dCBzdHJpbmcgdXNlZCBhcyB0aGUgaW5kaWNhdG9yIHRpdGxlLFxuICogIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRpdGxlIHRleHQuIFRoZSBpbmRpY2F0b3IgdGl0bGUgaXMgZGlzcGxheWVkIHdoZW4gdXNlcnMgbW92ZVxuICogIHRoZSBtb3VzZSBvdmVyIHRoZSBpbmRpY2F0b3IuXG4gKi9cbk9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpTWl4aW5JbmRpY2F0b3JFbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kaW5kaWNhdG9yID0gbnVsbDtcblx0dGhpcy5pbmRpY2F0b3IgPSBudWxsO1xuXHR0aGlzLmluZGljYXRvclRpdGxlID0gbnVsbDtcblxuXHQvLyBgaW5kaWNhdG9yVGl0bGVgcyBhcmUgZGVwcmVjYXRlZCBzaW5jZSAwLjMwLjBcblx0aWYgKCBjb25maWcuaW5kaWNhdG9yVGl0bGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRPTy51aS53YXJuRGVwcmVjYXRpb24oICdJbmRpY2F0b3JFbGVtZW50OiBXaWRnZXRzIHdpdGggaW5kaWNhdG9yVGl0bGUgc2V0IGFyZSBkZXByZWNhdGVkLCB1c2UgdGl0bGUgaW5zdGVhZC4gU2VlIFQ3NjYzOCBmb3IgZGV0YWlscy4nICk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnNldEluZGljYXRvciggY29uZmlnLmluZGljYXRvciB8fCB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5pbmRpY2F0b3IgKTtcblx0dGhpcy5zZXRJbmRpY2F0b3JUaXRsZSggY29uZmlnLmluZGljYXRvclRpdGxlIHx8IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmluZGljYXRvclRpdGxlICk7XG5cdHRoaXMuc2V0SW5kaWNhdG9yRWxlbWVudCggY29uZmlnLiRpbmRpY2F0b3IgfHwgJCggJzxzcGFuPicgKSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5pdENsYXNzKCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogU3ltYm9saWMgbmFtZSBvZiB0aGUgaW5kaWNhdG9yIChlLmcuLCDigJhjbGVhcuKAmSBvciAg4oCYZG93buKAmSkuXG4gKiBUaGUgc3RhdGljIHByb3BlcnR5IHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0aGUgI2luZGljYXRvciBjb25maWd1cmF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfVxuICovXG5PTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LnN0YXRpYy5pbmRpY2F0b3IgPSBudWxsO1xuXG4vKipcbiAqIEEgdGV4dCBzdHJpbmcgdXNlZCBhcyB0aGUgaW5kaWNhdG9yIHRpdGxlLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aXRsZSB0ZXh0LCBvciBgbnVsbGBcbiAqIGZvciBubyB0aXRsZS4gVGhlIHN0YXRpYyBwcm9wZXJ0eSB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGhlICNpbmRpY2F0b3JUaXRsZSBjb25maWd1cmF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICovXG5PTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LnN0YXRpYy5pbmRpY2F0b3JUaXRsZSA9IG51bGw7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgdGhlIGluZGljYXRvciBlbGVtZW50LlxuICpcbiAqIElmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBzZXQsIGl0IHdpbGwgYmUgY2xlYW5lZCB1cCBiZWZvcmUgc2V0dGluZyB1cCB0aGUgbmV3IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICRpbmRpY2F0b3IgRWxlbWVudCB0byB1c2UgYXMgaW5kaWNhdG9yXG4gKi9cbk9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQucHJvdG90eXBlLnNldEluZGljYXRvckVsZW1lbnQgPSBmdW5jdGlvbiAoICRpbmRpY2F0b3IgKSB7XG5cdGlmICggdGhpcy4kaW5kaWNhdG9yICkge1xuXHRcdHRoaXMuJGluZGljYXRvclxuXHRcdFx0LnJlbW92ZUNsYXNzKCAnb28tdWktaW5kaWNhdG9yRWxlbWVudC1pbmRpY2F0b3Igb28tdWktaW5kaWNhdG9yLScgKyB0aGlzLmluZGljYXRvciApXG5cdFx0XHQucmVtb3ZlQXR0ciggJ3RpdGxlJyApO1xuXHR9XG5cblx0dGhpcy4kaW5kaWNhdG9yID0gJGluZGljYXRvclxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWluZGljYXRvckVsZW1lbnQtaW5kaWNhdG9yJyApXG5cdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktaW5kaWNhdG9yRWxlbWVudC1ub0luZGljYXRvcicsICF0aGlzLmluZGljYXRvciApXG5cdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktaW5kaWNhdG9yLScgKyB0aGlzLmluZGljYXRvciwgISF0aGlzLmluZGljYXRvciApO1xuXHRpZiAoIHRoaXMuaW5kaWNhdG9yVGl0bGUgIT09IG51bGwgKSB7XG5cdFx0dGhpcy4kaW5kaWNhdG9yLmF0dHIoICd0aXRsZScsIHRoaXMuaW5kaWNhdG9yVGl0bGUgKTtcblx0fVxuXG5cdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW5kaWNhdG9yIGJ5IGl0cyBzeW1ib2xpYyBuYW1lOiDigJhjbGVhcuKAmSwg4oCYZG93buKAmSwg4oCYcmVxdWlyZWTigJksIOKAmHNlYXJjaOKAmSwg4oCYdXDigJkuIFVzZSBgbnVsbGAgdG8gcmVtb3ZlIHRoZSBpbmRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gaW5kaWNhdG9yIFN5bWJvbGljIG5hbWUgb2YgaW5kaWNhdG9yLCBvciBgbnVsbGAgZm9yIG5vIGluZGljYXRvclxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LnByb3RvdHlwZS5zZXRJbmRpY2F0b3IgPSBmdW5jdGlvbiAoIGluZGljYXRvciApIHtcblx0aW5kaWNhdG9yID0gdHlwZW9mIGluZGljYXRvciA9PT0gJ3N0cmluZycgJiYgaW5kaWNhdG9yLmxlbmd0aCA/IGluZGljYXRvci50cmltKCkgOiBudWxsO1xuXG5cdGlmICggdGhpcy5pbmRpY2F0b3IgIT09IGluZGljYXRvciApIHtcblx0XHRpZiAoIHRoaXMuJGluZGljYXRvciApIHtcblx0XHRcdGlmICggdGhpcy5pbmRpY2F0b3IgIT09IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMuJGluZGljYXRvci5yZW1vdmVDbGFzcyggJ29vLXVpLWluZGljYXRvci0nICsgdGhpcy5pbmRpY2F0b3IgKTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kaWNhdG9yICE9PSBudWxsICkge1xuXHRcdFx0XHR0aGlzLiRpbmRpY2F0b3IuYWRkQ2xhc3MoICdvby11aS1pbmRpY2F0b3ItJyArIGluZGljYXRvciApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmluZGljYXRvciA9IGluZGljYXRvcjtcblx0fVxuXG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1pbmRpY2F0b3JFbGVtZW50JywgISF0aGlzLmluZGljYXRvciApO1xuXHRpZiAoIHRoaXMuJGluZGljYXRvciApIHtcblx0XHR0aGlzLiRpbmRpY2F0b3IudG9nZ2xlQ2xhc3MoICdvby11aS1pbmRpY2F0b3JFbGVtZW50LW5vSW5kaWNhdG9yJywgIXRoaXMuaW5kaWNhdG9yICk7XG5cdH1cblx0dGhpcy51cGRhdGVUaGVtZUNsYXNzZXMoKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpbmRpY2F0b3IgdGl0bGUuXG4gKlxuICogVGhlIHRpdGxlIGlzIGRpc3BsYXllZCB3aGVuIGEgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgaW5kaWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufG51bGx9IGluZGljYXRvclRpdGxlIEluZGljYXRvciB0aXRsZSB0ZXh0LCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0ZXh0LCBvclxuICogICBgbnVsbGAgZm9yIG5vIGluZGljYXRvciB0aXRsZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5wcm90b3R5cGUuc2V0SW5kaWNhdG9yVGl0bGUgPSBmdW5jdGlvbiAoIGluZGljYXRvclRpdGxlICkge1xuXHRpbmRpY2F0b3JUaXRsZSA9XG5cdFx0KCB0eXBlb2YgaW5kaWNhdG9yVGl0bGUgPT09ICdmdW5jdGlvbicgfHwgKCB0eXBlb2YgaW5kaWNhdG9yVGl0bGUgPT09ICdzdHJpbmcnICYmIGluZGljYXRvclRpdGxlLmxlbmd0aCApICkgP1xuXHRcdFx0T08udWkucmVzb2x2ZU1zZyggaW5kaWNhdG9yVGl0bGUgKSA6IG51bGw7XG5cblx0aWYgKCB0aGlzLmluZGljYXRvclRpdGxlICE9PSBpbmRpY2F0b3JUaXRsZSApIHtcblx0XHR0aGlzLmluZGljYXRvclRpdGxlID0gaW5kaWNhdG9yVGl0bGU7XG5cdFx0aWYgKCB0aGlzLiRpbmRpY2F0b3IgKSB7XG5cdFx0XHRpZiAoIHRoaXMuaW5kaWNhdG9yVGl0bGUgIT09IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMuJGluZGljYXRvci5hdHRyKCAndGl0bGUnLCBpbmRpY2F0b3JUaXRsZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kaW5kaWNhdG9yLnJlbW92ZUF0dHIoICd0aXRsZScgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBgc2V0SW5kaWNhdG9yVGl0bGUgaXMgZGVwcmVjYXRlZCBzaW5jZSAwLjMwLjBcblx0aWYgKCBpbmRpY2F0b3JUaXRsZSAhPT0gbnVsbCApIHtcblx0XHQvLyBBdm9pZCBhIHdhcm5pbmcgd2hlbiB0aGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciB3aXRoIG5vIGluZGljYXRvclRpdGxlIHNldFxuXHRcdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ0luZGljYXRvckVsZW1lbnQ6IHNldEluZGljYXRvclRpdGxlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUaXRsZSBvZiBUaXRsZWRFbGVtZW50IGluc3RlYWQuIFNlZSBUNzY2MzggZm9yIGRldGFpbHMuJyApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3ltYm9saWMgbmFtZSBvZiB0aGUgaW5kaWNhdG9yIChlLmcuLCDigJhjbGVhcuKAmSBvciAg4oCYZG93buKAmSkuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBTeW1ib2xpYyBuYW1lIG9mIGluZGljYXRvclxuICovXG5PTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LnByb3RvdHlwZS5nZXRJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmluZGljYXRvcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRpY2F0b3IgdGl0bGUuXG4gKlxuICogVGhlIHRpdGxlIGlzIGRpc3BsYXllZCB3aGVuIGEgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgaW5kaWNhdG9yLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gSW5kaWNhdG9yIHRpdGxlIHRleHRcbiAqL1xuT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmluZGljYXRvclRpdGxlO1xufTtcblxuLyoqXG4gKiBUaGUgRmxhZ2dlZEVsZW1lbnQgY2xhc3MgaXMgYW4gYXR0cmlidXRlIG1peGluLCBtZWFuaW5nIHRoYXQgaXQgaXMgdXNlZCB0byBhZGRcbiAqIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0byBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYW5vdGhlciBjbGFzcy4gVGhlIGNsYXNzIHByb3ZpZGVzXG4gKiBhIOKAmGZsYWdz4oCZIHByb3BlcnR5IGFzc2lnbmVkIHRoZSBuYW1lIChvciBhbiBhcnJheSBvZiBuYW1lcykgb2Ygc3R5bGluZyBmbGFncyxcbiAqIHdoaWNoIGFyZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgbG9vayBhbmQgZmVlbCBvZiBhIHdpZGdldCB0byBiZXR0ZXIgZGVzY3JpYmUgaXRzXG4gKiBpbXBvcnRhbmNlIGFuZCBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFRoZSBsaWJyYXJ5IGN1cnJlbnRseSBjb250YWlucyB0aGUgZm9sbG93aW5nIHN0eWxpbmcgZmxhZ3MgZm9yIGdlbmVyYWwgdXNlOlxuICpcbiAqIC0gKipwcm9ncmVzc2l2ZSoqOiBQcm9ncmVzc2l2ZSBzdHlsaW5nIGlzIGFwcGxpZWQgdG8gY29udmV5IHRoYXQgdGhlIHdpZGdldCB3aWxsIG1vdmUgdGhlIHVzZXIgZm9yd2FyZCBpbiBhIHByb2Nlc3MuXG4gKiAtICoqZGVzdHJ1Y3RpdmUqKjogRGVzdHJ1Y3RpdmUgc3R5bGluZyBpcyBhcHBsaWVkIHRvIGNvbnZleSB0aGF0IHRoZSB3aWRnZXQgd2lsbCByZW1vdmUgc29tZXRoaW5nLlxuICpcbiAqIFRoZSBmbGFncyBhZmZlY3QgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbnM6XG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRmxhZ2dlZEVsZW1lbnQgaXMgbWl4ZWQgaW50byBCdXR0b25XaWRnZXQgdG8gcHJvdmlkZSBzdHlsaW5nIGZsYWdzXG4gKiAgICAgdmFyIGJ1dHRvbjEgPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1Byb2dyZXNzaXZlJyxcbiAqICAgICAgICAgICAgIGZsYWdzOiAncHJvZ3Jlc3NpdmUnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgYnV0dG9uMiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnRGVzdHJ1Y3RpdmUnLFxuICogICAgICAgICAgICAgZmxhZ3M6ICdkZXN0cnVjdGl2ZSdcbiAqICAgICAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGJ1dHRvbjEuJGVsZW1lbnQsIGJ1dHRvbjIuJGVsZW1lbnQgKTtcbiAqXG4gKiB7QGxpbmsgT08udWkuQWN0aW9uV2lkZ2V0IEFjdGlvbldpZGdldHN9LCB3aGljaCBhcmUgYSBzcGVjaWFsIGtpbmQgb2YgYnV0dG9uIHRoYXQgZXhlY3V0ZSBhbiBhY3Rpb24sIHVzZSB0aGVzZSBmbGFnczogKipwcmltYXJ5KiogYW5kICoqc2FmZSoqLlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL0VsZW1lbnRzL0ZsYWdnZWRcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7c3RyaW5nfHN0cmluZ1tdfSBbZmxhZ3NdIFRoZSBuYW1lIG9yIG5hbWVzIG9mIHRoZSBmbGFncyAoZS5nLiwgJ3Byb2dyZXNzaXZlJyBvciAncHJpbWFyeScpIHRvIGFwcGx5LlxuICogIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMl0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgYXZhaWxhYmxlIGZsYWdzLlxuICogIFsyXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvRWxlbWVudHMvRmxhZ2dlZFxuICogQGNmZyB7alF1ZXJ5fSBbJGZsYWdnZWRdIFRoZSBmbGFnZ2VkIGVsZW1lbnQuIEJ5IGRlZmF1bHQsXG4gKiAgdGhlIGZsYWdnZWQgZnVuY3Rpb25hbGl0eSBpcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNsYXNzICgkZWxlbWVudCkuXG4gKiAgSWYgYSBkaWZmZXJlbnQgZWxlbWVudCBpcyBzcGVjaWZpZWQsIHRoZSBmbGFnZ2VkIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSBhcHBsaWVkIHRvIGl0IGluc3RlYWQuXG4gKi9cbk9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluRmxhZ2dlZEVsZW1lbnQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmZsYWdzID0ge307XG5cdHRoaXMuJGZsYWdnZWQgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuc2V0RmxhZ3MoIGNvbmZpZy5mbGFncyApO1xuXHR0aGlzLnNldEZsYWdnZWRFbGVtZW50KCBjb25maWcuJGZsYWdnZWQgfHwgdGhpcy4kZWxlbWVudCApO1xufTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGZsYWdcbiAqIEEgZmxhZyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlICNjbGVhckZsYWdzIG9yICNzZXRGbGFncyBtZXRob2RzIGFyZSB1c2VkLiBUaGUgYGNoYW5nZXNgXG4gKiBwYXJhbWV0ZXIgY29udGFpbnMgdGhlIG5hbWUgb2YgZWFjaCBtb2RpZmllZCBmbGFnIGFuZCBpbmRpY2F0ZXMgd2hldGhlciBpdCB3YXNcbiAqIGFkZGVkIG9yIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxib29sZWFuPn0gY2hhbmdlcyBPYmplY3Qga2V5ZWQgYnkgZmxhZyBuYW1lLiBBIEJvb2xlYW4gYHRydWVgIGluZGljYXRlc1xuICogdGhhdCB0aGUgZmxhZyB3YXMgYWRkZWQsIGBmYWxzZWAgdGhhdCB0aGUgZmxhZyB3YXMgcmVtb3ZlZC5cbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU2V0IHRoZSBmbGFnZ2VkIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byByZXRhcmdldCBhIGZsYWdnZWQgbWl4aW4gc28gdGhhdCBpdHMgZnVuY3Rpb25hbGl0eSBhcHBsaWVzIHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAqIElmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBzZXQsIHRoZSBtZXRob2Qgd2lsbCByZW1vdmUgdGhlIG1peGlu4oCZcyBlZmZlY3Qgb24gdGhhdCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkZmxhZ2dlZCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIGZsYWdnZWRcbiAqL1xuT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQucHJvdG90eXBlLnNldEZsYWdnZWRFbGVtZW50ID0gZnVuY3Rpb24gKCAkZmxhZ2dlZCApIHtcblx0dmFyIGNsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyggdGhpcy5mbGFncyApLm1hcCggZnVuY3Rpb24gKCBmbGFnICkge1xuXHRcdHJldHVybiAnb28tdWktZmxhZ2dlZEVsZW1lbnQtJyArIGZsYWc7XG5cdH0gKTtcblxuXHRpZiAoIHRoaXMuJGZsYWdnZWQgKSB7XG5cdFx0dGhpcy4kZmxhZ2dlZC5yZW1vdmVDbGFzcyggY2xhc3NOYW1lcyApO1xuXHR9XG5cblx0dGhpcy4kZmxhZ2dlZCA9ICRmbGFnZ2VkLmFkZENsYXNzKCBjbGFzc05hbWVzICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgZmxhZyBpcyBzZXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZsYWcgTmFtZSBvZiBmbGFnXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZmxhZyBpcyBzZXRcbiAqL1xuT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQucHJvdG90eXBlLmhhc0ZsYWcgPSBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdC8vIFRoaXMgbWF5IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNvbnN0cnVjdG9yLCB0aHVzIGJlZm9yZSB0aGlzLmZsYWdzIGlzIHNldFxuXHRyZXR1cm4gdGhpcy5mbGFncyAmJiAoIGZsYWcgaW4gdGhpcy5mbGFncyApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hbWVzIG9mIGFsbCBmbGFncyBzZXQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119IEZsYWcgbmFtZXNcbiAqL1xuT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQucHJvdG90eXBlLmdldEZsYWdzID0gZnVuY3Rpb24gKCkge1xuXHQvLyBUaGlzIG1heSBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjb25zdHJ1Y3RvciwgdGh1cyBiZWZvcmUgdGhpcy5mbGFncyBpcyBzZXRcblx0cmV0dXJuIE9iamVjdC5rZXlzKCB0aGlzLmZsYWdzIHx8IHt9ICk7XG59O1xuXG4vKipcbiAqIENsZWFyIGFsbCBmbGFncy5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKiBAZmlyZXMgZmxhZ1xuICovXG5PTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5wcm90b3R5cGUuY2xlYXJGbGFncyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGZsYWcsIGNsYXNzTmFtZSxcblx0XHRjaGFuZ2VzID0ge30sXG5cdFx0cmVtb3ZlID0gW10sXG5cdFx0Y2xhc3NQcmVmaXggPSAnb28tdWktZmxhZ2dlZEVsZW1lbnQtJztcblxuXHRmb3IgKCBmbGFnIGluIHRoaXMuZmxhZ3MgKSB7XG5cdFx0Y2xhc3NOYW1lID0gY2xhc3NQcmVmaXggKyBmbGFnO1xuXHRcdGNoYW5nZXNbIGZsYWcgXSA9IGZhbHNlO1xuXHRcdGRlbGV0ZSB0aGlzLmZsYWdzWyBmbGFnIF07XG5cdFx0cmVtb3ZlLnB1c2goIGNsYXNzTmFtZSApO1xuXHR9XG5cblx0aWYgKCB0aGlzLiRmbGFnZ2VkICkge1xuXHRcdHRoaXMuJGZsYWdnZWQucmVtb3ZlQ2xhc3MoIHJlbW92ZSApO1xuXHR9XG5cblx0dGhpcy51cGRhdGVUaGVtZUNsYXNzZXMoKTtcblx0dGhpcy5lbWl0KCAnZmxhZycsIGNoYW5nZXMgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGZsYWdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfE9iamVjdC48c3RyaW5nLCBib29sZWFuPn0gZmxhZ3MgQSBmbGFnIG5hbWUsIGFuIGFycmF5IG9mIGZsYWcgbmFtZXMsXG4gKiAgb3IgYW4gb2JqZWN0IGtleWVkIGJ5IGZsYWcgbmFtZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmbGFnIHNob3VsZFxuICogIGJlIGFkZGVkIChgdHJ1ZWApIG9yIHJlbW92ZWQgKGBmYWxzZWApLlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICogQGZpcmVzIGZsYWdcbiAqL1xuT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQucHJvdG90eXBlLnNldEZsYWdzID0gZnVuY3Rpb24gKCBmbGFncyApIHtcblx0dmFyIGksIGxlbiwgZmxhZywgY2xhc3NOYW1lLFxuXHRcdGNoYW5nZXMgPSB7fSxcblx0XHRhZGQgPSBbXSxcblx0XHRyZW1vdmUgPSBbXSxcblx0XHRjbGFzc1ByZWZpeCA9ICdvby11aS1mbGFnZ2VkRWxlbWVudC0nO1xuXG5cdGlmICggdHlwZW9mIGZsYWdzID09PSAnc3RyaW5nJyApIHtcblx0XHRjbGFzc05hbWUgPSBjbGFzc1ByZWZpeCArIGZsYWdzO1xuXHRcdC8vIFNldFxuXHRcdGlmICggIXRoaXMuZmxhZ3NbIGZsYWdzIF0gKSB7XG5cdFx0XHR0aGlzLmZsYWdzWyBmbGFncyBdID0gdHJ1ZTtcblx0XHRcdGFkZC5wdXNoKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIGZsYWdzICkgKSB7XG5cdFx0Zm9yICggaSA9IDAsIGxlbiA9IGZsYWdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0ZmxhZyA9IGZsYWdzWyBpIF07XG5cdFx0XHRjbGFzc05hbWUgPSBjbGFzc1ByZWZpeCArIGZsYWc7XG5cdFx0XHQvLyBTZXRcblx0XHRcdGlmICggIXRoaXMuZmxhZ3NbIGZsYWcgXSApIHtcblx0XHRcdFx0Y2hhbmdlc1sgZmxhZyBdID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5mbGFnc1sgZmxhZyBdID0gdHJ1ZTtcblx0XHRcdFx0YWRkLnB1c2goIGNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggT08uaXNQbGFpbk9iamVjdCggZmxhZ3MgKSApIHtcblx0XHRmb3IgKCBmbGFnIGluIGZsYWdzICkge1xuXHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NQcmVmaXggKyBmbGFnO1xuXHRcdFx0aWYgKCBmbGFnc1sgZmxhZyBdICkge1xuXHRcdFx0XHQvLyBTZXRcblx0XHRcdFx0aWYgKCAhdGhpcy5mbGFnc1sgZmxhZyBdICkge1xuXHRcdFx0XHRcdGNoYW5nZXNbIGZsYWcgXSA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5mbGFnc1sgZmxhZyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRhZGQucHVzaCggY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFJlbW92ZVxuXHRcdFx0XHRpZiAoIHRoaXMuZmxhZ3NbIGZsYWcgXSApIHtcblx0XHRcdFx0XHRjaGFuZ2VzWyBmbGFnIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5mbGFnc1sgZmxhZyBdO1xuXHRcdFx0XHRcdHJlbW92ZS5wdXNoKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy4kZmxhZ2dlZCApIHtcblx0XHR0aGlzLiRmbGFnZ2VkXG5cdFx0XHQuYWRkQ2xhc3MoIGFkZCApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIHJlbW92ZSApO1xuXHR9XG5cblx0dGhpcy51cGRhdGVUaGVtZUNsYXNzZXMoKTtcblx0dGhpcy5lbWl0KCAnZmxhZycsIGNoYW5nZXMgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGl0bGVkRWxlbWVudCBpcyBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXMgdG8gcHJvdmlkZSBhIGB0aXRsZWAgYXR0cmlidXRlLlxuICogVGl0bGVzIGFyZSByZW5kZXJlZCBieSB0aGUgYnJvd3NlciBhbmQgYXJlIG1hZGUgdmlzaWJsZSB3aGVuIHRoZSB1c2VyIG1vdmVzXG4gKiB0aGUgbW91c2Ugb3ZlciB0aGUgZWxlbWVudC4gVGl0bGVzIGFyZSBub3QgdmlzaWJsZSBvbiB0b3VjaCBkZXZpY2VzLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIFRpdGxlZEVsZW1lbnQgcHJvdmlkZXMgYSBgdGl0bGVgIGF0dHJpYnV0ZSB0byB0aGVcbiAqICAgICAvLyBCdXR0b25XaWRnZXQgY2xhc3MuXG4gKiAgICAgdmFyIGJ1dHRvbiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcbiAqICAgICAgICAgbGFiZWw6ICdCdXR0b24gd2l0aCBUaXRsZScsXG4gKiAgICAgICAgIHRpdGxlOiAnSSBhbSBhIGJ1dHRvbidcbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggYnV0dG9uLiRlbGVtZW50ICk7XG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2pRdWVyeX0gWyR0aXRsZWRdIFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBgdGl0bGVgIGF0dHJpYnV0ZSBpcyBhcHBsaWVkLlxuICogIElmIHRoaXMgY29uZmlnIGlzIG9taXR0ZWQsIHRoZSB0aXRsZSBmdW5jdGlvbmFsaXR5IGlzIGFwcGxpZWQgdG8gJGVsZW1lbnQsIHRoZVxuICogIGVsZW1lbnQgY3JlYXRlZCBieSB0aGUgY2xhc3MuXG4gKiBAY2ZnIHtzdHJpbmd8RnVuY3Rpb259IFt0aXRsZV0gVGhlIHRpdGxlIHRleHQgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGV4dC4gSWZcbiAqICB0aGlzIGNvbmZpZyBpcyBvbWl0dGVkLCB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayAjc3RhdGljLXRpdGxlIHN0YXRpYyB0aXRsZX0gcHJvcGVydHkgaXMgdXNlZC5cbiAqL1xuT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCA9IGZ1bmN0aW9uIE9vVWlNaXhpblRpdGxlZEVsZW1lbnQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiR0aXRsZWQgPSBudWxsO1xuXHR0aGlzLnRpdGxlID0gbnVsbDtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnNldFRpdGxlKCBjb25maWcudGl0bGUgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy50aXRsZSA6IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLnRpdGxlICk7XG5cdHRoaXMuc2V0VGl0bGVkRWxlbWVudCggY29uZmlnLiR0aXRsZWQgfHwgdGhpcy4kZWxlbWVudCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5pdENsYXNzKCBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogVGhlIHRpdGxlIHRleHQsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRleHQsIG9yIGBudWxsYCBmb3Igbm8gdGl0bGUuIFRoZSB2YWx1ZSBvZiB0aGUgc3RhdGljIHByb3BlcnR5XG4gKiBpcyBvdmVycmlkZGVuIGlmIHRoZSAjdGl0bGUgY29uZmlnIG9wdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd8RnVuY3Rpb258bnVsbH1cbiAqL1xuT08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5zdGF0aWMudGl0bGUgPSBudWxsO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU2V0IHRoZSB0aXRsZWQgZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJldGFyZ2V0IGEgVGl0bGVkRWxlbWVudCBtaXhpbiBzbyB0aGF0IGl0cyBmdW5jdGlvbmFsaXR5IGFwcGxpZXMgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICogSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgdGhlIG1peGlu4oCZcyBlZmZlY3Qgb24gdGhhdCBlbGVtZW50IGlzIHJlbW92ZWQgYmVmb3JlIHRoZSBuZXcgZWxlbWVudCBpcyBzZXQgdXAuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICR0aXRsZWQgRWxlbWVudCB0aGF0IHNob3VsZCB1c2UgdGhlICd0aXRsZWQnIGZ1bmN0aW9uYWxpdHlcbiAqL1xuT08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5wcm90b3R5cGUuc2V0VGl0bGVkRWxlbWVudCA9IGZ1bmN0aW9uICggJHRpdGxlZCApIHtcblx0aWYgKCB0aGlzLiR0aXRsZWQgKSB7XG5cdFx0dGhpcy4kdGl0bGVkLnJlbW92ZUF0dHIoICd0aXRsZScgKTtcblx0fVxuXG5cdHRoaXMuJHRpdGxlZCA9ICR0aXRsZWQ7XG5cdGlmICggdGhpcy50aXRsZSApIHtcblx0XHR0aGlzLnVwZGF0ZVRpdGxlKCk7XG5cdH1cbn07XG5cbi8qKlxuICogU2V0IHRpdGxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufG51bGx9IHRpdGxlIFRpdGxlIHRleHQsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRleHQsIG9yIGBudWxsYCBmb3Igbm8gdGl0bGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAoIHRpdGxlICkge1xuXHR0aXRsZSA9IHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IE9PLnVpLnJlc29sdmVNc2coIHRpdGxlICkgOiB0aXRsZTtcblx0dGl0bGUgPSAoIHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycgJiYgdGl0bGUubGVuZ3RoICkgPyB0aXRsZSA6IG51bGw7XG5cblx0aWYgKCB0aGlzLnRpdGxlICE9PSB0aXRsZSApIHtcblx0XHR0aGlzLnRpdGxlID0gdGl0bGU7XG5cdFx0dGhpcy51cGRhdGVUaXRsZSgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdGl0bGUgYXR0cmlidXRlLCBpbiBjYXNlIG9mIGNoYW5nZXMgdG8gdGl0bGUgb3IgYWNjZXNzS2V5LlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKTtcblx0aWYgKCB0aGlzLiR0aXRsZWQgKSB7XG5cdFx0aWYgKCB0aXRsZSAhPT0gbnVsbCApIHtcblx0XHRcdC8vIE9ubHkgaWYgdGhpcyBpcyBhbiBBY2Nlc3NLZXllZEVsZW1lbnRcblx0XHRcdGlmICggdGhpcy5mb3JtYXRUaXRsZVdpdGhBY2Nlc3NLZXkgKSB7XG5cdFx0XHRcdHRpdGxlID0gdGhpcy5mb3JtYXRUaXRsZVdpdGhBY2Nlc3NLZXkoIHRpdGxlICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLiR0aXRsZWQuYXR0ciggJ3RpdGxlJywgdGl0bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kdGl0bGVkLnJlbW92ZUF0dHIoICd0aXRsZScgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aXRsZS5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRpdGxlIHN0cmluZ1xuICovXG5PTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMudGl0bGU7XG59O1xuXG4vKipcbiAqIEFjY2Vzc0tleWVkRWxlbWVudCBpcyBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXMgdG8gcHJvdmlkZSBhbiBgYWNjZXNza2V5YCBIVE1MIGF0dHJpYnV0ZS5cbiAqIEFjY2Vzc2tleXMgYWxsb3cgYW4gdXNlciB0byBnbyB0byBhIHNwZWNpZmljIGVsZW1lbnQgYnkgdXNpbmdcbiAqIGEgc2hvcnRjdXQgY29tYmluYXRpb24gb2YgYSBicm93c2VyIHNwZWNpZmljIGtleXMgKyB0aGUga2V5XG4gKiBzZXQgdG8gdGhlIGZpZWxkLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEFjY2Vzc0tleWVkRWxlbWVudCBwcm92aWRlcyBhbiBgYWNjZXNza2V5YCBhdHRyaWJ1dGUgdG8gdGhlXG4gKiAgICAgLy8gQnV0dG9uV2lkZ2V0IGNsYXNzLlxuICogICAgIHZhciBidXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgIGxhYmVsOiAnQnV0dG9uIHdpdGggQWNjZXNza2V5JyxcbiAqICAgICAgICAgYWNjZXNzS2V5OiAnaydcbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggYnV0dG9uLiRlbGVtZW50ICk7XG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2pRdWVyeX0gWyRhY2Nlc3NLZXllZF0gVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGBhY2Nlc3NrZXlgIGF0dHJpYnV0ZSBpcyBhcHBsaWVkLlxuICogIElmIHRoaXMgY29uZmlnIGlzIG9taXR0ZWQsIHRoZSBhY2Nlc3NrZXkgZnVuY3Rpb25hbGl0eSBpcyBhcHBsaWVkIHRvICRlbGVtZW50LCB0aGVcbiAqICBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGNsYXNzLlxuICogQGNmZyB7c3RyaW5nfEZ1bmN0aW9ufSBbYWNjZXNzS2V5XSBUaGUga2V5IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBrZXkuIElmXG4gKiAgdGhpcyBjb25maWcgaXMgb21pdHRlZCwgbm8gYWNjZXNza2V5IHdpbGwgYmUgYWRkZWQuXG4gKi9cbk9PLnVpLm1peGluLkFjY2Vzc0tleWVkRWxlbWVudCA9IGZ1bmN0aW9uIE9vVWlNaXhpbkFjY2Vzc0tleWVkRWxlbWVudCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuJGFjY2Vzc0tleWVkID0gbnVsbDtcblx0dGhpcy5hY2Nlc3NLZXkgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuc2V0QWNjZXNzS2V5KCBjb25maWcuYWNjZXNzS2V5IHx8IG51bGwgKTtcblx0dGhpcy5zZXRBY2Nlc3NLZXllZEVsZW1lbnQoIGNvbmZpZy4kYWNjZXNzS2V5ZWQgfHwgdGhpcy4kZWxlbWVudCApO1xuXG5cdC8vIElmIHRoaXMgaXMgYWxzbyBhIFRpdGxlZEVsZW1lbnQgYW5kIGl0IGluaXRpYWxpemVkIGJlZm9yZSB3ZSBkaWQsIHdlIG1heSBoYXZlXG5cdC8vIHRvIHVwZGF0ZSB0aGUgdGl0bGUgd2l0aCB0aGUgYWNjZXNzIGtleVxuXHRpZiAoIHRoaXMudXBkYXRlVGl0bGUgKSB7XG5cdFx0dGhpcy51cGRhdGVUaXRsZSgpO1xuXHR9XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbml0Q2xhc3MoIE9PLnVpLm1peGluLkFjY2Vzc0tleWVkRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIFRoZSBhY2Nlc3Mga2V5LCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleSwgb3IgYG51bGxgIGZvciBubyBhY2Nlc3NrZXkuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICovXG5PTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQuc3RhdGljLmFjY2Vzc0tleSA9IG51bGw7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgdGhlIGFjY2Vzc2tleWVkIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byByZXRhcmdldCBhIEFjY2Vzc0tleWVkRWxlbWVudCBtaXhpbiBzbyB0aGF0IGl0cyBmdW5jdGlvbmFsaXR5IGFwcGxpZXMgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICogSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgdGhlIG1peGluJ3MgZWZmZWN0IG9uIHRoYXQgZWxlbWVudCBpcyByZW1vdmVkIGJlZm9yZSB0aGUgbmV3IGVsZW1lbnQgaXMgc2V0IHVwLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkYWNjZXNzS2V5ZWQgRWxlbWVudCB0aGF0IHNob3VsZCB1c2UgdGhlICdhY2Nlc3NrZXllZCcgZnVuY3Rpb25hbGl0eVxuICovXG5PTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQucHJvdG90eXBlLnNldEFjY2Vzc0tleWVkRWxlbWVudCA9IGZ1bmN0aW9uICggJGFjY2Vzc0tleWVkICkge1xuXHRpZiAoIHRoaXMuJGFjY2Vzc0tleWVkICkge1xuXHRcdHRoaXMuJGFjY2Vzc0tleWVkLnJlbW92ZUF0dHIoICdhY2Nlc3NrZXknICk7XG5cdH1cblxuXHR0aGlzLiRhY2Nlc3NLZXllZCA9ICRhY2Nlc3NLZXllZDtcblx0aWYgKCB0aGlzLmFjY2Vzc0tleSApIHtcblx0XHR0aGlzLiRhY2Nlc3NLZXllZC5hdHRyKCAnYWNjZXNza2V5JywgdGhpcy5hY2Nlc3NLZXkgKTtcblx0fVxufTtcblxuLyoqXG4gKiBTZXQgYWNjZXNza2V5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufG51bGx9IGFjY2Vzc0tleSBLZXksIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5LCBvciBgbnVsbGAgZm9yIG5vIGFjY2Vzc2tleVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQucHJvdG90eXBlLnNldEFjY2Vzc0tleSA9IGZ1bmN0aW9uICggYWNjZXNzS2V5ICkge1xuXHRhY2Nlc3NLZXkgPSB0eXBlb2YgYWNjZXNzS2V5ID09PSAnc3RyaW5nJyA/IE9PLnVpLnJlc29sdmVNc2coIGFjY2Vzc0tleSApIDogbnVsbDtcblxuXHRpZiAoIHRoaXMuYWNjZXNzS2V5ICE9PSBhY2Nlc3NLZXkgKSB7XG5cdFx0aWYgKCB0aGlzLiRhY2Nlc3NLZXllZCApIHtcblx0XHRcdGlmICggYWNjZXNzS2V5ICE9PSBudWxsICkge1xuXHRcdFx0XHR0aGlzLiRhY2Nlc3NLZXllZC5hdHRyKCAnYWNjZXNza2V5JywgYWNjZXNzS2V5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiRhY2Nlc3NLZXllZC5yZW1vdmVBdHRyKCAnYWNjZXNza2V5JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmFjY2Vzc0tleSA9IGFjY2Vzc0tleTtcblxuXHRcdC8vIE9ubHkgaWYgdGhpcyBpcyBhIFRpdGxlZEVsZW1lbnRcblx0XHRpZiAoIHRoaXMudXBkYXRlVGl0bGUgKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVRpdGxlKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCBhY2Nlc3NrZXkuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBhY2Nlc3NLZXkgc3RyaW5nXG4gKi9cbk9PLnVpLm1peGluLkFjY2Vzc0tleWVkRWxlbWVudC5wcm90b3R5cGUuZ2V0QWNjZXNzS2V5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5hY2Nlc3NLZXk7XG59O1xuXG4vKipcbiAqIEFkZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWNjZXNzIGtleSB0byB0aGUgZWxlbWVudCdzIHRvb2x0aXAgbGFiZWwuXG4gKiAoVGhpcyBpcyBvbmx5IHB1YmxpYyBmb3IgaGFja3kgdXNhZ2UgaW4gRmllbGRMYXlvdXQuKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSBUb29sdGlwIGxhYmVsIGZvciBgdGl0bGVgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5PTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQucHJvdG90eXBlLmZvcm1hdFRpdGxlV2l0aEFjY2Vzc0tleSA9IGZ1bmN0aW9uICggdGl0bGUgKSB7XG5cdHZhciBhY2Nlc3NLZXk7XG5cblx0aWYgKCAhdGhpcy4kYWNjZXNzS2V5ZWQgKSB7XG5cdFx0Ly8gTm90IGluaXRpYWxpemVkIHlldDsgdGhlIGNvbnN0cnVjdG9yIHdpbGwgY2FsbCB1cGRhdGVUaXRsZSgpIHdoaWNoIHdpbGwgcmVydW4gdGhpcyBmdW5jdGlvblxuXHRcdHJldHVybiB0aXRsZTtcblx0fVxuXHQvLyBVc2UganF1ZXJ5LmFjY2Vzc0tleUxhYmVsIGlmIGF2YWlsYWJsZSB0byBzaG93IG1vZGlmaWVycywgb3RoZXJ3aXNlIGp1c3QgZGlzcGxheSB0aGUgc2luZ2xlIGtleVxuXHRpZiAoICQuZm4udXBkYXRlVG9vbHRpcEFjY2Vzc0tleXMgJiYgJC5mbi51cGRhdGVUb29sdGlwQWNjZXNzS2V5cy5nZXRBY2Nlc3NLZXlMYWJlbCApIHtcblx0XHRhY2Nlc3NLZXkgPSAkLmZuLnVwZGF0ZVRvb2x0aXBBY2Nlc3NLZXlzLmdldEFjY2Vzc0tleUxhYmVsKCB0aGlzLiRhY2Nlc3NLZXllZFsgMCBdICk7XG5cdH0gZWxzZSB7XG5cdFx0YWNjZXNzS2V5ID0gdGhpcy5nZXRBY2Nlc3NLZXkoKTtcblx0fVxuXHRpZiAoIGFjY2Vzc0tleSApIHtcblx0XHR0aXRsZSArPSAnIFsnICsgYWNjZXNzS2V5ICsgJ10nO1xuXHR9XG5cdHJldHVybiB0aXRsZTtcbn07XG5cbi8qKlxuICogQnV0dG9uV2lkZ2V0IGlzIGEgZ2VuZXJpYyB3aWRnZXQgZm9yIGJ1dHRvbnMuIEEgd2lkZSB2YXJpZXR5IG9mIGxvb2tzLFxuICogZmVlbHMsIGFuZCBmdW5jdGlvbmFsaXR5IGNhbiBiZSBjdXN0b21pemVkIHZpYSB0aGUgY2xhc3PigJlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogYW5kIG1ldGhvZHMuIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvQnV0dG9uc19hbmRfU3dpdGNoZXNcbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIGJ1dHRvbiB3aWRnZXQuXG4gKiAgICAgdmFyIGJ1dHRvbiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcbiAqICAgICAgICAgbGFiZWw6ICdCdXR0b24gd2l0aCBJY29uJyxcbiAqICAgICAgICAgaWNvbjogJ3RyYXNoJyxcbiAqICAgICAgICAgdGl0bGU6ICdSZW1vdmUnXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGJ1dHRvbi4kZWxlbWVudCApO1xuICpcbiAqIE5PVEU6IEhUTUwgZm9ybSBidXR0b25zIHNob3VsZCB1c2UgdGhlIE9PLnVpLkJ1dHRvbklucHV0V2lkZ2V0IGNsYXNzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSWNvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2Jvb2xlYW59IFthY3RpdmU9ZmFsc2VdIFdoZXRoZXIgYnV0dG9uIHNob3VsZCBiZSBzaG93biBhcyBhY3RpdmVcbiAqIEBjZmcge3N0cmluZ30gW2hyZWZdIEh5cGVybGluayB0byB2aXNpdCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZC5cbiAqIEBjZmcge3N0cmluZ30gW3RhcmdldF0gVGhlIGZyYW1lIG9yIHdpbmRvdyBpbiB3aGljaCB0byBvcGVuIHRoZSBoeXBlcmxpbmsuXG4gKiBAY2ZnIHtib29sZWFufSBbbm9Gb2xsb3ddIFNlYXJjaCBlbmdpbmUgdHJhdmVyc2FsIGhpbnQgKGRlZmF1bHQ6IHRydWUpXG4gKi9cbk9PLnVpLkJ1dHRvbldpZGdldCA9IGZ1bmN0aW9uIE9vVWlCdXR0b25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkJ1dHRvbldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLkljb25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRpdGxlZDogdGhpcy4kYnV0dG9uIH0gKSApO1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRhYkluZGV4ZWQ6IHRoaXMuJGJ1dHRvbiB9ICkgKTtcblx0T08udWkubWl4aW4uQWNjZXNzS2V5ZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRhY2Nlc3NLZXllZDogdGhpcy4kYnV0dG9uIH0gKSApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5ocmVmID0gbnVsbDtcblx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHR0aGlzLm5vRm9sbG93ID0gZmFsc2U7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuY29ubmVjdCggdGhpcywgeyBkaXNhYmxlOiAnb25EaXNhYmxlJyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kYnV0dG9uLmFwcGVuZCggdGhpcy4kaWNvbiwgdGhpcy4kbGFiZWwsIHRoaXMuJGluZGljYXRvciApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktYnV0dG9uV2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kYnV0dG9uICk7XG5cdHRoaXMuc2V0QWN0aXZlKCBjb25maWcuYWN0aXZlICk7XG5cdHRoaXMuc2V0SHJlZiggY29uZmlnLmhyZWYgKTtcblx0dGhpcy5zZXRUYXJnZXQoIGNvbmZpZy50YXJnZXQgKTtcblx0dGhpcy5zZXROb0ZvbGxvdyggY29uZmlnLm5vRm9sbG93ICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLkJ1dHRvbldpZGdldCwgT08udWkuV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5CdXR0b25XaWRnZXQsIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkJ1dHRvbldpZGdldCwgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkJ1dHRvbldpZGdldCwgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkJ1dHRvbldpZGdldCwgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CdXR0b25XaWRnZXQuc3RhdGljLmNhbmNlbEJ1dHRvbk1vdXNlRG93bkV2ZW50cyA9IGZhbHNlO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkJ1dHRvbldpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdzcGFuJztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEdldCBoeXBlcmxpbmsgbG9jYXRpb24uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBIeXBlcmxpbmsgbG9jYXRpb25cbiAqL1xuT08udWkuQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5ocmVmO1xufTtcblxuLyoqXG4gKiBHZXQgaHlwZXJsaW5rIHRhcmdldC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEh5cGVybGluayB0YXJnZXRcbiAqL1xuT08udWkuQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnRhcmdldDtcbn07XG5cbi8qKlxuICogR2V0IHNlYXJjaCBlbmdpbmUgdHJhdmVyc2FsIGhpbnQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBzZWFyY2ggZW5naW5lcyBzaG91bGQgYXZvaWQgdHJhdmVyc2luZyB0aGlzIGh5cGVybGlua1xuICovXG5PTy51aS5CdXR0b25XaWRnZXQucHJvdG90eXBlLmdldE5vRm9sbG93ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5ub0ZvbGxvdztcbn07XG5cbi8qKlxuICogU2V0IGh5cGVybGluayBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBocmVmIEh5cGVybGluayBsb2NhdGlvbiwgbnVsbCB0byByZW1vdmVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJ1dHRvbldpZGdldC5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uICggaHJlZiApIHtcblx0aHJlZiA9IHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBudWxsO1xuXHRpZiAoIGhyZWYgIT09IG51bGwgJiYgIU9PLnVpLmlzU2FmZVVybCggaHJlZiApICkge1xuXHRcdGhyZWYgPSAnLi8nICsgaHJlZjtcblx0fVxuXG5cdGlmICggaHJlZiAhPT0gdGhpcy5ocmVmICkge1xuXHRcdHRoaXMuaHJlZiA9IGhyZWY7XG5cdFx0dGhpcy51cGRhdGVIcmVmKCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlLCBpbiBjYXNlIG9mIGNoYW5nZXMgdG8gaHJlZiBvclxuICogZGlzYWJsZWQgc3RhdGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJ1dHRvbldpZGdldC5wcm90b3R5cGUudXBkYXRlSHJlZiA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmhyZWYgIT09IG51bGwgJiYgIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdHRoaXMuJGJ1dHRvbi5hdHRyKCAnaHJlZicsIHRoaXMuaHJlZiApO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuJGJ1dHRvbi5yZW1vdmVBdHRyKCAnaHJlZicgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgZGlzYWJsZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgRWxlbWVudCBpcyBkaXNhYmxlZFxuICovXG5PTy51aS5CdXR0b25XaWRnZXQucHJvdG90eXBlLm9uRGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy51cGRhdGVIcmVmKCk7XG59O1xuXG4vKipcbiAqIFNldCBoeXBlcmxpbmsgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRhcmdldCBIeXBlcmxpbmsgdGFyZ2V0LCBudWxsIHRvIHJlbW92ZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcblx0dGFyZ2V0ID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiBudWxsO1xuXG5cdGlmICggdGFyZ2V0ICE9PSB0aGlzLnRhcmdldCApIHtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHRpZiAoIHRhcmdldCAhPT0gbnVsbCApIHtcblx0XHRcdHRoaXMuJGJ1dHRvbi5hdHRyKCAndGFyZ2V0JywgdGFyZ2V0ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJGJ1dHRvbi5yZW1vdmVBdHRyKCAndGFyZ2V0JyApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgc2VhcmNoIGVuZ2luZSB0cmF2ZXJzYWwgaGludC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5vRm9sbG93IFRydWUgaWYgc2VhcmNoIGVuZ2luZXMgc2hvdWxkIGF2b2lkIHRyYXZlcnNpbmcgdGhpcyBoeXBlcmxpbmtcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJ1dHRvbldpZGdldC5wcm90b3R5cGUuc2V0Tm9Gb2xsb3cgPSBmdW5jdGlvbiAoIG5vRm9sbG93ICkge1xuXHRub0ZvbGxvdyA9IHR5cGVvZiBub0ZvbGxvdyA9PT0gJ2Jvb2xlYW4nID8gbm9Gb2xsb3cgOiB0cnVlO1xuXG5cdGlmICggbm9Gb2xsb3cgIT09IHRoaXMubm9Gb2xsb3cgKSB7XG5cdFx0dGhpcy5ub0ZvbGxvdyA9IG5vRm9sbG93O1xuXHRcdGlmICggbm9Gb2xsb3cgKSB7XG5cdFx0XHR0aGlzLiRidXR0b24uYXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kYnV0dG9uLnJlbW92ZUF0dHIoICdyZWwnICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBPdmVycmlkZSBtZXRob2QgdmlzaWJpbGl0eSBoaW50cyBmcm9tIEJ1dHRvbkVsZW1lbnRcbi8qKlxuICogQG1ldGhvZCBzZXRBY3RpdmVcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbi8qKlxuICogQG1ldGhvZCBpc0FjdGl2ZVxuICogQGluaGVyaXRkb2NcbiAqL1xuXG4vKipcbiAqIEEgQnV0dG9uR3JvdXBXaWRnZXQgZ3JvdXBzIHJlbGF0ZWQgYnV0dG9ucyBhbmQgaXMgdXNlZCB0b2dldGhlciB3aXRoIE9PLnVpLkJ1dHRvbldpZGdldCBhbmRcbiAqIGl0cyBzdWJjbGFzc2VzLiBFYWNoIGJ1dHRvbiBpbiBhIGdyb3VwIGlzIGFkZHJlc3NlZCBieSBhIHVuaXF1ZSByZWZlcmVuY2UuIEJ1dHRvbnMgY2FuIGJlIGFkZGVkLFxuICogcmVtb3ZlZCwgYW5kIGNsZWFyZWQgZnJvbSB0aGUgZ3JvdXAuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBCdXR0b25Hcm91cFdpZGdldCB3aXRoIHR3byBidXR0b25zLlxuICogICAgIHZhciBidXR0b24xID0gbmV3IE9PLnVpLlBvcHVwQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1NlbGVjdCBhIGNhdGVnb3J5JyxcbiAqICAgICAgICAgICAgIGljb246ICdtZW51JyxcbiAqICAgICAgICAgICAgIHBvcHVwOiB7XG4gKiAgICAgICAgICAgICAgICAgJGNvbnRlbnQ6ICQoICc8cD5MaXN0IG9mIGNhdGVnb3JpZXPigKY8L3A+JyApLFxuICogICAgICAgICAgICAgICAgIHBhZGRlZDogdHJ1ZSxcbiAqICAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnXG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgYnV0dG9uMiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnQWRkIGl0ZW0nXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgYnV0dG9uR3JvdXAgPSBuZXcgT08udWkuQnV0dG9uR3JvdXBXaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGl0ZW1zOiBbIGJ1dHRvbjEsIGJ1dHRvbjIgXVxuICogICAgICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggYnV0dG9uR3JvdXAuJGVsZW1lbnQgKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7T08udWkuQnV0dG9uV2lkZ2V0W119IFtpdGVtc10gQnV0dG9ucyB0byBhZGRcbiAqL1xuT08udWkuQnV0dG9uR3JvdXBXaWRnZXQgPSBmdW5jdGlvbiBPb1VpQnV0dG9uR3JvdXBXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkJ1dHRvbkdyb3VwV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uR3JvdXBFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRncm91cDogdGhpcy4kZWxlbWVudCB9ICkgKTtcblx0T08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYnV0dG9uR3JvdXBXaWRnZXQnICk7XG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnLml0ZW1zICkgKSB7XG5cdFx0dGhpcy5hZGRJdGVtcyggY29uZmlnLml0ZW1zICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQnV0dG9uR3JvdXBXaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uR3JvdXBXaWRnZXQsIE9PLnVpLm1peGluLkdyb3VwRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uR3JvdXBXaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CdXR0b25Hcm91cFdpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdzcGFuJztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEZvY3VzIHRoZSB3aWRnZXRcbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5CdXR0b25Hcm91cFdpZGdldC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdGlmICggdGhpcy5pdGVtc1sgMCBdICkge1xuXHRcdFx0dGhpcy5pdGVtc1sgMCBdLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CdXR0b25Hcm91cFdpZGdldC5wcm90b3R5cGUuc2ltdWxhdGVMYWJlbENsaWNrID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIEljb25XaWRnZXQgaXMgYSBnZW5lcmljIHdpZGdldCBmb3Ige0BsaW5rIE9PLnVpLm1peGluLkljb25FbGVtZW50IGljb25zfS4gSW4gZ2VuZXJhbCwgSWNvbldpZGdldHMgc2hvdWxkIGJlIHVzZWQgd2l0aCBPTy51aS5MYWJlbFdpZGdldCxcbiAqIHdoaWNoIGNyZWF0ZXMgYSBsYWJlbCB0aGF0IGlkZW50aWZpZXMgdGhlIGljb27igJlzIGZ1bmN0aW9uLiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV1cbiAqIGZvciBhIGxpc3Qgb2YgaWNvbnMgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQW4gSWNvbldpZGdldCB3aXRoIGEgbGFiZWwgdmlhIExhYmVsV2lkZ2V0LlxuICogICAgIHZhciBteUljb24gPSBuZXcgT08udWkuSWNvbldpZGdldCgge1xuICogICAgICAgICAgICAgaWNvbjogJ2hlbHAnLFxuICogICAgICAgICAgICAgdGl0bGU6ICdIZWxwJ1xuICogICAgICAgICAgfSApLFxuICogICAgICAgICAgLy8gQ3JlYXRlIGEgbGFiZWwuXG4gKiAgICAgICAgICBpY29uTGFiZWwgPSBuZXcgT08udWkuTGFiZWxXaWRnZXQoIHtcbiAqICAgICAgICAgICAgICBsYWJlbDogJ0hlbHAnXG4gKiAgICAgICAgICB9ICk7XG4gKiAgICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIG15SWNvbi4kZWxlbWVudCwgaWNvbkxhYmVsLiRlbGVtZW50ICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0ljb25zLF9JbmRpY2F0b3JzLF9hbmRfTGFiZWxzI0ljb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSWNvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuSWNvbldpZGdldCA9IGZ1bmN0aW9uIE9vVWlJY29uV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5JY29uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uSWNvbkVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJGljb246IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRpdGxlZDogdGhpcy4kZWxlbWVudCB9ICkgKTtcblx0T08udWkubWl4aW4uTGFiZWxFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRsYWJlbDogdGhpcy4kZWxlbWVudCwgaW52aXNpYmxlTGFiZWw6IHRydWUgfSApICk7XG5cdE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRmbGFnZ2VkOiB0aGlzLiRlbGVtZW50IH0gKSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1pY29uV2lkZ2V0JyApO1xuXHQvLyBSZW1vdmUgY2xhc3MgYWRkZWQgYnkgTGFiZWxFbGVtZW50IGluaXRpYWxpemF0aW9uLiBJdCBjYXVzZXMgdW5leHBlY3RlZCBDU1MgdG8gYXBwbHkgd2hlblxuXHQvLyBuZXN0ZWQgaW4gb3RoZXIgd2lkZ2V0cywgYmVjYXVzZSB0aGlzIHdpZGdldCB1c2VkIHRvIG5vdCBtaXggaW4gTGFiZWxFbGVtZW50LlxuXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktbGFiZWxFbGVtZW50LWxhYmVsJyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5JY29uV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkljb25XaWRnZXQsIE9PLnVpLm1peGluLkljb25FbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5JY29uV2lkZ2V0LCBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5JY29uV2lkZ2V0LCBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkljb25XaWRnZXQsIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuSWNvbldpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdzcGFuJztcblxuLyoqXG4gKiBJbmRpY2F0b3JXaWRnZXRzIGNyZWF0ZSBpbmRpY2F0b3JzLCB3aGljaCBhcmUgc21hbGwgZ3JhcGhpY3MgdGhhdCBhcmUgZ2VuZXJhbGx5IHVzZWQgdG8gZHJhd1xuICogYXR0ZW50aW9uIHRvIHRoZSBzdGF0dXMgb2YgYW4gaXRlbSBvciB0byBjbGFyaWZ5IHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBjb250cm9sLiBGb3IgYSBsaXN0IG9mXG4gKiBpbmRpY2F0b3JzIGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQW4gaW5kaWNhdG9yIHdpZGdldC5cbiAqICAgICB2YXIgaW5kaWNhdG9yMSA9IG5ldyBPTy51aS5JbmRpY2F0b3JXaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGluZGljYXRvcjogJ3JlcXVpcmVkJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIC8vIENyZWF0ZSBhIGZpZWxkc2V0IGxheW91dCB0byBhZGQgYSBsYWJlbC5cbiAqICAgICAgICAgZmllbGRzZXQgPSBuZXcgT08udWkuRmllbGRzZXRMYXlvdXQoKTtcbiAqICAgICBmaWVsZHNldC5hZGRJdGVtcyggW1xuICogICAgICAgICBuZXcgT08udWkuRmllbGRMYXlvdXQoIGluZGljYXRvcjEsIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnQSByZXF1aXJlZCBpbmRpY2F0b3I6J1xuICogICAgICAgICB9IClcbiAqICAgICBdICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggZmllbGRzZXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSWNvbnMsX0luZGljYXRvcnMsX2FuZF9MYWJlbHMjSW5kaWNhdG9yc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuSW5kaWNhdG9yV2lkZ2V0ID0gZnVuY3Rpb24gT29VaUluZGljYXRvcldpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuSW5kaWNhdG9yV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkaW5kaWNhdG9yOiB0aGlzLiRlbGVtZW50IH0gKSApO1xuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICR0aXRsZWQ6IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkbGFiZWw6IHRoaXMuJGVsZW1lbnQsIGludmlzaWJsZUxhYmVsOiB0cnVlIH0gKSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1pbmRpY2F0b3JXaWRnZXQnICk7XG5cdC8vIFJlbW92ZSBjbGFzcyBhZGRlZCBieSBMYWJlbEVsZW1lbnQgaW5pdGlhbGl6YXRpb24uIEl0IGNhdXNlcyB1bmV4cGVjdGVkIENTUyB0byBhcHBseSB3aGVuXG5cdC8vIG5lc3RlZCBpbiBvdGhlciB3aWRnZXRzLCBiZWNhdXNlIHRoaXMgd2lkZ2V0IHVzZWQgdG8gbm90IG1peCBpbiBMYWJlbEVsZW1lbnQuXG5cdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS1sYWJlbEVsZW1lbnQtbGFiZWwnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLkluZGljYXRvcldpZGdldCwgT08udWkuV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5JbmRpY2F0b3JXaWRnZXQsIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkluZGljYXRvcldpZGdldCwgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuSW5kaWNhdG9yV2lkZ2V0LCBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5JbmRpY2F0b3JXaWRnZXQuc3RhdGljLnRhZ05hbWUgPSAnc3Bhbic7XG5cbi8qKlxuICogTGFiZWxXaWRnZXRzIGhlbHAgaWRlbnRpZnkgdGhlIGZ1bmN0aW9uIG9mIGludGVyZmFjZSBlbGVtZW50cy4gRWFjaCBMYWJlbFdpZGdldCBjYW5cbiAqIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIGBsYWJlbGAgb3B0aW9uIHRoYXQgaXMgc2V0IHRvIGEgc3RyaW5nLCBhIGxhYmVsIG5vZGUsIG9yIGEgZnVuY3Rpb246XG4gKlxuICogLSBTdHJpbmc6IGEgcGxhaW50ZXh0IHN0cmluZ1xuICogLSBqUXVlcnkgc2VsZWN0aW9uOiBhIGpRdWVyeSBzZWxlY3Rpb24sIHVzZWQgZm9yIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbGFpbnRleHQgbGFiZWwsIGUuZy4sIGFcbiAqICAgbGFiZWwgdGhhdCBpbmNsdWRlcyBhIGxpbmsgb3Igc3BlY2lhbCBzdHlsaW5nLCBzdWNoIGFzIGEgZ3JheSBjb2xvciBvciBhZGRpdGlvbmFsIGdyYXBoaWNhbCBlbGVtZW50cy5cbiAqIC0gRnVuY3Rpb246IGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2R1Y2UgYSBzdHJpbmcgaW4gdGhlIGZ1dHVyZS4gRnVuY3Rpb25zIGFyZSB1c2VkXG4gKiAgIGluIGNhc2VzIHdoZXJlIHRoZSB2YWx1ZSBvZiB0aGUgbGFiZWwgaXMgbm90IGN1cnJlbnRseSBkZWZpbmVkLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgTGFiZWxXaWRnZXQgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBhbiB7QGxpbmsgT08udWkuSW5wdXRXaWRnZXQgaW5wdXQgd2lkZ2V0fSwgd2hpY2hcbiAqIHdpbGwgY29tZSBpbnRvIGZvY3VzIHdoZW4gdGhlIGxhYmVsIGlzIGNsaWNrZWQuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gVHdvIExhYmVsV2lkZ2V0cy5cbiAqICAgICB2YXIgbGFiZWwxID0gbmV3IE9PLnVpLkxhYmVsV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ3BsYWludGV4dCBsYWJlbCdcbiAqICAgICAgICAgfSApLFxuICogICAgICAgICBsYWJlbDIgPSBuZXcgT08udWkuTGFiZWxXaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAkKCAnPGE+JyApLmF0dHIoICdocmVmJywgJ2RlZmF1bHQuaHRtbCcgKS50ZXh0KCAnalF1ZXJ5IGxhYmVsJyApXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgLy8gQ3JlYXRlIGEgZmllbGRzZXQgbGF5b3V0IHdpdGggZmllbGRzIGZvciBlYWNoIGV4YW1wbGUuXG4gKiAgICAgICAgIGZpZWxkc2V0ID0gbmV3IE9PLnVpLkZpZWxkc2V0TGF5b3V0KCk7XG4gKiAgICAgZmllbGRzZXQuYWRkSXRlbXMoIFtcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBsYWJlbDEgKSxcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBsYWJlbDIgKVxuICogICAgIF0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBmaWVsZHNldC4kZWxlbWVudCApO1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPTy51aS5JbnB1dFdpZGdldH0gW2lucHV0XSB7QGxpbmsgT08udWkuSW5wdXRXaWRnZXQgSW5wdXQgd2lkZ2V0fSB0aGF0IHVzZXMgdGhlIGxhYmVsLlxuICogIENsaWNraW5nIHRoZSBsYWJlbCB3aWxsIGZvY3VzIHRoZSBzcGVjaWZpZWQgaW5wdXQgZmllbGQuXG4gKi9cbk9PLnVpLkxhYmVsV2lkZ2V0ID0gZnVuY3Rpb24gT29VaUxhYmVsV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5MYWJlbFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkbGFiZWw6IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmlucHV0ID0gY29uZmlnLmlucHV0O1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdGlmICggdGhpcy5pbnB1dCApIHtcblx0XHRpZiAoIHRoaXMuaW5wdXQuZ2V0SW5wdXRJZCgpICkge1xuXHRcdFx0dGhpcy4kZWxlbWVudC5hdHRyKCAnZm9yJywgdGhpcy5pbnB1dC5nZXRJbnB1dElkKCkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kbGFiZWwub24oICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5pbnB1dC5zaW11bGF0ZUxhYmVsQ2xpY2soKTtcblx0XHRcdH0uYmluZCggdGhpcyApICk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1sYWJlbFdpZGdldCcgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuTGFiZWxXaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTGFiZWxXaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTGFiZWxXaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5MYWJlbFdpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdsYWJlbCc7XG5cbi8qKlxuICogUGVuZGluZ0VsZW1lbnQgaXMgYSBtaXhpbiB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIGVsZW1lbnRzIHRoYXQgbm90aWZ5IHVzZXJzIHRoYXQgc29tZXRoaW5nIGlzIGhhcHBlbmluZ1xuICogYW5kIHRoYXQgdGhleSBzaG91bGQgd2FpdCBiZWZvcmUgcHJvY2VlZGluZy4gVGhlIHBlbmRpbmcgc3RhdGUgaXMgdmlzdWFsbHkgcmVwcmVzZW50ZWQgd2l0aCBhIHBlbmRpbmdcbiAqIHRleHR1cmUgdGhhdCBhcHBlYXJzIGluIHRoZSBoZWFkIG9mIGEgcGVuZGluZyB7QGxpbmsgT08udWkuUHJvY2Vzc0RpYWxvZyBwcm9jZXNzIGRpYWxvZ30gb3IgaW4gdGhlIGlucHV0XG4gKiBmaWVsZCBvZiBhIHtAbGluayBPTy51aS5UZXh0SW5wdXRXaWRnZXQgdGV4dCBpbnB1dCB3aWRnZXR9LlxuICpcbiAqIEN1cnJlbnRseSwge0BsaW5rIE9PLnVpLkFjdGlvbldpZGdldCBBY3Rpb24gd2lkZ2V0c30sIHdoaWNoIG1peCBpbiB0aGlzIGNsYXNzLCBjYW4gYWxzbyBiZSBtYXJrZWQgYXMgcGVuZGluZywgYnV0IG9ubHkgd2hlblxuICogdXNlZCBpbiB7QGxpbmsgT08udWkuTWVzc2FnZURpYWxvZyBtZXNzYWdlIGRpYWxvZ3N9LiBUaGUgYmVoYXZpb3IgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIGFjdGlvbiB3aWRnZXRzIHVzZWRcbiAqIGluIHByb2Nlc3MgZGlhbG9ncy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICBmdW5jdGlvbiBNZXNzYWdlRGlhbG9nKCBjb25maWcgKSB7XG4gKiAgICAgICAgIE1lc3NhZ2VEaWFsb2cucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIE1lc3NhZ2VEaWFsb2csIE9PLnVpLk1lc3NhZ2VEaWFsb2cgKTtcbiAqXG4gKiAgICAgTWVzc2FnZURpYWxvZy5zdGF0aWMubmFtZSA9ICdteU1lc3NhZ2VEaWFsb2cnO1xuICogICAgIE1lc3NhZ2VEaWFsb2cuc3RhdGljLmFjdGlvbnMgPSBbXG4gKiAgICAgICAgIHsgYWN0aW9uOiAnc2F2ZScsIGxhYmVsOiAnRG9uZScsIGZsYWdzOiAncHJpbWFyeScgfSxcbiAqICAgICAgICAgeyBsYWJlbDogJ0NhbmNlbCcsIGZsYWdzOiAnc2FmZScgfVxuICogICAgIF07XG4gKlxuICogICAgIE1lc3NhZ2VEaWFsb2cucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIE1lc3NhZ2VEaWFsb2cucGFyZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7IHBhZGRlZDogdHJ1ZSB9ICk7XG4gKiAgICAgICAgIHRoaXMuY29udGVudC4kZWxlbWVudC5hcHBlbmQoICc8cD5DbGljayB0aGUgXFwnRG9uZVxcJyBhY3Rpb24gd2lkZ2V0IHRvIHNlZSBpdHMgcGVuZGluZyBzdGF0ZS4gTm90ZSB0aGF0IGFjdGlvbiB3aWRnZXRzIGNhbiBiZSBtYXJrZWQgcGVuZGluZyBpbiBtZXNzYWdlIGRpYWxvZ3MgYnV0IG5vdCBwcm9jZXNzIGRpYWxvZ3MuPC9wPicgKTtcbiAqICAgICAgICAgdGhpcy4kYm9keS5hcHBlbmQoIHRoaXMuY29udGVudC4kZWxlbWVudCApO1xuICogICAgIH07XG4gKiAgICAgTWVzc2FnZURpYWxvZy5wcm90b3R5cGUuZ2V0Qm9keUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgcmV0dXJuIDEwMDtcbiAqICAgICB9XG4gKiAgICAgTWVzc2FnZURpYWxvZy5wcm90b3R5cGUuZ2V0QWN0aW9uUHJvY2VzcyA9IGZ1bmN0aW9uICggYWN0aW9uICkge1xuICogICAgICAgICB2YXIgZGlhbG9nID0gdGhpcztcbiAqICAgICAgICAgaWYgKCBhY3Rpb24gPT09ICdzYXZlJyApIHtcbiAqICAgICAgICAgICAgIGRpYWxvZy5nZXRBY3Rpb25zKCkuZ2V0KHthY3Rpb25zOiAnc2F2ZSd9KVswXS5wdXNoUGVuZGluZygpO1xuICogICAgICAgICAgICAgcmV0dXJuIG5ldyBPTy51aS5Qcm9jZXNzKClcbiAqICAgICAgICAgICAgIC5uZXh0KCAxMDAwIClcbiAqICAgICAgICAgICAgIC5uZXh0KCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgICAgICAgICAgZGlhbG9nLmdldEFjdGlvbnMoKS5nZXQoe2FjdGlvbnM6ICdzYXZlJ30pWzBdLnBvcFBlbmRpbmcoKTtcbiAqICAgICAgICAgICAgIH0gKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICByZXR1cm4gTWVzc2FnZURpYWxvZy5wYXJlbnQucHJvdG90eXBlLmdldEFjdGlvblByb2Nlc3MuY2FsbCggdGhpcywgYWN0aW9uICk7XG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdmFyIHdpbmRvd01hbmFnZXIgPSBuZXcgT08udWkuV2luZG93TWFuYWdlcigpO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHdpbmRvd01hbmFnZXIuJGVsZW1lbnQgKTtcbiAqXG4gKiAgICAgdmFyIGRpYWxvZyA9IG5ldyBNZXNzYWdlRGlhbG9nKCk7XG4gKiAgICAgd2luZG93TWFuYWdlci5hZGRXaW5kb3dzKCBbIGRpYWxvZyBdICk7XG4gKiAgICAgd2luZG93TWFuYWdlci5vcGVuV2luZG93KCBkaWFsb2cgKTtcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJHBlbmRpbmddIEVsZW1lbnQgdG8gbWFyayBhcyBwZW5kaW5nLCBkZWZhdWx0cyB0byB0aGlzLiRlbGVtZW50XG4gKi9cbk9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluUGVuZGluZ0VsZW1lbnQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnBlbmRpbmcgPSAwO1xuXHR0aGlzLiRwZW5kaW5nID0gbnVsbDtcblxuXHQvLyBJbml0aWFsaXNhdGlvblxuXHR0aGlzLnNldFBlbmRpbmdFbGVtZW50KCBjb25maWcuJHBlbmRpbmcgfHwgdGhpcy4kZWxlbWVudCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5pdENsYXNzKCBPTy51aS5taXhpbi5QZW5kaW5nRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU2V0IHRoZSBwZW5kaW5nIGVsZW1lbnQgKGFuZCBjbGVhbiB1cCBhbnkgZXhpc3Rpbmcgb25lKS5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gJHBlbmRpbmcgVGhlIGVsZW1lbnQgdG8gc2V0IHRvIHBlbmRpbmcuXG4gKi9cbk9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50LnByb3RvdHlwZS5zZXRQZW5kaW5nRWxlbWVudCA9IGZ1bmN0aW9uICggJHBlbmRpbmcgKSB7XG5cdGlmICggdGhpcy4kcGVuZGluZyApIHtcblx0XHR0aGlzLiRwZW5kaW5nLnJlbW92ZUNsYXNzKCAnb28tdWktcGVuZGluZ0VsZW1lbnQtcGVuZGluZycgKTtcblx0fVxuXG5cdHRoaXMuJHBlbmRpbmcgPSAkcGVuZGluZztcblx0aWYgKCB0aGlzLnBlbmRpbmcgPiAwICkge1xuXHRcdHRoaXMuJHBlbmRpbmcuYWRkQ2xhc3MoICdvby11aS1wZW5kaW5nRWxlbWVudC1wZW5kaW5nJyApO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgcGVuZGluZy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBFbGVtZW50IGlzIHBlbmRpbmdcbiAqL1xuT08udWkubWl4aW4uUGVuZGluZ0VsZW1lbnQucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICEhdGhpcy5wZW5kaW5nO1xufTtcblxuLyoqXG4gKiBJbmNyZWFzZSB0aGUgcGVuZGluZyBjb3VudGVyLiBUaGUgcGVuZGluZyBzdGF0ZSB3aWxsIHJlbWFpbiBhY3RpdmUgdW50aWwgdGhlIGNvdW50ZXIgaXMgemVyb1xuICogKGkuZS4sIHRoZSBudW1iZXIgb2YgY2FsbHMgdG8gI3B1c2hQZW5kaW5nIGFuZCAjcG9wUGVuZGluZyBpcyB0aGUgc2FtZSkuXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5QZW5kaW5nRWxlbWVudC5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy5wZW5kaW5nID09PSAwICkge1xuXHRcdHRoaXMuJHBlbmRpbmcuYWRkQ2xhc3MoICdvby11aS1wZW5kaW5nRWxlbWVudC1wZW5kaW5nJyApO1xuXHRcdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG5cdH1cblx0dGhpcy5wZW5kaW5nKys7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlIHRoZSBwZW5kaW5nIGNvdW50ZXIuIFRoZSBwZW5kaW5nIHN0YXRlIHdpbGwgcmVtYWluIGFjdGl2ZSB1bnRpbCB0aGUgY291bnRlciBpcyB6ZXJvXG4gKiAoaS5lLiwgdGhlIG51bWJlciBvZiBjYWxscyB0byAjcHVzaFBlbmRpbmcgYW5kICNwb3BQZW5kaW5nIGlzIHRoZSBzYW1lKS5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50LnByb3RvdHlwZS5wb3BQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMucGVuZGluZyA9PT0gMSApIHtcblx0XHR0aGlzLiRwZW5kaW5nLnJlbW92ZUNsYXNzKCAnb28tdWktcGVuZGluZ0VsZW1lbnQtcGVuZGluZycgKTtcblx0XHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXHR9XG5cdHRoaXMucGVuZGluZyA9IE1hdGgubWF4KCAwLCB0aGlzLnBlbmRpbmcgLSAxICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVsZW1lbnQgdGhhdCB3aWxsIHN0aWNrIGFkamFjZW50IHRvIGEgc3BlY2lmaWVkIGNvbnRhaW5lciwgZXZlbiB3aGVuIGl0IGlzIGluc2VydGVkIGVsc2V3aGVyZVxuICogaW4gdGhlIGRvY3VtZW50IChmb3IgZXhhbXBsZSwgaW4gYW4gT08udWkuV2luZG93J3MgJG92ZXJsYXkpLlxuICpcbiAqIFRoZSBlbGVtZW50cydzIHBvc2l0aW9uIGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgbWFpbnRhaW5lZCB3aGVuIHdpbmRvdyBpcyByZXNpemVkIG9yIHRoZVxuICogcGFnZSBpcyBzY3JvbGxlZC4gSWYgeW91IHJlcG9zaXRpb24gdGhlIGNvbnRhaW5lciBtYW51YWxseSwgeW91IGhhdmUgdG8gY2FsbCAjcG9zaXRpb24gdG8gbWFrZVxuICogc3VyZSB0aGUgZWxlbWVudCBpcyBzdGlsbCBwbGFjZWQgY29ycmVjdGx5LlxuICpcbiAqIEFzIHBvc2l0aW9uaW5nIGlzIG9ubHkgcG9zc2libGUgd2hlbiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgY29udGFpbmVyIGFyZSBhdHRhY2hlZCB0byB0aGUgRE9NXG4gKiBhbmQgdmlzaWJsZSwgaXQncyBvbmx5IGRvbmUgYWZ0ZXIgeW91IGNhbGwgI3RvZ2dsZVBvc2l0aW9uaW5nLiBZb3UgbWlnaHQgd2FudCB0byBkbyB0aGlzIGluc2lkZVxuICogdGhlICN0b2dnbGUgbWV0aG9kIHRvIGRpc3BsYXkgYSBmbG9hdGluZyBwb3B1cCwgZm9yIGV4YW1wbGUuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2pRdWVyeX0gWyRmbG9hdGFibGVdIE5vZGUgdG8gcG9zaXRpb24sIGFzc2lnbmVkIHRvICMkZmxvYXRhYmxlLCBvbWl0IHRvIHVzZSAjJGVsZW1lbnRcbiAqIEBjZmcge2pRdWVyeX0gWyRmbG9hdGFibGVDb250YWluZXJdIE5vZGUgdG8gcG9zaXRpb24gYWRqYWNlbnQgdG9cbiAqIEBjZmcge3N0cmluZ30gW3ZlcnRpY2FsUG9zaXRpb249J2JlbG93J10gV2hlcmUgdG8gcG9zaXRpb24gJGZsb2F0YWJsZSB2ZXJ0aWNhbGx5OlxuICogICdiZWxvdyc6IERpcmVjdGx5IGJlbG93ICRmbG9hdGFibGVDb250YWluZXIsIGFsaWduaW5nIGYncyB0b3AgZWRnZSB3aXRoIGZDJ3MgYm90dG9tIGVkZ2VcbiAqICAnYWJvdmUnOiBEaXJlY3RseSBhYm92ZSAkZmxvYXRhYmxlQ29udGFpbmVyLCBhbGlnbmluZyBmJ3MgYm90dG9tIGVkZ2Ugd2l0aCBmQydzIHRvcCBlZGdlXG4gKiAgJ3RvcCc6IEFsaWduIHRoZSB0b3AgZWRnZSB3aXRoICRmbG9hdGFibGVDb250YWluZXIncyB0b3AgZWRnZVxuICogICdib3R0b20nOiBBbGlnbiB0aGUgYm90dG9tIGVkZ2Ugd2l0aCAkZmxvYXRhYmxlQ29udGFpbmVyJ3MgYm90dG9tIGVkZ2VcbiAqICAnY2VudGVyJzogVmVydGljYWxseSBhbGlnbiB0aGUgY2VudGVyIHdpdGggJGZsb2F0YWJsZUNvbnRhaW5lcidzIGNlbnRlclxuICogQGNmZyB7c3RyaW5nfSBbaG9yaXpvbnRhbFBvc2l0aW9uPSdzdGFydCddIFdoZXJlIHRvIHBvc2l0aW9uICRmbG9hdGFibGUgaG9yaXpvbnRhbGx5OlxuICogICdiZWZvcmUnOiBEaXJlY3RseSBiZWZvcmUgJGZsb2F0YWJsZUNvbnRhaW5lciwgYWxpZ25pbmcgZidzIGVuZCBlZGdlIHdpdGggZkMncyBzdGFydCBlZGdlXG4gKiAgJ2FmdGVyJzogRGlyZWN0bHkgYWZ0ZXIgJGZsb2F0YWJsZUNvbnRhaW5lciwgYWxpZ25pbmcgZidzIHN0YXJ0IGVkZ2Ugd2l0aCBmQydzIGVuZCBlZGdlXG4gKiAgJ3N0YXJ0JzogQWxpZ24gdGhlIHN0YXJ0IChsZWZ0IGluIExUUiwgcmlnaHQgaW4gUlRMKSBlZGdlIHdpdGggJGZsb2F0YWJsZUNvbnRhaW5lcidzIHN0YXJ0IGVkZ2VcbiAqICAnZW5kJzogQWxpZ24gdGhlIGVuZCAocmlnaHQgaW4gTFRSLCBsZWZ0IGluIFJUTCkgZWRnZSB3aXRoICRmbG9hdGFibGVDb250YWluZXIncyBlbmQgZWRnZVxuICogICdjZW50ZXInOiBIb3Jpem9udGFsbHkgYWxpZ24gdGhlIGNlbnRlciB3aXRoICRmbG9hdGFibGVDb250YWluZXIncyBjZW50ZXJcbiAqIEBjZmcge2Jvb2xlYW59IFtoaWRlV2hlbk91dE9mVmlldz10cnVlXSBXaGV0aGVyIHRvIGhpZGUgdGhlIGZsb2F0YWJsZSBlbGVtZW50IGlmIHRoZSBjb250YWluZXJcbiAqICBpcyBvdXQgb2Ygdmlld1xuICovXG5PTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluRmxvYXRhYmxlRWxlbWVudCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuJGZsb2F0YWJsZSA9IG51bGw7XG5cdHRoaXMuJGZsb2F0YWJsZUNvbnRhaW5lciA9IG51bGw7XG5cdHRoaXMuJGZsb2F0YWJsZVdpbmRvdyA9IG51bGw7XG5cdHRoaXMuJGZsb2F0YWJsZUNsb3Nlc3RTY3JvbGxhYmxlID0gbnVsbDtcblx0dGhpcy5mbG9hdGFibGVPdXRPZlZpZXcgPSBmYWxzZTtcblx0dGhpcy5vbkZsb2F0YWJsZVNjcm9sbEhhbmRsZXIgPSB0aGlzLnBvc2l0aW9uLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5vbkZsb2F0YWJsZVdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB0aGlzLnBvc2l0aW9uLmJpbmQoIHRoaXMgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnNldEZsb2F0YWJsZUNvbnRhaW5lciggY29uZmlnLiRmbG9hdGFibGVDb250YWluZXIgKTtcblx0dGhpcy5zZXRGbG9hdGFibGVFbGVtZW50KCBjb25maWcuJGZsb2F0YWJsZSB8fCB0aGlzLiRlbGVtZW50ICk7XG5cdHRoaXMuc2V0VmVydGljYWxQb3NpdGlvbiggY29uZmlnLnZlcnRpY2FsUG9zaXRpb24gfHwgJ2JlbG93JyApO1xuXHR0aGlzLnNldEhvcml6b250YWxQb3NpdGlvbiggY29uZmlnLmhvcml6b250YWxQb3NpdGlvbiB8fCAnc3RhcnQnICk7XG5cdHRoaXMuaGlkZVdoZW5PdXRPZlZpZXcgPSBjb25maWcuaGlkZVdoZW5PdXRPZlZpZXcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWNvbmZpZy5oaWRlV2hlbk91dE9mVmlldztcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgZmxvYXRhYmxlIGVsZW1lbnQuXG4gKlxuICogSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgaXQgd2lsbCBiZSBjbGVhbmVkIHVwIGJlZm9yZSBzZXR0aW5nIHVwIHRoZSBuZXcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGZsb2F0YWJsZSBFbGVtZW50IHRvIG1ha2UgZmxvYXRhYmxlXG4gKi9cbk9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnQucHJvdG90eXBlLnNldEZsb2F0YWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoICRmbG9hdGFibGUgKSB7XG5cdGlmICggdGhpcy4kZmxvYXRhYmxlICkge1xuXHRcdHRoaXMuJGZsb2F0YWJsZS5yZW1vdmVDbGFzcyggJ29vLXVpLWZsb2F0YWJsZUVsZW1lbnQtZmxvYXRhYmxlJyApO1xuXHRcdHRoaXMuJGZsb2F0YWJsZS5jc3MoIHsgbGVmdDogJycsIHRvcDogJycgfSApO1xuXHR9XG5cblx0dGhpcy4kZmxvYXRhYmxlID0gJGZsb2F0YWJsZS5hZGRDbGFzcyggJ29vLXVpLWZsb2F0YWJsZUVsZW1lbnQtZmxvYXRhYmxlJyApO1xuXHR0aGlzLnBvc2l0aW9uKCk7XG59O1xuXG4vKipcbiAqIFNldCBmbG9hdGFibGUgY29udGFpbmVyLlxuICpcbiAqIFRoZSBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeXxudWxsfSAkZmxvYXRhYmxlQ29udGFpbmVyIENvbnRhaW5lciB0byBrZWVwIHZpc2libGUsIG9yIG51bGwgdG8gdW5zZXRcbiAqL1xuT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5wcm90b3R5cGUuc2V0RmxvYXRhYmxlQ29udGFpbmVyID0gZnVuY3Rpb24gKCAkZmxvYXRhYmxlQ29udGFpbmVyICkge1xuXHR0aGlzLiRmbG9hdGFibGVDb250YWluZXIgPSAkZmxvYXRhYmxlQ29udGFpbmVyO1xuXHRpZiAoIHRoaXMuJGZsb2F0YWJsZSApIHtcblx0XHR0aGlzLnBvc2l0aW9uKCk7XG5cdH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIGhvdyB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIHZlcnRpY2FsbHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uICdiZWxvdycsICdhYm92ZScsICd0b3AnLCAnYm90dG9tJyBvciAnY2VudGVyJ1xuICovXG5PTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50LnByb3RvdHlwZS5zZXRWZXJ0aWNhbFBvc2l0aW9uID0gZnVuY3Rpb24gKCBwb3NpdGlvbiApIHtcblx0aWYgKCBbICdiZWxvdycsICdhYm92ZScsICd0b3AnLCAnYm90dG9tJywgJ2NlbnRlcicgXS5pbmRleE9mKCBwb3NpdGlvbiApID09PSAtMSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIHZhbHVlIGZvciB2ZXJ0aWNhbCBwb3NpdGlvbjogJyArIHBvc2l0aW9uICk7XG5cdH1cblx0aWYgKCB0aGlzLnZlcnRpY2FsUG9zaXRpb24gIT09IHBvc2l0aW9uICkge1xuXHRcdHRoaXMudmVydGljYWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdGlmICggdGhpcy4kZmxvYXRhYmxlICkge1xuXHRcdFx0dGhpcy5wb3NpdGlvbigpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDaGFuZ2UgaG93IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgaG9yaXpvbnRhbGx5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAnYmVmb3JlJywgJ2FmdGVyJywgJ3N0YXJ0JywgJ2VuZCcgb3IgJ2NlbnRlcidcbiAqL1xuT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5wcm90b3R5cGUuc2V0SG9yaXpvbnRhbFBvc2l0aW9uID0gZnVuY3Rpb24gKCBwb3NpdGlvbiApIHtcblx0aWYgKCBbICdiZWZvcmUnLCAnYWZ0ZXInLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicgXS5pbmRleE9mKCBwb3NpdGlvbiApID09PSAtMSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIHZhbHVlIGZvciBob3Jpem9udGFsIHBvc2l0aW9uOiAnICsgcG9zaXRpb24gKTtcblx0fVxuXHRpZiAoIHRoaXMuaG9yaXpvbnRhbFBvc2l0aW9uICE9PSBwb3NpdGlvbiApIHtcblx0XHR0aGlzLmhvcml6b250YWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdGlmICggdGhpcy4kZmxvYXRhYmxlICkge1xuXHRcdFx0dGhpcy5wb3NpdGlvbigpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBUb2dnbGUgcG9zaXRpb25pbmcuXG4gKlxuICogRG8gbm90IHR1cm4gcG9zaXRpb25pbmcgb24gdW50aWwgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdmlzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwb3NpdGlvbmluZ10gRW5hYmxlIHBvc2l0aW9uaW5nLCBvbWl0IHRvIHRvZ2dsZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50LnByb3RvdHlwZS50b2dnbGVQb3NpdGlvbmluZyA9IGZ1bmN0aW9uICggcG9zaXRpb25pbmcgKSB7XG5cdHZhciBjbG9zZXN0U2Nyb2xsYWJsZU9mQ29udGFpbmVyO1xuXG5cdGlmICggIXRoaXMuJGZsb2F0YWJsZSB8fCAhdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cG9zaXRpb25pbmcgPSBwb3NpdGlvbmluZyA9PT0gdW5kZWZpbmVkID8gIXRoaXMucG9zaXRpb25pbmcgOiAhIXBvc2l0aW9uaW5nO1xuXG5cdGlmICggcG9zaXRpb25pbmcgJiYgIXRoaXMud2FybmVkVW5hdHRhY2hlZCAmJiAhdGhpcy5pc0VsZW1lbnRBdHRhY2hlZCgpICkge1xuXHRcdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ0Zsb2F0YWJsZUVsZW1lbnQjdG9nZ2xlUG9zaXRpb25pbmc6IEJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLCB0aGUgZWxlbWVudCBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uJyApO1xuXHRcdHRoaXMud2FybmVkVW5hdHRhY2hlZCA9IHRydWU7XG5cdH1cblxuXHRpZiAoIHRoaXMucG9zaXRpb25pbmcgIT09IHBvc2l0aW9uaW5nICkge1xuXHRcdHRoaXMucG9zaXRpb25pbmcgPSBwb3NpdGlvbmluZztcblxuXHRcdGNsb3Nlc3RTY3JvbGxhYmxlT2ZDb250YWluZXIgPSBPTy51aS5FbGVtZW50LnN0YXRpYy5nZXRDbG9zZXN0U2Nyb2xsYWJsZUNvbnRhaW5lciggdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyWyAwIF0gKTtcblx0XHQvLyBJZiB0aGUgc2Nyb2xsYWJsZSBpcyB0aGUgcm9vdCwgd2UgaGF2ZSB0byBsaXN0ZW4gdG8gc2Nyb2xsIGV2ZW50c1xuXHRcdC8vIG9uIHRoZSB3aW5kb3cgYmVjYXVzZSBvZiBicm93c2VyIGluY29uc2lzdGVuY2llcy5cblx0XHRpZiAoICQoIGNsb3Nlc3RTY3JvbGxhYmxlT2ZDb250YWluZXIgKS5pcyggJ2h0bWwsIGJvZHknICkgKSB7XG5cdFx0XHRjbG9zZXN0U2Nyb2xsYWJsZU9mQ29udGFpbmVyID0gT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0V2luZG93KCBjbG9zZXN0U2Nyb2xsYWJsZU9mQ29udGFpbmVyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwb3NpdGlvbmluZyApIHtcblx0XHRcdHRoaXMuJGZsb2F0YWJsZVdpbmRvdyA9ICQoIHRoaXMuZ2V0RWxlbWVudFdpbmRvdygpICk7XG5cdFx0XHR0aGlzLiRmbG9hdGFibGVXaW5kb3cub24oICdyZXNpemUnLCB0aGlzLm9uRmxvYXRhYmxlV2luZG93UmVzaXplSGFuZGxlciApO1xuXG5cdFx0XHR0aGlzLiRmbG9hdGFibGVDbG9zZXN0U2Nyb2xsYWJsZSA9ICQoIGNsb3Nlc3RTY3JvbGxhYmxlT2ZDb250YWluZXIgKTtcblx0XHRcdHRoaXMuJGZsb2F0YWJsZUNsb3Nlc3RTY3JvbGxhYmxlLm9uKCAnc2Nyb2xsJywgdGhpcy5vbkZsb2F0YWJsZVNjcm9sbEhhbmRsZXIgKTtcblxuXHRcdFx0Ly8gSW5pdGlhbCBwb3NpdGlvbiBhZnRlciB2aXNpYmxlXG5cdFx0XHR0aGlzLnBvc2l0aW9uKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdGhpcy4kZmxvYXRhYmxlV2luZG93ICkge1xuXHRcdFx0XHR0aGlzLiRmbG9hdGFibGVXaW5kb3cub2ZmKCAncmVzaXplJywgdGhpcy5vbkZsb2F0YWJsZVdpbmRvd1Jlc2l6ZUhhbmRsZXIgKTtcblx0XHRcdFx0dGhpcy4kZmxvYXRhYmxlV2luZG93ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLiRmbG9hdGFibGVDbG9zZXN0U2Nyb2xsYWJsZSApIHtcblx0XHRcdFx0dGhpcy4kZmxvYXRhYmxlQ2xvc2VzdFNjcm9sbGFibGUub2ZmKCAnc2Nyb2xsJywgdGhpcy5vbkZsb2F0YWJsZVNjcm9sbEhhbmRsZXIgKTtcblx0XHRcdFx0dGhpcy4kZmxvYXRhYmxlQ2xvc2VzdFNjcm9sbGFibGUgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLiRmbG9hdGFibGUuY3NzKCB7IGxlZnQ6ICcnLCByaWdodDogJycsIHRvcDogJycgfSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0IG9mIHRoZSBnaXZlbiBjb250YWluZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudFxuICogQHBhcmFtIHtqUXVlcnl9ICRjb250YWluZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbk9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnQucHJvdG90eXBlLmlzRWxlbWVudEluVmlld3BvcnQgPSBmdW5jdGlvbiAoICRlbGVtZW50LCAkY29udGFpbmVyICkge1xuXHR2YXIgZWxlbVJlY3QsIGNvbnRSZWN0LCB0b3BFZGdlSW5Cb3VuZHMsIGJvdHRvbUVkZ2VJbkJvdW5kcywgbGVmdEVkZ2VJbkJvdW5kcywgcmlnaHRFZGdlSW5Cb3VuZHMsXG5cdFx0c3RhcnRFZGdlSW5Cb3VuZHMsIGVuZEVkZ2VJbkJvdW5kcywgdmlld3BvcnRTcGFjaW5nLFxuXHRcdGRpcmVjdGlvbiA9ICRlbGVtZW50LmNzcyggJ2RpcmVjdGlvbicgKTtcblxuXHRlbGVtUmVjdCA9ICRlbGVtZW50WyAwIF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGlmICggJGNvbnRhaW5lclsgMCBdID09PSB3aW5kb3cgKSB7XG5cdFx0dmlld3BvcnRTcGFjaW5nID0gT08udWkuZ2V0Vmlld3BvcnRTcGFjaW5nKCk7XG5cdFx0Y29udFJlY3QgPSB7XG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcblx0XHRcdGJvdHRvbTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXHRcdH07XG5cdFx0Y29udFJlY3QudG9wICs9IHZpZXdwb3J0U3BhY2luZy50b3A7XG5cdFx0Y29udFJlY3QubGVmdCArPSB2aWV3cG9ydFNwYWNpbmcubGVmdDtcblx0XHRjb250UmVjdC5yaWdodCAtPSB2aWV3cG9ydFNwYWNpbmcucmlnaHQ7XG5cdFx0Y29udFJlY3QuYm90dG9tIC09IHZpZXdwb3J0U3BhY2luZy5ib3R0b207XG5cdH0gZWxzZSB7XG5cdFx0Y29udFJlY3QgPSAkY29udGFpbmVyWyAwIF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdH1cblxuXHR0b3BFZGdlSW5Cb3VuZHMgPSBlbGVtUmVjdC50b3AgPj0gY29udFJlY3QudG9wICYmIGVsZW1SZWN0LnRvcCA8PSBjb250UmVjdC5ib3R0b207XG5cdGJvdHRvbUVkZ2VJbkJvdW5kcyA9IGVsZW1SZWN0LmJvdHRvbSA+PSBjb250UmVjdC50b3AgJiYgZWxlbVJlY3QuYm90dG9tIDw9IGNvbnRSZWN0LmJvdHRvbTtcblx0bGVmdEVkZ2VJbkJvdW5kcyA9IGVsZW1SZWN0LmxlZnQgPj0gY29udFJlY3QubGVmdCAmJiBlbGVtUmVjdC5sZWZ0IDw9IGNvbnRSZWN0LnJpZ2h0O1xuXHRyaWdodEVkZ2VJbkJvdW5kcyA9IGVsZW1SZWN0LnJpZ2h0ID49IGNvbnRSZWN0LmxlZnQgJiYgZWxlbVJlY3QucmlnaHQgPD0gY29udFJlY3QucmlnaHQ7XG5cdGlmICggZGlyZWN0aW9uID09PSAncnRsJyApIHtcblx0XHRzdGFydEVkZ2VJbkJvdW5kcyA9IHJpZ2h0RWRnZUluQm91bmRzO1xuXHRcdGVuZEVkZ2VJbkJvdW5kcyA9IGxlZnRFZGdlSW5Cb3VuZHM7XG5cdH0gZWxzZSB7XG5cdFx0c3RhcnRFZGdlSW5Cb3VuZHMgPSBsZWZ0RWRnZUluQm91bmRzO1xuXHRcdGVuZEVkZ2VJbkJvdW5kcyA9IHJpZ2h0RWRnZUluQm91bmRzO1xuXHR9XG5cblx0aWYgKCB0aGlzLnZlcnRpY2FsUG9zaXRpb24gPT09ICdiZWxvdycgJiYgIWJvdHRvbUVkZ2VJbkJvdW5kcyApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKCB0aGlzLnZlcnRpY2FsUG9zaXRpb24gPT09ICdhYm92ZScgJiYgIXRvcEVkZ2VJbkJvdW5kcyApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKCB0aGlzLmhvcml6b250YWxQb3NpdGlvbiA9PT0gJ2JlZm9yZScgJiYgIXN0YXJ0RWRnZUluQm91bmRzICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoIHRoaXMuaG9yaXpvbnRhbFBvc2l0aW9uID09PSAnYWZ0ZXInICYmICFlbmRFZGdlSW5Cb3VuZHMgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gVGhlIG90aGVyIHBvc2l0aW9uaW5nIHZhbHVlcyBhcmUgYWxsIGFib3V0IGJlaW5nIGluc2lkZSB0aGUgY29udGFpbmVyLFxuXHQvLyBzbyBpbiB0aG9zZSBjYXNlcyBhbGwgd2UgY2FyZSBhYm91dCBpcyB0aGF0IGFueSBwYXJ0IG9mIHRoZSBjb250YWluZXIgaXMgdmlzaWJsZS5cblx0cmV0dXJuIGVsZW1SZWN0LnRvcCA8PSBjb250UmVjdC5ib3R0b20gJiYgZWxlbVJlY3QuYm90dG9tID49IGNvbnRSZWN0LnRvcCAmJlxuXHRcdGVsZW1SZWN0LmxlZnQgPD0gY29udFJlY3QucmlnaHQgJiYgZWxlbVJlY3QucmlnaHQgPj0gY29udFJlY3QubGVmdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZsb2F0YWJsZSBpcyBoaWRkZW4gdG8gdGhlIHVzZXIgYmVjYXVzZSBpdCB3YXMgb2Zmc2NyZWVuLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZsb2F0YWJsZSBpcyBvdXQgb2Ygdmlld1xuICovXG5PTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50LnByb3RvdHlwZS5pc0Zsb2F0YWJsZU91dE9mVmlldyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZmxvYXRhYmxlT3V0T2ZWaWV3O1xufTtcblxuLyoqXG4gKiBQb3NpdGlvbiB0aGUgZmxvYXRhYmxlIGJlbG93IGl0cyBjb250YWluZXIuXG4gKlxuICogVGhpcyBzaG91bGQgb25seSBiZSBkb25lIHdoZW4gYm90aCBvZiB0aGVtIGFyZSBhdHRhY2hlZCB0byB0aGUgRE9NIGFuZCB2aXNpYmxlLlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMucG9zaXRpb25pbmcgKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpZiAoICEoXG5cdFx0Ly8gVG8gY29udGludWUsIHNvbWUgdGhpbmdzIG5lZWQgdG8gYmUgdHJ1ZTpcblx0XHQvLyBUaGUgZWxlbWVudCBtdXN0IGFjdHVhbGx5IGJlIGluIHRoZSBET01cblx0XHR0aGlzLmlzRWxlbWVudEF0dGFjaGVkKCkgJiYgKFxuXHRcdFx0Ly8gVGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBpcyB0aGUgY3VycmVudCB3aW5kb3dcblx0XHRcdHRoaXMuJGZsb2F0YWJsZUNsb3Nlc3RTY3JvbGxhYmxlWyAwIF0gPT09IHRoaXMuZ2V0RWxlbWVudFdpbmRvdygpIHx8XG5cdFx0XHQvLyBPUiBpcyBhbiBlbGVtZW50IGluIHRoZSBlbGVtZW50J3MgRE9NXG5cdFx0XHQkLmNvbnRhaW5zKCB0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLCB0aGlzLiRmbG9hdGFibGVDbG9zZXN0U2Nyb2xsYWJsZVsgMCBdIClcblx0XHQpXG5cdCkgKSB7XG5cdFx0Ly8gQWJvcnQgZWFybHkgaWYgaW1wb3J0YW50IHBhcnRzIG9mIHRoZSB3aWRnZXQgYXJlIG5vIGxvbmdlciBhdHRhY2hlZCB0byB0aGUgRE9NXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aGlzLmZsb2F0YWJsZU91dE9mVmlldyA9IHRoaXMuaGlkZVdoZW5PdXRPZlZpZXcgJiYgIXRoaXMuaXNFbGVtZW50SW5WaWV3cG9ydCggdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLCB0aGlzLiRmbG9hdGFibGVDbG9zZXN0U2Nyb2xsYWJsZSApO1xuXHRpZiAoIHRoaXMuZmxvYXRhYmxlT3V0T2ZWaWV3ICkge1xuXHRcdHRoaXMuJGZsb2F0YWJsZS5hZGRDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuJGZsb2F0YWJsZS5yZW1vdmVDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXHR9XG5cblx0dGhpcy4kZmxvYXRhYmxlLmNzcyggdGhpcy5jb21wdXRlUG9zaXRpb24oKSApO1xuXG5cdC8vIFdlIHVwZGF0ZWQgdGhlIHBvc2l0aW9uLCBzbyByZS1ldmFsdWF0ZSB0aGUgY2xpcHBpbmcgc3RhdGUuXG5cdC8vIChDbGlwcGFibGVFbGVtZW50IGRvZXMgbm90IGxpc3RlbiB0byAnc2Nyb2xsJyBldmVudHMgb24gJGZsb2F0YWJsZUNvbnRhaW5lcidzIHBhcmVudCwgYW5kIHNvXG5cdC8vIHdpbGwgbm90IG5vdGljZSB0aGUgbmVlZCB0byB1cGRhdGUgaXRzZWxmLilcblx0Ly8gVE9ETzogVGhpcyBpcyB0ZXJyaWJsZSwgd2Ugc2hvdWxkbid0IG5lZWQgdG8ga25vdyBhYm91dCBDbGlwcGFibGVFbGVtZW50IGF0IGFsbCBoZXJlLiBXaHkgZG9lc1xuXHQvLyBpdCBub3QgbGlzdGVuIHRvIHRoZSByaWdodCBldmVudHMgaW4gdGhlIHJpZ2h0IHBsYWNlcz9cblx0aWYgKCB0aGlzLmNsaXAgKSB7XG5cdFx0dGhpcy5jbGlwKCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBob3cgIyRmbG9hdGFibGUgc2hvdWxkIGJlIHBvc2l0aW9uZWQgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mICMkZmxvYXRhYmxlQ29udGFpbmVyXG4gKiBhbmQgdGhlIHBvc2l0aW9uaW5nIHNldHRpbmdzLiBUaGlzIGlzIGEgaGVscGVyIGZvciAjcG9zaXRpb24gdGhhdCBzaG91bGRuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5LFxuICogYnV0IG1heSBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMgaWYgdGhleSB3YW50IHRvIGNoYW5nZSBvciBhZGQgdG8gdGhlIHBvc2l0aW9uaW5nIGxvZ2ljLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gTmV3IHBvc2l0aW9uIHRvIGFwcGx5IHdpdGggLmNzcygpLiBLZXlzIGFyZSAndG9wJywgJ2xlZnQnLCAnYm90dG9tJyBhbmQgJ3JpZ2h0Jy5cbiAqL1xuT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5wcm90b3R5cGUuY29tcHV0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaXNCb2R5LCBzY3JvbGxhYmxlWCwgc2Nyb2xsYWJsZVksIGNvbnRhaW5lclBvcyxcblx0XHRob3JpelNjcm9sbGJhckhlaWdodCwgdmVydFNjcm9sbGJhcldpZHRoLCBzY3JvbGxUb3AsIHNjcm9sbExlZnQsXG5cdFx0bmV3UG9zID0geyB0b3A6ICcnLCBsZWZ0OiAnJywgYm90dG9tOiAnJywgcmlnaHQ6ICcnIH0sXG5cdFx0ZGlyZWN0aW9uID0gdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLmNzcyggJ2RpcmVjdGlvbicgKSxcblx0XHQkb2Zmc2V0UGFyZW50ID0gdGhpcy4kZmxvYXRhYmxlLm9mZnNldFBhcmVudCgpO1xuXG5cdGlmICggJG9mZnNldFBhcmVudC5pcyggJ2h0bWwnICkgKSB7XG5cdFx0Ly8gVGhlIGlubmVySGVpZ2h0L1dpZHRoIGFuZCBjbGllbnRIZWlnaHQvV2lkdGggY2FsY3VsYXRpb25zIGRvbid0IHdvcmsgd2VsbCBvbiB0aGVcblx0XHQvLyA8aHRtbD4gZWxlbWVudCwgYnV0IHRoZXkgZG8gd29yayBvbiB0aGUgPGJvZHk+XG5cdFx0JG9mZnNldFBhcmVudCA9ICQoICRvZmZzZXRQYXJlbnRbIDAgXS5vd25lckRvY3VtZW50LmJvZHkgKTtcblx0fVxuXHRpc0JvZHkgPSAkb2Zmc2V0UGFyZW50LmlzKCAnYm9keScgKTtcblx0c2Nyb2xsYWJsZVggPSAkb2Zmc2V0UGFyZW50LmNzcyggJ292ZXJmbG93LXgnICkgPT09ICdzY3JvbGwnIHx8ICRvZmZzZXRQYXJlbnQuY3NzKCAnb3ZlcmZsb3cteCcgKSA9PT0gJ2F1dG8nO1xuXHRzY3JvbGxhYmxlWSA9ICRvZmZzZXRQYXJlbnQuY3NzKCAnb3ZlcmZsb3cteScgKSA9PT0gJ3Njcm9sbCcgfHwgJG9mZnNldFBhcmVudC5jc3MoICdvdmVyZmxvdy15JyApID09PSAnYXV0byc7XG5cblx0dmVydFNjcm9sbGJhcldpZHRoID0gJG9mZnNldFBhcmVudC5pbm5lcldpZHRoKCkgLSAkb2Zmc2V0UGFyZW50LnByb3AoICdjbGllbnRXaWR0aCcgKTtcblx0aG9yaXpTY3JvbGxiYXJIZWlnaHQgPSAkb2Zmc2V0UGFyZW50LmlubmVySGVpZ2h0KCkgLSAkb2Zmc2V0UGFyZW50LnByb3AoICdjbGllbnRIZWlnaHQnICk7XG5cdC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcHV0ZSBhbmQgYWRkIHNjcm9sbFRvcCBhbmQgc2Nyb2xsTGVmdCBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgdGhlIGJvZHksXG5cdC8vIG9yIGlmIGl0IGlzbid0IHNjcm9sbGFibGVcblx0c2Nyb2xsVG9wID0gc2Nyb2xsYWJsZVkgJiYgIWlzQm9keSA/ICRvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wKCkgOiAwO1xuXHRzY3JvbGxMZWZ0ID0gc2Nyb2xsYWJsZVggJiYgIWlzQm9keSA/IE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldFNjcm9sbExlZnQoICRvZmZzZXRQYXJlbnRbIDAgXSApIDogMDtcblxuXHQvLyBBdm9pZCBwYXNzaW5nIHRoZSA8Ym9keT4gdG8gZ2V0UmVsYXRpdmVQb3NpdGlvbigpLCBiZWNhdXNlIGl0IHdvbid0IHJldHVybiB3aGF0IHdlIGV4cGVjdFxuXHQvLyBpZiB0aGUgPGJvZHk+IGhhcyBhIG1hcmdpblxuXHRjb250YWluZXJQb3MgPSBpc0JvZHkgP1xuXHRcdHRoaXMuJGZsb2F0YWJsZUNvbnRhaW5lci5vZmZzZXQoKSA6XG5cdFx0T08udWkuRWxlbWVudC5zdGF0aWMuZ2V0UmVsYXRpdmVQb3NpdGlvbiggdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLCAkb2Zmc2V0UGFyZW50ICk7XG5cdGNvbnRhaW5lclBvcy5ib3R0b20gPSBjb250YWluZXJQb3MudG9wICsgdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLm91dGVySGVpZ2h0KCk7XG5cdGNvbnRhaW5lclBvcy5yaWdodCA9IGNvbnRhaW5lclBvcy5sZWZ0ICsgdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLm91dGVyV2lkdGgoKTtcblx0Y29udGFpbmVyUG9zLnN0YXJ0ID0gZGlyZWN0aW9uID09PSAncnRsJyA/IGNvbnRhaW5lclBvcy5yaWdodCA6IGNvbnRhaW5lclBvcy5sZWZ0O1xuXHRjb250YWluZXJQb3MuZW5kID0gZGlyZWN0aW9uID09PSAncnRsJyA/IGNvbnRhaW5lclBvcy5sZWZ0IDogY29udGFpbmVyUG9zLnJpZ2h0O1xuXG5cdGlmICggdGhpcy52ZXJ0aWNhbFBvc2l0aW9uID09PSAnYmVsb3cnICkge1xuXHRcdG5ld1Bvcy50b3AgPSBjb250YWluZXJQb3MuYm90dG9tO1xuXHR9IGVsc2UgaWYgKCB0aGlzLnZlcnRpY2FsUG9zaXRpb24gPT09ICdhYm92ZScgKSB7XG5cdFx0bmV3UG9zLmJvdHRvbSA9ICRvZmZzZXRQYXJlbnQub3V0ZXJIZWlnaHQoKSAtIGNvbnRhaW5lclBvcy50b3A7XG5cdH0gZWxzZSBpZiAoIHRoaXMudmVydGljYWxQb3NpdGlvbiA9PT0gJ3RvcCcgKSB7XG5cdFx0bmV3UG9zLnRvcCA9IGNvbnRhaW5lclBvcy50b3A7XG5cdH0gZWxzZSBpZiAoIHRoaXMudmVydGljYWxQb3NpdGlvbiA9PT0gJ2JvdHRvbScgKSB7XG5cdFx0bmV3UG9zLmJvdHRvbSA9ICRvZmZzZXRQYXJlbnQub3V0ZXJIZWlnaHQoKSAtIGNvbnRhaW5lclBvcy5ib3R0b207XG5cdH0gZWxzZSBpZiAoIHRoaXMudmVydGljYWxQb3NpdGlvbiA9PT0gJ2NlbnRlcicgKSB7XG5cdFx0bmV3UG9zLnRvcCA9IGNvbnRhaW5lclBvcy50b3AgK1xuXHRcdFx0KCB0aGlzLiRmbG9hdGFibGVDb250YWluZXIuaGVpZ2h0KCkgLSB0aGlzLiRmbG9hdGFibGUuaGVpZ2h0KCkgKSAvIDI7XG5cdH1cblxuXHRpZiAoIHRoaXMuaG9yaXpvbnRhbFBvc2l0aW9uID09PSAnYmVmb3JlJyApIHtcblx0XHRuZXdQb3MuZW5kID0gY29udGFpbmVyUG9zLnN0YXJ0O1xuXHR9IGVsc2UgaWYgKCB0aGlzLmhvcml6b250YWxQb3NpdGlvbiA9PT0gJ2FmdGVyJyApIHtcblx0XHRuZXdQb3Muc3RhcnQgPSBjb250YWluZXJQb3MuZW5kO1xuXHR9IGVsc2UgaWYgKCB0aGlzLmhvcml6b250YWxQb3NpdGlvbiA9PT0gJ3N0YXJ0JyApIHtcblx0XHRuZXdQb3Muc3RhcnQgPSBjb250YWluZXJQb3Muc3RhcnQ7XG5cdH0gZWxzZSBpZiAoIHRoaXMuaG9yaXpvbnRhbFBvc2l0aW9uID09PSAnZW5kJyApIHtcblx0XHRuZXdQb3MuZW5kID0gY29udGFpbmVyUG9zLmVuZDtcblx0fSBlbHNlIGlmICggdGhpcy5ob3Jpem9udGFsUG9zaXRpb24gPT09ICdjZW50ZXInICkge1xuXHRcdG5ld1Bvcy5sZWZ0ID0gY29udGFpbmVyUG9zLmxlZnQgK1xuXHRcdFx0KCB0aGlzLiRmbG9hdGFibGVDb250YWluZXIud2lkdGgoKSAtIHRoaXMuJGZsb2F0YWJsZS53aWR0aCgpICkgLyAyO1xuXHR9XG5cblx0aWYgKCBuZXdQb3Muc3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gJ3J0bCcgKSB7XG5cdFx0XHRuZXdQb3MucmlnaHQgPSAoIGlzQm9keSA/ICQoICRvZmZzZXRQYXJlbnRbIDAgXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIDogJG9mZnNldFBhcmVudCApLm91dGVyV2lkdGgoKSAtIG5ld1Bvcy5zdGFydDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3UG9zLmxlZnQgPSBuZXdQb3Muc3RhcnQ7XG5cdFx0fVxuXHRcdGRlbGV0ZSBuZXdQb3Muc3RhcnQ7XG5cdH1cblx0aWYgKCBuZXdQb3MuZW5kICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYgKCBkaXJlY3Rpb24gPT09ICdydGwnICkge1xuXHRcdFx0bmV3UG9zLmxlZnQgPSBuZXdQb3MuZW5kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdQb3MucmlnaHQgPSAoIGlzQm9keSA/ICQoICRvZmZzZXRQYXJlbnRbIDAgXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIDogJG9mZnNldFBhcmVudCApLm91dGVyV2lkdGgoKSAtIG5ld1Bvcy5lbmQ7XG5cdFx0fVxuXHRcdGRlbGV0ZSBuZXdQb3MuZW5kO1xuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3Igc2Nyb2xsIHBvc2l0aW9uXG5cdGlmICggbmV3UG9zLnRvcCAhPT0gJycgKSB7XG5cdFx0bmV3UG9zLnRvcCArPSBzY3JvbGxUb3A7XG5cdH1cblx0aWYgKCBuZXdQb3MuYm90dG9tICE9PSAnJyApIHtcblx0XHRuZXdQb3MuYm90dG9tIC09IHNjcm9sbFRvcDtcblx0fVxuXHRpZiAoIG5ld1Bvcy5sZWZ0ICE9PSAnJyApIHtcblx0XHRuZXdQb3MubGVmdCArPSBzY3JvbGxMZWZ0O1xuXHR9XG5cdGlmICggbmV3UG9zLnJpZ2h0ICE9PSAnJyApIHtcblx0XHRuZXdQb3MucmlnaHQgLT0gc2Nyb2xsTGVmdDtcblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHNjcm9sbGJhciBndXR0ZXJcblx0aWYgKCBuZXdQb3MuYm90dG9tICE9PSAnJyApIHtcblx0XHRuZXdQb3MuYm90dG9tIC09IGhvcml6U2Nyb2xsYmFySGVpZ2h0O1xuXHR9XG5cdGlmICggZGlyZWN0aW9uID09PSAncnRsJyApIHtcblx0XHRpZiAoIG5ld1Bvcy5sZWZ0ICE9PSAnJyApIHtcblx0XHRcdG5ld1Bvcy5sZWZ0IC09IHZlcnRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKCBuZXdQb3MucmlnaHQgIT09ICcnICkge1xuXHRcdFx0bmV3UG9zLnJpZ2h0IC09IHZlcnRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3UG9zO1xufTtcblxuLyoqXG4gKiBFbGVtZW50IHRoYXQgY2FuIGJlIGF1dG9tYXRpY2FsbHkgY2xpcHBlZCB0byB2aXNpYmxlIGJvdW5kYXJpZXMuXG4gKlxuICogV2hlbmV2ZXIgdGhlIGVsZW1lbnQncyBuYXR1cmFsIGhlaWdodCBjaGFuZ2VzLCB5b3UgaGF2ZSB0byBjYWxsXG4gKiB7QGxpbmsgT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudCNjbGlwfSB0byBtYWtlIHN1cmUgaXQncyBzdGlsbFxuICogY2xpcHBpbmcgY29ycmVjdGx5LlxuICpcbiAqIFRoZSBkaW1lbnNpb25zIG9mICMkY2xpcHBhYmxlQ29udGFpbmVyIHdpbGwgYmUgY29tcGFyZWQgdG8gdGhlIGJvdW5kYXJpZXMgb2YgdGhlXG4gKiBuZWFyZXN0IHNjcm9sbGFibGUgY29udGFpbmVyLiBJZiAjJGNsaXBwYWJsZUNvbnRhaW5lciBpcyB0b28gdGFsbCBhbmQvb3IgdG9vIHdpZGUsXG4gKiB0aGVuICMkY2xpcHBhYmxlIHdpbGwgYmUgZ2l2ZW4gYSBmaXhlZCByZWR1Y2VkIGhlaWdodCBhbmQvb3Igd2lkdGggYW5kIHdpbGwgYmUgbWFkZVxuICogc2Nyb2xsYWJsZS4gQnkgZGVmYXVsdCwgIyRjbGlwcGFibGUgYW5kICMkY2xpcHBhYmxlQ29udGFpbmVyIGFyZSB0aGUgc2FtZSBlbGVtZW50LFxuICogYnV0IHlvdSBjYW4gYnVpbGQgYSBzdGF0aWMgZm9vdGVyIGJ5IHNldHRpbmcgIyRjbGlwcGFibGVDb250YWluZXIgdG8gYW4gZWxlbWVudCB0aGF0IGNvbnRhaW5zXG4gKiAjJGNsaXBwYWJsZSBhbmQgdGhlIGZvb3Rlci5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJGNsaXBwYWJsZV0gTm9kZSB0byBjbGlwLCBhc3NpZ25lZCB0byAjJGNsaXBwYWJsZSwgb21pdCB0byB1c2UgIyRlbGVtZW50XG4gKiBAY2ZnIHtqUXVlcnl9IFskY2xpcHBhYmxlQ29udGFpbmVyXSBOb2RlIHRvIGtlZXAgdmlzaWJsZSwgYXNzaWduZWQgdG8gIyRjbGlwcGFibGVDb250YWluZXIsXG4gKiAgIG9taXQgdG8gdXNlICMkY2xpcHBhYmxlXG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpTWl4aW5DbGlwcGFibGVFbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kY2xpcHBhYmxlID0gbnVsbDtcblx0dGhpcy4kY2xpcHBhYmxlQ29udGFpbmVyID0gbnVsbDtcblx0dGhpcy5jbGlwcGluZyA9IGZhbHNlO1xuXHR0aGlzLmNsaXBwZWRIb3Jpem9udGFsbHkgPSBmYWxzZTtcblx0dGhpcy5jbGlwcGVkVmVydGljYWxseSA9IGZhbHNlO1xuXHR0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyID0gbnVsbDtcblx0dGhpcy4kY2xpcHBhYmxlU2Nyb2xsZXIgPSBudWxsO1xuXHR0aGlzLiRjbGlwcGFibGVXaW5kb3cgPSBudWxsO1xuXHR0aGlzLmlkZWFsV2lkdGggPSBudWxsO1xuXHR0aGlzLmlkZWFsSGVpZ2h0ID0gbnVsbDtcblx0dGhpcy5vbkNsaXBwYWJsZVNjcm9sbEhhbmRsZXIgPSB0aGlzLmNsaXAuYmluZCggdGhpcyApO1xuXHR0aGlzLm9uQ2xpcHBhYmxlV2luZG93UmVzaXplSGFuZGxlciA9IHRoaXMuY2xpcC5iaW5kKCB0aGlzICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0aWYgKCBjb25maWcuJGNsaXBwYWJsZUNvbnRhaW5lciApIHtcblx0XHR0aGlzLnNldENsaXBwYWJsZUNvbnRhaW5lciggY29uZmlnLiRjbGlwcGFibGVDb250YWluZXIgKTtcblx0fVxuXHR0aGlzLnNldENsaXBwYWJsZUVsZW1lbnQoIGNvbmZpZy4kY2xpcHBhYmxlIHx8IHRoaXMuJGVsZW1lbnQgKTtcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgY2xpcHBhYmxlIGVsZW1lbnQuXG4gKlxuICogSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IHNldCwgaXQgd2lsbCBiZSBjbGVhbmVkIHVwIGJlZm9yZSBzZXR0aW5nIHVwIHRoZSBuZXcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGNsaXBwYWJsZSBFbGVtZW50IHRvIG1ha2UgY2xpcHBhYmxlXG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQucHJvdG90eXBlLnNldENsaXBwYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoICRjbGlwcGFibGUgKSB7XG5cdGlmICggdGhpcy4kY2xpcHBhYmxlICkge1xuXHRcdHRoaXMuJGNsaXBwYWJsZS5yZW1vdmVDbGFzcyggJ29vLXVpLWNsaXBwYWJsZUVsZW1lbnQtY2xpcHBhYmxlJyApO1xuXHRcdHRoaXMuJGNsaXBwYWJsZS5jc3MoIHsgd2lkdGg6ICcnLCBoZWlnaHQ6ICcnLCBvdmVyZmxvd1g6ICcnLCBvdmVyZmxvd1k6ICcnIH0gKTtcblx0XHRPTy51aS5FbGVtZW50LnN0YXRpYy5yZWNvbnNpZGVyU2Nyb2xsYmFycyggdGhpcy4kY2xpcHBhYmxlWyAwIF0gKTtcblx0fVxuXG5cdHRoaXMuJGNsaXBwYWJsZSA9ICRjbGlwcGFibGUuYWRkQ2xhc3MoICdvby11aS1jbGlwcGFibGVFbGVtZW50LWNsaXBwYWJsZScgKTtcblx0dGhpcy5jbGlwKCk7XG59O1xuXG4vKipcbiAqIFNldCBjbGlwcGFibGUgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgaXMgdGhlIGNvbnRhaW5lciB0aGF0IHdpbGwgYmUgbWVhc3VyZWQgd2hlbiBkZWNpZGluZyB3aGV0aGVyIHRvIGNsaXAuIFdoZW4gY2xpcHBpbmcsXG4gKiAjJGNsaXBwYWJsZSB3aWxsIGJlIHJlc2l6ZWQgaW4gb3JkZXIgdG8ga2VlcCB0aGUgY2xpcHBhYmxlIGNvbnRhaW5lciBmdWxseSB2aXNpYmxlLlxuICpcbiAqIElmIHRoZSBjbGlwcGFibGUgY29udGFpbmVyIGlzIHVuc2V0LCAjJGNsaXBwYWJsZSB3aWxsIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl8bnVsbH0gJGNsaXBwYWJsZUNvbnRhaW5lciBDb250YWluZXIgdG8ga2VlcCB2aXNpYmxlLCBvciBudWxsIHRvIHVuc2V0XG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQucHJvdG90eXBlLnNldENsaXBwYWJsZUNvbnRhaW5lciA9IGZ1bmN0aW9uICggJGNsaXBwYWJsZUNvbnRhaW5lciApIHtcblx0dGhpcy4kY2xpcHBhYmxlQ29udGFpbmVyID0gJGNsaXBwYWJsZUNvbnRhaW5lcjtcblx0aWYgKCB0aGlzLiRjbGlwcGFibGUgKSB7XG5cdFx0dGhpcy5jbGlwKCk7XG5cdH1cbn07XG5cbi8qKlxuICogVG9nZ2xlIGNsaXBwaW5nLlxuICpcbiAqIERvIG5vdCB0dXJuIGNsaXBwaW5nIG9uIHVudGlsIGFmdGVyIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00gYW5kIHZpc2libGUuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbY2xpcHBpbmddIEVuYWJsZSBjbGlwcGluZywgb21pdCB0byB0b2dnbGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudC5wcm90b3R5cGUudG9nZ2xlQ2xpcHBpbmcgPSBmdW5jdGlvbiAoIGNsaXBwaW5nICkge1xuXHRjbGlwcGluZyA9IGNsaXBwaW5nID09PSB1bmRlZmluZWQgPyAhdGhpcy5jbGlwcGluZyA6ICEhY2xpcHBpbmc7XG5cblx0aWYgKCBjbGlwcGluZyAmJiAhdGhpcy53YXJuZWRVbmF0dGFjaGVkICYmICF0aGlzLmlzRWxlbWVudEF0dGFjaGVkKCkgKSB7XG5cdFx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnQ2xpcHBhYmxlRWxlbWVudCN0b2dnbGVDbGlwcGluZzogQmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QsIHRoZSBlbGVtZW50IG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS4nICk7XG5cdFx0dGhpcy53YXJuZWRVbmF0dGFjaGVkID0gdHJ1ZTtcblx0fVxuXG5cdGlmICggdGhpcy5jbGlwcGluZyAhPT0gY2xpcHBpbmcgKSB7XG5cdFx0dGhpcy5jbGlwcGluZyA9IGNsaXBwaW5nO1xuXHRcdGlmICggY2xpcHBpbmcgKSB7XG5cdFx0XHR0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyID0gJCggdGhpcy5nZXRDbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnRDb250YWluZXIoKSApO1xuXHRcdFx0Ly8gSWYgdGhlIGNsaXBwYWJsZSBjb250YWluZXIgaXMgdGhlIHJvb3QsIHdlIGhhdmUgdG8gbGlzdGVuIHRvIHNjcm9sbCBldmVudHMgYW5kIGNoZWNrXG5cdFx0XHQvLyBqUXVlcnkuc2Nyb2xsVG9wIG9uIHRoZSB3aW5kb3cgYmVjYXVzZSBvZiBicm93c2VyIGluY29uc2lzdGVuY2llc1xuXHRcdFx0dGhpcy4kY2xpcHBhYmxlU2Nyb2xsZXIgPSB0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyLmlzKCAnaHRtbCwgYm9keScgKSA/XG5cdFx0XHRcdCQoIE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldFdpbmRvdyggdGhpcy4kY2xpcHBhYmxlU2Nyb2xsYWJsZUNvbnRhaW5lciApICkgOlxuXHRcdFx0XHR0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyO1xuXHRcdFx0dGhpcy4kY2xpcHBhYmxlU2Nyb2xsZXIub24oICdzY3JvbGwnLCB0aGlzLm9uQ2xpcHBhYmxlU2Nyb2xsSGFuZGxlciApO1xuXHRcdFx0dGhpcy4kY2xpcHBhYmxlV2luZG93ID0gJCggdGhpcy5nZXRFbGVtZW50V2luZG93KCkgKVxuXHRcdFx0XHQub24oICdyZXNpemUnLCB0aGlzLm9uQ2xpcHBhYmxlV2luZG93UmVzaXplSGFuZGxlciApO1xuXHRcdFx0Ly8gSW5pdGlhbCBjbGlwIGFmdGVyIHZpc2libGVcblx0XHRcdHRoaXMuY2xpcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRjbGlwcGFibGUuY3NzKCB7XG5cdFx0XHRcdHdpZHRoOiAnJyxcblx0XHRcdFx0aGVpZ2h0OiAnJyxcblx0XHRcdFx0bWF4V2lkdGg6ICcnLFxuXHRcdFx0XHRtYXhIZWlnaHQ6ICcnLFxuXHRcdFx0XHRvdmVyZmxvd1g6ICcnLFxuXHRcdFx0XHRvdmVyZmxvd1k6ICcnXG5cdFx0XHR9ICk7XG5cdFx0XHRPTy51aS5FbGVtZW50LnN0YXRpYy5yZWNvbnNpZGVyU2Nyb2xsYmFycyggdGhpcy4kY2xpcHBhYmxlWyAwIF0gKTtcblxuXHRcdFx0dGhpcy4kY2xpcHBhYmxlU2Nyb2xsYWJsZUNvbnRhaW5lciA9IG51bGw7XG5cdFx0XHR0aGlzLiRjbGlwcGFibGVTY3JvbGxlci5vZmYoICdzY3JvbGwnLCB0aGlzLm9uQ2xpcHBhYmxlU2Nyb2xsSGFuZGxlciApO1xuXHRcdFx0dGhpcy4kY2xpcHBhYmxlU2Nyb2xsZXIgPSBudWxsO1xuXHRcdFx0dGhpcy4kY2xpcHBhYmxlV2luZG93Lm9mZiggJ3Jlc2l6ZScsIHRoaXMub25DbGlwcGFibGVXaW5kb3dSZXNpemVIYW5kbGVyICk7XG5cdFx0XHR0aGlzLiRjbGlwcGFibGVXaW5kb3cgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZWxlbWVudCB3aWxsIGJlIGNsaXBwZWQgdG8gZml0IHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIG5lYXJlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXIuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gRWxlbWVudCB3aWxsIGJlIGNsaXBwZWQgdG8gdGhlIHZpc2libGUgYXJlYVxuICovXG5PTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50LnByb3RvdHlwZS5pc0NsaXBwaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jbGlwcGluZztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdHRvbSBvciByaWdodCBvZiB0aGUgZWxlbWVudCBpcyBiZWluZyBjbGlwcGVkIGJ5IHRoZSBuZWFyZXN0IHNjcm9sbGFibGUgY29udGFpbmVyLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFBhcnQgb2YgdGhlIGVsZW1lbnQgaXMgYmVpbmcgY2xpcHBlZFxuICovXG5PTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50LnByb3RvdHlwZS5pc0NsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNsaXBwZWRIb3Jpem9udGFsbHkgfHwgdGhpcy5jbGlwcGVkVmVydGljYWxseTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHJpZ2h0IG9mIHRoZSBlbGVtZW50IGlzIGJlaW5nIGNsaXBwZWQgYnkgdGhlIG5lYXJlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXIuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gUGFydCBvZiB0aGUgZWxlbWVudCBpcyBiZWluZyBjbGlwcGVkXG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQucHJvdG90eXBlLmlzQ2xpcHBlZEhvcml6b250YWxseSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuY2xpcHBlZEhvcml6b250YWxseTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCBpcyBiZWluZyBjbGlwcGVkIGJ5IHRoZSBuZWFyZXN0IHNjcm9sbGFibGUgY29udGFpbmVyLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFBhcnQgb2YgdGhlIGVsZW1lbnQgaXMgYmVpbmcgY2xpcHBlZFxuICovXG5PTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50LnByb3RvdHlwZS5pc0NsaXBwZWRWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jbGlwcGVkVmVydGljYWxseTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpZGVhbCBzaXplLiBUaGVzZSBhcmUgdGhlIGRpbWVuc2lvbnMgIyRjbGlwcGFibGUgd2lsbCBoYXZlIHdoZW4gaXQncyBub3QgYmVpbmcgY2xpcHBlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFt3aWR0aF0gV2lkdGggYXMgYSBudW1iZXIgb2YgcGl4ZWxzIG9yIENTUyBzdHJpbmcgd2l0aCB1bml0IHN1ZmZpeFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbaGVpZ2h0XSBIZWlnaHQgYXMgYSBudW1iZXIgb2YgcGl4ZWxzIG9yIENTUyBzdHJpbmcgd2l0aCB1bml0IHN1ZmZpeFxuICovXG5PTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50LnByb3RvdHlwZS5zZXRJZGVhbFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cdHRoaXMuaWRlYWxXaWR0aCA9IHdpZHRoO1xuXHR0aGlzLmlkZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdGlmICggIXRoaXMuY2xpcHBpbmcgKSB7XG5cdFx0Ly8gVXBkYXRlIGRpbWVuc2lvbnNcblx0XHR0aGlzLiRjbGlwcGFibGUuY3NzKCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSApO1xuXHR9XG5cdC8vIFdoaWxlIGNsaXBwaW5nLCBpZGVhbFdpZHRoIGFuZCBpZGVhbEhlaWdodCBhcmUgbm90IGNvbnNpZGVyZWRcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzaWRlIG9mIHRoZSBjbGlwcGFibGUgb24gd2hpY2ggaXQgaXMgXCJhbmNob3JlZFwiIChhbGlnbmVkIHRvIHNvbWV0aGluZyBlbHNlKS5cbiAqIENsaXBwYWJsZUVsZW1lbnQgd2lsbCBjbGlwIHRoZSBvcHBvc2l0ZSBzaWRlIHdoZW4gcmVkdWNpbmcgZWxlbWVudCdzIHdpZHRoLlxuICpcbiAqIENsYXNzZXMgdGhhdCBtaXggaW4gQ2xpcHBhYmxlRWxlbWVudCBzaG91bGQgb3ZlcnJpZGUgdGhpcyB0byByZXR1cm4gJ3JpZ2h0JyBpZiB0aGVpclxuICogY2xpcHBhYmxlIGlzIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbmQgdXNpbmcgJ3JpZ2h0OiBOcHgnIChhbmQgbm90IHVzaW5nICdsZWZ0JykuXG4gKiBJZiB5b3VyIGNsYXNzIGFsc28gbWl4ZXMgaW4gRmxvYXRhYmxlRWxlbWVudCwgdGhpcyBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogKFRoaXMgY2FuJ3QgYmUgZ3Vlc3NlZCBmcm9tIHRoZSBhY3R1YWwgQ1NTIGJlY2F1c2UgdGhlIGNvbXB1dGVkIHZhbHVlcyBmb3IgJ2xlZnQnLydyaWdodCcgYXJlXG4gKiBhbHdheXMgaW4gcGl4ZWxzLCBldmVuIGlmIHRoZXkgd2VyZSB1bnNldCBvciBzZXQgdG8gJ2F1dG8nLilcbiAqXG4gKiBXaGVuIGluIGRvdWJ0LCAnbGVmdCcgKG9yICdyaWdodCcgaW4gUlRMKSBpcyBhIHNhbmUgZmFsbGJhY2suXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSAnbGVmdCcgb3IgJ3JpZ2h0J1xuICovXG5PTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50LnByb3RvdHlwZS5nZXRIb3Jpem9udGFsQW5jaG9yRWRnZSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmNvbXB1dGVQb3NpdGlvbiAmJiB0aGlzLnBvc2l0aW9uaW5nICYmIHRoaXMuY29tcHV0ZVBvc2l0aW9uKCkucmlnaHQgIT09ICcnICkge1xuXHRcdHJldHVybiAncmlnaHQnO1xuXHR9XG5cdHJldHVybiAnbGVmdCc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2lkZSBvZiB0aGUgY2xpcHBhYmxlIG9uIHdoaWNoIGl0IGlzIFwiYW5jaG9yZWRcIiAoYWxpZ25lZCB0byBzb21ldGhpbmcgZWxzZSkuXG4gKiBDbGlwcGFibGVFbGVtZW50IHdpbGwgY2xpcCB0aGUgb3Bwb3NpdGUgc2lkZSB3aGVuIHJlZHVjaW5nIGVsZW1lbnQncyB3aWR0aC5cbiAqXG4gKiBDbGFzc2VzIHRoYXQgbWl4IGluIENsaXBwYWJsZUVsZW1lbnQgc2hvdWxkIG92ZXJyaWRlIHRoaXMgdG8gcmV0dXJuICdib3R0b20nIGlmIHRoZWlyXG4gKiBjbGlwcGFibGUgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFuZCB1c2luZyAnYm90dG9tOiBOcHgnIChhbmQgbm90IHVzaW5nICd0b3AnKS5cbiAqIElmIHlvdXIgY2xhc3MgYWxzbyBtaXhlcyBpbiBGbG9hdGFibGVFbGVtZW50LCB0aGlzIGlzIGhhbmRsZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiAoVGhpcyBjYW4ndCBiZSBndWVzc2VkIGZyb20gdGhlIGFjdHVhbCBDU1MgYmVjYXVzZSB0aGUgY29tcHV0ZWQgdmFsdWVzIGZvciAnbGVmdCcvJ3JpZ2h0JyBhcmVcbiAqIGFsd2F5cyBpbiBwaXhlbHMsIGV2ZW4gaWYgdGhleSB3ZXJlIHVuc2V0IG9yIHNldCB0byAnYXV0bycuKVxuICpcbiAqIFdoZW4gaW4gZG91YnQsICd0b3AnIGlzIGEgc2FuZSBmYWxsYmFjay5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICd0b3AnIG9yICdib3R0b20nXG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQucHJvdG90eXBlLmdldFZlcnRpY2FsQW5jaG9yRWRnZSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmNvbXB1dGVQb3NpdGlvbiAmJiB0aGlzLnBvc2l0aW9uaW5nICYmIHRoaXMuY29tcHV0ZVBvc2l0aW9uKCkuYm90dG9tICE9PSAnJyApIHtcblx0XHRyZXR1cm4gJ2JvdHRvbSc7XG5cdH1cblx0cmV0dXJuICd0b3AnO1xufTtcblxuLyoqXG4gKiBDbGlwIGVsZW1lbnQgdG8gdmlzaWJsZSBib3VuZGFyaWVzIGFuZCBhbGxvdyBzY3JvbGxpbmcgd2hlbiBuZWVkZWQuIFlvdSBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZFxuICogd2hlbiB0aGUgZWxlbWVudCdzIG5hdHVyYWwgaGVpZ2h0IGNoYW5nZXMuXG4gKlxuICogRWxlbWVudCB3aWxsIGJlIGNsaXBwZWQgdGhlIGJvdHRvbSBvciByaWdodCBvZiB0aGUgZWxlbWVudCBpcyB3aXRoaW4gMTBweCBvZiB0aGUgZWRnZSBvZiwgb3JcbiAqIG92ZXJsYXBwZWQgYnksIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIG5lYXJlc3Qgc2Nyb2xsYWJsZSBjb250YWluZXIuXG4gKlxuICogQmVjYXVzZSBjYWxsaW5nIGNsaXAoKSB3aGVuIHRoZSBuYXR1cmFsIGhlaWdodCBjaGFuZ2VzIGlzbid0IGFsd2F5cyBwb3NzaWJsZSwgd2UgYWxzbyBzZXRcbiAqIG1heC1oZWlnaHQgd2hlbiB0aGUgZWxlbWVudCBpc24ndCBiZWluZyBjbGlwcGVkLiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIGVsZW1lbnQgdHJpZXMgdG8gZ3Jvd1xuICogYmV5b25kIHRoZSBlZGdlLCBzb21ldGhpbmcgcmVhc29uYWJsZSB3aWxsIGhhcHBlbiBiZWZvcmUgY2xpcCgpIGlzIGNhbGxlZC5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBleHRyYUhlaWdodCwgZXh0cmFXaWR0aCwgdmlld3BvcnRTcGFjaW5nLFxuXHRcdGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCwgYWxsb3RlZFdpZHRoLCBhbGxvdGVkSGVpZ2h0LFxuXHRcdG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCwgY2xpcFdpZHRoLCBjbGlwSGVpZ2h0LFxuXHRcdCRpdGVtLCBpdGVtUmVjdCwgJHZpZXdwb3J0LCB2aWV3cG9ydFJlY3QsIGF2YWlsYWJsZVJlY3QsXG5cdFx0ZGlyZWN0aW9uLCB2ZXJ0U2Nyb2xsYmFyV2lkdGgsIGhvcml6U2Nyb2xsYmFySGVpZ2h0LFxuXHRcdC8vIEV4dHJhIHRvbGVyYW5jZSBzbyB0aGF0IHRoZSBzbG9wcHkgY29kZSBiZWxvdyBkb2Vzbid0IHJlc3VsdCBpbiByZXN1bHRzIHRoYXQgYXJlIG9mZlxuXHRcdC8vIGJ5IG9uZSBvciB0d28gcGl4ZWxzLiAoQW5kIGFsc28gc28gdGhhdCB3ZSBoYXZlIHNwYWNlIHRvIGRpc3BsYXkgZHJvcCBzaGFkb3dzLilcblx0XHQvLyBDaG9zZW4gYnkgZmFpciBkaWNlIHJvbGwuXG5cdFx0YnVmZmVyID0gNztcblxuXHRpZiAoICF0aGlzLmNsaXBwaW5nICkge1xuXHRcdC8vIHRoaXMuJGNsaXBwYWJsZVNjcm9sbGFibGVDb250YWluZXIgYW5kIHRoaXMuJGNsaXBwYWJsZVdpbmRvdyBhcmUgbnVsbCwgc28gdGhlIGJlbG93IHdpbGwgZmFpbFxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVjdEludGVyc2VjdGlvbiggYSwgYiApIHtcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0b3V0LnRvcCA9IE1hdGgubWF4KCBhLnRvcCwgYi50b3AgKTtcblx0XHRvdXQubGVmdCA9IE1hdGgubWF4KCBhLmxlZnQsIGIubGVmdCApO1xuXHRcdG91dC5ib3R0b20gPSBNYXRoLm1pbiggYS5ib3R0b20sIGIuYm90dG9tICk7XG5cdFx0b3V0LnJpZ2h0ID0gTWF0aC5taW4oIGEucmlnaHQsIGIucmlnaHQgKTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0dmlld3BvcnRTcGFjaW5nID0gT08udWkuZ2V0Vmlld3BvcnRTcGFjaW5nKCk7XG5cblx0aWYgKCB0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyLmlzKCAnaHRtbCwgYm9keScgKSApIHtcblx0XHQkdmlld3BvcnQgPSAkKCB0aGlzLiRjbGlwcGFibGVTY3JvbGxhYmxlQ29udGFpbmVyWyAwIF0ub3duZXJEb2N1bWVudC5ib2R5ICk7XG5cdFx0Ly8gRGltZW5zaW9ucyBvZiB0aGUgYnJvd3NlciB3aW5kb3csIHJhdGhlciB0aGFuIHRoZSBlbGVtZW50IVxuXHRcdHZpZXdwb3J0UmVjdCA9IHtcblx0XHRcdHRvcDogMCxcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRyaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuXHRcdFx0Ym90dG9tOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cdFx0fTtcblx0XHR2aWV3cG9ydFJlY3QudG9wICs9IHZpZXdwb3J0U3BhY2luZy50b3A7XG5cdFx0dmlld3BvcnRSZWN0LmxlZnQgKz0gdmlld3BvcnRTcGFjaW5nLmxlZnQ7XG5cdFx0dmlld3BvcnRSZWN0LnJpZ2h0IC09IHZpZXdwb3J0U3BhY2luZy5yaWdodDtcblx0XHR2aWV3cG9ydFJlY3QuYm90dG9tIC09IHZpZXdwb3J0U3BhY2luZy5ib3R0b207XG5cdH0gZWxzZSB7XG5cdFx0JHZpZXdwb3J0ID0gdGhpcy4kY2xpcHBhYmxlU2Nyb2xsYWJsZUNvbnRhaW5lcjtcblx0XHR2aWV3cG9ydFJlY3QgPSAkdmlld3BvcnRbIDAgXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHQvLyBDb252ZXJ0IGludG8gYSBwbGFpbiBvYmplY3Rcblx0XHR2aWV3cG9ydFJlY3QgPSAkLmV4dGVuZCgge30sIHZpZXdwb3J0UmVjdCApO1xuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3Igc2Nyb2xsYmFyIGd1dHRlclxuXHRkaXJlY3Rpb24gPSAkdmlld3BvcnQuY3NzKCAnZGlyZWN0aW9uJyApO1xuXHR2ZXJ0U2Nyb2xsYmFyV2lkdGggPSAkdmlld3BvcnQuaW5uZXJXaWR0aCgpIC0gJHZpZXdwb3J0LnByb3AoICdjbGllbnRXaWR0aCcgKTtcblx0aG9yaXpTY3JvbGxiYXJIZWlnaHQgPSAkdmlld3BvcnQuaW5uZXJIZWlnaHQoKSAtICR2aWV3cG9ydC5wcm9wKCAnY2xpZW50SGVpZ2h0JyApO1xuXHR2aWV3cG9ydFJlY3QuYm90dG9tIC09IGhvcml6U2Nyb2xsYmFySGVpZ2h0O1xuXHRpZiAoIGRpcmVjdGlvbiA9PT0gJ3J0bCcgKSB7XG5cdFx0dmlld3BvcnRSZWN0LmxlZnQgKz0gdmVydFNjcm9sbGJhcldpZHRoO1xuXHR9IGVsc2Uge1xuXHRcdHZpZXdwb3J0UmVjdC5yaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyV2lkdGg7XG5cdH1cblxuXHQvLyBBZGQgYXJiaXRyYXJ5IHRvbGVyYW5jZVxuXHR2aWV3cG9ydFJlY3QudG9wICs9IGJ1ZmZlcjtcblx0dmlld3BvcnRSZWN0LmxlZnQgKz0gYnVmZmVyO1xuXHR2aWV3cG9ydFJlY3QucmlnaHQgLT0gYnVmZmVyO1xuXHR2aWV3cG9ydFJlY3QuYm90dG9tIC09IGJ1ZmZlcjtcblxuXHQkaXRlbSA9IHRoaXMuJGNsaXBwYWJsZUNvbnRhaW5lciB8fCB0aGlzLiRjbGlwcGFibGU7XG5cblx0ZXh0cmFIZWlnaHQgPSAkaXRlbS5vdXRlckhlaWdodCgpIC0gdGhpcy4kY2xpcHBhYmxlLm91dGVySGVpZ2h0KCk7XG5cdGV4dHJhV2lkdGggPSAkaXRlbS5vdXRlcldpZHRoKCkgLSB0aGlzLiRjbGlwcGFibGUub3V0ZXJXaWR0aCgpO1xuXG5cdGl0ZW1SZWN0ID0gJGl0ZW1bIDAgXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0Ly8gQ29udmVydCBpbnRvIGEgcGxhaW4gb2JqZWN0XG5cdGl0ZW1SZWN0ID0gJC5leHRlbmQoIHt9LCBpdGVtUmVjdCApO1xuXG5cdC8vIEl0ZW0gbWlnaHQgYWxyZWFkeSBiZSBjbGlwcGVkLCBzbyB3ZSBjYW4ndCBqdXN0IHVzZSBpdHMgZGltZW5zaW9ucyAoaW4gY2FzZSB3ZSBtaWdodCBuZWVkIHRvXG5cdC8vIG1ha2UgaXQgbGFyZ2VyIHRoYW4gYmVmb3JlKS4gRXh0ZW5kIHRoZSByZWN0YW5nbGUgdG8gdGhlIG1heGltdW0gc2l6ZSB3ZSBhcmUgYWxsb3dlZCB0byB0YWtlLlxuXHRpZiAoIHRoaXMuZ2V0SG9yaXpvbnRhbEFuY2hvckVkZ2UoKSA9PT0gJ3JpZ2h0JyApIHtcblx0XHRpdGVtUmVjdC5sZWZ0ID0gdmlld3BvcnRSZWN0LmxlZnQ7XG5cdH0gZWxzZSB7XG5cdFx0aXRlbVJlY3QucmlnaHQgPSB2aWV3cG9ydFJlY3QucmlnaHQ7XG5cdH1cblx0aWYgKCB0aGlzLmdldFZlcnRpY2FsQW5jaG9yRWRnZSgpID09PSAnYm90dG9tJyApIHtcblx0XHRpdGVtUmVjdC50b3AgPSB2aWV3cG9ydFJlY3QudG9wO1xuXHR9IGVsc2Uge1xuXHRcdGl0ZW1SZWN0LmJvdHRvbSA9IHZpZXdwb3J0UmVjdC5ib3R0b207XG5cdH1cblxuXHRhdmFpbGFibGVSZWN0ID0gcmVjdEludGVyc2VjdGlvbiggdmlld3BvcnRSZWN0LCBpdGVtUmVjdCApO1xuXG5cdGRlc2lyZWRXaWR0aCA9IE1hdGgubWF4KCAwLCBhdmFpbGFibGVSZWN0LnJpZ2h0IC0gYXZhaWxhYmxlUmVjdC5sZWZ0ICk7XG5cdGRlc2lyZWRIZWlnaHQgPSBNYXRoLm1heCggMCwgYXZhaWxhYmxlUmVjdC5ib3R0b20gLSBhdmFpbGFibGVSZWN0LnRvcCApO1xuXHQvLyBJdCBzaG91bGQgbmV2ZXIgYmUgZGVzaXJhYmxlIHRvIGV4Y2VlZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYnJvd3NlciB2aWV3cG9ydC4uLiByaWdodD9cblx0ZGVzaXJlZFdpZHRoID0gTWF0aC5taW4oIGRlc2lyZWRXaWR0aCxcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSB2aWV3cG9ydFNwYWNpbmcubGVmdCAtIHZpZXdwb3J0U3BhY2luZy5yaWdodCApO1xuXHRkZXNpcmVkSGVpZ2h0ID0gTWF0aC5taW4oIGRlc2lyZWRIZWlnaHQsXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIHZpZXdwb3J0U3BhY2luZy50b3AgLSB2aWV3cG9ydFNwYWNpbmcucmlnaHQgKTtcblx0YWxsb3RlZFdpZHRoID0gTWF0aC5jZWlsKCBkZXNpcmVkV2lkdGggLSBleHRyYVdpZHRoICk7XG5cdGFsbG90ZWRIZWlnaHQgPSBNYXRoLmNlaWwoIGRlc2lyZWRIZWlnaHQgLSBleHRyYUhlaWdodCApO1xuXHRuYXR1cmFsV2lkdGggPSB0aGlzLiRjbGlwcGFibGUucHJvcCggJ3Njcm9sbFdpZHRoJyApO1xuXHRuYXR1cmFsSGVpZ2h0ID0gdGhpcy4kY2xpcHBhYmxlLnByb3AoICdzY3JvbGxIZWlnaHQnICk7XG5cdGNsaXBXaWR0aCA9IGFsbG90ZWRXaWR0aCA8IG5hdHVyYWxXaWR0aDtcblx0Y2xpcEhlaWdodCA9IGFsbG90ZWRIZWlnaHQgPCBuYXR1cmFsSGVpZ2h0O1xuXG5cdGlmICggY2xpcFdpZHRoICkge1xuXHRcdC8vIFRoZSBvcmRlciBtYXR0ZXJzIGhlcmUuIElmIG92ZXJmbG93IGlzIG5vdCBzZXQgZmlyc3QsIENocm9tZSBkaXNwbGF5cyBib2d1cyBzY3JvbGxiYXJzLiBTZWUgVDE1NzY3Mi5cblx0XHQvLyBGb3JjaW5nIGEgcmVmbG93IGlzIGEgc21hbGxlciB3b3JrYXJvdW5kIHRoYW4gY2FsbGluZyByZWNvbnNpZGVyU2Nyb2xsYmFycygpIGZvciB0aGlzIGNhc2UuXG5cdFx0dGhpcy4kY2xpcHBhYmxlLmNzcyggJ292ZXJmbG93WCcsICdzY3JvbGwnICk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZvaWRcblx0XHR2b2lkIHRoaXMuJGNsaXBwYWJsZVsgMCBdLm9mZnNldEhlaWdodDsgLy8gRm9yY2UgcmVmbG93XG5cdFx0dGhpcy4kY2xpcHBhYmxlLmNzcygge1xuXHRcdFx0d2lkdGg6IE1hdGgubWF4KCAwLCBhbGxvdGVkV2lkdGggKSxcblx0XHRcdG1heFdpZHRoOiAnJ1xuXHRcdH0gKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRjbGlwcGFibGUuY3NzKCB7XG5cdFx0XHRvdmVyZmxvd1g6ICcnLFxuXHRcdFx0d2lkdGg6IHRoaXMuaWRlYWxXaWR0aCB8fCAnJyxcblx0XHRcdG1heFdpZHRoOiBNYXRoLm1heCggMCwgYWxsb3RlZFdpZHRoIClcblx0XHR9ICk7XG5cdH1cblx0aWYgKCBjbGlwSGVpZ2h0ICkge1xuXHRcdC8vIFRoZSBvcmRlciBtYXR0ZXJzIGhlcmUuIElmIG92ZXJmbG93IGlzIG5vdCBzZXQgZmlyc3QsIENocm9tZSBkaXNwbGF5cyBib2d1cyBzY3JvbGxiYXJzLiBTZWUgVDE1NzY3Mi5cblx0XHQvLyBGb3JjaW5nIGEgcmVmbG93IGlzIGEgc21hbGxlciB3b3JrYXJvdW5kIHRoYW4gY2FsbGluZyByZWNvbnNpZGVyU2Nyb2xsYmFycygpIGZvciB0aGlzIGNhc2UuXG5cdFx0dGhpcy4kY2xpcHBhYmxlLmNzcyggJ292ZXJmbG93WScsICdzY3JvbGwnICk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZvaWRcblx0XHR2b2lkIHRoaXMuJGNsaXBwYWJsZVsgMCBdLm9mZnNldEhlaWdodDsgLy8gRm9yY2UgcmVmbG93XG5cdFx0dGhpcy4kY2xpcHBhYmxlLmNzcygge1xuXHRcdFx0aGVpZ2h0OiBNYXRoLm1heCggMCwgYWxsb3RlZEhlaWdodCApLFxuXHRcdFx0bWF4SGVpZ2h0OiAnJ1xuXHRcdH0gKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRjbGlwcGFibGUuY3NzKCB7XG5cdFx0XHRvdmVyZmxvd1k6ICcnLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmlkZWFsSGVpZ2h0IHx8ICcnLFxuXHRcdFx0bWF4SGVpZ2h0OiBNYXRoLm1heCggMCwgYWxsb3RlZEhlaWdodCApXG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSWYgd2Ugc3RvcHBlZCBjbGlwcGluZyBpbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnNcblx0aWYgKCAoIHRoaXMuY2xpcHBlZEhvcml6b250YWxseSAmJiAhY2xpcFdpZHRoICkgfHwgKCB0aGlzLmNsaXBwZWRWZXJ0aWNhbGx5ICYmICFjbGlwSGVpZ2h0ICkgKSB7XG5cdFx0T08udWkuRWxlbWVudC5zdGF0aWMucmVjb25zaWRlclNjcm9sbGJhcnMoIHRoaXMuJGNsaXBwYWJsZVsgMCBdICk7XG5cdH1cblxuXHR0aGlzLmNsaXBwZWRIb3Jpem9udGFsbHkgPSBjbGlwV2lkdGg7XG5cdHRoaXMuY2xpcHBlZFZlcnRpY2FsbHkgPSBjbGlwSGVpZ2h0O1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQb3B1cFdpZGdldCBpcyBhIGNvbnRhaW5lciBmb3IgY29udGVudC4gVGhlIHBvcHVwIGlzIG92ZXJsYWlkIGFuZCBwb3NpdGlvbmVkIGFic29sdXRlbHkuXG4gKiBCeSBkZWZhdWx0LCBlYWNoIHBvcHVwIGhhcyBhbiBhbmNob3IgdGhhdCBwb2ludHMgdG93YXJkIGl0cyBvcmlnaW4uXG4gKiBQbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraS5vcmddIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMuXG4gKlxuICogVW5saWtlIG1vc3Qgd2lkZ2V0cywgUG9wdXBXaWRnZXQgaXMgaW5pdGlhbGx5IGhpZGRlbiBhbmQgbXVzdCBiZSBzaG93biBieSBjYWxsaW5nICN0b2dnbGUuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBQb3B1cFdpZGdldC5cbiAqICAgICB2YXIgcG9wdXAgPSBuZXcgT08udWkuUG9wdXBXaWRnZXQoIHtcbiAqICAgICAgICAgJGNvbnRlbnQ6ICQoICc8cD5IaSB0aGVyZSE8L3A+JyApLFxuICogICAgICAgICBwYWRkZWQ6IHRydWUsXG4gKiAgICAgICAgIHdpZHRoOiAzMDBcbiAqICAgICB9ICk7XG4gKlxuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHBvcHVwLiRlbGVtZW50ICk7XG4gKiAgICAgLy8gVG8gZGlzcGxheSB0aGUgcG9wdXAsIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSB0byAndHJ1ZScuXG4gKiAgICAgcG9wdXAudG9nZ2xlKCB0cnVlICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL1BvcHVwc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5DbGlwcGFibGVFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge251bWJlcnxudWxsfSBbd2lkdGg9MzIwXSBXaWR0aCBvZiBwb3B1cCBpbiBwaXhlbHMuIFBhc3MgYG51bGxgIHRvIHVzZSBhdXRvbWF0aWMgd2lkdGguXG4gKiBAY2ZnIHtudW1iZXJ8bnVsbH0gW2hlaWdodD1udWxsXSBIZWlnaHQgb2YgcG9wdXAgaW4gcGl4ZWxzLiBQYXNzIGBudWxsYCB0byB1c2UgYXV0b21hdGljIGhlaWdodC5cbiAqIEBjZmcge2Jvb2xlYW59IFthbmNob3I9dHJ1ZV0gU2hvdyBhbmNob3IgcG9pbnRpbmcgdG8gb3JpZ2luIG9mIHBvcHVwXG4gKiBAY2ZnIHtzdHJpbmd9IFtwb3NpdGlvbj0nYmVsb3cnXSBXaGVyZSB0byBwb3NpdGlvbiB0aGUgcG9wdXAgcmVsYXRpdmUgdG8gJGZsb2F0YWJsZUNvbnRhaW5lclxuICogICdhYm92ZSc6IFB1dCBwb3B1cCBhYm92ZSAkZmxvYXRhYmxlQ29udGFpbmVyOyBhbmNob3IgcG9pbnRzIGRvd24gdG8gdGhlIGhvcml6b250YWwgY2VudGVyXG4gKiAgICAgICAgICAgb2YgJGZsb2F0YWJsZUNvbnRhaW5lclxuICogICdiZWxvdyc6IFB1dCBwb3B1cCBiZWxvdyAkZmxvYXRhYmxlQ29udGFpbmVyOyBhbmNob3IgcG9pbnRzIHVwIHRvIHRoZSBob3Jpem9udGFsIGNlbnRlclxuICogICAgICAgICAgIG9mICRmbG9hdGFibGVDb250YWluZXJcbiAqICAnYmVmb3JlJzogUHV0IHBvcHVwIHRvIHRoZSBsZWZ0IChMVFIpIC8gcmlnaHQgKFJUTCkgb2YgJGZsb2F0YWJsZUNvbnRhaW5lcjsgYW5jaG9yIHBvaW50c1xuICogICAgICAgICAgICBlbmR3YXJkcyAocmlnaHQvbGVmdCkgdG8gdGhlIHZlcnRpY2FsIGNlbnRlciBvZiAkZmxvYXRhYmxlQ29udGFpbmVyXG4gKiAgJ2FmdGVyJzogUHV0IHBvcHVwIHRvIHRoZSByaWdodCAoTFRSKSAvIGxlZnQgKFJUTCkgb2YgJGZsb2F0YWJsZUNvbnRhaW5lcjsgYW5jaG9yIHBvaW50c1xuICogICAgICAgICAgICBzdGFydHdhcmRzIChsZWZ0L3JpZ2h0KSB0byB0aGUgdmVydGljYWwgY2VudGVyIG9mICRmbG9hdGFibGVDb250YWluZXJcbiAqIEBjZmcge3N0cmluZ30gW2FsaWduPSdjZW50ZXInXSBIb3cgdG8gYWxpZ24gdGhlIHBvcHVwIHRvICRmbG9hdGFibGVDb250YWluZXJcbiAqICAnZm9yd2FyZHMnOiBJZiBwb3NpdGlvbiBpcyBhYm92ZS9iZWxvdywgbW92ZSB0aGUgcG9wdXAgYXMgZmFyIGVuZHdhcmRzIChyaWdodCBpbiBMVFIsIGxlZnQgaW4gUlRMKVxuICogICAgICAgICAgICAgIGFzIHBvc3NpYmxlIHdoaWxlIHN0aWxsIGtlZXBpbmcgdGhlIGFuY2hvciB3aXRoaW4gdGhlIHBvcHVwO1xuICogICAgICAgICAgICAgIGlmIHBvc2l0aW9uIGlzIGJlZm9yZS9hZnRlciwgbW92ZSB0aGUgcG9wdXAgYXMgZmFyIGRvd253YXJkcyBhcyBwb3NzaWJsZS5cbiAqICAnYmFja3dhcmRzJzogSWYgcG9zaXRpb24gaXMgYWJvdmUvYmVsb3csIG1vdmUgdGhlIHBvcHVwIGFzIGZhciBzdGFydHdhcmRzIChsZWZ0IGluIExUUiwgcmlnaHQgaW4gUlRMKVxuICogICAgICAgICAgICAgICBhcyBwb3NzaWJsZSB3aGlsZSBzdGlsbCBrZWVwaW5nIHRoZSBhbmNob3Igd2l0aGluIHRoZSBwb3B1cDtcbiAqICAgICAgICAgICAgICAgaWYgcG9zaXRpb24gaW4gYmVmb3JlL2FmdGVyLCBtb3ZlIHRoZSBwb3B1cCBhcyBmYXIgdXB3YXJkcyBhcyBwb3NzaWJsZS5cbiAqICAnY2VudGVyJzogSG9yaXpvbnRhbGx5IChpZiBwb3NpdGlvbiBpcyBhYm92ZS9iZWxvdykgb3IgdmVydGljYWxseSAoYmVmb3JlL2FmdGVyKSBhbGlnbiB0aGUgY2VudGVyXG4gKiAgICAgICAgICAgIG9mIHRoZSBwb3B1cCB3aXRoIHRoZSBjZW50ZXIgb2YgJGZsb2F0YWJsZUNvbnRhaW5lci5cbiAqICdmb3JjZS1sZWZ0JzogQWxpYXMgZm9yICdmb3J3YXJkcycgaW4gTFRSIGFuZCAnYmFja3dhcmRzJyBpbiBSVExcbiAqICdmb3JjZS1yaWdodCc6IEFsaWFzIGZvciAnYmFja3dhcmRzJyBpbiBSVEwgYW5kICdmb3J3YXJkcycgaW4gTFRSXG4gKiBAY2ZnIHtib29sZWFufSBbYXV0b0ZsaXA9dHJ1ZV0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCB0aGUgcG9wdXAncyBwb3NpdGlvbiBiZXR3ZWVuXG4gKiAgJ2Fib3ZlJyBhbmQgJ2JlbG93Jywgb3IgYmV0d2VlbiAnYmVmb3JlJyBhbmQgJ2FmdGVyJywgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBpbiB0aGVcbiAqICBkZXNpcmVkIGRpcmVjdGlvbiB0byBkaXNwbGF5IHRoZSBwb3B1cCB3aXRob3V0IGNsaXBwaW5nXG4gKiBAY2ZnIHtqUXVlcnl9IFskY29udGFpbmVyXSBDb25zdHJhaW4gdGhlIHBvcHVwIHRvIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyLlxuICogIFNlZSB0aGUgW09PVUkgZG9jcyBvbiBNZWRpYVdpa2ldWzNdIGZvciBhbiBleGFtcGxlLlxuICogIFszXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9Qb3B1cHMjY29udGFpbmVyRXhhbXBsZVxuICogQGNmZyB7bnVtYmVyfSBbY29udGFpbmVyUGFkZGluZz0xMF0gUGFkZGluZyBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgaXRzIGNvbnRhaW5lciwgc3BlY2lmaWVkIGFzIGEgbnVtYmVyIG9mIHBpeGVscy5cbiAqIEBjZmcge2pRdWVyeX0gWyRjb250ZW50XSBDb250ZW50IHRvIGFwcGVuZCB0byB0aGUgcG9wdXAncyBib2R5XG4gKiBAY2ZnIHtqUXVlcnl9IFskZm9vdGVyXSBDb250ZW50IHRvIGFwcGVuZCB0byB0aGUgcG9wdXAncyBmb290ZXJcbiAqIEBjZmcge2Jvb2xlYW59IFthdXRvQ2xvc2U9ZmFsc2VdIEF1dG9tYXRpY2FsbHkgY2xvc2UgdGhlIHBvcHVwIHdoZW4gaXQgbG9zZXMgZm9jdXMuXG4gKiBAY2ZnIHtqUXVlcnl9IFskYXV0b0Nsb3NlSWdub3JlXSBFbGVtZW50cyB0aGF0IHdpbGwgbm90IGNsb3NlIHRoZSBwb3B1cCB3aGVuIGNsaWNrZWQuXG4gKiAgVGhpcyBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVsZXZhbnQgaWYgI2F1dG9DbG9zZSBpcyBzZXQgdG8gYHRydWVgLiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsyXVxuICogIGZvciBhbiBleGFtcGxlLlxuICogIFsyXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9Qb3B1cHMjYXV0b2Nsb3NlRXhhbXBsZVxuICogQGNmZyB7Ym9vbGVhbn0gW2hlYWQ9ZmFsc2VdIFNob3cgYSBwb3B1cCBoZWFkZXIgdGhhdCBjb250YWlucyBhICNsYWJlbCAoaWYgc3BlY2lmaWVkKSBhbmQgY2xvc2VcbiAqICBidXR0b24uXG4gKiBAY2ZnIHtib29sZWFufSBbcGFkZGVkPWZhbHNlXSBBZGQgcGFkZGluZyB0byB0aGUgcG9wdXAncyBib2R5XG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVBvcHVwV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Qb3B1cFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllcyAobXVzdCBiZSBzZXQgYmVmb3JlIENsaXBwYWJsZUVsZW1lbnQgY29uc3RydWN0b3IgY2FsbClcblx0dGhpcy4kYm9keSA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy4kcG9wdXAgPSAkKCAnPGRpdj4nICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywge1xuXHRcdCRjbGlwcGFibGU6IHRoaXMuJGJvZHksXG5cdFx0JGNsaXBwYWJsZUNvbnRhaW5lcjogdGhpcy4kcG9wdXBcblx0fSApICk7XG5cdE9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiRhbmNob3IgPSAkKCAnPGRpdj4nICk7XG5cdC8vIElmIHVuZGVmaW5lZCwgd2lsbCBiZSBjb21wdXRlZCBsYXppbHkgaW4gY29tcHV0ZVBvc2l0aW9uKClcblx0dGhpcy4kY29udGFpbmVyID0gY29uZmlnLiRjb250YWluZXI7XG5cdHRoaXMuY29udGFpbmVyUGFkZGluZyA9IGNvbmZpZy5jb250YWluZXJQYWRkaW5nICE9PSB1bmRlZmluZWQgPyBjb25maWcuY29udGFpbmVyUGFkZGluZyA6IDEwO1xuXHR0aGlzLmF1dG9DbG9zZSA9ICEhY29uZmlnLmF1dG9DbG9zZTtcblx0dGhpcy50cmFuc2l0aW9uVGltZW91dCA9IG51bGw7XG5cdHRoaXMuYW5jaG9yZWQgPSBmYWxzZTtcblx0dGhpcy5vbkRvY3VtZW50TW91c2VEb3duSGFuZGxlciA9IHRoaXMub25Eb2N1bWVudE1vdXNlRG93bi5iaW5kKCB0aGlzICk7XG5cdHRoaXMub25Eb2N1bWVudEtleURvd25IYW5kbGVyID0gdGhpcy5vbkRvY3VtZW50S2V5RG93bi5iaW5kKCB0aGlzICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy5zZXRTaXplKCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQgKTtcblx0dGhpcy50b2dnbGVBbmNob3IoIGNvbmZpZy5hbmNob3IgPT09IHVuZGVmaW5lZCB8fCBjb25maWcuYW5jaG9yICk7XG5cdHRoaXMuc2V0QWxpZ25tZW50KCBjb25maWcuYWxpZ24gfHwgJ2NlbnRlcicgKTtcblx0dGhpcy5zZXRQb3NpdGlvbiggY29uZmlnLnBvc2l0aW9uIHx8ICdiZWxvdycgKTtcblx0dGhpcy5zZXRBdXRvRmxpcCggY29uZmlnLmF1dG9GbGlwID09PSB1bmRlZmluZWQgfHwgY29uZmlnLmF1dG9GbGlwICk7XG5cdHRoaXMuc2V0QXV0b0Nsb3NlSWdub3JlKCBjb25maWcuJGF1dG9DbG9zZUlnbm9yZSApO1xuXHR0aGlzLiRib2R5LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYm9keScgKTtcblx0dGhpcy4kYW5jaG9yLmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yJyApO1xuXHR0aGlzLiRwb3B1cFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwV2lkZ2V0LXBvcHVwJyApXG5cdFx0LmFwcGVuZCggdGhpcy4kYm9keSApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRwb3B1cCwgdGhpcy4kYW5jaG9yICk7XG5cdC8vIE1vdmUgY29udGVudCwgd2hpY2ggd2FzIGFkZGVkIHRvICMkZWxlbWVudCBieSBPTy51aS5XaWRnZXQsIHRvIHRoZSBib2R5XG5cdC8vIEZJWE1FIFRoaXMgaXMgZ3Jvc3MsIHdlIHNob3VsZCB1c2UgJyRib2R5JyBvciBzb21ldGhpbmcgZm9yIHRoZSBjb25maWdcblx0aWYgKCBjb25maWcuJGNvbnRlbnQgaW5zdGFuY2VvZiAkICkge1xuXHRcdHRoaXMuJGJvZHkuYXBwZW5kKCBjb25maWcuJGNvbnRlbnQgKTtcblx0fVxuXG5cdGlmICggY29uZmlnLnBhZGRlZCApIHtcblx0XHR0aGlzLiRib2R5LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYm9keS1wYWRkZWQnICk7XG5cdH1cblxuXHRpZiAoIGNvbmZpZy5oZWFkICkge1xuXHRcdHRoaXMuY2xvc2VCdXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7IGZyYW1lZDogZmFsc2UsIGljb246ICdjbG9zZScgfSApO1xuXHRcdHRoaXMuY2xvc2VCdXR0b24uY29ubmVjdCggdGhpcywgeyBjbGljazogJ29uQ2xvc2VCdXR0b25DbGljaycgfSApO1xuXHRcdHRoaXMuJGhlYWQgPSAkKCAnPGRpdj4nIClcblx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwV2lkZ2V0LWhlYWQnIClcblx0XHRcdC5hcHBlbmQoIHRoaXMuJGxhYmVsLCB0aGlzLmNsb3NlQnV0dG9uLiRlbGVtZW50ICk7XG5cdFx0dGhpcy4kcG9wdXAucHJlcGVuZCggdGhpcy4kaGVhZCApO1xuXHR9XG5cblx0aWYgKCBjb25maWcuJGZvb3RlciApIHtcblx0XHR0aGlzLiRmb290ZXIgPSAkKCAnPGRpdj4nIClcblx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwV2lkZ2V0LWZvb3RlcicgKVxuXHRcdFx0LmFwcGVuZCggY29uZmlnLiRmb290ZXIgKTtcblx0XHR0aGlzLiRwb3B1cC5hcHBlbmQoIHRoaXMuJGZvb3RlciApO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGx5IGhpZGRlbiAtIHVzaW5nICN0b2dnbGUgbWF5IGNhdXNlIGVycm9ycyBpZiBzdWJjbGFzc2VzIG92ZXJyaWRlIHRvZ2dsZSB3aXRoIG1ldGhvZHNcblx0Ly8gdGhhdCByZWZlcmVuY2UgcHJvcGVydGllcyBub3QgaW5pdGlhbGl6ZWQgYXQgdGhhdCB0aW1lIG9mIHBhcmVudCBjbGFzcyBjb25zdHJ1Y3Rpb25cblx0Ly8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHBvc3QtY29uc3RydWN0b3Igc2V0dXBcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1lbGVtZW50LWhpZGRlbicgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUG9wdXBXaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBXaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBXaWRnZXQsIE9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlBvcHVwV2lkZ2V0LCBPTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50ICk7XG5cbi8qIEV2ZW50cyAqL1xuXG4vKipcbiAqIEBldmVudCByZWFkeVxuICpcbiAqIFRoZSBwb3B1cCBpcyByZWFkeTogaXQgaXMgdmlzaWJsZSBhbmQgaGFzIGJlZW4gcG9zaXRpb25lZCBhbmQgY2xpcHBlZC5cbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlcyBkb2N1bWVudCBtb3VzZSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIE1vdXNlIGRvd24gZXZlbnRcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGlmIChcblx0XHR0aGlzLmlzVmlzaWJsZSgpICYmXG5cdFx0IU9PLnVpLmNvbnRhaW5zKCB0aGlzLiRlbGVtZW50LmFkZCggdGhpcy4kYXV0b0Nsb3NlSWdub3JlICkuZ2V0KCksIGUudGFyZ2V0LCB0cnVlIClcblx0KSB7XG5cdFx0dGhpcy50b2dnbGUoIGZhbHNlICk7XG5cdH1cbn07XG5cbi8vIERlcHJlY2F0ZWQgYWxpYXMgc2luY2UgMC4yOC4zXG5PTy51aS5Qb3B1cFdpZGdldC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ29uTW91c2VEb3duIGlzIGRlcHJlY2F0ZWQsIHVzZSBvbkRvY3VtZW50TW91c2VEb3duIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudE1vdXNlRG93bi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIEJpbmQgZG9jdW1lbnQgbW91c2UgZG93biBsaXN0ZW5lci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Qb3B1cFdpZGdldC5wcm90b3R5cGUuYmluZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENhcHR1cmUgY2xpY2tzIG91dHNpZGUgcG9wdXBcblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgdGhpcy5vbkRvY3VtZW50TW91c2VEb3duSGFuZGxlciwgdHJ1ZSApO1xuXHQvLyBXZSBhZGQgJ2NsaWNrJyBldmVudCBiZWNhdXNlIGlPUyBzYWZhcmkgbmVlZHMgdG8gcmVzcG9uZCB0byB0aGlzIGV2ZW50LlxuXHQvLyBXZSBjYW4ndCB1c2UgJ3RvdWNoc3RhcnQnIChhcyBpcyB1c3VhbGx5IHRoZSBlcXVpdmFsZW50IHRvICdtb3VzZWRvd24nKSBiZWNhdXNlXG5cdC8vIHRoZW4gaXQgd2lsbCB0cmlnZ2VyIHdoZW4gc2Nyb2xsaW5nLiBXaGlsZSBpT1MgU2FmYXJpIGhhcyBzb21lIHJlcG9ydGVkIGJlaGF2aW9yXG5cdC8vIG9mIG9jY2FzaW9uYWxseSBub3QgZW1pdHRpbmcgJ2NsaWNrJyBwcm9wZXJseSwgdGhhdCBldmVudCBzZWVtcyB0byBiZSB0aGUgc3RhbmRhcmRcblx0Ly8gdGhhdCBpdCBzaG91bGQgYmUgZW1pdHRpbmcsIHNvIHdlIGFkZCBpdCB0byB0aGlzIGFuZCB3aWxsIG9wZXJhdGUgdGhlIGV2ZW50IGhhbmRsZXJcblx0Ly8gb24gd2hpY2hldmVyIG9mIHRoZXNlIGV2ZW50cyB3YXMgdHJpZ2dlcmVkIGZpcnN0XG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgdGhpcy5vbkRvY3VtZW50TW91c2VEb3duSGFuZGxlciwgdHJ1ZSApO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5iaW5kTW91c2VEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ2JpbmRNb3VzZURvd25MaXN0ZW5lciBpcyBkZXByZWNhdGVkLCB1c2UgYmluZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIgaW5zdGVhZCcgKTtcblx0dGhpcy5iaW5kRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgY2xvc2UgYnV0dG9uIGNsaWNrIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Qb3B1cFdpZGdldC5wcm90b3R5cGUub25DbG9zZUJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuaXNWaXNpYmxlKCkgKSB7XG5cdFx0dGhpcy50b2dnbGUoIGZhbHNlICk7XG5cdH1cbn07XG5cbi8qKlxuICogVW5iaW5kIGRvY3VtZW50IG1vdXNlIGRvd24gbGlzdGVuZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnVuYmluZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIHRoaXMub25Eb2N1bWVudE1vdXNlRG93bkhhbmRsZXIsIHRydWUgKTtcblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB0aGlzLm9uRG9jdW1lbnRNb3VzZURvd25IYW5kbGVyLCB0cnVlICk7XG59O1xuXG4vLyBEZXByZWNhdGVkIGFsaWFzIHNpbmNlIDAuMjguM1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnVuYmluZE1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICd1bmJpbmRNb3VzZURvd25MaXN0ZW5lciBpcyBkZXByZWNhdGVkLCB1c2UgdW5iaW5kRG9jdW1lbnRNb3VzZURvd25MaXN0ZW5lciBpbnN0ZWFkJyApO1xuXHR0aGlzLnVuYmluZERvY3VtZW50TW91c2VEb3duTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGRvY3VtZW50IGtleSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIEtleSBkb3duIGV2ZW50XG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5vbkRvY3VtZW50S2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKFxuXHRcdGUud2hpY2ggPT09IE9PLnVpLktleXMuRVNDQVBFICYmXG5cdFx0dGhpcy5pc1Zpc2libGUoKVxuXHQpIHtcblx0XHR0aGlzLnRvZ2dsZSggZmFsc2UgKTtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLyoqXG4gKiBCaW5kIGRvY3VtZW50IGtleSBkb3duIGxpc3RlbmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCB0aGlzLm9uRG9jdW1lbnRLZXlEb3duSGFuZGxlciwgdHJ1ZSApO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5iaW5kS2V5RG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICdiaW5kS2V5RG93bkxpc3RlbmVyIGlzIGRlcHJlY2F0ZWQsIHVzZSBiaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIgaW5zdGVhZCcgKTtcblx0dGhpcy5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgZG9jdW1lbnQga2V5IGRvd24gbGlzdGVuZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnVuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgdGhpcy5vbkRvY3VtZW50S2V5RG93bkhhbmRsZXIsIHRydWUgKTtcbn07XG5cbi8vIERlcHJlY2F0ZWQgYWxpYXMgc2luY2UgMC4yOC4zXG5PTy51aS5Qb3B1cFdpZGdldC5wcm90b3R5cGUudW5iaW5kS2V5RG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICd1bmJpbmRLZXlEb3duTGlzdGVuZXIgaXMgZGVwcmVjYXRlZCwgdXNlIHVuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyIGluc3RlYWQnICk7XG5cdHRoaXMudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBTaG93LCBoaWRlLCBvciB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGFuY2hvci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93XSBTaG93IGFuY2hvciwgb21pdCB0byB0b2dnbGVcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnRvZ2dsZUFuY2hvciA9IGZ1bmN0aW9uICggc2hvdyApIHtcblx0c2hvdyA9IHNob3cgPT09IHVuZGVmaW5lZCA/ICF0aGlzLmFuY2hvcmVkIDogISFzaG93O1xuXG5cdGlmICggdGhpcy5hbmNob3JlZCAhPT0gc2hvdyApIHtcblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQnICk7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQtJyArIHRoaXMuYW5jaG9yRWRnZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQnICk7XG5cdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQtJyArIHRoaXMuYW5jaG9yRWRnZSApO1xuXHRcdH1cblx0XHR0aGlzLmFuY2hvcmVkID0gc2hvdztcblx0fVxufTtcblxuLyoqXG4gKiBDaGFuZ2Ugd2hpY2ggZWRnZSB0aGUgYW5jaG9yIGFwcGVhcnMgb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVkZ2UgJ3RvcCcsICdib3R0b20nLCAnc3RhcnQnIG9yICdlbmQnXG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5zZXRBbmNob3JFZGdlID0gZnVuY3Rpb24gKCBlZGdlICkge1xuXHRpZiAoIFsgJ3RvcCcsICdib3R0b20nLCAnc3RhcnQnLCAnZW5kJyBdLmluZGV4T2YoIGVkZ2UgKSA9PT0gLTEgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCB2YWx1ZSBmb3IgZWRnZTogJyArIGVkZ2UgKTtcblx0fVxuXHRpZiAoIHRoaXMuYW5jaG9yRWRnZSAhPT0gbnVsbCApIHtcblx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQtJyArIHRoaXMuYW5jaG9yRWRnZSApO1xuXHR9XG5cdHRoaXMuYW5jaG9yRWRnZSA9IGVkZ2U7XG5cdGlmICggdGhpcy5hbmNob3JlZCApIHtcblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtYW5jaG9yZWQtJyArIGVkZ2UgKTtcblx0fVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYW5jaG9yIGlzIHZpc2libGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gQW5jaG9yIGlzIHZpc2libGVcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLmhhc0FuY2hvciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuYW5jaG9yZWQ7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIHRoZSBwb3B1cC4gVGhlIHBvcHVwIGlzIGluaXRpYWxseSBoaWRkZW4gYW5kIG11c3QgYmUgc2hvd24gYnkgY2FsbGluZ1xuICogYC50b2dnbGUoIHRydWUgKWAgYWZ0ZXIgaXRzICMkZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICpcbiAqIERvIG5vdCBzaG93IHRoZSBwb3B1cCB3aGlsZSBpdCBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIERPTS4gVGhlIGNhbGN1bGF0aW9ucyByZXF1aXJlZCB0byBkaXNwbGF5XG4gKiBpdCBpbiB0aGUgcmlnaHQgcGxhY2UgYW5kIHdpdGggdGhlIHJpZ2h0IGRpbWVuc2lvbnMgb25seSB3b3JrIGNvcnJlY3RseSB3aGlsZSBpdCBpcyBhdHRhY2hlZC5cbiAqIFNpZGUtZWZmZWN0cyBtYXkgaW5jbHVkZSBicm9rZW4gaW50ZXJmYWNlIGFuZCBleGNlcHRpb25zIGJlaW5nIHRocm93bi4gVGhpcyB3YXNuJ3QgYWx3YXlzXG4gKiBzdHJpY3RseSBlbmZvcmNlZCwgc28gY3VycmVudGx5IGl0IG9ubHkgZ2VuZXJhdGVzIGEgd2FybmluZyBpbiB0aGUgYnJvd3NlciBjb25zb2xlLlxuICpcbiAqIEBmaXJlcyByZWFkeVxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICggc2hvdyApIHtcblx0dmFyIGNoYW5nZSwgbm9ybWFsSGVpZ2h0LCBvcHBvc2l0ZUhlaWdodCwgbm9ybWFsV2lkdGgsIG9wcG9zaXRlV2lkdGg7XG5cdHNob3cgPSBzaG93ID09PSB1bmRlZmluZWQgPyAhdGhpcy5pc1Zpc2libGUoKSA6ICEhc2hvdztcblxuXHRjaGFuZ2UgPSBzaG93ICE9PSB0aGlzLmlzVmlzaWJsZSgpO1xuXG5cdGlmICggc2hvdyAmJiAhdGhpcy53YXJuZWRVbmF0dGFjaGVkICYmICF0aGlzLmlzRWxlbWVudEF0dGFjaGVkKCkgKSB7XG5cdFx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnUG9wdXBXaWRnZXQjdG9nZ2xlOiBCZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCwgdGhlIHBvcHVwIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS4nICk7XG5cdFx0dGhpcy53YXJuZWRVbmF0dGFjaGVkID0gdHJ1ZTtcblx0fVxuXHRpZiAoIHNob3cgJiYgIXRoaXMuJGZsb2F0YWJsZUNvbnRhaW5lciAmJiB0aGlzLmlzRWxlbWVudEF0dGFjaGVkKCkgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgZmxvYXRhYmxlQ29udGFpbmVyIGlzIG5vdCBzZXRcblx0XHR0aGlzLnNldEZsb2F0YWJsZUNvbnRhaW5lciggdGhpcy4kZWxlbWVudC5wYXJlbnQoKSApO1xuXHR9XG5cblx0aWYgKCBjaGFuZ2UgJiYgc2hvdyAmJiB0aGlzLmF1dG9GbGlwICkge1xuXHRcdC8vIFJlc2V0IGF1dG8tZmxpcHBpbmcgYmVmb3JlIHNob3dpbmcgdGhlIHBvcHVwIGFnYWluLiBJdCdzIHBvc3NpYmxlIHdlIG5vIGxvbmdlciBuZWVkIHRvIGZsaXBcblx0XHQvLyAoZS5nLiBpZiB0aGUgdXNlciBzY3JvbGxlZCkuXG5cdFx0dGhpcy5pc0F1dG9GbGlwcGVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlBvcHVwV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUudG9nZ2xlLmNhbGwoIHRoaXMsIHNob3cgKTtcblxuXHRpZiAoIGNoYW5nZSApIHtcblx0XHR0aGlzLnRvZ2dsZVBvc2l0aW9uaW5nKCBzaG93ICYmICEhdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyICk7XG5cblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICkge1xuXHRcdFx0XHR0aGlzLmJpbmREb2N1bWVudE1vdXNlRG93bkxpc3RlbmVyKCk7XG5cdFx0XHRcdHRoaXMuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcblx0XHRcdHRoaXMudG9nZ2xlQ2xpcHBpbmcoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmF1dG9GbGlwICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucG9wdXBQb3NpdGlvbiA9PT0gJ2Fib3ZlJyB8fCB0aGlzLnBvcHVwUG9zaXRpb24gPT09ICdiZWxvdycgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xpcHBlZFZlcnRpY2FsbHkoKSB8fCB0aGlzLmlzRmxvYXRhYmxlT3V0T2ZWaWV3KCkgKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiBvcGVuaW5nIHRoZSBwb3B1cCBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvbiBjYXVzZXMgaXQgdG8gYmUgY2xpcHBlZCwgb3BlblxuXHRcdFx0XHRcdFx0Ly8gaW4gdGhlIG9wcG9zaXRlIG9uZSBpbnN0ZWFkXG5cdFx0XHRcdFx0XHRub3JtYWxIZWlnaHQgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5pc0F1dG9GbGlwcGVkID0gIXRoaXMuaXNBdXRvRmxpcHBlZDtcblx0XHRcdFx0XHRcdHRoaXMucG9zaXRpb24oKTtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5pc0NsaXBwZWRWZXJ0aWNhbGx5KCkgfHwgdGhpcy5pc0Zsb2F0YWJsZU91dE9mVmlldygpICkge1xuXHRcdFx0XHRcdFx0XHQvLyBJZiB0aGF0IGFsc28gY2F1c2VzIGl0IHRvIGJlIGNsaXBwZWQsIG9wZW4gaW4gd2hpY2hldmVyIGRpcmVjdGlvblxuXHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIG1vcmUgc3BhY2Vcblx0XHRcdFx0XHRcdFx0b3Bwb3NpdGVIZWlnaHQgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG9wcG9zaXRlSGVpZ2h0IDwgbm9ybWFsSGVpZ2h0ICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaXNBdXRvRmxpcHBlZCA9ICF0aGlzLmlzQXV0b0ZsaXBwZWQ7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5wb3B1cFBvc2l0aW9uID09PSAnYmVmb3JlJyB8fCB0aGlzLnBvcHVwUG9zaXRpb24gPT09ICdhZnRlcicgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xpcHBlZEhvcml6b250YWxseSgpIHx8IHRoaXMuaXNGbG9hdGFibGVPdXRPZlZpZXcoKSApIHtcblx0XHRcdFx0XHRcdC8vIElmIG9wZW5pbmcgdGhlIHBvcHVwIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uIGNhdXNlcyBpdCB0byBiZSBjbGlwcGVkLCBvcGVuXG5cdFx0XHRcdFx0XHQvLyBpbiB0aGUgb3Bwb3NpdGUgb25lIGluc3RlYWRcblx0XHRcdFx0XHRcdG5vcm1hbFdpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5pc0F1dG9GbGlwcGVkID0gIXRoaXMuaXNBdXRvRmxpcHBlZDtcblx0XHRcdFx0XHRcdC8vIER1ZSB0byBUMTgwMTczIGhvcml6b250YWxseSBjbGlwcGVkIFBvcHVwV2lkZ2V0cyBoYXZlIG1lc3NlZCB1cCBkaW1lbnNpb25zLFxuXHRcdFx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIHBvc2l0aW9uaW5nIHRvIGJlIG9mZi4gVG9nZ2xlIGNsaXBwaW5nIGJhY2sgYW5kIGZvcnQgdG8gd29yayBhcm91bmQuXG5cdFx0XHRcdFx0XHR0aGlzLnRvZ2dsZUNsaXBwaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVDbGlwcGluZyggdHJ1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xpcHBlZEhvcml6b250YWxseSgpIHx8IHRoaXMuaXNGbG9hdGFibGVPdXRPZlZpZXcoKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhhdCBhbHNvIGNhdXNlcyBpdCB0byBiZSBjbGlwcGVkLCBvcGVuIGluIHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBtb3JlIHNwYWNlXG5cdFx0XHRcdFx0XHRcdG9wcG9zaXRlV2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XG5cdFx0XHRcdFx0XHRcdGlmICggb3Bwb3NpdGVXaWR0aCA8IG5vcm1hbFdpZHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaXNBdXRvRmxpcHBlZCA9ICF0aGlzLmlzQXV0b0ZsaXBwZWQ7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRHVlIHRvIFQxODAxNzMgaG9yaXpvbnRhbGx5IGNsaXBwZWQgUG9wdXBXaWRnZXRzIGhhdmUgbWVzc2VkIHVwIGRpbWVuc2lvbnMsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIHBvc2l0aW9uaW5nIHRvIGJlIG9mZi4gVG9nZ2xlIGNsaXBwaW5nIGJhY2sgYW5kIGZvcnQgdG8gd29yayBhcm91bmQuXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy50b2dnbGVDbGlwcGluZyggZmFsc2UgKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBvc2l0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy50b2dnbGVDbGlwcGluZyggdHJ1ZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCggJ3JlYWR5JyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRvZ2dsZUNsaXBwaW5nKCBmYWxzZSApO1xuXHRcdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblx0XHRcdFx0dGhpcy51bmJpbmREb2N1bWVudE1vdXNlRG93bkxpc3RlbmVyKCk7XG5cdFx0XHRcdHRoaXMudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzaXplIG9mIHRoZSBwb3B1cC5cbiAqXG4gKiBDaGFuZ2luZyB0aGUgc2l6ZSBtYXkgYWxzbyBjaGFuZ2UgdGhlIHBvcHVwJ3MgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHRoZSBhbGlnbm1lbnQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW3dpZHRoPTMyMF0gV2lkdGggaW4gcGl4ZWxzLiBQYXNzIGBudWxsYCB0byB1c2UgYXV0b21hdGljIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW2hlaWdodD1udWxsXSBIZWlnaHQgaW4gcGl4ZWxzLiBQYXNzIGBudWxsYCB0byB1c2UgYXV0b21hdGljIGhlaWdodC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYW5zaXRpb249ZmFsc2VdIFVzZSBhIHNtb290aCB0cmFuc2l0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2l0aW9uICkge1xuXHR0aGlzLndpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogMzIwO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogbnVsbDtcblx0aWYgKCB0aGlzLmlzVmlzaWJsZSgpICkge1xuXHRcdHRoaXMudXBkYXRlRGltZW5zaW9ucyggdHJhbnNpdGlvbiApO1xuXHR9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc2l6ZSBhbmQgcG9zaXRpb24uXG4gKlxuICogT25seSB1c2UgdGhpcyB0byBrZWVwIHRoZSBwb3B1cCBwcm9wZXJseSBhbmNob3JlZC4gVXNlICNzZXRTaXplIHRvIGNoYW5nZSB0aGUgc2l6ZSwgYW5kIHRoaXMgd2lsbFxuICogYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbdHJhbnNpdGlvbj1mYWxzZV0gVXNlIGEgc21vb3RoIHRyYW5zaXRpb25cbiAqIEBjaGFpbmFibGVcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnVwZGF0ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoIHRyYW5zaXRpb24gKSB7XG5cdHZhciB3aWRnZXQgPSB0aGlzO1xuXG5cdC8vIFByZXZlbnQgdHJhbnNpdGlvbiBmcm9tIGJlaW5nIGludGVycnVwdGVkXG5cdGNsZWFyVGltZW91dCggdGhpcy50cmFuc2l0aW9uVGltZW91dCApO1xuXHRpZiAoIHRyYW5zaXRpb24gKSB7XG5cdFx0Ly8gRW5hYmxlIHRyYW5zaXRpb25cblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtdHJhbnNpdGlvbmluZycgKTtcblx0fVxuXG5cdHRoaXMucG9zaXRpb24oKTtcblxuXHRpZiAoIHRyYW5zaXRpb24gKSB7XG5cdFx0Ly8gUHJldmVudCB0cmFuc2l0aW9uaW5nIGFmdGVyIHRyYW5zaXRpb24gaXMgY29tcGxldGVcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0d2lkZ2V0LiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtdHJhbnNpdGlvbmluZycgKTtcblx0XHR9LCAyMDAgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmV2ZW50IHRyYW5zaXRpb25pbmcgaW1tZWRpYXRlbHlcblx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBXaWRnZXQtdHJhbnNpdGlvbmluZycgKTtcblx0fVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qb3B1cFdpZGdldC5wcm90b3R5cGUuY29tcHV0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZGlyZWN0aW9uLCBhbGlnbiwgdmVydGljYWwsIHN0YXJ0LCBlbmQsIG5lYXIsIGZhciwgc2l6ZVByb3AsIHBvcHVwU2l6ZSwgYW5jaG9yU2l6ZSwgYW5jaG9yUG9zLFxuXHRcdGFuY2hvck9mZnNldCwgYW5jaG9yTWFyZ2luLCBwYXJlbnRQb3NpdGlvbiwgcG9zaXRpb25Qcm9wLCBwb3NpdGlvbkFkanVzdG1lbnQsIGZsb2F0YWJsZVBvcyxcblx0XHRvZmZzZXRQYXJlbnRQb3MsIGNvbnRhaW5lclBvcywgcG9wdXBQb3NpdGlvbiwgdmlld3BvcnRTcGFjaW5nLFxuXHRcdHBvcHVwUG9zID0ge30sXG5cdFx0YW5jaG9yQ3NzID0geyBsZWZ0OiAnJywgcmlnaHQ6ICcnLCB0b3A6ICcnLCBib3R0b206ICcnIH0sXG5cdFx0cG9wdXBQb3NpdGlvbk9wcG9zaXRlTWFwID0ge1xuXHRcdFx0YWJvdmU6ICdiZWxvdycsXG5cdFx0XHRiZWxvdzogJ2Fib3ZlJyxcblx0XHRcdGJlZm9yZTogJ2FmdGVyJyxcblx0XHRcdGFmdGVyOiAnYmVmb3JlJ1xuXHRcdH0sXG5cdFx0YWxpZ25NYXAgPSB7XG5cdFx0XHRsdHI6IHtcblx0XHRcdFx0J2ZvcmNlLWxlZnQnOiAnYmFja3dhcmRzJyxcblx0XHRcdFx0J2ZvcmNlLXJpZ2h0JzogJ2ZvcndhcmRzJ1xuXHRcdFx0fSxcblx0XHRcdHJ0bDoge1xuXHRcdFx0XHQnZm9yY2UtbGVmdCc6ICdmb3J3YXJkcycsXG5cdFx0XHRcdCdmb3JjZS1yaWdodCc6ICdiYWNrd2FyZHMnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmNob3JFZGdlTWFwID0ge1xuXHRcdFx0YWJvdmU6ICdib3R0b20nLFxuXHRcdFx0YmVsb3c6ICd0b3AnLFxuXHRcdFx0YmVmb3JlOiAnZW5kJyxcblx0XHRcdGFmdGVyOiAnc3RhcnQnXG5cdFx0fSxcblx0XHRoUG9zTWFwID0ge1xuXHRcdFx0Zm9yd2FyZHM6ICdzdGFydCcsXG5cdFx0XHRjZW50ZXI6ICdjZW50ZXInLFxuXHRcdFx0YmFja3dhcmRzOiB0aGlzLmFuY2hvcmVkID8gJ2JlZm9yZScgOiAnZW5kJ1xuXHRcdH0sXG5cdFx0dlBvc01hcCA9IHtcblx0XHRcdGZvcndhcmRzOiAndG9wJyxcblx0XHRcdGNlbnRlcjogJ2NlbnRlcicsXG5cdFx0XHRiYWNrd2FyZHM6ICdib3R0b20nXG5cdFx0fTtcblxuXHRpZiAoICF0aGlzLiRjb250YWluZXIgKSB7XG5cdFx0Ly8gTGF6eS1pbml0aWFsaXplICRjb250YWluZXIgaWYgbm90IHNwZWNpZmllZCBpbiBjb25zdHJ1Y3RvclxuXHRcdHRoaXMuJGNvbnRhaW5lciA9ICQoIHRoaXMuZ2V0Q2xvc2VzdFNjcm9sbGFibGVFbGVtZW50Q29udGFpbmVyKCkgKTtcblx0fVxuXHRkaXJlY3Rpb24gPSB0aGlzLiRjb250YWluZXIuY3NzKCAnZGlyZWN0aW9uJyApO1xuXG5cdC8vIFNldCBoZWlnaHQgYW5kIHdpZHRoIGJlZm9yZSB3ZSBkbyBhbnl0aGluZyBlbHNlLCBzaW5jZSBpdCBtaWdodCBjYXVzZSBvdXIgbWVhc3VyZW1lbnRzXG5cdC8vIHRvIGNoYW5nZSAoZS5nLiBkdWUgdG8gc2Nyb2xsYmFycyBhcHBlYXJpbmcgb3IgZGlzYXBwZWFyaW5nKSwgYW5kIGl0IGFsc28gYWZmZWN0cyBjZW50ZXJpbmdcblx0dGhpcy4kcG9wdXAuY3NzKCB7XG5cdFx0d2lkdGg6IHRoaXMud2lkdGggIT09IG51bGwgPyB0aGlzLndpZHRoIDogJ2F1dG8nLFxuXHRcdGhlaWdodDogdGhpcy5oZWlnaHQgIT09IG51bGwgPyB0aGlzLmhlaWdodCA6ICdhdXRvJ1xuXHR9ICk7XG5cblx0YWxpZ24gPSBhbGlnbk1hcFsgZGlyZWN0aW9uIF1bIHRoaXMuYWxpZ24gXSB8fCB0aGlzLmFsaWduO1xuXHRwb3B1cFBvc2l0aW9uID0gdGhpcy5wb3B1cFBvc2l0aW9uO1xuXHRpZiAoIHRoaXMuaXNBdXRvRmxpcHBlZCApIHtcblx0XHRwb3B1cFBvc2l0aW9uID0gcG9wdXBQb3NpdGlvbk9wcG9zaXRlTWFwWyBwb3B1cFBvc2l0aW9uIF07XG5cdH1cblxuXHQvLyBJZiB0aGUgcG9wdXAgaXMgcG9zaXRpb25lZCBiZWZvcmUgb3IgYWZ0ZXIsIHRoZW4gdGhlIGFuY2hvciBwb3NpdGlvbmluZyBpcyB2ZXJ0aWNhbCwgb3RoZXJ3aXNlIGhvcml6b250YWxcblx0dmVydGljYWwgPSBwb3B1cFBvc2l0aW9uID09PSAnYmVmb3JlJyB8fCBwb3B1cFBvc2l0aW9uID09PSAnYWZ0ZXInO1xuXHRzdGFydCA9IHZlcnRpY2FsID8gJ3RvcCcgOiAoIGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnICk7XG5cdGVuZCA9IHZlcnRpY2FsID8gJ2JvdHRvbScgOiAoIGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAnbGVmdCcgOiAncmlnaHQnICk7XG5cdG5lYXIgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnO1xuXHRmYXIgPSB2ZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0Jztcblx0c2l6ZVByb3AgPSB2ZXJ0aWNhbCA/ICdIZWlnaHQnIDogJ1dpZHRoJztcblx0cG9wdXBTaXplID0gdmVydGljYWwgPyAoIHRoaXMuaGVpZ2h0IHx8IHRoaXMuJHBvcHVwLmhlaWdodCgpICkgOiAoIHRoaXMud2lkdGggfHwgdGhpcy4kcG9wdXAud2lkdGgoKSApO1xuXG5cdHRoaXMuc2V0QW5jaG9yRWRnZSggYW5jaG9yRWRnZU1hcFsgcG9wdXBQb3NpdGlvbiBdICk7XG5cdHRoaXMuaG9yaXpvbnRhbFBvc2l0aW9uID0gdmVydGljYWwgPyBwb3B1cFBvc2l0aW9uIDogaFBvc01hcFsgYWxpZ24gXTtcblx0dGhpcy52ZXJ0aWNhbFBvc2l0aW9uID0gdmVydGljYWwgPyB2UG9zTWFwWyBhbGlnbiBdIDogcG9wdXBQb3NpdGlvbjtcblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdHBhcmVudFBvc2l0aW9uID0gT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5wcm90b3R5cGUuY29tcHV0ZVBvc2l0aW9uLmNhbGwoIHRoaXMgKTtcblx0Ly8gRmluZCBvdXQgd2hpY2ggcHJvcGVydHkgRmxvYXRhYmxlRWxlbWVudCB1c2VkIGZvciBwb3NpdGlvbmluZywgYW5kIGFkanVzdCB0aGF0IHZhbHVlXG5cdHBvc2l0aW9uUHJvcCA9IHZlcnRpY2FsID9cblx0XHQoIHBhcmVudFBvc2l0aW9uLnRvcCAhPT0gJycgPyAndG9wJyA6ICdib3R0b20nICkgOlxuXHRcdCggcGFyZW50UG9zaXRpb24ubGVmdCAhPT0gJycgPyAnbGVmdCcgOiAncmlnaHQnICk7XG5cblx0Ly8gRmlndXJlIG91dCB3aGVyZSB0aGUgbmVhciBhbmQgZmFyIGVkZ2VzIG9mIHRoZSBwb3B1cCBhbmQgJGZsb2F0YWJsZUNvbnRhaW5lciBhcmVcblx0ZmxvYXRhYmxlUG9zID0gdGhpcy4kZmxvYXRhYmxlQ29udGFpbmVyLm9mZnNldCgpO1xuXHRmbG9hdGFibGVQb3NbIGZhciBdID0gZmxvYXRhYmxlUG9zWyBuZWFyIF0gKyB0aGlzLiRmbG9hdGFibGVDb250YWluZXJbICdvdXRlcicgKyBzaXplUHJvcCBdKCk7XG5cdC8vIE1lYXN1cmUgd2hlcmUgdGhlIG9mZnNldFBhcmVudCBpcyBhbmQgY29tcHV0ZSBvdXIgcG9zaXRpb24gYmFzZWQgb24gdGhhdCBhbmQgcGFyZW50UG9zaXRpb25cblx0b2Zmc2V0UGFyZW50UG9zID0gdGhpcy4kZWxlbWVudC5vZmZzZXRQYXJlbnQoKVsgMCBdID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgP1xuXHRcdHsgdG9wOiAwLCBsZWZ0OiAwIH0gOlxuXHRcdHRoaXMuJGVsZW1lbnQub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCk7XG5cblx0aWYgKCBwb3NpdGlvblByb3AgPT09IG5lYXIgKSB7XG5cdFx0cG9wdXBQb3NbIG5lYXIgXSA9IG9mZnNldFBhcmVudFBvc1sgbmVhciBdICsgcGFyZW50UG9zaXRpb25bIG5lYXIgXTtcblx0XHRwb3B1cFBvc1sgZmFyIF0gPSBwb3B1cFBvc1sgbmVhciBdICsgcG9wdXBTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHBvcHVwUG9zWyBmYXIgXSA9IG9mZnNldFBhcmVudFBvc1sgbmVhciBdICtcblx0XHRcdHRoaXMuJGVsZW1lbnQub2Zmc2V0UGFyZW50KClbICdpbm5lcicgKyBzaXplUHJvcCBdKCkgLSBwYXJlbnRQb3NpdGlvblsgZmFyIF07XG5cdFx0cG9wdXBQb3NbIG5lYXIgXSA9IHBvcHVwUG9zWyBmYXIgXSAtIHBvcHVwU2l6ZTtcblx0fVxuXG5cdGlmICggdGhpcy5hbmNob3JlZCApIHtcblx0XHQvLyBQb3NpdGlvbiB0aGUgYW5jaG9yICh3aGljaCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBwb3B1cCkgdG8gcG9pbnQgdG8gJGZsb2F0YWJsZUNvbnRhaW5lclxuXHRcdGFuY2hvclBvcyA9ICggZmxvYXRhYmxlUG9zWyBzdGFydCBdICsgZmxvYXRhYmxlUG9zWyBlbmQgXSApIC8gMjtcblx0XHRhbmNob3JPZmZzZXQgPSAoIHN0YXJ0ID09PSBmYXIgPyAtMSA6IDEgKSAqICggYW5jaG9yUG9zIC0gcG9wdXBQb3NbIHN0YXJ0IF0gKTtcblxuXHRcdC8vIElmIHRoZSBhbmNob3IgaXMgbGVzcyB0aGFuIDIqYW5jaG9yU2l6ZSBmcm9tIGVpdGhlciBlZGdlLCBtb3ZlIHRoZSBwb3B1cCB0byBtYWtlIG1vcmUgc3BhY2Vcblx0XHQvLyB0aGlzLiRhbmNob3Iud2lkdGgoKS9oZWlnaHQoKSByZXR1cm5zIDAgYmVjYXVzZSBvZiB0aGUgQ1NTIHRyaWNrZXJ5IHdlIHVzZSwgc28gdXNlIHNjcm9sbFdpZHRoL0hlaWdodFxuXHRcdGFuY2hvclNpemUgPSB0aGlzLiRhbmNob3JbIDAgXVsgJ3Njcm9sbCcgKyBzaXplUHJvcCBdO1xuXHRcdGFuY2hvck1hcmdpbiA9IHBhcnNlRmxvYXQoIHRoaXMuJGFuY2hvci5jc3MoICdtYXJnaW4tJyArIHN0YXJ0ICkgKTtcblx0XHRpZiAoIGFuY2hvck9mZnNldCArIGFuY2hvck1hcmdpbiA8IDIgKiBhbmNob3JTaXplICkge1xuXHRcdFx0Ly8gTm90IGVub3VnaCBzcGFjZSBmb3IgdGhlIGFuY2hvciBvbiB0aGUgc3RhcnQgc2lkZTsgcHVsbCB0aGUgcG9wdXAgc3RhcnR3YXJkc1xuXHRcdFx0cG9zaXRpb25BZGp1c3RtZW50ID0gKCBwb3NpdGlvblByb3AgPT09IHN0YXJ0ID8gLTEgOiAxICkgKlxuXHRcdFx0XHQoIDIgKiBhbmNob3JTaXplIC0gKCBhbmNob3JPZmZzZXQgKyBhbmNob3JNYXJnaW4gKSApO1xuXHRcdH0gZWxzZSBpZiAoIGFuY2hvck9mZnNldCArIGFuY2hvck1hcmdpbiA+IHBvcHVwU2l6ZSAtIDIgKiBhbmNob3JTaXplICkge1xuXHRcdFx0Ly8gTm90IGVub3VnaCBzcGFjZSBmb3IgdGhlIGFuY2hvciBvbiB0aGUgZW5kIHNpZGU7IHB1bGwgdGhlIHBvcHVwIGVuZHdhcmRzXG5cdFx0XHRwb3NpdGlvbkFkanVzdG1lbnQgPSAoIHBvc2l0aW9uUHJvcCA9PT0gZW5kID8gLTEgOiAxICkgKlxuXHRcdFx0XHQoIGFuY2hvck9mZnNldCArIGFuY2hvck1hcmdpbiAtICggcG9wdXBTaXplIC0gMiAqIGFuY2hvclNpemUgKSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbkFkanVzdG1lbnQgPSAwO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwb3NpdGlvbkFkanVzdG1lbnQgPSAwO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIHBvcHVwIHdpbGwgZ28gYmV5b25kIHRoZSBlZGdlIG9mIHRoaXMuJGNvbnRhaW5lclxuXHRjb250YWluZXJQb3MgPSB0aGlzLiRjb250YWluZXJbIDAgXSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID9cblx0XHR7IHRvcDogMCwgbGVmdDogMCB9IDpcblx0XHR0aGlzLiRjb250YWluZXIub2Zmc2V0KCk7XG5cdGNvbnRhaW5lclBvc1sgZmFyIF0gPSBjb250YWluZXJQb3NbIG5lYXIgXSArIHRoaXMuJGNvbnRhaW5lclsgJ2lubmVyJyArIHNpemVQcm9wIF0oKTtcblx0aWYgKCB0aGlzLiRjb250YWluZXJbIDAgXSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHZpZXdwb3J0U3BhY2luZyA9IE9PLnVpLmdldFZpZXdwb3J0U3BhY2luZygpO1xuXHRcdGNvbnRhaW5lclBvc1sgbmVhciBdICs9IHZpZXdwb3J0U3BhY2luZ1sgbmVhciBdO1xuXHRcdGNvbnRhaW5lclBvc1sgZmFyIF0gLT0gdmlld3BvcnRTcGFjaW5nWyBmYXIgXTtcblx0fVxuXHQvLyBUYWtlIGludG8gYWNjb3VudCBob3cgbXVjaCB0aGUgcG9wdXAgd2lsbCBtb3ZlIGJlY2F1c2Ugb2YgdGhlIGFkanVzdG1lbnRzIHdlJ3JlIGdvaW5nIHRvIG1ha2Vcblx0cG9wdXBQb3NbIG5lYXIgXSArPSAoIHBvc2l0aW9uUHJvcCA9PT0gbmVhciA/IDEgOiAtMSApICogcG9zaXRpb25BZGp1c3RtZW50O1xuXHRwb3B1cFBvc1sgZmFyIF0gKz0gKCBwb3NpdGlvblByb3AgPT09IG5lYXIgPyAxIDogLTEgKSAqIHBvc2l0aW9uQWRqdXN0bWVudDtcblx0aWYgKCBjb250YWluZXJQb3NbIG5lYXIgXSArIHRoaXMuY29udGFpbmVyUGFkZGluZyA+IHBvcHVwUG9zWyBuZWFyIF0gKSB7XG5cdFx0Ly8gUG9wdXAgZ29lcyBiZXlvbmQgdGhlIG5lYXIgKGxlZnQvdG9wKSBlZGdlLCBtb3ZlIGl0IHRvIHRoZSByaWdodC9ib3R0b21cblx0XHRwb3NpdGlvbkFkanVzdG1lbnQgKz0gKCBwb3NpdGlvblByb3AgPT09IG5lYXIgPyAxIDogLTEgKSAqXG5cdFx0XHQoIGNvbnRhaW5lclBvc1sgbmVhciBdICsgdGhpcy5jb250YWluZXJQYWRkaW5nIC0gcG9wdXBQb3NbIG5lYXIgXSApO1xuXHR9IGVsc2UgaWYgKCBjb250YWluZXJQb3NbIGZhciBdIC0gdGhpcy5jb250YWluZXJQYWRkaW5nIDwgcG9wdXBQb3NbIGZhciBdICkge1xuXHRcdC8vIFBvcHVwIGdvZXMgYmV5b25kIHRoZSBmYXIgKHJpZ2h0L2JvdHRvbSkgZWRnZSwgbW92ZSBpdCB0byB0aGUgbGVmdC90b3Bcblx0XHRwb3NpdGlvbkFkanVzdG1lbnQgKz0gKCBwb3NpdGlvblByb3AgPT09IGZhciA/IDEgOiAtMSApICpcblx0XHRcdCggcG9wdXBQb3NbIGZhciBdIC0gKCBjb250YWluZXJQb3NbIGZhciBdIC0gdGhpcy5jb250YWluZXJQYWRkaW5nICkgKTtcblx0fVxuXG5cdGlmICggdGhpcy5hbmNob3JlZCApIHtcblx0XHQvLyBBZGp1c3QgYW5jaG9yT2Zmc2V0IGZvciBwb3NpdGlvbkFkanVzdG1lbnRcblx0XHRhbmNob3JPZmZzZXQgKz0gKCBwb3NpdGlvblByb3AgPT09IHN0YXJ0ID8gLTEgOiAxICkgKiBwb3NpdGlvbkFkanVzdG1lbnQ7XG5cblx0XHQvLyBQb3NpdGlvbiB0aGUgYW5jaG9yXG5cdFx0YW5jaG9yQ3NzWyBzdGFydCBdID0gYW5jaG9yT2Zmc2V0O1xuXHRcdHRoaXMuJGFuY2hvci5jc3MoIGFuY2hvckNzcyApO1xuXHR9XG5cblx0Ly8gTW92ZSB0aGUgcG9wdXAgaWYgbmVlZGVkXG5cdHBhcmVudFBvc2l0aW9uWyBwb3NpdGlvblByb3AgXSArPSBwb3NpdGlvbkFkanVzdG1lbnQ7XG5cblx0cmV0dXJuIHBhcmVudFBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBTZXQgcG9wdXAgYWxpZ25tZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFthbGlnbj1jZW50ZXJdIEFsaWdubWVudCBvZiB0aGUgcG9wdXAsIGBjZW50ZXJgLCBgZm9yY2UtbGVmdGAsIGBmb3JjZS1yaWdodGAsXG4gKiAgYGJhY2t3YXJkc2Agb3IgYGZvcndhcmRzYC5cbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnNldEFsaWdubWVudCA9IGZ1bmN0aW9uICggYWxpZ24gKSB7XG5cdC8vIFZhbGlkYXRlIGFsaWdubWVudFxuXHRpZiAoIFsgJ2ZvcmNlLWxlZnQnLCAnZm9yY2UtcmlnaHQnLCAnYmFja3dhcmRzJywgJ2ZvcndhcmRzJywgJ2NlbnRlcicgXS5pbmRleE9mKCBhbGlnbiApID4gLTEgKSB7XG5cdFx0dGhpcy5hbGlnbiA9IGFsaWduO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuYWxpZ24gPSAnY2VudGVyJztcblx0fVxuXHR0aGlzLnBvc2l0aW9uKCk7XG59O1xuXG4vKipcbiAqIEdldCBwb3B1cCBhbGlnbm1lbnRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFsaWdubWVudCBvZiB0aGUgcG9wdXAsIGBjZW50ZXJgLCBgZm9yY2UtbGVmdGAsIGBmb3JjZS1yaWdodGAsXG4gKiAgYGJhY2t3YXJkc2Agb3IgYGZvcndhcmRzYC5cbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLmdldEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuYWxpZ247XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIHBvcHVwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAnYWJvdmUnLCAnYmVsb3cnLCAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICggcG9zaXRpb24gKSB7XG5cdGlmICggWyAnYWJvdmUnLCAnYmVsb3cnLCAnYmVmb3JlJywgJ2FmdGVyJyBdLmluZGV4T2YoIHBvc2l0aW9uICkgPT09IC0xICkge1xuXHRcdHBvc2l0aW9uID0gJ2JlbG93Jztcblx0fVxuXHR0aGlzLnBvcHVwUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0dGhpcy5wb3NpdGlvbigpO1xufTtcblxuLyoqXG4gKiBHZXQgcG9wdXAgcG9zaXRpb25pbmcuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSAnYWJvdmUnLCAnYmVsb3cnLCAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMucG9wdXBQb3NpdGlvbjtcbn07XG5cbi8qKlxuICogU2V0IHBvcHVwIGF1dG8tZmxpcHBpbmcuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBhdXRvRmxpcCBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHRoZSBwb3B1cCdzIHBvc2l0aW9uIGJldHdlZW5cbiAqICAnYWJvdmUnIGFuZCAnYmVsb3cnLCBvciBiZXR3ZWVuICdiZWZvcmUnIGFuZCAnYWZ0ZXInLCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGluIHRoZVxuICogIGRlc2lyZWQgZGlyZWN0aW9uIHRvIGRpc3BsYXkgdGhlIHBvcHVwIHdpdGhvdXQgY2xpcHBpbmdcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnNldEF1dG9GbGlwID0gZnVuY3Rpb24gKCBhdXRvRmxpcCApIHtcblx0YXV0b0ZsaXAgPSAhIWF1dG9GbGlwO1xuXG5cdGlmICggdGhpcy5hdXRvRmxpcCAhPT0gYXV0b0ZsaXAgKSB7XG5cdFx0dGhpcy5hdXRvRmxpcCA9IGF1dG9GbGlwO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldCB3aGljaCBlbGVtZW50cyB3aWxsIG5vdCBjbG9zZSB0aGUgcG9wdXAgd2hlbiBjbGlja2VkLlxuICpcbiAqIEZvciBhdXRvLWNsb3NpbmcgcG9wdXBzLCBjbGlja3Mgb24gdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgY2F1c2UgdGhlIHBvcHVwIHRvIGF1dG8tY2xvc2UuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICRhdXRvQ2xvc2VJZ25vcmUgRWxlbWVudHMgdG8gaWdub3JlIGZvciBhdXRvLWNsb3NpbmdcbiAqL1xuT08udWkuUG9wdXBXaWRnZXQucHJvdG90eXBlLnNldEF1dG9DbG9zZUlnbm9yZSA9IGZ1bmN0aW9uICggJGF1dG9DbG9zZUlnbm9yZSApIHtcblx0dGhpcy4kYXV0b0Nsb3NlSWdub3JlID0gJGF1dG9DbG9zZUlnbm9yZTtcbn07XG5cbi8qKlxuICogR2V0IGFuIElEIG9mIHRoZSBib2R5IGVsZW1lbnQsIHRoaXMgY2FuIGJlIHVzZWQgYXMgdGhlXG4gKiBgYXJpYS1kZXNjcmliZWRieWAgYXR0cmlidXRlIGZvciBhbiBpbnB1dCBmaWVsZC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBJRCBvZiB0aGUgYm9keSBlbGVtZW50XG4gKi9cbk9PLnVpLlBvcHVwV2lkZ2V0LnByb3RvdHlwZS5nZXRCb2R5SWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpZCA9IHRoaXMuJGJvZHkuYXR0ciggJ2lkJyApO1xuXHRpZiAoIGlkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0aWQgPSBPTy51aS5nZW5lcmF0ZUVsZW1lbnRJZCgpO1xuXHRcdHRoaXMuJGJvZHkuYXR0ciggJ2lkJywgaWQgKTtcblx0fVxuXHRyZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIFBvcHVwRWxlbWVudCBpcyBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXMgdG8gZ2VuZXJhdGUgYSB7QGxpbmsgT08udWkuUG9wdXBXaWRnZXQgcG9wdXAgd2lkZ2V0fS5cbiAqIEEgcG9wdXAgaXMgYSBjb250YWluZXIgZm9yIGNvbnRlbnQuIEl0IGlzIG92ZXJsYWlkIGFuZCBwb3NpdGlvbmVkIGFic29sdXRlbHkuIEJ5IGRlZmF1bHQsIGVhY2hcbiAqIHBvcHVwIGhhcyBhbiBhbmNob3IsIHdoaWNoIGlzIGFuIGFycm93LWxpa2UgcHJvdHJ1c2lvbiB0aGF0IHBvaW50cyB0b3dhcmQgdGhlIHBvcHVw4oCZcyBvcmlnaW4uXG4gKiBTZWUge0BsaW5rIE9PLnVpLlBvcHVwV2lkZ2V0IFBvcHVwV2lkZ2V0fSBmb3IgYW4gZXhhbXBsZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7T2JqZWN0fSBbcG9wdXBdIENvbmZpZ3VyYXRpb24gdG8gcGFzcyB0byBwb3B1cFxuICogQGNmZyB7Ym9vbGVhbn0gW3BvcHVwLmF1dG9DbG9zZT10cnVlXSBQb3B1cCBhdXRvLWNsb3NlcyB3aGVuIGl0IGxvc2VzIGZvY3VzXG4gKi9cbk9PLnVpLm1peGluLlBvcHVwRWxlbWVudCA9IGZ1bmN0aW9uIE9vVWlNaXhpblBvcHVwRWxlbWVudCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMucG9wdXAgPSBuZXcgT08udWkuUG9wdXBXaWRnZXQoICQuZXh0ZW5kKFxuXHRcdHtcblx0XHRcdGF1dG9DbG9zZTogdHJ1ZSxcblx0XHRcdCRmbG9hdGFibGVDb250YWluZXI6IHRoaXMuJGVsZW1lbnRcblx0XHR9LFxuXHRcdGNvbmZpZy5wb3B1cCxcblx0XHR7XG5cdFx0XHQkYXV0b0Nsb3NlSWdub3JlOiB0aGlzLiRlbGVtZW50LmFkZCggY29uZmlnLnBvcHVwICYmIGNvbmZpZy5wb3B1cC4kYXV0b0Nsb3NlSWdub3JlIClcblx0XHR9XG5cdCkgKTtcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgcG9wdXAuXG4gKlxuICogQHJldHVybiB7T08udWkuUG9wdXBXaWRnZXR9IFBvcHVwIHdpZGdldFxuICovXG5PTy51aS5taXhpbi5Qb3B1cEVsZW1lbnQucHJvdG90eXBlLmdldFBvcHVwID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5wb3B1cDtcbn07XG5cbi8qKlxuICogUG9wdXBCdXR0b25XaWRnZXRzIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBhIGNvbnRhaW5lZCB7QGxpbmsgT08udWkuUG9wdXBXaWRnZXQgUG9wdXBXaWRnZXR9LFxuICogd2hpY2ggaXMgdXNlZCB0byBkaXNwbGF5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3Igb3B0aW9ucy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIFBvcHVwQnV0dG9uV2lkZ2V0LlxuICogICAgIHZhciBwb3B1cEJ1dHRvbiA9IG5ldyBPTy51aS5Qb3B1cEJ1dHRvbldpZGdldCgge1xuICogICAgICAgICBsYWJlbDogJ1BvcHVwIGJ1dHRvbiB3aXRoIG9wdGlvbnMnLFxuICogICAgICAgICBpY29uOiAnbWVudScsXG4gKiAgICAgICAgIHBvcHVwOiB7XG4gKiAgICAgICAgICAgICAkY29udGVudDogJCggJzxwPkFkZGl0aW9uYWwgb3B0aW9ucyBoZXJlLjwvcD4nICksXG4gKiAgICAgICAgICAgICBwYWRkZWQ6IHRydWUsXG4gKiAgICAgICAgICAgICBhbGlnbjogJ2ZvcmNlLWxlZnQnXG4gKiAgICAgICAgIH1cbiAqICAgICB9ICk7XG4gKiAgICAgLy8gQXBwZW5kIHRoZSBidXR0b24gdG8gdGhlIERPTS5cbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBwb3B1cEJ1dHRvbi4kZWxlbWVudCApO1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuQnV0dG9uV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlBvcHVwRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJG92ZXJsYXldIFJlbmRlciB0aGUgcG9wdXAgaW50byBhIHNlcGFyYXRlIGxheWVyLiBUaGlzIGNvbmZpZ3VyYXRpb24gaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gKiAgdGhlIGV4cGFuZGVkIHBvcHVwIGlzIGxhcmdlciB0aGFuIGl0cyBjb250YWluaW5nIGA8ZGl2PmAuIFRoZSBzcGVjaWZpZWQgb3ZlcmxheSBsYXllciBpcyB1c3VhbGx5IG9uIHRvcCBvZiB0aGVcbiAqICBjb250YWluaW5nIGA8ZGl2PmAgYW5kIGhhcyBhIGxhcmdlciBhcmVhLiBCeSBkZWZhdWx0LCB0aGUgcG9wdXAgdXNlcyByZWxhdGl2ZSBwb3NpdGlvbmluZy5cbiAqICBTZWUgPGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL0NvbmNlcHRzI092ZXJsYXlzPi5cbiAqL1xuT08udWkuUG9wdXBCdXR0b25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpUG9wdXBCdXR0b25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlBvcHVwQnV0dG9uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uUG9wdXBFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kb3ZlcmxheSA9ICggY29uZmlnLiRvdmVybGF5ID09PSB0cnVlID8gT08udWkuZ2V0RGVmYXVsdE92ZXJsYXkoKSA6IGNvbmZpZy4kb3ZlcmxheSApIHx8IHRoaXMuJGVsZW1lbnQ7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuY29ubmVjdCggdGhpcywgeyBjbGljazogJ29uQWN0aW9uJyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwQnV0dG9uV2lkZ2V0JyApO1xuXHR0aGlzLnBvcHVwLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktcG9wdXBCdXR0b25XaWRnZXQtcG9wdXAnIClcblx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1wb3B1cEJ1dHRvbldpZGdldC1mcmFtZWQtcG9wdXAnLCB0aGlzLmlzRnJhbWVkKCkgKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLXBvcHVwQnV0dG9uV2lkZ2V0LWZyYW1lbGVzcy1wb3B1cCcsICF0aGlzLmlzRnJhbWVkKCkgKTtcblx0dGhpcy4kb3ZlcmxheS5hcHBlbmQoIHRoaXMucG9wdXAuJGVsZW1lbnQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUG9wdXBCdXR0b25XaWRnZXQsIE9PLnVpLkJ1dHRvbldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBCdXR0b25XaWRnZXQsIE9PLnVpLm1peGluLlBvcHVwRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIHRoZSBidXR0b24gYWN0aW9uIGJlaW5nIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Qb3B1cEJ1dHRvbldpZGdldC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMucG9wdXAudG9nZ2xlKCk7XG59O1xuXG4vKipcbiAqIE1peGluIGZvciBPTy51aS5XaWRnZXQgc3ViY2xhc3NlcyB0byBwcm92aWRlIE9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5cbiAqXG4gKiBVc2UgdG9nZXRoZXIgd2l0aCBPTy51aS5taXhpbi5JdGVtV2lkZ2V0IHRvIG1ha2UgZGlzYWJsZWQgc3RhdGUgaW5oZXJpdGFibGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkdyb3VwRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5taXhpbi5Hcm91cFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlNaXhpbkdyb3VwV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5taXhpbkNsYXNzKCBPTy51aS5taXhpbi5Hcm91cFdpZGdldCwgT08udWkubWl4aW4uR3JvdXBFbGVtZW50ICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSB3aWRnZXQuXG4gKlxuICogVGhpcyB3aWxsIGFsc28gdXBkYXRlIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiBjaGlsZCB3aWRnZXRzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgRGlzYWJsZSB3aWRnZXRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLkdyb3VwV2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggZGlzYWJsZWQgKSB7XG5cdHZhciBpLCBsZW47XG5cblx0Ly8gUGFyZW50IG1ldGhvZFxuXHQvLyBOb3RlOiBDYWxsaW5nICNzZXREaXNhYmxlZCB0aGlzIHdheSBhc3N1bWVzIHRoaXMgaXMgbWl4ZWQgaW50byBhbiBPTy51aS5XaWRnZXRcblx0T08udWkuV2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZC5jYWxsKCB0aGlzLCBkaXNhYmxlZCApO1xuXG5cdC8vIER1cmluZyBjb25zdHJ1Y3Rpb24sICNzZXREaXNhYmxlZCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgY29uc3RydWN0b3Jcblx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0dGhpcy5pdGVtc1sgaSBdLnVwZGF0ZURpc2FibGVkKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1peGluIGZvciB3aWRnZXRzIHVzZWQgYXMgaXRlbXMgaW4gd2lkZ2V0cyB0aGF0IG1peCBpbiBPTy51aS5taXhpbi5Hcm91cFdpZGdldC5cbiAqXG4gKiBJdGVtIHdpZGdldHMgaGF2ZSBhIHJlZmVyZW5jZSB0byBhIE9PLnVpLm1peGluLkdyb3VwV2lkZ2V0IHdoaWxlIHRoZXkgYXJlIGF0dGFjaGVkIHRvIHRoZSBncm91cC4gVGhpc1xuICogYWxsb3dzIGJpZGlyZWN0aW9uYWwgY29tbXVuaWNhdGlvbi5cbiAqXG4gKiBVc2UgdG9nZXRoZXIgd2l0aCBPTy51aS5taXhpbi5Hcm91cFdpZGdldCB0byBtYWtlIGRpc2FibGVkIHN0YXRlIGluaGVyaXRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5PTy51aS5taXhpbi5JdGVtV2lkZ2V0ID0gZnVuY3Rpb24gT29VaU1peGluSXRlbVdpZGdldCgpIHtcblx0Ly9cbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBDaGVjayBpZiB3aWRnZXQgaXMgZGlzYWJsZWQuXG4gKlxuICogQ2hlY2tzIHBhcmVudCBpZiBwcmVzZW50LCBtYWtpbmcgZGlzYWJsZWQgc3RhdGUgaW5oZXJpdGFibGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2lkZ2V0IGlzIGRpc2FibGVkXG4gKi9cbk9PLnVpLm1peGluLkl0ZW1XaWRnZXQucHJvdG90eXBlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmRpc2FibGVkIHx8XG5cdFx0KCB0aGlzLmVsZW1lbnRHcm91cCBpbnN0YW5jZW9mIE9PLnVpLldpZGdldCAmJiB0aGlzLmVsZW1lbnRHcm91cC5pc0Rpc2FibGVkKCkgKTtcbn07XG5cbi8qKlxuICogU2V0IGdyb3VwIGVsZW1lbnQgaXMgaW4uXG4gKlxuICogQHBhcmFtIHtPTy51aS5taXhpbi5Hcm91cEVsZW1lbnR8bnVsbH0gZ3JvdXAgR3JvdXAgZWxlbWVudCwgbnVsbCBpZiBub25lXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5JdGVtV2lkZ2V0LnByb3RvdHlwZS5zZXRFbGVtZW50R3JvdXAgPSBmdW5jdGlvbiAoIGdyb3VwICkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdC8vIE5vdGU6IENhbGxpbmcgI3NldEVsZW1lbnRHcm91cCB0aGlzIHdheSBhc3N1bWVzIHRoaXMgaXMgbWl4ZWQgaW50byBhbiBPTy51aS5FbGVtZW50XG5cdE9PLnVpLkVsZW1lbnQucHJvdG90eXBlLnNldEVsZW1lbnRHcm91cC5jYWxsKCB0aGlzLCBncm91cCApO1xuXG5cdC8vIEluaXRpYWxpemUgaXRlbSBkaXNhYmxlZCBzdGF0ZXNcblx0dGhpcy51cGRhdGVEaXNhYmxlZCgpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcHRpb25XaWRnZXRzIGFyZSBzcGVjaWFsIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGFuZCBjb25maWd1cmVkIHdpdGggZGF0YS4gVGhlXG4gKiBkYXRhIGlzIG9mdGVuIHVuaXF1ZSBmb3IgZWFjaCBvcHRpb24sIGJ1dCBpdCBkb2VzIG5vdCBoYXZlIHRvIGJlLiBPcHRpb25XaWRnZXRzIGFyZSB1c2VkXG4gKiB3aXRoIE9PLnVpLlNlbGVjdFdpZGdldCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gb2YgbXV0dWFsbHkgZXhjbHVzaXZlIG9wdGlvbnMuIEZvciBtb3JlIGluZm9ybWF0aW9uXG4gKiBhbmQgZXhhbXBsZXMsIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9uc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkl0ZW1XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uTGFiZWxFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkFjY2Vzc0tleWVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldCA9IGZ1bmN0aW9uIE9vVWlPcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk9wdGlvbldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkl0ZW1XaWRnZXQuY2FsbCggdGhpcyApO1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG5cdHRoaXMuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcblx0dGhpcy5wcmVzc2VkID0gZmFsc2U7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5kYXRhKCAnb28tdWktb3B0aW9uV2lkZ2V0JywgdGhpcyApXG5cdFx0Ly8gQWxsb3cgcHJvZ3JhbW1hdGljIGZvY3Vzc2luZyAoYW5kIGJ5IGFjY2Vzc2tleSksIGJ1dCBub3QgdGFiYmluZ1xuXHRcdC5hdHRyKCAndGFiaW5kZXgnLCAnLTEnIClcblx0XHQuYXR0ciggJ3JvbGUnLCAnb3B0aW9uJyApXG5cdFx0LmF0dHIoICdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktb3B0aW9uV2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kbGFiZWwgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuT3B0aW9uV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLk9wdGlvbldpZGdldCwgT08udWkubWl4aW4uSXRlbVdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuT3B0aW9uV2lkZ2V0LCBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLk9wdGlvbldpZGdldCwgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLk9wdGlvbldpZGdldCwgT08udWkubWl4aW4uQWNjZXNzS2V5ZWRFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5PcHRpb25XaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgb3B0aW9uIGNhbiBiZSBzZWxlY3RlZC4gU2VlICNzZXRTZWxlY3RlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkuT3B0aW9uV2lkZ2V0LnN0YXRpYy5zZWxlY3RhYmxlID0gdHJ1ZTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgb3B0aW9uIGNhbiBiZSBoaWdobGlnaHRlZC4gU2VlICNzZXRIaWdobGlnaHRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkuT3B0aW9uV2lkZ2V0LnN0YXRpYy5oaWdobGlnaHRhYmxlID0gdHJ1ZTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgb3B0aW9uIGNhbiBiZSBwcmVzc2VkLiBTZWUgI3NldFByZXNzZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldC5zdGF0aWMucHJlc3NhYmxlID0gdHJ1ZTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgb3B0aW9uIHdpbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IHdoZW4gaXQgaXMgc2VsZWN0ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldC5zdGF0aWMuc2Nyb2xsSW50b1ZpZXdPblNlbGVjdCA9IGZhbHNlO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG9wdGlvbiBjYW4gYmUgc2VsZWN0ZWQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXRlbSBpcyBzZWxlY3RhYmxlXG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldC5wcm90b3R5cGUuaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuc2VsZWN0YWJsZSAmJiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmlzVmlzaWJsZSgpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgb3B0aW9uIGNhbiBiZSBoaWdobGlnaHRlZC4gQSBoaWdobGlnaHQgaW5kaWNhdGVzIHRoYXQgdGhlIG9wdGlvblxuICogbWF5IGJlIHNlbGVjdGVkIHdoZW4gYSB1c2VyIHByZXNzZXMgZW50ZXIgb3IgY2xpY2tzLiBEaXNhYmxlZCBpdGVtcyBjYW5ub3RcbiAqIGJlIGhpZ2hsaWdodGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEl0ZW0gaXMgaGlnaGxpZ2h0YWJsZVxuICovXG5PTy51aS5PcHRpb25XaWRnZXQucHJvdG90eXBlLmlzSGlnaGxpZ2h0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmhpZ2hsaWdodGFibGUgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5pc1Zpc2libGUoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG9wdGlvbiBjYW4gYmUgcHJlc3NlZC4gVGhlIHByZXNzZWQgc3RhdGUgb2NjdXJzIHdoZW4gYSB1c2VyIG1vdXNlc1xuICogZG93biBvbiBhbiBpdGVtLCBidXQgaGFzIG5vdCB5ZXQgbGV0IGdvIG9mIHRoZSBtb3VzZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBJdGVtIGlzIHByZXNzYWJsZVxuICovXG5PTy51aS5PcHRpb25XaWRnZXQucHJvdG90eXBlLmlzUHJlc3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMucHJlc3NhYmxlICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMuaXNWaXNpYmxlKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXRlbSBpcyBzZWxlY3RlZFxuICovXG5PTy51aS5PcHRpb25XaWRnZXQucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnNlbGVjdGVkO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgb3B0aW9uIGlzIGhpZ2hsaWdodGVkLiBBIGhpZ2hsaWdodCBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAqIGl0ZW0gbWF5IGJlIHNlbGVjdGVkIHdoZW4gYSB1c2VyIHByZXNzZXMgZW50ZXIgb3IgY2xpY2tzLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEl0ZW0gaXMgaGlnaGxpZ2h0ZWRcbiAqL1xuT08udWkuT3B0aW9uV2lkZ2V0LnByb3RvdHlwZS5pc0hpZ2hsaWdodGVkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5oaWdobGlnaHRlZDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG9wdGlvbiBpcyBwcmVzc2VkLiBUaGUgcHJlc3NlZCBzdGF0ZSBvY2N1cnMgd2hlbiBhIHVzZXIgbW91c2VzXG4gKiBkb3duIG9uIGFuIGl0ZW0sIGJ1dCBoYXMgbm90IHlldCBsZXQgZ28gb2YgdGhlIG1vdXNlLiBUaGUgaXRlbSBtYXkgYXBwZWFyXG4gKiBzZWxlY3RlZCwgYnV0IGl0IHdpbGwgbm90IGJlIHNlbGVjdGVkIHVudGlsIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBJdGVtIGlzIHByZXNzZWRcbiAqL1xuT08udWkuT3B0aW9uV2lkZ2V0LnByb3RvdHlwZS5pc1ByZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnByZXNzZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3B0aW9u4oCZcyBzZWxlY3RlZCBzdGF0ZS4gSW4gZ2VuZXJhbCwgYWxsIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHNlbGVjdGlvblxuICogc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIFNlbGVjdFdpZGdldOKAmXMge0BsaW5rIE9PLnVpLlNlbGVjdFdpZGdldCNzZWxlY3RJdGVtIHNlbGVjdEl0ZW0oIFtpdGVtXSApfVxuICogbWV0aG9kIGluc3RlYWQgb2YgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhdGU9ZmFsc2VdIFNlbGVjdCBvcHRpb25cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRpZiAoIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLnNlbGVjdGFibGUgKSB7XG5cdFx0dGhpcy5zZWxlY3RlZCA9ICEhc3RhdGU7XG5cdFx0dGhpcy4kZWxlbWVudFxuXHRcdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktb3B0aW9uV2lkZ2V0LXNlbGVjdGVkJywgc3RhdGUgKVxuXHRcdFx0LmF0dHIoICdhcmlhLXNlbGVjdGVkJywgc3RhdGUudG9TdHJpbmcoKSApO1xuXHRcdGlmICggc3RhdGUgJiYgdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuc2Nyb2xsSW50b1ZpZXdPblNlbGVjdCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsRWxlbWVudEludG9WaWV3KCk7XG5cdFx0fVxuXHRcdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3B0aW9u4oCZcyBoaWdobGlnaHRlZCBzdGF0ZS4gSW4gZ2VuZXJhbCwgYWxsIHByb2dyYW1tYXRpY1xuICogbW9kaWZpY2F0aW9ucyB0byB0aGUgaGlnaGxpZ2h0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZVxuICogU2VsZWN0V2lkZ2V04oCZcyB7QGxpbmsgT08udWkuU2VsZWN0V2lkZ2V0I2hpZ2hsaWdodEl0ZW0gaGlnaGxpZ2h0SXRlbSggW2l0ZW1dICl9XG4gKiBtZXRob2QgaW5zdGVhZCBvZiB0aGlzIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGF0ZT1mYWxzZV0gSGlnaGxpZ2h0IG9wdGlvblxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuT3B0aW9uV2lkZ2V0LnByb3RvdHlwZS5zZXRIaWdobGlnaHRlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuaGlnaGxpZ2h0YWJsZSApIHtcblx0XHR0aGlzLmhpZ2hsaWdodGVkID0gISFzdGF0ZTtcblx0XHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCAnb28tdWktb3B0aW9uV2lkZ2V0LWhpZ2hsaWdodGVkJywgc3RhdGUgKTtcblx0XHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9wdGlvbuKAmXMgcHJlc3NlZCBzdGF0ZS4gSW4gZ2VuZXJhbCwgYWxsXG4gKiBwcm9ncmFtbWF0aWMgbW9kaWZpY2F0aW9ucyB0byB0aGUgcHJlc3NlZCBzdGF0ZSBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGVcbiAqIFNlbGVjdFdpZGdldOKAmXMge0BsaW5rIE9PLnVpLlNlbGVjdFdpZGdldCNwcmVzc0l0ZW0gcHJlc3NJdGVtKCBbaXRlbV0gKX1cbiAqIG1ldGhvZCBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YXRlPWZhbHNlXSBQcmVzcyBvcHRpb25cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLk9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0UHJlc3NlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMucHJlc3NhYmxlICkge1xuXHRcdHRoaXMucHJlc3NlZCA9ICEhc3RhdGU7XG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLW9wdGlvbldpZGdldC1wcmVzc2VkJywgc3RhdGUgKTtcblx0XHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGV4dCB0byBtYXRjaCBzZWFyY2ggc3RyaW5ncyBhZ2FpbnN0LlxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIGxhYmVsIHRleHQsIGJ1dCBzdWJjbGFzc2VzXG4gKiBjYW4gb3ZlcnJpZGUgdGhpcyB0byBwcm92aWRlIG1vcmUgY29tcGxleCBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn0gU3RyaW5nIHRvIG1hdGNoIHNlYXJjaCBzdHJpbmcgYWdhaW5zdFxuICovXG5PTy51aS5PcHRpb25XaWRnZXQucHJvdG90eXBlLmdldE1hdGNoVGV4dCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGxhYmVsID0gdGhpcy5nZXRMYWJlbCgpO1xuXHRyZXR1cm4gdHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyA/IGxhYmVsIDogdGhpcy4kbGFiZWwudGV4dCgpO1xufTtcblxuLyoqXG4gKiBBIFNlbGVjdFdpZGdldCBpcyBvZiBhIGdlbmVyaWMgc2VsZWN0aW9uIG9mIG9wdGlvbnMuIFRoZSBPT1VJIGxpYnJhcnkgY29udGFpbnMgc2V2ZXJhbCB0eXBlcyBvZlxuICogc2VsZWN0IHdpZGdldHMsIGluY2x1ZGluZyB7QGxpbmsgT08udWkuQnV0dG9uU2VsZWN0V2lkZ2V0IGJ1dHRvbiBzZWxlY3RzfSxcbiAqIHtAbGluayBPTy51aS5SYWRpb1NlbGVjdFdpZGdldCByYWRpbyBzZWxlY3RzfSwgYW5kIHtAbGluayBPTy51aS5NZW51U2VsZWN0V2lkZ2V0XG4gKiBtZW51IHNlbGVjdHN9LlxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBPTy51aS5PcHRpb25XaWRnZXQgb3IgT08udWkuRGVjb3JhdGVkT3B0aW9uV2lkZ2V0LiBGb3IgbW9yZVxuICogaW5mb3JtYXRpb24sIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIHNlbGVjdCB3aWRnZXQgd2l0aCB0aHJlZSBvcHRpb25zLlxuICogICAgIHZhciBzZWxlY3QgPSBuZXcgT08udWkuU2VsZWN0V2lkZ2V0KCB7XG4gKiAgICAgICAgIGl0ZW1zOiBbXG4gKiAgICAgICAgICAgICBuZXcgT08udWkuT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICAgICAgZGF0YTogJ2EnLFxuICogICAgICAgICAgICAgICAgIGxhYmVsOiAnT3B0aW9uIE9uZScsXG4gKiAgICAgICAgICAgICB9ICksXG4gKiAgICAgICAgICAgICBuZXcgT08udWkuT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICAgICAgZGF0YTogJ2InLFxuICogICAgICAgICAgICAgICAgIGxhYmVsOiAnT3B0aW9uIFR3bycsXG4gKiAgICAgICAgICAgICB9ICksXG4gKiAgICAgICAgICAgICBuZXcgT08udWkuT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICAgICAgZGF0YTogJ2MnLFxuICogICAgICAgICAgICAgICAgIGxhYmVsOiAnT3B0aW9uIFRocmVlJyxcbiAqICAgICAgICAgICAgIH0gKVxuICogICAgICAgICBdXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHNlbGVjdC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9PcHRpb25zXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cFdpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7T08udWkuT3B0aW9uV2lkZ2V0W119IFtpdGVtc10gQW4gYXJyYXkgb2Ygb3B0aW9ucyB0byBhZGQgdG8gdGhlIHNlbGVjdC5cbiAqICBPcHRpb25zIGFyZSBjcmVhdGVkIHdpdGgge0BsaW5rIE9PLnVpLk9wdGlvbldpZGdldCBPcHRpb25XaWRnZXR9IGNsYXNzZXMuIFNlZVxuICogIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzJdIGZvciBleGFtcGxlcy5cbiAqICBbMl06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9uc1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQgPSBmdW5jdGlvbiBPb1VpU2VsZWN0V2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5TZWxlY3RXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5Hcm91cFdpZGdldC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkZ3JvdXA6IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnByZXNzZWQgPSBmYWxzZTtcblx0dGhpcy5zZWxlY3RpbmcgPSBudWxsO1xuXHR0aGlzLm9uRG9jdW1lbnRNb3VzZVVwSGFuZGxlciA9IHRoaXMub25Eb2N1bWVudE1vdXNlVXAuYmluZCggdGhpcyApO1xuXHR0aGlzLm9uRG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5vbkRvY3VtZW50TW91c2VNb3ZlLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5vbkRvY3VtZW50S2V5RG93bkhhbmRsZXIgPSB0aGlzLm9uRG9jdW1lbnRLZXlEb3duLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5vbkRvY3VtZW50S2V5UHJlc3NIYW5kbGVyID0gdGhpcy5vbkRvY3VtZW50S2V5UHJlc3MuYmluZCggdGhpcyApO1xuXHR0aGlzLmtleVByZXNzQnVmZmVyID0gJyc7XG5cdHRoaXMua2V5UHJlc3NCdWZmZXJUaW1lciA9IG51bGw7XG5cdHRoaXMuYmxvY2tNb3VzZU92ZXJFdmVudHMgPSAwO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHtcblx0XHR0b2dnbGU6ICdvblRvZ2dsZSdcblx0fSApO1xuXHR0aGlzLiRlbGVtZW50Lm9uKCB7XG5cdFx0Zm9jdXNpbjogdGhpcy5vbkZvY3VzLmJpbmQoIHRoaXMgKSxcblx0XHRtb3VzZWRvd246IHRoaXMub25Nb3VzZURvd24uYmluZCggdGhpcyApLFxuXHRcdG1vdXNlb3ZlcjogdGhpcy5vbk1vdXNlT3Zlci5iaW5kKCB0aGlzICksXG5cdFx0bW91c2VsZWF2ZTogdGhpcy5vbk1vdXNlTGVhdmUuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktc2VsZWN0V2lkZ2V0IG9vLXVpLXNlbGVjdFdpZGdldC1kZXByZXNzZWQnIClcblx0XHQuYXR0ciggJ3JvbGUnLCAnbGlzdGJveCcgKTtcblx0dGhpcy5zZXRGb2N1c093bmVyKCB0aGlzLiRlbGVtZW50ICk7XG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnLml0ZW1zICkgKSB7XG5cdFx0dGhpcy5hZGRJdGVtcyggY29uZmlnLml0ZW1zICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuU2VsZWN0V2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlNlbGVjdFdpZGdldCwgT08udWkubWl4aW4uR3JvdXBXaWRnZXQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGhpZ2hsaWdodFxuICpcbiAqIEEgYGhpZ2hsaWdodGAgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBoaWdobGlnaHQgaXMgY2hhbmdlZCB3aXRoIHRoZSAjaGlnaGxpZ2h0SXRlbSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR8bnVsbH0gaXRlbSBIaWdobGlnaHRlZCBpdGVtXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgcHJlc3NcbiAqXG4gKiBBIGBwcmVzc2AgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSAjcHJlc3NJdGVtIG1ldGhvZCBpcyB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgbW9kaWZ5IHRoZVxuICogcHJlc3NlZCBzdGF0ZSBvZiBhbiBvcHRpb24uXG4gKlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR8bnVsbH0gaXRlbSBQcmVzc2VkIGl0ZW1cbiAqL1xuXG4vKipcbiAqIEBldmVudCBzZWxlY3RcbiAqXG4gKiBBIGBzZWxlY3RgIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkIHByb2dyYW1tYXRpY2FsbHkgd2l0aCB0aGUgI3NlbGVjdEl0ZW0gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0fG51bGx9IGl0ZW0gU2VsZWN0ZWQgaXRlbVxuICovXG5cbi8qKlxuICogQGV2ZW50IGNob29zZVxuICogQSBgY2hvb3NlYCBldmVudCBpcyBlbWl0dGVkIHdoZW4gYW4gaXRlbSBpcyBjaG9zZW4gd2l0aCB0aGUgI2Nob29zZUl0ZW0gbWV0aG9kLlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR9IGl0ZW0gQ2hvc2VuIGl0ZW1cbiAqL1xuXG4vKipcbiAqIEBldmVudCBhZGRcbiAqXG4gKiBBbiBgYWRkYCBldmVudCBpcyBlbWl0dGVkIHdoZW4gb3B0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNlbGVjdCB3aXRoIHRoZSAjYWRkSXRlbXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0W119IGl0ZW1zIEFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgaW5zZXJ0aW9uIHBvaW50XG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgcmVtb3ZlXG4gKlxuICogQSBgcmVtb3ZlYCBldmVudCBpcyBlbWl0dGVkIHdoZW4gb3B0aW9ucyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBzZWxlY3Qgd2l0aCB0aGUgI2NsZWFySXRlbXNcbiAqIG9yICNyZW1vdmVJdGVtcyBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0W119IGl0ZW1zIFJlbW92ZWQgaXRlbXNcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGZvY3VzIGV2ZW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0dmFyIGl0ZW07XG5cdGlmICggZXZlbnQudGFyZ2V0ID09PSB0aGlzLiRlbGVtZW50WyAwIF0gKSB7XG5cdFx0Ly8gVGhpcyB3aWRnZXQgd2FzIGZvY3Vzc2VkLCBlLmcuIGJ5IHRoZSB1c2VyIHRhYmJpbmcgdG8gaXQuXG5cdFx0Ly8gVGhlIHN0eWxlcyBmb3IgZm9jdXMgc3RhdGUgZGVwZW5kIG9uIG9uZSBvZiB0aGUgaXRlbXMgYmVpbmcgc2VsZWN0ZWQuXG5cdFx0aWYgKCAhdGhpcy5maW5kU2VsZWN0ZWRJdGVtKCkgKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5maW5kRmlyc3RTZWxlY3RhYmxlSXRlbSgpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoIGV2ZW50LnRhcmdldC50YWJJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHQvLyBPbmUgb2YgdGhlIG9wdGlvbnMgZ290IGZvY3Vzc2VkIChhbmQgdGhlIGV2ZW50IGJ1YmJsZWQgdXAgaGVyZSkuXG5cdFx0XHQvLyBUaGV5IGNhbid0IGJlIHRhYmJlZCB0bywgYnV0IHRoZXkgY2FuIGJlIGFjdGl2YXRlZCB1c2luZyBhY2Nlc3NrZXlzLlxuXHRcdFx0Ly8gT3B0aW9uV2lkZ2V0cyBhbmQgZm9jdXNhYmxlIFVJIGVsZW1lbnRzIGluc2lkZSB0aGVtIGhhdmUgdGFiaW5kZXg9XCItMVwiIHNldC5cblx0XHRcdGl0ZW0gPSB0aGlzLmZpbmRUYXJnZXRJdGVtKCBldmVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUaGVyZSBpcyBzb21ldGhpbmcgYWN0dWFsbHkgdXNlci1mb2N1c2FibGUgaW4gb25lIG9mIHRoZSBsYWJlbHMgb2YgdGhlIG9wdGlvbnMsIGFuZCB0aGVcblx0XHRcdC8vIHVzZXIgZm9jdXNzZWQgaXQgKGUuZy4gYnkgdGFiYmluZyB0byBpdCkuIERvIG5vdGhpbmcgKGVzcGVjaWFsbHksIGRvbid0IGNoYW5nZSB0aGUgZm9jdXMpLlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmICggaXRlbSApIHtcblx0XHRpZiAoIGl0ZW0uY29uc3RydWN0b3Iuc3RhdGljLmhpZ2hsaWdodGFibGUgKSB7XG5cdFx0XHR0aGlzLmhpZ2hsaWdodEl0ZW0oIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZWxlY3RJdGVtKCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBldmVudC50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbIDAgXSApIHtcblx0XHR0aGlzLiRmb2N1c093bmVyLmZvY3VzKCk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBNb3VzZSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIGl0ZW07XG5cblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgZS53aGljaCA9PT0gT08udWkuTW91c2VCdXR0b25zLkxFRlQgKSB7XG5cdFx0dGhpcy50b2dnbGVQcmVzc2VkKCB0cnVlICk7XG5cdFx0aXRlbSA9IHRoaXMuZmluZFRhcmdldEl0ZW0oIGUgKTtcblx0XHRpZiAoIGl0ZW0gJiYgaXRlbS5pc1NlbGVjdGFibGUoKSApIHtcblx0XHRcdHRoaXMucHJlc3NJdGVtKCBpdGVtICk7XG5cdFx0XHR0aGlzLnNlbGVjdGluZyA9IGl0ZW07XG5cdFx0XHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdGhpcy5vbkRvY3VtZW50TW91c2VVcEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIHRoaXMub25Eb2N1bWVudE1vdXNlTW92ZUhhbmRsZXIsIHRydWUgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgZG9jdW1lbnQgbW91c2UgdXAgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgTW91c2UgdXAgZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZVVwID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgaXRlbTtcblxuXHR0aGlzLnRvZ2dsZVByZXNzZWQoIGZhbHNlICk7XG5cdGlmICggIXRoaXMuc2VsZWN0aW5nICkge1xuXHRcdGl0ZW0gPSB0aGlzLmZpbmRUYXJnZXRJdGVtKCBlICk7XG5cdFx0aWYgKCBpdGVtICYmIGl0ZW0uaXNTZWxlY3RhYmxlKCkgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdGluZyA9IGl0ZW07XG5cdFx0fVxuXHR9XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICYmIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUICYmIHRoaXMuc2VsZWN0aW5nICkge1xuXHRcdHRoaXMucHJlc3NJdGVtKCBudWxsICk7XG5cdFx0dGhpcy5jaG9vc2VJdGVtKCB0aGlzLnNlbGVjdGluZyApO1xuXHRcdHRoaXMuc2VsZWN0aW5nID0gbnVsbDtcblx0fVxuXG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCB0aGlzLm9uRG9jdW1lbnRNb3VzZVVwSGFuZGxlciwgdHJ1ZSApO1xuXHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCB0aGlzLm9uRG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyLCB0cnVlICk7XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICdvbk1vdXNlVXAgaXMgZGVwcmVjYXRlZCwgdXNlIG9uRG9jdW1lbnRNb3VzZVVwIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudE1vdXNlVXAuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgZG9jdW1lbnQgbW91c2UgbW92ZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBNb3VzZSBtb3ZlIGV2ZW50XG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlTW92ZSA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIGl0ZW07XG5cblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgdGhpcy5wcmVzc2VkICkge1xuXHRcdGl0ZW0gPSB0aGlzLmZpbmRUYXJnZXRJdGVtKCBlICk7XG5cdFx0aWYgKCBpdGVtICYmIGl0ZW0gIT09IHRoaXMuc2VsZWN0aW5nICYmIGl0ZW0uaXNTZWxlY3RhYmxlKCkgKSB7XG5cdFx0XHR0aGlzLnByZXNzSXRlbSggaXRlbSApO1xuXHRcdFx0dGhpcy5zZWxlY3RpbmcgPSBpdGVtO1xuXHRcdH1cblx0fVxufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ29uTW91c2VNb3ZlIGlzIGRlcHJlY2F0ZWQsIHVzZSBvbkRvY3VtZW50TW91c2VNb3ZlIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudE1vdXNlTW92ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSBvdmVyIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgTW91c2Ugb3ZlciBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBpdGVtO1xuXHRpZiAoIHRoaXMuYmxvY2tNb3VzZU92ZXJFdmVudHMgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdGl0ZW0gPSB0aGlzLmZpbmRUYXJnZXRJdGVtKCBlICk7XG5cdFx0dGhpcy5oaWdobGlnaHRJdGVtKCBpdGVtICYmIGl0ZW0uaXNIaWdobGlnaHRhYmxlKCkgPyBpdGVtIDogbnVsbCApO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGxlYXZlIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgTW91c2Ugb3ZlciBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHR0aGlzLmhpZ2hsaWdodEl0ZW0oIG51bGwgKTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBkb2N1bWVudCBrZXkgZG93biBldmVudHMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIEtleSBkb3duIGV2ZW50XG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Eb2N1bWVudEtleURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBuZXh0SXRlbSxcblx0XHRoYW5kbGVkID0gZmFsc2UsXG5cdFx0Y3VycmVudEl0ZW0gPSB0aGlzLmZpbmRIaWdobGlnaHRlZEl0ZW0oKSB8fCB0aGlzLmZpbmRTZWxlY3RlZEl0ZW0oKTtcblxuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSAmJiB0aGlzLmlzVmlzaWJsZSgpICkge1xuXHRcdHN3aXRjaCAoIGUua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgT08udWkuS2V5cy5FTlRFUjpcblx0XHRcdFx0aWYgKCBjdXJyZW50SXRlbSAmJiBjdXJyZW50SXRlbS5jb25zdHJ1Y3Rvci5zdGF0aWMuaGlnaGxpZ2h0YWJsZSApIHtcblx0XHRcdFx0XHQvLyBXYXMgb25seSBoaWdobGlnaHRlZCwgbm93IGxldCdzIHNlbGVjdCBpdC4gTm8tb3AgaWYgYWxyZWFkeSBzZWxlY3RlZC5cblx0XHRcdFx0XHR0aGlzLmNob29zZUl0ZW0oIGN1cnJlbnRJdGVtICk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIE9PLnVpLktleXMuVVA6XG5cdFx0XHRjYXNlIE9PLnVpLktleXMuTEVGVDpcblx0XHRcdFx0dGhpcy5jbGVhcktleVByZXNzQnVmZmVyKCk7XG5cdFx0XHRcdG5leHRJdGVtID0gdGhpcy5maW5kUmVsYXRpdmVTZWxlY3RhYmxlSXRlbSggY3VycmVudEl0ZW0sIC0xICk7XG5cdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgT08udWkuS2V5cy5ET1dOOlxuXHRcdFx0Y2FzZSBPTy51aS5LZXlzLlJJR0hUOlxuXHRcdFx0XHR0aGlzLmNsZWFyS2V5UHJlc3NCdWZmZXIoKTtcblx0XHRcdFx0bmV4dEl0ZW0gPSB0aGlzLmZpbmRSZWxhdGl2ZVNlbGVjdGFibGVJdGVtKCBjdXJyZW50SXRlbSwgMSApO1xuXHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIE9PLnVpLktleXMuRVNDQVBFOlxuXHRcdFx0Y2FzZSBPTy51aS5LZXlzLlRBQjpcblx0XHRcdFx0aWYgKCBjdXJyZW50SXRlbSAmJiBjdXJyZW50SXRlbS5jb25zdHJ1Y3Rvci5zdGF0aWMuaGlnaGxpZ2h0YWJsZSApIHtcblx0XHRcdFx0XHRjdXJyZW50SXRlbS5zZXRIaWdobGlnaHRlZCggZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyKCk7XG5cdFx0XHRcdHRoaXMudW5iaW5kRG9jdW1lbnRLZXlQcmVzc0xpc3RlbmVyKCk7XG5cdFx0XHRcdC8vIERvbid0IHByZXZlbnQgdGFiYmluZyBhd2F5IC8gZGVmb2N1c2luZ1xuXHRcdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmICggbmV4dEl0ZW0gKSB7XG5cdFx0XHRpZiAoIG5leHRJdGVtLmNvbnN0cnVjdG9yLnN0YXRpYy5oaWdobGlnaHRhYmxlICkge1xuXHRcdFx0XHR0aGlzLmhpZ2hsaWdodEl0ZW0oIG5leHRJdGVtICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNob29zZUl0ZW0oIG5leHRJdGVtICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNjcm9sbEl0ZW1JbnRvVmlldyggbmV4dEl0ZW0gKTtcblx0XHR9XG5cblx0XHRpZiAoIGhhbmRsZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fVxufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICdvbktleURvd24gaXMgZGVwcmVjYXRlZCwgdXNlIG9uRG9jdW1lbnRLZXlEb3duIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudEtleURvd24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBCaW5kIGRvY3VtZW50IGtleSBkb3duIGxpc3RlbmVyLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCB0aGlzLm9uRG9jdW1lbnRLZXlEb3duSGFuZGxlciwgdHJ1ZSApO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuYmluZEtleURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnYmluZEtleURvd25MaXN0ZW5lciBpcyBkZXByZWNhdGVkLCB1c2UgYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyIGluc3RlYWQnICk7XG5cdHRoaXMuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbn07XG5cbi8qKlxuICogVW5iaW5kIGRvY3VtZW50IGtleSBkb3duIGxpc3RlbmVyLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS51bmJpbmREb2N1bWVudEtleURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHRoaXMub25Eb2N1bWVudEtleURvd25IYW5kbGVyLCB0cnVlICk7XG59O1xuXG4vLyBEZXByZWNhdGVkIGFsaWFzIHNpbmNlIDAuMjguM1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS51bmJpbmRLZXlEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ3VuYmluZEtleURvd25MaXN0ZW5lciBpcyBkZXByZWNhdGVkLCB1c2UgdW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIgaW5zdGVhZCcgKTtcblx0dGhpcy51bmJpbmREb2N1bWVudEtleURvd25MaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIFNjcm9sbCBpdGVtIGludG8gdmlldywgcHJldmVudGluZyBzcHVyaW91cyBtb3VzZSBoaWdobGlnaHQgYWN0aW9ucyBmcm9tIGhhcHBlbmluZy5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLk9wdGlvbldpZGdldH0gaXRlbSBJdGVtIHRvIHNjcm9sbCBpbnRvIHZpZXdcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5zY3JvbGxJdGVtSW50b1ZpZXcgPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdHZhciB3aWRnZXQgPSB0aGlzO1xuXHQvLyBDaHJvbWl1bSdzIEJsaW5rIGVuZ2luZSB3aWxsIGdlbmVyYXRlIHNwdXJpb3VzICdtb3VzZW92ZXInIGV2ZW50cyBkdXJpbmcgcHJvZ3JhbW1hdGljIHNjcm9sbGluZ1xuXHQvLyBhbmQgYXJvdW5kIDEwMC0xNTAgbXMgYWZ0ZXIgaXQgaXMgZmluaXNoZWQuXG5cdHRoaXMuYmxvY2tNb3VzZU92ZXJFdmVudHMrKztcblx0aXRlbS5zY3JvbGxFbGVtZW50SW50b1ZpZXcoKS5kb25lKCBmdW5jdGlvbiAoKSB7XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0d2lkZ2V0LmJsb2NrTW91c2VPdmVyRXZlbnRzLS07XG5cdFx0fSwgMjAwICk7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGtleS1wcmVzcyBidWZmZXJcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuY2xlYXJLZXlQcmVzc0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmtleVByZXNzQnVmZmVyVGltZXIgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmtleVByZXNzQnVmZmVyVGltZXIgKTtcblx0XHR0aGlzLmtleVByZXNzQnVmZmVyVGltZXIgPSBudWxsO1xuXHR9XG5cdHRoaXMua2V5UHJlc3NCdWZmZXIgPSAnJztcbn07XG5cbi8qKlxuICogSGFuZGxlIGtleSBwcmVzcyBldmVudHMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIEtleSBwcmVzcyBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Eb2N1bWVudEtleVByZXNzID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgYywgZmlsdGVyLCBpdGVtO1xuXG5cdGlmICggIWUuY2hhckNvZGUgKSB7XG5cdFx0aWYgKCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuQkFDS1NQQUNFICYmIHRoaXMua2V5UHJlc3NCdWZmZXIgIT09ICcnICkge1xuXHRcdFx0dGhpcy5rZXlQcmVzc0J1ZmZlciA9IHRoaXMua2V5UHJlc3NCdWZmZXIuc3Vic3RyKCAwLCB0aGlzLmtleVByZXNzQnVmZmVyLmxlbmd0aCAtIDEgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0aWYgKCBTdHJpbmcuZnJvbUNvZGVQb2ludCApIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0YyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KCBlLmNoYXJDb2RlICk7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGUuY2hhckNvZGUgKTtcblx0fVxuXG5cdGlmICggdGhpcy5rZXlQcmVzc0J1ZmZlclRpbWVyICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5rZXlQcmVzc0J1ZmZlclRpbWVyICk7XG5cdH1cblx0dGhpcy5rZXlQcmVzc0J1ZmZlclRpbWVyID0gc2V0VGltZW91dCggdGhpcy5jbGVhcktleVByZXNzQnVmZmVyLmJpbmQoIHRoaXMgKSwgMTUwMCApO1xuXG5cdGl0ZW0gPSB0aGlzLmZpbmRIaWdobGlnaHRlZEl0ZW0oKSB8fCB0aGlzLmZpbmRTZWxlY3RlZEl0ZW0oKTtcblxuXHRpZiAoIHRoaXMua2V5UHJlc3NCdWZmZXIgPT09IGMgKSB7XG5cdFx0Ly8gQ29tbW9uIChpZiB3ZWlyZCkgc3BlY2lhbCBjYXNlOiB0eXBpbmcgXCJ4eHh4XCIgd2lsbCBjeWNsZSB0aHJvdWdoIGFsbFxuXHRcdC8vIHRoZSBpdGVtcyBiZWdpbm5pbmcgd2l0aCBcInhcIi5cblx0XHRpZiAoIGl0ZW0gKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5maW5kUmVsYXRpdmVTZWxlY3RhYmxlSXRlbSggaXRlbSwgMSApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aGlzLmtleVByZXNzQnVmZmVyICs9IGM7XG5cdH1cblxuXHRmaWx0ZXIgPSB0aGlzLmdldEl0ZW1NYXRjaGVyKCB0aGlzLmtleVByZXNzQnVmZmVyLCBmYWxzZSApO1xuXHRpZiAoICFpdGVtIHx8ICFmaWx0ZXIoIGl0ZW0gKSApIHtcblx0XHRpdGVtID0gdGhpcy5maW5kUmVsYXRpdmVTZWxlY3RhYmxlSXRlbSggaXRlbSwgMSwgZmlsdGVyICk7XG5cdH1cblx0aWYgKCBpdGVtICkge1xuXHRcdGlmICggdGhpcy5pc1Zpc2libGUoKSAmJiBpdGVtLmNvbnN0cnVjdG9yLnN0YXRpYy5oaWdobGlnaHRhYmxlICkge1xuXHRcdFx0dGhpcy5oaWdobGlnaHRJdGVtKCBpdGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2hvb3NlSXRlbSggaXRlbSApO1xuXHRcdH1cblx0XHR0aGlzLnNjcm9sbEl0ZW1JbnRvVmlldyggaXRlbSApO1xuXHR9XG5cblx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnb25LZXlQcmVzcyBpcyBkZXByZWNhdGVkLCB1c2Ugb25Eb2N1bWVudEtleVByZXNzIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudEtleVByZXNzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbWF0Y2hlciBmb3IgdGhlIHNwZWNpZmljIHN0cmluZ1xuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZyB0byBtYXRjaCBhZ2FpbnN0IGl0ZW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGFjdD1mYWxzZV0gT25seSBhY2NlcHQgZXhhY3QgbWF0Y2hlc1xuICogQHJldHVybiB7RnVuY3Rpb259IGZ1bmN0aW9uICggT08udWkuT3B0aW9uV2lkZ2V0ICkgPT4gYm9vbGVhblxuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmdldEl0ZW1NYXRjaGVyID0gZnVuY3Rpb24gKCBzLCBleGFjdCApIHtcblx0dmFyIHJlO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0aWYgKCBzLm5vcm1hbGl6ZSApIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0cyA9IHMubm9ybWFsaXplKCk7XG5cdH1cblx0cyA9IGV4YWN0ID8gcy50cmltKCkgOiBzLnJlcGxhY2UoIC9eXFxzKy8sICcnICk7XG5cdHJlID0gJ15cXFxccyonICsgcy5yZXBsYWNlKCAvKFtcXFxce30oKXwuPyorXFwtXiRbXFxdXSkvZywgJ1xcXFwkMScgKS5yZXBsYWNlKCAvXFxzKy9nLCAnXFxcXHMrJyApO1xuXHRpZiAoIGV4YWN0ICkge1xuXHRcdHJlICs9ICdcXFxccyokJztcblx0fVxuXHRyZSA9IG5ldyBSZWdFeHAoIHJlLCAnaScgKTtcblx0cmV0dXJuIGZ1bmN0aW9uICggaXRlbSApIHtcblx0XHR2YXIgbWF0Y2hUZXh0ID0gaXRlbS5nZXRNYXRjaFRleHQoKTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0aWYgKCBtYXRjaFRleHQubm9ybWFsaXplICkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0bWF0Y2hUZXh0ID0gbWF0Y2hUZXh0Lm5vcm1hbGl6ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmUudGVzdCggbWF0Y2hUZXh0ICk7XG5cdH07XG59O1xuXG4vKipcbiAqIEJpbmQgZG9jdW1lbnQga2V5IHByZXNzIGxpc3RlbmVyLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5iaW5kRG9jdW1lbnRLZXlQcmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoICdrZXlwcmVzcycsIHRoaXMub25Eb2N1bWVudEtleVByZXNzSGFuZGxlciwgdHJ1ZSApO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuYmluZEtleVByZXNzTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ2JpbmRLZXlQcmVzc0xpc3RlbmVyIGlzIGRlcHJlY2F0ZWQsIHVzZSBiaW5kRG9jdW1lbnRLZXlQcmVzc0xpc3RlbmVyIGluc3RlYWQnICk7XG5cdHRoaXMuYmluZERvY3VtZW50S2V5UHJlc3NMaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vKipcbiAqIFVuYmluZCBkb2N1bWVudCBrZXkgZG93biBsaXN0ZW5lci5cbiAqXG4gKiBJZiB5b3Ugb3ZlcnJpZGUgdGhpcywgYmUgc3VyZSB0byBjYWxsIHRoaXMuY2xlYXJLZXlQcmVzc0J1ZmZlcigpIGZyb20geW91clxuICogaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLnVuYmluZERvY3VtZW50S2V5UHJlc3NMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5cHJlc3MnLCB0aGlzLm9uRG9jdW1lbnRLZXlQcmVzc0hhbmRsZXIsIHRydWUgKTtcblx0dGhpcy5jbGVhcktleVByZXNzQnVmZmVyKCk7XG59O1xuXG4vLyBEZXByZWNhdGVkIGFsaWFzIHNpbmNlIDAuMjguM1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS51bmJpbmRLZXlQcmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS53YXJuRGVwcmVjYXRpb24oICd1bmJpbmRLZXlQcmVzc0xpc3RlbmVyIGlzIGRlcHJlY2F0ZWQsIHVzZSB1bmJpbmREb2N1bWVudEtleVByZXNzTGlzdGVuZXIgaW5zdGVhZCcgKTtcblx0dGhpcy51bmJpbmREb2N1bWVudEtleVByZXNzTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBWaXNpYmlsaXR5IGNoYW5nZSBoYW5kbGVyXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Ub2dnbGUgPSBmdW5jdGlvbiAoIHZpc2libGUgKSB7XG5cdGlmICggIXZpc2libGUgKSB7XG5cdFx0dGhpcy5jbGVhcktleVByZXNzQnVmZmVyKCk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjbG9zZXN0IGl0ZW0gdG8gYSBqUXVlcnkuRXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlXG4gKiBAcmV0dXJuIHtPTy51aS5PcHRpb25XaWRnZXR8bnVsbH0gT3V0bGluZSBpdGVtIHdpZGdldCwgYG51bGxgIGlmIG5vbmUgd2FzIGZvdW5kXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuZmluZFRhcmdldEl0ZW0gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciAkb3B0aW9uID0gJCggZS50YXJnZXQgKS5jbG9zZXN0KCAnLm9vLXVpLW9wdGlvbldpZGdldCcgKTtcblx0aWYgKCAhJG9wdGlvbi5jbG9zZXN0KCAnLm9vLXVpLXNlbGVjdFdpZGdldCcgKS5pcyggdGhpcy4kZWxlbWVudCApICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiAkb3B0aW9uLmRhdGEoICdvby11aS1vcHRpb25XaWRnZXQnICkgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogRmluZCBzZWxlY3RlZCBpdGVtLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLk9wdGlvbldpZGdldHxudWxsfSBTZWxlY3RlZCBpdGVtLCBgbnVsbGAgaWYgbm8gaXRlbSBpcyBzZWxlY3RlZFxuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmZpbmRTZWxlY3RlZEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpLCBsZW47XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCB0aGlzLml0ZW1zWyBpIF0uaXNTZWxlY3RlZCgpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIGkgXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZpbmQgaGlnaGxpZ2h0ZWQgaXRlbS5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5PcHRpb25XaWRnZXR8bnVsbH0gSGlnaGxpZ2h0ZWQgaXRlbSwgYG51bGxgIGlmIG5vIGl0ZW0gaXMgaGlnaGxpZ2h0ZWRcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5maW5kSGlnaGxpZ2h0ZWRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggdGhpcy5pdGVtc1sgaSBdLmlzSGlnaGxpZ2h0ZWQoKSApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyBpIF07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgcHJlc3NlZCBzdGF0ZS5cbiAqXG4gKiBQcmVzcyBpcyBhIHN0YXRlIHRoYXQgb2NjdXJzIHdoZW4gYSB1c2VyIG1vdXNlcyBkb3duIG9uIGFuIGl0ZW0sIGJ1dFxuICogaGFzIG5vdCB5ZXQgbGV0IGdvIG9mIHRoZSBtb3VzZS4gVGhlIGl0ZW0gbWF5IGFwcGVhciBzZWxlY3RlZCwgYnV0IGl0IHdpbGwgbm90IGJlIHNlbGVjdGVkXG4gKiB1bnRpbCB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBwcmVzc2VkIEFuIG9wdGlvbiBpcyBiZWluZyBwcmVzc2VkXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUudG9nZ2xlUHJlc3NlZCA9IGZ1bmN0aW9uICggcHJlc3NlZCApIHtcblx0aWYgKCBwcmVzc2VkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cHJlc3NlZCA9ICF0aGlzLnByZXNzZWQ7XG5cdH1cblx0aWYgKCBwcmVzc2VkICE9PSB0aGlzLnByZXNzZWQgKSB7XG5cdFx0dGhpcy4kZWxlbWVudFxuXHRcdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktc2VsZWN0V2lkZ2V0LXByZXNzZWQnLCBwcmVzc2VkIClcblx0XHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLXNlbGVjdFdpZGdldC1kZXByZXNzZWQnLCAhcHJlc3NlZCApO1xuXHRcdHRoaXMucHJlc3NlZCA9IHByZXNzZWQ7XG5cdH1cbn07XG5cbi8qKlxuICogSGlnaGxpZ2h0IGFuIG9wdGlvbi4gSWYgdGhlIGBpdGVtYCBwYXJhbSBpcyBvbWl0dGVkLCBubyBvcHRpb25zIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbiAqIGFuZCBhbnkgZXhpc3RpbmcgaGlnaGxpZ2h0IHdpbGwgYmUgcmVtb3ZlZC4gVGhlIGhpZ2hsaWdodCBpcyBtdXR1YWxseSBleGNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR9IFtpdGVtXSBJdGVtIHRvIGhpZ2hsaWdodCwgb21pdCBmb3Igbm8gaGlnaGxpZ2h0XG4gKiBAZmlyZXMgaGlnaGxpZ2h0XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmhpZ2hsaWdodEl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdHZhciBpLCBsZW4sIGhpZ2hsaWdodGVkLFxuXHRcdGNoYW5nZWQgPSBmYWxzZTtcblxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRoaWdobGlnaHRlZCA9IHRoaXMuaXRlbXNbIGkgXSA9PT0gaXRlbTtcblx0XHRpZiAoIHRoaXMuaXRlbXNbIGkgXS5pc0hpZ2hsaWdodGVkKCkgIT09IGhpZ2hsaWdodGVkICkge1xuXHRcdFx0dGhpcy5pdGVtc1sgaSBdLnNldEhpZ2hsaWdodGVkKCBoaWdobGlnaHRlZCApO1xuXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdGlmICggY2hhbmdlZCApIHtcblx0XHRpZiAoIGl0ZW0gKSB7XG5cdFx0XHR0aGlzLiRmb2N1c093bmVyLmF0dHIoICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBpdGVtLmdldEVsZW1lbnRJZCgpICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJGZvY3VzT3duZXIucmVtb3ZlQXR0ciggJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcgKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCAnaGlnaGxpZ2h0JywgaXRlbSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZldGNoIGFuIGl0ZW0gYnkgaXRzIGxhYmVsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBMYWJlbCBvZiB0aGUgaXRlbSB0byBzZWxlY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVmaXg9ZmFsc2VdIEFsbG93IGEgcHJlZml4IG1hdGNoLCBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gbWF0Y2hlc1xuICogQHJldHVybiB7T08udWkuRWxlbWVudHxudWxsfSBJdGVtIHdpdGggZXF1aXZhbGVudCBsYWJlbCwgYG51bGxgIGlmIG5vbmUgZXhpc3RzXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuZ2V0SXRlbUZyb21MYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHByZWZpeCApIHtcblx0dmFyIGksIGl0ZW0sIGZvdW5kLFxuXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoLFxuXHRcdGZpbHRlciA9IHRoaXMuZ2V0SXRlbU1hdGNoZXIoIGxhYmVsLCB0cnVlICk7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdGlmICggaXRlbSBpbnN0YW5jZW9mIE9PLnVpLk9wdGlvbldpZGdldCAmJiBpdGVtLmlzU2VsZWN0YWJsZSgpICYmIGZpbHRlciggaXRlbSApICkge1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBwcmVmaXggKSB7XG5cdFx0Zm91bmQgPSBudWxsO1xuXHRcdGZpbHRlciA9IHRoaXMuZ2V0SXRlbU1hdGNoZXIoIGxhYmVsLCBmYWxzZSApO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0aWYgKCBpdGVtIGluc3RhbmNlb2YgT08udWkuT3B0aW9uV2lkZ2V0ICYmIGl0ZW0uaXNTZWxlY3RhYmxlKCkgJiYgZmlsdGVyKCBpdGVtICkgKSB7XG5cdFx0XHRcdGlmICggZm91bmQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm91bmQgPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZvdW5kICkge1xuXHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBQcm9ncmFtbWF0aWNhbGx5IHNlbGVjdCBhbiBvcHRpb24gYnkgaXRzIGxhYmVsLiBJZiB0aGUgaXRlbSBkb2VzIG5vdCBleGlzdCxcbiAqIGFsbCBvcHRpb25zIHdpbGwgYmUgZGVzZWxlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXSBMYWJlbCBvZiB0aGUgaXRlbSB0byBzZWxlY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVmaXg9ZmFsc2VdIEFsbG93IGEgcHJlZml4IG1hdGNoLCBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gbWF0Y2hlc1xuICogQGZpcmVzIHNlbGVjdFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5zZWxlY3RJdGVtQnlMYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHByZWZpeCApIHtcblx0dmFyIGl0ZW1Gcm9tTGFiZWwgPSB0aGlzLmdldEl0ZW1Gcm9tTGFiZWwoIGxhYmVsLCAhIXByZWZpeCApO1xuXHRpZiAoIGxhYmVsID09PSB1bmRlZmluZWQgfHwgIWl0ZW1Gcm9tTGFiZWwgKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0SXRlbSgpO1xuXHR9XG5cdHJldHVybiB0aGlzLnNlbGVjdEl0ZW0oIGl0ZW1Gcm9tTGFiZWwgKTtcbn07XG5cbi8qKlxuICogUHJvZ3JhbW1hdGljYWxseSBzZWxlY3QgYW4gb3B0aW9uIGJ5IGl0cyBkYXRhLiBJZiB0aGUgYGRhdGFgIHBhcmFtZXRlciBpcyBvbWl0dGVkLFxuICogb3IgaWYgdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGFsbCBvcHRpb25zIHdpbGwgYmUgZGVzZWxlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkYXRhXSBWYWx1ZSBvZiB0aGUgaXRlbSB0byBzZWxlY3QsIG9taXQgdG8gZGVzZWxlY3QgYWxsXG4gKiBAZmlyZXMgc2VsZWN0XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLnNlbGVjdEl0ZW1CeURhdGEgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdHZhciBpdGVtRnJvbURhdGEgPSB0aGlzLmZpbmRJdGVtRnJvbURhdGEoIGRhdGEgKTtcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgfHwgIWl0ZW1Gcm9tRGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RJdGVtKCk7XG5cdH1cblx0cmV0dXJuIHRoaXMuc2VsZWN0SXRlbSggaXRlbUZyb21EYXRhICk7XG59O1xuXG4vKipcbiAqIFByb2dyYW1tYXRpY2FsbHkgc2VsZWN0IGFuIG9wdGlvbiBieSBpdHMgcmVmZXJlbmNlLiBJZiB0aGUgYGl0ZW1gIHBhcmFtZXRlciBpcyBvbWl0dGVkLFxuICogYWxsIG9wdGlvbnMgd2lsbCBiZSBkZXNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0fSBbaXRlbV0gSXRlbSB0byBzZWxlY3QsIG9taXQgdG8gZGVzZWxlY3QgYWxsXG4gKiBAZmlyZXMgc2VsZWN0XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuc2VsZWN0SXRlbSA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0dmFyIGksIGxlbiwgc2VsZWN0ZWQsXG5cdFx0Y2hhbmdlZCA9IGZhbHNlO1xuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdGVkID0gdGhpcy5pdGVtc1sgaSBdID09PSBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtc1sgaSBdLmlzU2VsZWN0ZWQoKSAhPT0gc2VsZWN0ZWQgKSB7XG5cdFx0XHR0aGlzLml0ZW1zWyBpIF0uc2V0U2VsZWN0ZWQoIHNlbGVjdGVkICk7XG5cdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0aWYgKCBjaGFuZ2VkICkge1xuXHRcdGlmICggaXRlbSAmJiAhaXRlbS5jb25zdHJ1Y3Rvci5zdGF0aWMuaGlnaGxpZ2h0YWJsZSApIHtcblx0XHRcdGlmICggaXRlbSApIHtcblx0XHRcdFx0dGhpcy4kZm9jdXNPd25lci5hdHRyKCAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgaXRlbS5nZXRFbGVtZW50SWQoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kZm9jdXNPd25lci5yZW1vdmVBdHRyKCAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmVtaXQoICdzZWxlY3QnLCBpdGVtICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHJlc3MgYW4gaXRlbS5cbiAqXG4gKiBQcmVzcyBpcyBhIHN0YXRlIHRoYXQgb2NjdXJzIHdoZW4gYSB1c2VyIG1vdXNlcyBkb3duIG9uIGFuIGl0ZW0sIGJ1dCBoYXMgbm90XG4gKiB5ZXQgbGV0IGdvIG9mIHRoZSBtb3VzZS4gVGhlIGl0ZW0gbWF5IGFwcGVhciBzZWxlY3RlZCwgYnV0IGl0IHdpbGwgbm90IGJlIHNlbGVjdGVkIHVudGlsIHRoZSB1c2VyXG4gKiByZWxlYXNlcyB0aGUgbW91c2UuXG4gKlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR9IFtpdGVtXSBJdGVtIHRvIHByZXNzLCBvbWl0IHRvIGRlcHJlc3MgYWxsXG4gKiBAZmlyZXMgcHJlc3NcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUucHJlc3NJdGVtID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR2YXIgaSwgbGVuLCBwcmVzc2VkLFxuXHRcdGNoYW5nZWQgPSBmYWxzZTtcblxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRwcmVzc2VkID0gdGhpcy5pdGVtc1sgaSBdID09PSBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtc1sgaSBdLmlzUHJlc3NlZCgpICE9PSBwcmVzc2VkICkge1xuXHRcdFx0dGhpcy5pdGVtc1sgaSBdLnNldFByZXNzZWQoIHByZXNzZWQgKTtcblx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0dGhpcy5lbWl0KCAncHJlc3MnLCBpdGVtICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hvb3NlIGFuIGl0ZW0uXG4gKlxuICogTm90ZSB0aGF0IOKAmGNob29zZeKAmSBzaG91bGQgbmV2ZXIgYmUgbW9kaWZpZWQgcHJvZ3JhbW1hdGljYWxseS4gQSB1c2VyIGNhbiBjaG9vc2VcbiAqIGFuIG9wdGlvbiB3aXRoIHRoZSBrZXlib2FyZCBvciBtb3VzZSBhbmQgaXQgYmVjb21lcyBzZWxlY3RlZC4gVG8gc2VsZWN0IGFuIGl0ZW0gcHJvZ3JhbW1hdGljYWxseSxcbiAqIHVzZSB0aGUgI3NlbGVjdEl0ZW0gbWV0aG9kLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGlkZW50aWNhbCB0byAjc2VsZWN0SXRlbSwgYnV0IG1heSB2YXJ5IGluIHN1YmNsYXNzZXMgdGhhdCB0YWtlIGFkZGl0aW9uYWwgYWN0aW9uXG4gKiB3aGVuIHVzZXJzIGNob29zZSBhbiBpdGVtIHdpdGggdGhlIGtleWJvYXJkIG9yIG1vdXNlLlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0fSBpdGVtIEl0ZW0gdG8gY2hvb3NlXG4gKiBAZmlyZXMgY2hvb3NlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmNob29zZUl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdGlmICggaXRlbSApIHtcblx0XHR0aGlzLnNlbGVjdEl0ZW0oIGl0ZW0gKTtcblx0XHR0aGlzLmVtaXQoICdjaG9vc2UnLCBpdGVtICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluZCBhbiBvcHRpb24gYnkgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzcGVjaWZpZWQgaXRlbSAob3IgdG8gdGhlIHN0YXJ0IG9mIHRoZSBvcHRpb24gYXJyYXksXG4gKiBpZiBpdGVtIGlzIGBudWxsYCkuIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gc2VhcmNoIHRocm91Z2ggdGhlIG9wdGlvbiBhcnJheSBpcyBzcGVjaWZpZWQgd2l0aCBhXG4gKiBudW1iZXI6IC0xIGZvciByZXZlcnNlICh0aGUgZGVmYXVsdCkgb3IgMSBmb3IgZm9yd2FyZC4gVGhlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBvcHRpb24sIG9yXG4gKiBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG9wdGlvbnMgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0fG51bGx9IGl0ZW0gSXRlbSB0byBkZXNjcmliZSB0aGUgc3RhcnQgcG9zaXRpb24sIG9yIGBudWxsYCB0byBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIG1vdmUgaW46IC0xIHRvIG1vdmUgYmFja3dhcmQsIDEgdG8gbW92ZSBmb3J3YXJkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXSBPbmx5IGNvbnNpZGVyIGl0ZW1zIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAqICB0cnVlLiBGdW5jdGlvbiB0YWtlcyBhbiBPTy51aS5PcHRpb25XaWRnZXQgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICogQHJldHVybiB7T08udWkuT3B0aW9uV2lkZ2V0fG51bGx9IEl0ZW0gYXQgcG9zaXRpb24sIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIHNlbGVjdFxuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmZpbmRSZWxhdGl2ZVNlbGVjdGFibGVJdGVtID0gZnVuY3Rpb24gKCBpdGVtLCBkaXJlY3Rpb24sIGZpbHRlciApIHtcblx0dmFyIGN1cnJlbnRJbmRleCwgbmV4dEluZGV4LCBpLFxuXHRcdGluY3JlYXNlID0gZGlyZWN0aW9uID4gMCA/IDEgOiAtMSxcblx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblxuXHRpZiAoIGl0ZW0gaW5zdGFuY2VvZiBPTy51aS5PcHRpb25XaWRnZXQgKSB7XG5cdFx0Y3VycmVudEluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKCBpdGVtICk7XG5cdFx0bmV4dEluZGV4ID0gKCBjdXJyZW50SW5kZXggKyBpbmNyZWFzZSArIGxlbiApICUgbGVuO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQgYW5kIG1vdmluZyBmb3J3YXJkLCBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLlxuXHRcdC8vIElmIG1vdmluZyBiYWNrd2FyZCwgc3RhcnQgYXQgdGhlIGVuZC5cblx0XHRuZXh0SW5kZXggPSBkaXJlY3Rpb24gPiAwID8gMCA6IGxlbiAtIDE7XG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBuZXh0SW5kZXggXTtcblx0XHRpZiAoXG5cdFx0XHRpdGVtIGluc3RhbmNlb2YgT08udWkuT3B0aW9uV2lkZ2V0ICYmIGl0ZW0uaXNTZWxlY3RhYmxlKCkgJiZcblx0XHRcdCggIWZpbHRlciB8fCBmaWx0ZXIoIGl0ZW0gKSApXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9XG5cdFx0bmV4dEluZGV4ID0gKCBuZXh0SW5kZXggKyBpbmNyZWFzZSArIGxlbiApICUgbGVuO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBuZXh0IHNlbGVjdGFibGUgaXRlbSBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHNlbGVjdGFibGUgaXRlbXMuXG4gKiBEaXNhYmxlZCBvcHRpb25zIGFuZCBtZW51LXNlY3Rpb24gbWFya2VycyBhbmQgYnJlYWtzIGFyZSBub3Qgc2VsZWN0YWJsZS5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5PcHRpb25XaWRnZXR8bnVsbH0gSXRlbSwgYG51bGxgIGlmIHRoZXJlIGFyZW4ndCBhbnkgc2VsZWN0YWJsZSBpdGVtc1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmZpbmRGaXJzdFNlbGVjdGFibGVJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5maW5kUmVsYXRpdmVTZWxlY3RhYmxlSXRlbSggbnVsbCwgMSApO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygb3B0aW9ucyB0byB0aGUgc2VsZWN0LiBPcHRpb25hbGx5LCBhbiBpbmRleCBudW1iZXIgY2FuIGJlIHVzZWQgdG9cbiAqIHNwZWNpZnkgYW4gaW5zZXJ0aW9uIHBvaW50LlxuICpcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0W119IGl0ZW1zIEl0ZW1zIHRvIGFkZFxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gSW5kZXggdG8gaW5zZXJ0IGl0ZW1zIGFmdGVyXG4gKiBAZmlyZXMgYWRkXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5TZWxlY3RXaWRnZXQucHJvdG90eXBlLmFkZEl0ZW1zID0gZnVuY3Rpb24gKCBpdGVtcywgaW5kZXggKSB7XG5cdC8vIE1peGluIG1ldGhvZFxuXHRPTy51aS5taXhpbi5Hcm91cFdpZGdldC5wcm90b3R5cGUuYWRkSXRlbXMuY2FsbCggdGhpcywgaXRlbXMsIGluZGV4ICk7XG5cblx0Ly8gQWx3YXlzIHByb3ZpZGUgYW4gaW5kZXgsIGV2ZW4gaWYgaXQgd2FzIG9taXR0ZWRcblx0dGhpcy5lbWl0KCAnYWRkJywgaXRlbXMsIGluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLml0ZW1zLmxlbmd0aCAtIGl0ZW1zLmxlbmd0aCAtIDEgOiBpbmRleCApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIHNwZWNpZmllZCBhcnJheSBvZiBvcHRpb25zIGZyb20gdGhlIHNlbGVjdC4gT3B0aW9ucyB3aWxsIGJlIGRldGFjaGVkXG4gKiBmcm9tIHRoZSBET00sIG5vdCByZW1vdmVkLCBzbyB0aGV5IGNhbiBiZSByZXVzZWQgbGF0ZXIuIFRvIHJlbW92ZSBhbGwgb3B0aW9ucyBmcm9tXG4gKiB0aGUgc2VsZWN0LCB5b3UgbWF5IHdpc2ggdG8gdXNlIHRoZSAjY2xlYXJJdGVtcyBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLk9wdGlvbldpZGdldFtdfSBpdGVtcyBJdGVtcyB0byByZW1vdmVcbiAqIEBmaXJlcyByZW1vdmVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUucmVtb3ZlSXRlbXMgPSBmdW5jdGlvbiAoIGl0ZW1zICkge1xuXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG5cdC8vIERlc2VsZWN0IGl0ZW1zIGJlaW5nIHJlbW92ZWRcblx0Zm9yICggaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdGlmICggaXRlbS5pc1NlbGVjdGVkKCkgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdEl0ZW0oIG51bGwgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNaXhpbiBtZXRob2Rcblx0T08udWkubWl4aW4uR3JvdXBXaWRnZXQucHJvdG90eXBlLnJlbW92ZUl0ZW1zLmNhbGwoIHRoaXMsIGl0ZW1zICk7XG5cblx0dGhpcy5lbWl0KCAncmVtb3ZlJywgaXRlbXMgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgYWxsIG9wdGlvbnMgZnJvbSB0aGUgc2VsZWN0LiBPcHRpb25zIHdpbGwgYmUgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLCBub3QgcmVtb3ZlZCxcbiAqIHNvIHRoYXQgdGhleSBjYW4gYmUgcmV1c2VkIGxhdGVyLiBUbyByZW1vdmUgYSBzdWJzZXQgb2Ygb3B0aW9ucyBmcm9tIHRoZSBzZWxlY3QsIHVzZVxuICogdGhlICNyZW1vdmVJdGVtcyBtZXRob2QuXG4gKlxuICogQGZpcmVzIHJlbW92ZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuU2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5jbGVhckl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKCk7XG5cblx0Ly8gTWl4aW4gbWV0aG9kXG5cdE9PLnVpLm1peGluLkdyb3VwV2lkZ2V0LnByb3RvdHlwZS5jbGVhckl0ZW1zLmNhbGwoIHRoaXMgKTtcblxuXHQvLyBDbGVhciBzZWxlY3Rpb25cblx0dGhpcy5zZWxlY3RJdGVtKCBudWxsICk7XG5cblx0dGhpcy5lbWl0KCAncmVtb3ZlJywgaXRlbXMgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBET00gZWxlbWVudCB3aGljaCBoYXMgZm9jdXMgd2hpbGUgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIFNlbGVjdFdpZGdldC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgIGFuZCBgYXJpYS1leHBhbmRlZGAgb24gaXQuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtqUXVlcnl9ICRmb2N1c093bmVyXG4gKi9cbk9PLnVpLlNlbGVjdFdpZGdldC5wcm90b3R5cGUuc2V0Rm9jdXNPd25lciA9IGZ1bmN0aW9uICggJGZvY3VzT3duZXIgKSB7XG5cdHRoaXMuJGZvY3VzT3duZXIgPSAkZm9jdXNPd25lcjtcbn07XG5cbi8qKlxuICogRGVjb3JhdGVkT3B0aW9uV2lkZ2V0cyBhcmUge0BsaW5rIE9PLnVpLk9wdGlvbldpZGdldCBvcHRpb25zfSB0aGF0IGNhbiBiZSBjb25maWd1cmVkXG4gKiB3aXRoIGFuIHtAbGluayBPTy51aS5taXhpbi5JY29uRWxlbWVudCBpY29ufSBhbmQvb3Ige0BsaW5rIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgaW5kaWNhdG9yfS5cbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB3aXRoIE9PLnVpLlNlbGVjdFdpZGdldCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gb2YgbXV0dWFsbHkgZXhjbHVzaXZlXG4gKiBvcHRpb25zLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBvcHRpb25zIGFuZCBzZWxlY3RzLCBwbGVhc2Ugc2VlIHRoZVxuICogW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIERlY29yYXRlZCBvcHRpb25zIGluIGEgc2VsZWN0IHdpZGdldC5cbiAqICAgICB2YXIgc2VsZWN0ID0gbmV3IE9PLnVpLlNlbGVjdFdpZGdldCgge1xuICogICAgICAgICBpdGVtczogW1xuICogICAgICAgICAgICAgbmV3IE9PLnVpLkRlY29yYXRlZE9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgIGRhdGE6ICdhJyxcbiAqICAgICAgICAgICAgICAgICBsYWJlbDogJ09wdGlvbiB3aXRoIGljb24nLFxuICogICAgICAgICAgICAgICAgIGljb246ICdoZWxwJ1xuICogICAgICAgICAgICAgfSApLFxuICogICAgICAgICAgICAgbmV3IE9PLnVpLkRlY29yYXRlZE9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgIGRhdGE6ICdiJyxcbiAqICAgICAgICAgICAgICAgICBsYWJlbDogJ09wdGlvbiB3aXRoIGluZGljYXRvcicsXG4gKiAgICAgICAgICAgICAgICAgaW5kaWNhdG9yOiAnbmV4dCdcbiAqICAgICAgICAgICAgIH0gKVxuICogICAgICAgICBdXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHNlbGVjdC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9PcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5PcHRpb25XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSWNvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5EZWNvcmF0ZWRPcHRpb25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpRGVjb3JhdGVkT3B0aW9uV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5EZWNvcmF0ZWRPcHRpb25XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5JY29uRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktZGVjb3JhdGVkT3B0aW9uV2lkZ2V0JyApXG5cdFx0LnByZXBlbmQoIHRoaXMuJGljb24gKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGluZGljYXRvciApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5EZWNvcmF0ZWRPcHRpb25XaWRnZXQsIE9PLnVpLk9wdGlvbldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRGVjb3JhdGVkT3B0aW9uV2lkZ2V0LCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRGVjb3JhdGVkT3B0aW9uV2lkZ2V0LCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5cbi8qKlxuICogTWVudU9wdGlvbldpZGdldCBpcyBhbiBvcHRpb24gd2lkZ2V0IHRoYXQgbG9va3MgbGlrZSBhIG1lbnUgaXRlbS4gVGhlIGNsYXNzIGlzIHVzZWQgd2l0aFxuICogT08udWkuTWVudVNlbGVjdFdpZGdldCB0byBjcmVhdGUgYSBtZW51IG9mIG11dHVhbGx5IGV4Y2x1c2l2ZSBvcHRpb25zLiBQbGVhc2Ugc2VlXG4gKiB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9ucyNNZW51X3NlbGVjdHNfYW5kX29wdGlvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkRlY29yYXRlZE9wdGlvbldpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5NZW51T3B0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gT29VaU1lbnVPcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk1lbnVPcHRpb25XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5jaGVja0ljb24gPSBuZXcgT08udWkuSWNvbldpZGdldCgge1xuXHRcdGljb246ICdjaGVjaycsXG5cdFx0Y2xhc3NlczogWyAnb28tdWktbWVudU9wdGlvbldpZGdldC1jaGVja0ljb24nIF1cblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQucHJlcGVuZCggdGhpcy5jaGVja0ljb24uJGVsZW1lbnQgKVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLW1lbnVPcHRpb25XaWRnZXQnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk1lbnVPcHRpb25XaWRnZXQsIE9PLnVpLkRlY29yYXRlZE9wdGlvbldpZGdldCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVPcHRpb25XaWRnZXQuc3RhdGljLnNjcm9sbEludG9WaWV3T25TZWxlY3QgPSB0cnVlO1xuXG4vKipcbiAqIE1lbnVTZWN0aW9uT3B0aW9uV2lkZ2V0cyBhcmUgdXNlZCBpbnNpZGUge0BsaW5rIE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQgbWVudSBzZWxlY3Qgd2lkZ2V0c30gdG8gZ3JvdXAgb25lIG9yIG1vcmUgcmVsYXRlZFxuICoge0BsaW5rIE9PLnVpLk1lbnVPcHRpb25XaWRnZXQgbWVudSBvcHRpb25zfS4gTWVudVNlY3Rpb25PcHRpb25XaWRnZXRzIGNhbm5vdCBiZSBoaWdobGlnaHRlZCBvciBzZWxlY3RlZC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICB2YXIgZHJvcGRvd24gPSBuZXcgT08udWkuRHJvcGRvd25XaWRnZXQoIHtcbiAqICAgICAgICAgbWVudToge1xuICogICAgICAgICAgICAgaXRlbXM6IFtcbiAqICAgICAgICAgICAgICAgICBuZXcgT08udWkuTWVudVNlY3Rpb25PcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdEb2dzJ1xuICogICAgICAgICAgICAgICAgIH0gKSxcbiAqICAgICAgICAgICAgICAgICBuZXcgT08udWkuTWVudU9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgICAgICBkYXRhOiAnY29yZ2knLFxuICogICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1dlbHNoIENvcmdpJ1xuICogICAgICAgICAgICAgICAgIH0gKSxcbiAqICAgICAgICAgICAgICAgICBuZXcgT08udWkuTWVudU9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgICAgICBkYXRhOiAncG9vZGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdTdGFuZGFyZCBQb29kbGUnXG4gKiAgICAgICAgICAgICAgICAgfSApLFxuICogICAgICAgICAgICAgICAgIG5ldyBPTy51aS5NZW51U2VjdGlvbk9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0NhdHMnXG4gKiAgICAgICAgICAgICAgICAgfSApLFxuICogICAgICAgICAgICAgICAgIG5ldyBPTy51aS5NZW51T3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICdsaW9uJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdMaW9uJ1xuICogICAgICAgICAgICAgICAgIH0gKVxuICogICAgICAgICAgICAgXVxuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGRyb3Bkb3duLiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5EZWNvcmF0ZWRPcHRpb25XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuTWVudVNlY3Rpb25PcHRpb25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpTWVudVNlY3Rpb25PcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk1lbnVTZWN0aW9uT3B0aW9uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktbWVudVNlY3Rpb25PcHRpb25XaWRnZXQnIClcblx0XHQucmVtb3ZlQXR0ciggJ3JvbGUgYXJpYS1zZWxlY3RlZCcgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuTWVudVNlY3Rpb25PcHRpb25XaWRnZXQsIE9PLnVpLkRlY29yYXRlZE9wdGlvbldpZGdldCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVTZWN0aW9uT3B0aW9uV2lkZ2V0LnN0YXRpYy5zZWxlY3RhYmxlID0gZmFsc2U7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuTWVudVNlY3Rpb25PcHRpb25XaWRnZXQuc3RhdGljLmhpZ2hsaWdodGFibGUgPSBmYWxzZTtcblxuLyoqXG4gKiBNZW51U2VsZWN0V2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLlNlbGVjdFdpZGdldCBzZWxlY3Qgd2lkZ2V0fSB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kXG4gKiBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggT08udWkuTWVudU9wdGlvbldpZGdldC4gSXQgaXMgZGVzaWduZWQgYmUgdXNlZCBhcyBwYXJ0IG9mIGFub3RoZXIgd2lkZ2V0LlxuICogU2VlIHtAbGluayBPTy51aS5Ecm9wZG93bldpZGdldCBEcm9wZG93bldpZGdldH0sIHtAbGluayBPTy51aS5Db21ib0JveElucHV0V2lkZ2V0IENvbWJvQm94SW5wdXRXaWRnZXR9LFxuICogYW5kIHtAbGluayBPTy51aS5taXhpbi5Mb29rdXBFbGVtZW50IExvb2t1cEVsZW1lbnR9IGZvciBleGFtcGxlcyBvZiB3aWRnZXRzIHRoYXQgY29udGFpbiBtZW51cy5cbiAqIE1lbnVTZWxlY3RXaWRnZXRzIHRoZW1zZWx2ZXMgYXJlIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIHJhdGhlciBzdWJjbGFzc2VkXG4gKiBhbmQgY3VzdG9taXplZCB0byBiZSBvcGVuZWQsIGNsb3NlZCwgYW5kIGRpc3BsYXllZCBhcyBuZWVkZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgbWVudXMgYXJlIGNsaXBwZWQgdG8gdGhlIHZpc2libGUgdmlld3BvcnQgYW5kIGFyZSBub3QgdmlzaWJsZSB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZVxuICogbW91c2Ugb3V0c2lkZSB0aGUgbWVudS5cbiAqXG4gKiBNZW51cyBhbHNvIGhhdmUgc3VwcG9ydCBmb3Iga2V5Ym9hcmQgaW50ZXJhY3Rpb246XG4gKlxuICogLSBFbnRlci9SZXR1cm4ga2V5OiBjaG9vc2UgYW5kIHNlbGVjdCBhIG1lbnUgb3B0aW9uXG4gKiAtIFVwLWFycm93IGtleTogaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBtZW51IG9wdGlvblxuICogLSBEb3duLWFycm93IGtleTogaGlnaGxpZ2h0IHRoZSBuZXh0IG1lbnUgb3B0aW9uXG4gKiAtIEVzYyBrZXk6IGhpZGUgdGhlIG1lbnVcbiAqXG4gKiBVbmxpa2UgbW9zdCB3aWRnZXRzLCBNZW51U2VsZWN0V2lkZ2V0IGlzIGluaXRpYWxseSBoaWRkZW4gYW5kIG11c3QgYmUgc2hvd24gYnkgY2FsbGluZyAjdG9nZ2xlLlxuICpcbiAqIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9PcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5TZWxlY3RXaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPTy51aS5UZXh0SW5wdXRXaWRnZXR9IFtpbnB1dF0gVGV4dCBpbnB1dCB1c2VkIHRvIGltcGxlbWVudCBvcHRpb24gaGlnaGxpZ2h0aW5nIGZvciBtZW51IGl0ZW1zIHRoYXQgbWF0Y2hcbiAqICB0aGUgdGV4dCB0aGUgdXNlciB0eXBlcy4gVGhpcyBjb25maWcgaXMgdXNlZCBieSB7QGxpbmsgT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldCBDb21ib0JveElucHV0V2lkZ2V0fVxuICogIGFuZCB7QGxpbmsgT08udWkubWl4aW4uTG9va3VwRWxlbWVudCBMb29rdXBFbGVtZW50fVxuICogQGNmZyB7alF1ZXJ5fSBbJGlucHV0XSBUZXh0IGlucHV0IHVzZWQgdG8gaW1wbGVtZW50IG9wdGlvbiBoaWdobGlnaHRpbmcgZm9yIG1lbnUgaXRlbXMgdGhhdCBtYXRjaFxuICogIHRoZSB0ZXh0IHRoZSB1c2VyIHR5cGVzLiBUaGlzIGNvbmZpZyBpcyB1c2VkIGJ5IHtAbGluayBPTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldCBUYWdNdWx0aXNlbGVjdFdpZGdldH1cbiAqIEBjZmcge09PLnVpLldpZGdldH0gW3dpZGdldF0gV2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVudSdzIGFjdGl2ZSBzdGF0ZS4gSWYgdGhlIHVzZXIgY2xpY2tzIHRoZSBtb3VzZVxuICogIGFueXdoZXJlIG9uIHRoZSBwYWdlIG91dHNpZGUgb2YgdGhpcyB3aWRnZXQsIHRoZSBtZW51IGlzIGhpZGRlbi4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGEgYnV0dG9uXG4gKiAgdGhhdCB0b2dnbGVzIHRoZSBtZW51J3MgdmlzaWJpbGl0eSBvbiBjbGljaywgdGhlIG1lbnUgd2lsbCBiZSBoaWRkZW4gdGhlbiByZS1zaG93biB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogIHRoYXQgYnV0dG9uLCB1bmxlc3MgdGhlIGJ1dHRvbiAob3IgaXRzIHBhcmVudCB3aWRnZXQpIGlzIHBhc3NlZCBpbiBoZXJlLlxuICogQGNmZyB7Ym9vbGVhbn0gW2F1dG9IaWRlPXRydWVdIEhpZGUgdGhlIG1lbnUgd2hlbiB0aGUgbW91c2UgaXMgcHJlc3NlZCBvdXRzaWRlIHRoZSBtZW51LlxuICogQGNmZyB7alF1ZXJ5fSBbJGF1dG9DbG9zZUlnbm9yZV0gSWYgdGhlc2UgZWxlbWVudHMgYXJlIGNsaWNrZWQsIGRvbid0IGF1dG8taGlkZSB0aGUgbWVudS5cbiAqIEBjZmcge2Jvb2xlYW59IFtoaWRlT25DaG9vc2U9dHJ1ZV0gSGlkZSB0aGUgbWVudSB3aGVuIHRoZSB1c2VyIGNob29zZXMgYW4gb3B0aW9uLlxuICogQGNmZyB7Ym9vbGVhbn0gW2ZpbHRlckZyb21JbnB1dD1mYWxzZV0gRmlsdGVyIHRoZSBkaXNwbGF5ZWQgb3B0aW9ucyBmcm9tIHRoZSBpbnB1dFxuICogQGNmZyB7Ym9vbGVhbn0gW2hpZ2hsaWdodE9uRmlsdGVyXSBIaWdobGlnaHQgdGhlIGZpcnN0IHJlc3VsdCB3aGVuIGZpbHRlcmluZ1xuICogQGNmZyB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoIG9mIHRoZSBtZW51XG4gKi9cbk9PLnVpLk1lbnVTZWxlY3RXaWRnZXQgPSBmdW5jdGlvbiBPb1VpTWVudVNlbGVjdFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkNsaXBwYWJsZUVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJGNsaXBwYWJsZTogdGhpcy4kZ3JvdXAgfSApICk7XG5cdE9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gSW5pdGlhbCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb3RoZXIgdGhhbiAnY2VudGVyJyB3aWxsIHJlc3VsdCBpblxuXHQvLyB0aGUgbWVudSBiZWluZyBmbGlwcGVkIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgaW4gdGhlIGNvbnRhaW5lci5cblx0Ly8gU3RvcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHdlIGtub3cgd2hhdCB0byByZXNldCB0by5cblx0dGhpcy5vcmlnaW5hbFZlcnRpY2FsUG9zaXRpb24gPSB0aGlzLnZlcnRpY2FsUG9zaXRpb247XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmF1dG9IaWRlID0gY29uZmlnLmF1dG9IaWRlID09PSB1bmRlZmluZWQgfHwgISFjb25maWcuYXV0b0hpZGU7XG5cdHRoaXMuaGlkZU9uQ2hvb3NlID0gY29uZmlnLmhpZGVPbkNob29zZSA9PT0gdW5kZWZpbmVkIHx8ICEhY29uZmlnLmhpZGVPbkNob29zZTtcblx0dGhpcy5maWx0ZXJGcm9tSW5wdXQgPSAhIWNvbmZpZy5maWx0ZXJGcm9tSW5wdXQ7XG5cdHRoaXMuJGlucHV0ID0gY29uZmlnLiRpbnB1dCA/IGNvbmZpZy4kaW5wdXQgOiBjb25maWcuaW5wdXQgPyBjb25maWcuaW5wdXQuJGlucHV0IDogbnVsbDtcblx0dGhpcy4kd2lkZ2V0ID0gY29uZmlnLndpZGdldCA/IGNvbmZpZy53aWRnZXQuJGVsZW1lbnQgOiBudWxsO1xuXHR0aGlzLiRhdXRvQ2xvc2VJZ25vcmUgPSBjb25maWcuJGF1dG9DbG9zZUlnbm9yZSB8fCAkKCBbXSApO1xuXHR0aGlzLm9uRG9jdW1lbnRNb3VzZURvd25IYW5kbGVyID0gdGhpcy5vbkRvY3VtZW50TW91c2VEb3duLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5vbklucHV0RWRpdEhhbmRsZXIgPSBPTy51aS5kZWJvdW5jZSggdGhpcy51cGRhdGVJdGVtVmlzaWJpbGl0eS5iaW5kKCB0aGlzICksIDEwMCApO1xuXHR0aGlzLmhpZ2hsaWdodE9uRmlsdGVyID0gISFjb25maWcuaGlnaGxpZ2h0T25GaWx0ZXI7XG5cdHRoaXMud2lkdGggPSBjb25maWcud2lkdGg7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLW1lbnVTZWxlY3RXaWRnZXQnICk7XG5cdGlmICggY29uZmlnLndpZGdldCApIHtcblx0XHR0aGlzLnNldEZvY3VzT3duZXIoIGNvbmZpZy53aWRnZXQuJHRhYkluZGV4ZWQgKTtcblx0fVxuXG5cdC8vIEluaXRpYWxseSBoaWRkZW4gLSB1c2luZyAjdG9nZ2xlIG1heSBjYXVzZSBlcnJvcnMgaWYgc3ViY2xhc3NlcyBvdmVycmlkZSB0b2dnbGUgd2l0aCBtZXRob2RzXG5cdC8vIHRoYXQgcmVmZXJlbmNlIHByb3BlcnRpZXMgbm90IGluaXRpYWxpemVkIGF0IHRoYXQgdGltZSBvZiBwYXJlbnQgY2xhc3MgY29uc3RydWN0aW9uXG5cdC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSBwb3N0LWNvbnN0cnVjdG9yIHNldHVwXG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktZWxlbWVudC1oaWRkZW4nICk7XG5cdHRoaXMuJGZvY3VzT3duZXIuYXR0ciggJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQsIE9PLnVpLlNlbGVjdFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTWVudVNlbGVjdFdpZGdldCwgT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTWVudVNlbGVjdFdpZGdldCwgT08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBAZXZlbnQgcmVhZHlcbiAqXG4gKiBUaGUgbWVudSBpcyByZWFkeTogaXQgaXMgdmlzaWJsZSBhbmQgaGFzIGJlZW4gcG9zaXRpb25lZCBhbmQgY2xpcHBlZC5cbiAqL1xuXG4vKiBTdGF0aWMgcHJvcGVydGllcyAqL1xuXG4vKipcbiAqIFBvc2l0aW9ucyB0byBmbGlwIHRvIGlmIHRoZXJlIGlzbid0IHJvb20gaW4gdGhlIGNvbnRhaW5lciBmb3IgdGhlXG4gKiBtZW51IGluIGEgc3BlY2lmaWMgZGlyZWN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAqL1xuT08udWkuTWVudVNlbGVjdFdpZGdldC5zdGF0aWMuZmxpcHBlZFBvc2l0aW9ucyA9IHtcblx0YmVsb3c6ICdhYm92ZScsXG5cdGFib3ZlOiAnYmVsb3cnLFxuXHR0b3A6ICdib3R0b20nLFxuXHRib3R0b206ICd0b3AnXG59O1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlcyBkb2N1bWVudCBtb3VzZSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgTW91c2UgZG93biBldmVudFxuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbkRvY3VtZW50TW91c2VEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoXG5cdFx0dGhpcy5pc1Zpc2libGUoKSAmJlxuXHRcdCFPTy51aS5jb250YWlucyhcblx0XHRcdHRoaXMuJGVsZW1lbnQuYWRkKCB0aGlzLiR3aWRnZXQgKS5hZGQoIHRoaXMuJGF1dG9DbG9zZUlnbm9yZSApLmdldCgpLFxuXHRcdFx0ZS50YXJnZXQsXG5cdFx0XHR0cnVlXG5cdFx0KVxuXHQpIHtcblx0XHR0aGlzLnRvZ2dsZSggZmFsc2UgKTtcblx0fVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbkRvY3VtZW50S2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIGN1cnJlbnRJdGVtID0gdGhpcy5maW5kSGlnaGxpZ2h0ZWRJdGVtKCkgfHwgdGhpcy5maW5kU2VsZWN0ZWRJdGVtKCk7XG5cblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgdGhpcy5pc1Zpc2libGUoKSApIHtcblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIE9PLnVpLktleXMuTEVGVDpcblx0XHRcdGNhc2UgT08udWkuS2V5cy5SSUdIVDpcblx0XHRcdFx0Ly8gRG8gbm90aGluZyBpZiBhIHRleHQgZmllbGQgaXMgYXNzb2NpYXRlZCwgYXJyb3cga2V5cyB3aWxsIGJlIGhhbmRsZWQgbmF0aXZlbHlcblx0XHRcdFx0aWYgKCAhdGhpcy4kaW5wdXQgKSB7XG5cdFx0XHRcdFx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLm9uRG9jdW1lbnRLZXlEb3duLmNhbGwoIHRoaXMsIGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgT08udWkuS2V5cy5FU0NBUEU6XG5cdFx0XHRjYXNlIE9PLnVpLktleXMuVEFCOlxuXHRcdFx0XHRpZiAoIGN1cnJlbnRJdGVtICkge1xuXHRcdFx0XHRcdGN1cnJlbnRJdGVtLnNldEhpZ2hsaWdodGVkKCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudG9nZ2xlKCBmYWxzZSApO1xuXHRcdFx0XHQvLyBEb24ndCBwcmV2ZW50IHRhYmJpbmcgYXdheSwgcHJldmVudCBkZWZvY3VzaW5nXG5cdFx0XHRcdGlmICggZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLkVTQ0FQRSApIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5vbkRvY3VtZW50S2V5RG93bi5jYWxsKCB0aGlzLCBlICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogVXBkYXRlIG1lbnUgaXRlbSB2aXNpYmlsaXR5IGFuZCBjbGlwcGluZyBhZnRlciBpbnB1dCBjaGFuZ2VzIChpZiBmaWx0ZXJGcm9tSW5wdXQgaXMgZW5hYmxlZClcbiAqIG9yIGFmdGVyIGl0ZW1zIHdlcmUgYWRkZWQvcmVtb3ZlZCAoYWx3YXlzKS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucHJvdG90eXBlLnVwZGF0ZUl0ZW1WaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgaXRlbSwgaXRlbXMsIHZpc2libGUsIHNlY3Rpb24sIHNlY3Rpb25FbXB0eSwgZmlsdGVyLCBleGFjdEZpbHRlcixcblx0XHRhbnlWaXNpYmxlID0gZmFsc2UsXG5cdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGgsXG5cdFx0c2hvd0FsbCA9ICF0aGlzLmlzVmlzaWJsZSgpLFxuXHRcdGV4YWN0TWF0Y2ggPSBmYWxzZTtcblxuXHRpZiAoIHRoaXMuJGlucHV0ICYmIHRoaXMuZmlsdGVyRnJvbUlucHV0ICkge1xuXHRcdGZpbHRlciA9IHNob3dBbGwgPyBudWxsIDogdGhpcy5nZXRJdGVtTWF0Y2hlciggdGhpcy4kaW5wdXQudmFsKCkgKTtcblx0XHRleGFjdEZpbHRlciA9IHRoaXMuZ2V0SXRlbU1hdGNoZXIoIHRoaXMuJGlucHV0LnZhbCgpLCB0cnVlICk7XG5cdFx0Ly8gSGlkZSBub24tbWF0Y2hpbmcgb3B0aW9ucywgYW5kIGFsc28gaGlkZSBzZWN0aW9uIGhlYWRlcnMgaWYgYWxsIG9wdGlvbnNcblx0XHQvLyBpbiB0aGVpciBzZWN0aW9uIGFyZSBoaWRkZW4uXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRpZiAoIGl0ZW0gaW5zdGFuY2VvZiBPTy51aS5NZW51U2VjdGlvbk9wdGlvbldpZGdldCApIHtcblx0XHRcdFx0aWYgKCBzZWN0aW9uICkge1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwcmV2aW91cyBzZWN0aW9uIHdhcyBlbXB0eSwgaGlkZSBpdHMgaGVhZGVyXG5cdFx0XHRcdFx0c2VjdGlvbi50b2dnbGUoIHNob3dBbGwgfHwgIXNlY3Rpb25FbXB0eSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlY3Rpb24gPSBpdGVtO1xuXHRcdFx0XHRzZWN0aW9uRW1wdHkgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICggaXRlbSBpbnN0YW5jZW9mIE9PLnVpLk9wdGlvbldpZGdldCApIHtcblx0XHRcdFx0dmlzaWJsZSA9IHNob3dBbGwgfHwgZmlsdGVyKCBpdGVtICk7XG5cdFx0XHRcdGV4YWN0TWF0Y2ggPSBleGFjdE1hdGNoIHx8IGV4YWN0RmlsdGVyKCBpdGVtICk7XG5cdFx0XHRcdGFueVZpc2libGUgPSBhbnlWaXNpYmxlIHx8IHZpc2libGU7XG5cdFx0XHRcdHNlY3Rpb25FbXB0eSA9IHNlY3Rpb25FbXB0eSAmJiAhdmlzaWJsZTtcblx0XHRcdFx0aXRlbS50b2dnbGUoIHZpc2libGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gUHJvY2VzcyB0aGUgZmluYWwgc2VjdGlvblxuXHRcdGlmICggc2VjdGlvbiApIHtcblx0XHRcdHNlY3Rpb24udG9nZ2xlKCBzaG93QWxsIHx8ICFzZWN0aW9uRW1wdHkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGFueVZpc2libGUgJiYgdGhpcy5pdGVtcy5sZW5ndGggJiYgIWV4YWN0TWF0Y2ggKSB7XG5cdFx0XHR0aGlzLnNjcm9sbEl0ZW1JbnRvVmlldyggdGhpcy5pdGVtc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYW55VmlzaWJsZSApIHtcblx0XHRcdHRoaXMuaGlnaGxpZ2h0SXRlbSggbnVsbCApO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1tZW51U2VsZWN0V2lkZ2V0LWludmlzaWJsZScsICFhbnlWaXNpYmxlICk7XG5cblx0XHRpZiAoIHRoaXMuaGlnaGxpZ2h0T25GaWx0ZXIgKSB7XG5cdFx0XHQvLyBIaWdobGlnaHQgdGhlIGZpcnN0IGl0ZW0gb24gdGhlIGxpc3Rcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdFx0aXRlbXMgPSB0aGlzLmdldEl0ZW1zKCk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGl0ZW1zWyBpIF0uaXNWaXNpYmxlKCkgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuaGlnaGxpZ2h0SXRlbSggaXRlbSApO1xuXHRcdH1cblxuXHR9XG5cblx0Ly8gUmVldmFsdWF0ZSBjbGlwcGluZ1xuXHR0aGlzLmNsaXAoKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuTWVudVNlbGVjdFdpZGdldC5wcm90b3R5cGUuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuJGlucHV0ICkge1xuXHRcdHRoaXMuJGlucHV0Lm9uKCAna2V5ZG93bicsIHRoaXMub25Eb2N1bWVudEtleURvd25IYW5kbGVyICk7XG5cdH0gZWxzZSB7XG5cdFx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLmJpbmREb2N1bWVudEtleURvd25MaXN0ZW5lci5jYWxsKCB0aGlzICk7XG5cdH1cbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuTWVudVNlbGVjdFdpZGdldC5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy4kaW5wdXQgKSB7XG5cdFx0dGhpcy4kaW5wdXQub2ZmKCAna2V5ZG93bicsIHRoaXMub25Eb2N1bWVudEtleURvd25IYW5kbGVyICk7XG5cdH0gZWxzZSB7XG5cdFx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLnVuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyLmNhbGwoIHRoaXMgKTtcblx0fVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5iaW5kRG9jdW1lbnRLZXlQcmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuJGlucHV0ICkge1xuXHRcdGlmICggdGhpcy5maWx0ZXJGcm9tSW5wdXQgKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC5vbiggJ2tleWRvd24gbW91c2V1cCBjdXQgcGFzdGUgY2hhbmdlIGlucHV0IHNlbGVjdCcsIHRoaXMub25JbnB1dEVkaXRIYW5kbGVyICk7XG5cdFx0XHR0aGlzLnVwZGF0ZUl0ZW1WaXNpYmlsaXR5KCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5iaW5kRG9jdW1lbnRLZXlQcmVzc0xpc3RlbmVyLmNhbGwoIHRoaXMgKTtcblx0fVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS51bmJpbmREb2N1bWVudEtleVByZXNzTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy4kaW5wdXQgKSB7XG5cdFx0aWYgKCB0aGlzLmZpbHRlckZyb21JbnB1dCApIHtcblx0XHRcdHRoaXMuJGlucHV0Lm9mZiggJ2tleWRvd24gbW91c2V1cCBjdXQgcGFzdGUgY2hhbmdlIGlucHV0IHNlbGVjdCcsIHRoaXMub25JbnB1dEVkaXRIYW5kbGVyICk7XG5cdFx0XHR0aGlzLnVwZGF0ZUl0ZW1WaXNpYmlsaXR5KCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS51bmJpbmREb2N1bWVudEtleVByZXNzTGlzdGVuZXIuY2FsbCggdGhpcyApO1xuXHR9XG59O1xuXG4vKipcbiAqIENob29zZSBhbiBpdGVtLlxuICpcbiAqIFdoZW4gYSB1c2VyIGNob29zZXMgYW4gaXRlbSwgdGhlIG1lbnUgaXMgY2xvc2VkLCB1bmxlc3MgdGhlIGhpZGVPbkNob29zZSBjb25maWcgb3B0aW9uIGlzIHNldCB0byBmYWxzZS5cbiAqXG4gKiBOb3RlIHRoYXQg4oCYY2hvb3Nl4oCZIHNob3VsZCBuZXZlciBiZSBtb2RpZmllZCBwcm9ncmFtbWF0aWNhbGx5LiBBIHVzZXIgY2FuIGNob29zZSBhbiBvcHRpb24gd2l0aCB0aGUga2V5Ym9hcmRcbiAqIG9yIG1vdXNlIGFuZCBpdCBiZWNvbWVzIHNlbGVjdGVkLiBUbyBzZWxlY3QgYW4gaXRlbSBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlICNzZWxlY3RJdGVtIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLk9wdGlvbldpZGdldH0gaXRlbSBJdGVtIHRvIGNob29zZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuTWVudVNlbGVjdFdpZGdldC5wcm90b3R5cGUuY2hvb3NlSXRlbSA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLmNob29zZUl0ZW0uY2FsbCggdGhpcywgaXRlbSApO1xuXHRpZiAoIHRoaXMuaGlkZU9uQ2hvb3NlICkge1xuXHRcdHRoaXMudG9nZ2xlKCBmYWxzZSApO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5hZGRJdGVtcyA9IGZ1bmN0aW9uICggaXRlbXMsIGluZGV4ICkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5hZGRJdGVtcy5jYWxsKCB0aGlzLCBpdGVtcywgaW5kZXggKTtcblxuXHR0aGlzLnVwZGF0ZUl0ZW1WaXNpYmlsaXR5KCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucHJvdG90eXBlLnJlbW92ZUl0ZW1zID0gZnVuY3Rpb24gKCBpdGVtcyApIHtcblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRPTy51aS5NZW51U2VsZWN0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUucmVtb3ZlSXRlbXMuY2FsbCggdGhpcywgaXRlbXMgKTtcblxuXHR0aGlzLnVwZGF0ZUl0ZW1WaXNpYmlsaXR5KCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVTZWxlY3RXaWRnZXQucHJvdG90eXBlLmNsZWFySXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLmNsZWFySXRlbXMuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudXBkYXRlSXRlbVZpc2liaWxpdHkoKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgdGhlIG1lbnUuIFRoZSBtZW51IGlzIGluaXRpYWxseSBoaWRkZW4gYW5kIG11c3QgYmUgc2hvd24gYnkgY2FsbGluZ1xuICogYC50b2dnbGUoIHRydWUgKWAgYWZ0ZXIgaXRzICMkZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICpcbiAqIERvIG5vdCBzaG93IHRoZSBtZW51IHdoaWxlIGl0IGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgRE9NLiBUaGUgY2FsY3VsYXRpb25zIHJlcXVpcmVkIHRvIGRpc3BsYXlcbiAqIGl0IGluIHRoZSByaWdodCBwbGFjZSBhbmQgd2l0aCB0aGUgcmlnaHQgZGltZW5zaW9ucyBvbmx5IHdvcmsgY29ycmVjdGx5IHdoaWxlIGl0IGlzIGF0dGFjaGVkLlxuICogU2lkZS1lZmZlY3RzIG1heSBpbmNsdWRlIGJyb2tlbiBpbnRlcmZhY2UgYW5kIGV4Y2VwdGlvbnMgYmVpbmcgdGhyb3duLiBUaGlzIHdhc24ndCBhbHdheXNcbiAqIHN0cmljdGx5IGVuZm9yY2VkLCBzbyBjdXJyZW50bHkgaXQgb25seSBnZW5lcmF0ZXMgYSB3YXJuaW5nIGluIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gKlxuICogQGZpcmVzIHJlYWR5XG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51U2VsZWN0V2lkZ2V0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoIHZpc2libGUgKSB7XG5cdHZhciBjaGFuZ2UsIG9yaWdpbmFsSGVpZ2h0LCBmbGlwcGVkSGVpZ2h0O1xuXG5cdHZpc2libGUgPSAoIHZpc2libGUgPT09IHVuZGVmaW5lZCA/ICF0aGlzLnZpc2libGUgOiAhIXZpc2libGUgKSAmJiAhIXRoaXMuaXRlbXMubGVuZ3RoO1xuXHRjaGFuZ2UgPSB2aXNpYmxlICE9PSB0aGlzLmlzVmlzaWJsZSgpO1xuXG5cdGlmICggdmlzaWJsZSAmJiAhdGhpcy53YXJuZWRVbmF0dGFjaGVkICYmICF0aGlzLmlzRWxlbWVudEF0dGFjaGVkKCkgKSB7XG5cdFx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnTWVudVNlbGVjdFdpZGdldCN0b2dnbGU6IEJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLCB0aGUgbWVudSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uJyApO1xuXHRcdHRoaXMud2FybmVkVW5hdHRhY2hlZCA9IHRydWU7XG5cdH1cblxuXHRpZiAoIGNoYW5nZSAmJiB2aXNpYmxlICkge1xuXHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBzaG93aW5nIHRoZSBwb3B1cCBhZ2Fpbi4gSXQncyBwb3NzaWJsZSB3ZSBubyBsb25nZXIgbmVlZCB0byBmbGlwXG5cdFx0Ly8gKGUuZy4gaWYgdGhlIHVzZXIgc2Nyb2xsZWQpLlxuXHRcdHRoaXMuc2V0VmVydGljYWxQb3NpdGlvbiggdGhpcy5vcmlnaW5hbFZlcnRpY2FsUG9zaXRpb24gKTtcblx0fVxuXG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuTWVudVNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLnRvZ2dsZS5jYWxsKCB0aGlzLCB2aXNpYmxlICk7XG5cblx0aWYgKCBjaGFuZ2UgKSB7XG5cdFx0aWYgKCB2aXNpYmxlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMud2lkdGggKSB7XG5cdFx0XHRcdHRoaXMuc2V0SWRlYWxTaXplKCB0aGlzLndpZHRoICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLiRmbG9hdGFibGVDb250YWluZXIgKSB7XG5cdFx0XHRcdHRoaXMuJGNsaXBwYWJsZS5jc3MoICd3aWR0aCcsICdhdXRvJyApO1xuXHRcdFx0XHR0aGlzLnNldElkZWFsU2l6ZShcblx0XHRcdFx0XHR0aGlzLiRmbG9hdGFibGVDb250YWluZXJbIDAgXS5vZmZzZXRXaWR0aCA+IHRoaXMuJGNsaXBwYWJsZVsgMCBdLm9mZnNldFdpZHRoID9cblx0XHRcdFx0XHRcdC8vIERyb3Bkb3duIGlzIHNtYWxsZXIgdGhhbiBoYW5kbGUgc28gZXhwYW5kIHRvIHdpZHRoXG5cdFx0XHRcdFx0XHR0aGlzLiRmbG9hdGFibGVDb250YWluZXJbIDAgXS5vZmZzZXRXaWR0aCA6XG5cdFx0XHRcdFx0XHQvLyBEcm9wZG93biBpcyBsYXJnZXIgdGhhbiBoYW5kbGUgc28gYXV0byBzaXplXG5cdFx0XHRcdFx0XHQnYXV0bydcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy4kY2xpcHBhYmxlLmNzcyggJ3dpZHRoJywgJycgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50b2dnbGVQb3NpdGlvbmluZyggISF0aGlzLiRmbG9hdGFibGVDb250YWluZXIgKTtcblx0XHRcdHRoaXMudG9nZ2xlQ2xpcHBpbmcoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIoKTtcblx0XHRcdHRoaXMuYmluZERvY3VtZW50S2V5UHJlc3NMaXN0ZW5lcigpO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCggdGhpcy5pc0NsaXBwZWRWZXJ0aWNhbGx5KCkgfHwgdGhpcy5pc0Zsb2F0YWJsZU91dE9mVmlldygpICkgJiZcblx0XHRcdFx0dGhpcy5vcmlnaW5hbFZlcnRpY2FsUG9zaXRpb24gIT09ICdjZW50ZXInXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgb3BlbmluZyB0aGUgbWVudSBpbiBvbmUgZGlyZWN0aW9uIGNhdXNlcyBpdCB0byBiZSBjbGlwcGVkLCBmbGlwIGl0XG5cdFx0XHRcdG9yaWdpbmFsSGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdFx0dGhpcy5zZXRWZXJ0aWNhbFBvc2l0aW9uKFxuXHRcdFx0XHRcdHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmZsaXBwZWRQb3NpdGlvbnNbIHRoaXMub3JpZ2luYWxWZXJ0aWNhbFBvc2l0aW9uIF1cblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCB0aGlzLmlzQ2xpcHBlZFZlcnRpY2FsbHkoKSB8fCB0aGlzLmlzRmxvYXRhYmxlT3V0T2ZWaWV3KCkgKSB7XG5cdFx0XHRcdFx0Ly8gSWYgZmxpcHBpbmcgYWxzbyBjYXVzZXMgaXQgdG8gYmUgY2xpcHBlZCwgb3BlbiBpbiB3aGljaGV2ZXIgZGlyZWN0aW9uXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBtb3JlIHNwYWNlXG5cdFx0XHRcdFx0ZmxpcHBlZEhlaWdodCA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0aWYgKCBvcmlnaW5hbEhlaWdodCA+IGZsaXBwZWRIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZlcnRpY2FsUG9zaXRpb24oIHRoaXMub3JpZ2luYWxWZXJ0aWNhbFBvc2l0aW9uICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBOb3RlIHRoYXQgd2UgZG8gbm90IGZsaXAgdGhlIG1lbnUncyBvcGVuaW5nIGRpcmVjdGlvbiBpZiB0aGUgY2xpcHBpbmcgY2hhbmdlc1xuXHRcdFx0Ly8gbGF0ZXIgKGUuZy4gYWZ0ZXIgdGhlIHVzZXIgc2Nyb2xscyksIHRoYXQgc2VlbXMgbGlrZSBpdCB3b3VsZCBiZSBhbm5veWluZ1xuXG5cdFx0XHR0aGlzLiRmb2N1c093bmVyLmF0dHIoICdhcmlhLWV4cGFuZGVkJywgJ3RydWUnICk7XG5cblx0XHRcdGlmICggdGhpcy5maW5kU2VsZWN0ZWRJdGVtKCkgKSB7XG5cdFx0XHRcdHRoaXMuJGZvY3VzT3duZXIuYXR0ciggJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHRoaXMuZmluZFNlbGVjdGVkSXRlbSgpLmdldEVsZW1lbnRJZCgpICk7XG5cdFx0XHRcdHRoaXMuZmluZFNlbGVjdGVkSXRlbSgpLnNjcm9sbEVsZW1lbnRJbnRvVmlldyggeyBkdXJhdGlvbjogMCB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF1dG8taGlkZVxuXHRcdFx0aWYgKCB0aGlzLmF1dG9IaWRlICkge1xuXHRcdFx0XHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCB0aGlzLm9uRG9jdW1lbnRNb3VzZURvd25IYW5kbGVyLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCggJ3JlYWR5JyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRmb2N1c093bmVyLnJlbW92ZUF0dHIoICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnICk7XG5cdFx0XHR0aGlzLnVuYmluZERvY3VtZW50S2V5RG93bkxpc3RlbmVyKCk7XG5cdFx0XHR0aGlzLnVuYmluZERvY3VtZW50S2V5UHJlc3NMaXN0ZW5lcigpO1xuXHRcdFx0dGhpcy4kZm9jdXNPd25lci5hdHRyKCAnYXJpYS1leHBhbmRlZCcsICdmYWxzZScgKTtcblx0XHRcdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIHRoaXMub25Eb2N1bWVudE1vdXNlRG93bkhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHRoaXMudG9nZ2xlUG9zaXRpb25pbmcoIGZhbHNlICk7XG5cdFx0XHR0aGlzLnRvZ2dsZUNsaXBwaW5nKCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcm9wZG93bldpZGdldHMgYXJlIG5vdCBtZW51cyB0aGVtc2VsdmVzLCByYXRoZXIgdGhleSBjb250YWluIGEgbWVudSBvZiBvcHRpb25zIGNyZWF0ZWQgd2l0aFxuICogT08udWkuTWVudU9wdGlvbldpZGdldC4gVGhlIERyb3Bkb3duV2lkZ2V0IHRha2VzIGNhcmUgb2Ygb3BlbmluZyBhbmQgZGlzcGxheWluZyB0aGUgbWVudSBzbyB0aGF0XG4gKiB1c2VycyBjYW4gaW50ZXJhY3Qgd2l0aCBpdC5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgdGhpcyB3aXRoaW4gYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dCwgdXNlXG4gKiBPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0IGluc3RlYWQuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBEcm9wZG93bldpZGdldCB3aXRoIGEgbWVudSB0aGF0IGNvbnRhaW5zIHRocmVlIG9wdGlvbnMuXG4gKiAgICAgdmFyIGRyb3BEb3duID0gbmV3IE9PLnVpLkRyb3Bkb3duV2lkZ2V0KCB7XG4gKiAgICAgICAgIGxhYmVsOiAnRHJvcGRvd24gbWVudTogU2VsZWN0IGEgbWVudSBvcHRpb24nLFxuICogICAgICAgICBtZW51OiB7XG4gKiAgICAgICAgICAgICBpdGVtczogW1xuICogICAgICAgICAgICAgICAgIG5ldyBPTy51aS5NZW51T3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICdhJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdGaXJzdCdcbiAqICAgICAgICAgICAgICAgICB9ICksXG4gKiAgICAgICAgICAgICAgICAgbmV3IE9PLnVpLk1lbnVPcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgICAgICAgICAgZGF0YTogJ2InLFxuICogICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1NlY29uZCdcbiAqICAgICAgICAgICAgICAgICB9ICksXG4gKiAgICAgICAgICAgICAgICAgbmV3IE9PLnVpLk1lbnVPcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgICAgICAgICAgZGF0YTogJ2MnLFxuICogICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1RoaXJkJ1xuICogICAgICAgICAgICAgICAgIH0gKVxuICogICAgICAgICAgICAgXVxuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICpcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBkcm9wRG93bi4kZWxlbWVudCApO1xuICpcbiAqICAgICBkcm9wRG93bi5nZXRNZW51KCkuc2VsZWN0SXRlbUJ5RGF0YSggJ2InICk7XG4gKlxuICogICAgIGRyb3BEb3duLmdldE1lbnUoKS5maW5kU2VsZWN0ZWRJdGVtKCkuZ2V0RGF0YSgpOyAvLyBSZXR1cm5zICdiJy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXS5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9ucyNNZW51X3NlbGVjdHNfYW5kX29wdGlvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5JY29uRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPYmplY3R9IFttZW51XSBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgT08udWkuTWVudVNlbGVjdFdpZGdldCBtZW51IHNlbGVjdCB3aWRnZXR9XG4gKiBAY2ZnIHtqUXVlcnl9IFskb3ZlcmxheV0gUmVuZGVyIHRoZSBtZW51IGludG8gYSBzZXBhcmF0ZSBsYXllci4gVGhpcyBjb25maWd1cmF0aW9uIGlzIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZVxuICogIHRoZSBleHBhbmRlZCBtZW51IGlzIGxhcmdlciB0aGFuIGl0cyBjb250YWluaW5nIGA8ZGl2PmAuIFRoZSBzcGVjaWZpZWQgb3ZlcmxheSBsYXllciBpcyB1c3VhbGx5IG9uIHRvcCBvZiB0aGVcbiAqICBjb250YWluaW5nIGA8ZGl2PmAgYW5kIGhhcyBhIGxhcmdlciBhcmVhLiBCeSBkZWZhdWx0LCB0aGUgbWVudSB1c2VzIHJlbGF0aXZlIHBvc2l0aW9uaW5nLlxuICogIFNlZSA8aHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvQ29uY2VwdHMjT3ZlcmxheXM+LlxuICovXG5PTy51aS5Ecm9wZG93bldpZGdldCA9IGZ1bmN0aW9uIE9vVWlEcm9wZG93bldpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7IGluZGljYXRvcjogJ2Rvd24nIH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Ecm9wZG93bldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllcyAobXVzdCBiZSBzZXQgYmVmb3JlIFRhYkluZGV4ZWRFbGVtZW50IGNvbnN0cnVjdG9yIGNhbGwpXG5cdHRoaXMuJGhhbmRsZSA9ICQoICc8YnV0dG9uPicgKTtcblx0dGhpcy4kb3ZlcmxheSA9ICggY29uZmlnLiRvdmVybGF5ID09PSB0cnVlID8gT08udWkuZ2V0RGVmYXVsdE92ZXJsYXkoKSA6IGNvbmZpZy4kb3ZlcmxheSApIHx8IHRoaXMuJGVsZW1lbnQ7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkljb25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRpdGxlZDogdGhpcy4kbGFiZWwgfSApICk7XG5cdE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICR0YWJJbmRleGVkOiB0aGlzLiRoYW5kbGUgfSApICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLm1lbnUgPSBuZXcgT08udWkuTWVudVNlbGVjdFdpZGdldCggJC5leHRlbmQoIHtcblx0XHR3aWRnZXQ6IHRoaXMsXG5cdFx0JGZsb2F0YWJsZUNvbnRhaW5lcjogdGhpcy4kZWxlbWVudFxuXHR9LCBjb25maWcubWVudSApICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGhhbmRsZS5vbigge1xuXHRcdGNsaWNrOiB0aGlzLm9uQ2xpY2suYmluZCggdGhpcyApLFxuXHRcdGtleWRvd246IHRoaXMub25LZXlEb3duLmJpbmQoIHRoaXMgKSxcblx0XHQvLyBIYWNrPyBIYW5kbGUgdHlwZS10by1zZWFyY2ggd2hlbiBtZW51IGlzIG5vdCBleHBhbmRlZCBhbmQgbm90IGhhbmRsaW5nIGl0cyBvd24gZXZlbnRzXG5cdFx0a2V5cHJlc3M6IHRoaXMubWVudS5vbkRvY3VtZW50S2V5UHJlc3NIYW5kbGVyLFxuXHRcdGJsdXI6IHRoaXMubWVudS5jbGVhcktleVByZXNzQnVmZmVyLmJpbmQoIHRoaXMubWVudSApXG5cdH0gKTtcblx0dGhpcy5tZW51LmNvbm5lY3QoIHRoaXMsIHtcblx0XHRzZWxlY3Q6ICdvbk1lbnVTZWxlY3QnLFxuXHRcdHRvZ2dsZTogJ29uTWVudVRvZ2dsZSdcblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGhhbmRsZVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWRyb3Bkb3duV2lkZ2V0LWhhbmRsZScgKVxuXHRcdC5hdHRyKCB7XG5cdFx0XHR0eXBlOiAnYnV0dG9uJyxcblx0XHRcdCdhcmlhLW93bnMnOiB0aGlzLm1lbnUuZ2V0RWxlbWVudElkKCksXG5cdFx0XHQnYXJpYS1oYXNwb3B1cCc6ICdsaXN0Ym94J1xuXHRcdH0gKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGljb24sIHRoaXMuJGxhYmVsLCB0aGlzLiRpbmRpY2F0b3IgKTtcblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWRyb3Bkb3duV2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kaGFuZGxlICk7XG5cdHRoaXMuJG92ZXJsYXkuYXBwZW5kKCB0aGlzLm1lbnUuJGVsZW1lbnQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuRHJvcGRvd25XaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRHJvcGRvd25XaWRnZXQsIE9PLnVpLm1peGluLkljb25FbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Ecm9wZG93bldpZGdldCwgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRHJvcGRvd25XaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRHJvcGRvd25XaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkRyb3Bkb3duV2lkZ2V0LCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IHRoZSBtZW51LlxuICpcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVTZWxlY3RXaWRnZXR9IE1lbnUgb2Ygd2lkZ2V0XG4gKi9cbk9PLnVpLkRyb3Bkb3duV2lkZ2V0LnByb3RvdHlwZS5nZXRNZW51ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5tZW51O1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIG1lbnUgc2VsZWN0IGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5NZW51T3B0aW9uV2lkZ2V0fSBpdGVtIFNlbGVjdGVkIG1lbnUgaXRlbVxuICovXG5PTy51aS5Ecm9wZG93bldpZGdldC5wcm90b3R5cGUub25NZW51U2VsZWN0ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR2YXIgc2VsZWN0ZWRMYWJlbDtcblxuXHRpZiAoICFpdGVtICkge1xuXHRcdHRoaXMuc2V0TGFiZWwoIG51bGwgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzZWxlY3RlZExhYmVsID0gaXRlbS5nZXRMYWJlbCgpO1xuXG5cdC8vIElmIHRoZSBsYWJlbCBpcyBhIERPTSBlbGVtZW50LCBjbG9uZSBpdCwgYmVjYXVzZSBzZXRMYWJlbCB3aWxsIGFwcGVuZCgpIGl0XG5cdGlmICggc2VsZWN0ZWRMYWJlbCBpbnN0YW5jZW9mICQgKSB7XG5cdFx0c2VsZWN0ZWRMYWJlbCA9IHNlbGVjdGVkTGFiZWwuY2xvbmUoKTtcblx0fVxuXG5cdHRoaXMuc2V0TGFiZWwoIHNlbGVjdGVkTGFiZWwgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1lbnUgdG9nZ2xlIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGUgT3BlbiBzdGF0ZSBvZiB0aGUgbWVudVxuICovXG5PTy51aS5Ecm9wZG93bldpZGdldC5wcm90b3R5cGUub25NZW51VG9nZ2xlID0gZnVuY3Rpb24gKCBpc1Zpc2libGUgKSB7XG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1kcm9wZG93bldpZGdldC1vcGVuJywgaXNWaXNpYmxlICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSBjbGljayBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGNsaWNrIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuRHJvcGRvd25XaWRnZXQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICYmIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUICkge1xuXHRcdHRoaXMubWVudS50b2dnbGUoKTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBrZXkgZG93biBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuRHJvcGRvd25XaWRnZXQucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKFxuXHRcdCF0aGlzLmlzRGlzYWJsZWQoKSAmJlxuXHRcdChcblx0XHRcdGUud2hpY2ggPT09IE9PLnVpLktleXMuRU5URVIgfHxcblx0XHRcdChcblx0XHRcdFx0ZS53aGljaCA9PT0gT08udWkuS2V5cy5TUEFDRSAmJlxuXHRcdFx0XHQvLyBBdm9pZCBjb25mbGljdHMgd2l0aCB0eXBlLXRvLXNlYXJjaCwgc2VlIFNlbGVjdFdpZGdldCNvbktleVByZXNzLlxuXHRcdFx0XHQvLyBTcGFjZSBvbmx5IGNsb3NlcyB0aGUgbWVudSBpcyB0aGUgdXNlciBpcyBub3QgdHlwaW5nIHRvIHNlYXJjaC5cblx0XHRcdFx0dGhpcy5tZW51LmtleVByZXNzQnVmZmVyID09PSAnJ1xuXHRcdFx0KSB8fFxuXHRcdFx0KFxuXHRcdFx0XHQhdGhpcy5tZW51LmlzVmlzaWJsZSgpICYmXG5cdFx0XHRcdChcblx0XHRcdFx0XHRlLndoaWNoID09PSBPTy51aS5LZXlzLlVQIHx8XG5cdFx0XHRcdFx0ZS53aGljaCA9PT0gT08udWkuS2V5cy5ET1dOXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHQpXG5cdCkge1xuXHRcdHRoaXMubWVudS50b2dnbGUoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogUmFkaW9PcHRpb25XaWRnZXQgaXMgYW4gb3B0aW9uIHdpZGdldCB0aGF0IGxvb2tzIGxpa2UgYSByYWRpbyBidXR0b24uXG4gKiBUaGUgY2xhc3MgaXMgdXNlZCB3aXRoIE9PLnVpLlJhZGlvU2VsZWN0V2lkZ2V0IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBvZiByYWRpbyBvcHRpb25zLlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9ucyNCdXR0b25fc2VsZWN0c19hbmRfb3B0aW9uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5PcHRpb25XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuUmFkaW9PcHRpb25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpUmFkaW9PcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllcyAobXVzdCBiZSBkb25lIGJlZm9yZSBwYXJlbnQgY29uc3RydWN0b3Igd2hpY2ggY2FsbHMgI3NldERpc2FibGVkKVxuXHR0aGlzLnJhZGlvID0gbmV3IE9PLnVpLlJhZGlvSW5wdXRXaWRnZXQoIHsgdmFsdWU6IGNvbmZpZy5kYXRhLCB0YWJJbmRleDogLTEgfSApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5SYWRpb09wdGlvbldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0Ly8gUmVtb3ZlIGltcGxpY2l0IHJvbGUsIHdlJ3JlIGhhbmRsaW5nIGl0IG91cnNlbHZlc1xuXHR0aGlzLnJhZGlvLiRpbnB1dC5hdHRyKCAncm9sZScsICdwcmVzZW50YXRpb24nICk7XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1yYWRpb09wdGlvbldpZGdldCcgKVxuXHRcdC5hdHRyKCAncm9sZScsICdyYWRpbycgKVxuXHRcdC5hdHRyKCAnYXJpYS1jaGVja2VkJywgJ2ZhbHNlJyApXG5cdFx0LnJlbW92ZUF0dHIoICdhcmlhLXNlbGVjdGVkJyApXG5cdFx0LnByZXBlbmQoIHRoaXMucmFkaW8uJGVsZW1lbnQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUmFkaW9PcHRpb25XaWRnZXQsIE9PLnVpLk9wdGlvbldpZGdldCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvT3B0aW9uV2lkZ2V0LnN0YXRpYy5oaWdobGlnaHRhYmxlID0gZmFsc2U7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUmFkaW9PcHRpb25XaWRnZXQuc3RhdGljLnNjcm9sbEludG9WaWV3T25TZWxlY3QgPSB0cnVlO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvT3B0aW9uV2lkZ2V0LnN0YXRpYy5wcmVzc2FibGUgPSBmYWxzZTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb09wdGlvbldpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdsYWJlbCc7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb09wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5SYWRpb09wdGlvbldpZGdldC5wYXJlbnQucHJvdG90eXBlLnNldFNlbGVjdGVkLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cblx0dGhpcy5yYWRpby5zZXRTZWxlY3RlZCggc3RhdGUgKTtcblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hdHRyKCAnYXJpYS1jaGVja2VkJywgc3RhdGUudG9TdHJpbmcoKSApXG5cdFx0LnJlbW92ZUF0dHIoICdhcmlhLXNlbGVjdGVkJyApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb09wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbiAoIGRpc2FibGVkICkge1xuXHRPTy51aS5SYWRpb09wdGlvbldpZGdldC5wYXJlbnQucHJvdG90eXBlLnNldERpc2FibGVkLmNhbGwoIHRoaXMsIGRpc2FibGVkICk7XG5cblx0dGhpcy5yYWRpby5zZXREaXNhYmxlZCggdGhpcy5pc0Rpc2FibGVkKCkgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmFkaW9TZWxlY3RXaWRnZXQgaXMgYSB7QGxpbmsgT08udWkuU2VsZWN0V2lkZ2V0IHNlbGVjdCB3aWRnZXR9IHRoYXQgY29udGFpbnMgcmFkaW9cbiAqIG9wdGlvbnMgYW5kIGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBPTy51aS5SYWRpb09wdGlvbldpZGdldC4gVGhlIFJhZGlvU2VsZWN0V2lkZ2V0IHByb3ZpZGVzXG4gKiBhbiBpbnRlcmZhY2UgZm9yIGFkZGluZywgcmVtb3ZpbmcgYW5kIHNlbGVjdGluZyBvcHRpb25zLlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSB0aGlzIHdpdGhpbiBhbiBIVE1MIGZvcm0sIHN1Y2ggYXMgYSBPTy51aS5Gb3JtTGF5b3V0LCB1c2VcbiAqIE9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQgaW5zdGVhZC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIFJhZGlvU2VsZWN0V2lkZ2V0IHdpdGggUmFkaW9PcHRpb25zLlxuICogICAgIHZhciBvcHRpb24xID0gbmV3IE9PLnVpLlJhZGlvT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBkYXRhOiAnYScsXG4gKiAgICAgICAgICAgICBsYWJlbDogJ1NlbGVjdGVkIHJhZGlvIG9wdGlvbidcbiAqICAgICAgICAgfSApLFxuICogICAgICAgICBvcHRpb24yID0gbmV3IE9PLnVpLlJhZGlvT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBkYXRhOiAnYicsXG4gKiAgICAgICAgICAgICBsYWJlbDogJ1Vuc2VsZWN0ZWQgcmFkaW8gb3B0aW9uJ1xuICogICAgICAgICB9ICk7XG4gKiAgICAgICAgIHJhZGlvU2VsZWN0ID0gbmV3IE9PLnVpLlJhZGlvU2VsZWN0V2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBpdGVtczogWyBvcHRpb24xLCBvcHRpb24yIF1cbiAqICAgICAgICAgfSApO1xuICpcbiAqICAgICAvLyBTZWxlY3QgJ29wdGlvbiAxJyB1c2luZyB0aGUgUmFkaW9TZWxlY3RXaWRnZXQncyBzZWxlY3RJdGVtKCkgbWV0aG9kLlxuICogICAgIHJhZGlvU2VsZWN0LnNlbGVjdEl0ZW0oIG9wdGlvbjEgKTtcbiAqXG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggcmFkaW9TZWxlY3QuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9uc1xuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5TZWxlY3RXaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuUmFkaW9TZWxlY3RXaWRnZXQgPSBmdW5jdGlvbiBPb1VpUmFkaW9TZWxlY3RXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlJhZGlvU2VsZWN0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGVsZW1lbnQub24oIHtcblx0XHRmb2N1czogdGhpcy5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApLFxuXHRcdGJsdXI6IHRoaXMudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktcmFkaW9TZWxlY3RXaWRnZXQnIClcblx0XHQuYXR0ciggJ3JvbGUnLCAncmFkaW9ncm91cCcgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUmFkaW9TZWxlY3RXaWRnZXQsIE9PLnVpLlNlbGVjdFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUmFkaW9TZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5cbi8qKlxuICogTXVsdGlvcHRpb25XaWRnZXRzIGFyZSBzcGVjaWFsIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGFuZCBjb25maWd1cmVkIHdpdGggZGF0YS4gVGhlXG4gKiBkYXRhIGlzIG9mdGVuIHVuaXF1ZSBmb3IgZWFjaCBvcHRpb24sIGJ1dCBpdCBkb2VzIG5vdCBoYXZlIHRvIGJlLiBNdWx0aW9wdGlvbldpZGdldHMgYXJlIHVzZWRcbiAqIHdpdGggT08udWkuU2VsZWN0V2lkZ2V0IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBvZiBtdXR1YWxseSBleGNsdXNpdmUgb3B0aW9ucy4gRm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqIGFuZCBleGFtcGxlcywgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9NdWx0aW9wdGlvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5JdGVtV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbc2VsZWN0ZWQ9ZmFsc2VdIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBpbml0aWFsbHkgc2VsZWN0ZWRcbiAqL1xuT08udWkuTXVsdGlvcHRpb25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpTXVsdGlvcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk11bHRpb3B0aW9uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uSXRlbVdpZGdldC5jYWxsKCB0aGlzICk7XG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uVGl0bGVkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1tdWx0aW9wdGlvbldpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGxhYmVsICk7XG5cdHRoaXMuc2V0U2VsZWN0ZWQoIGNvbmZpZy5zZWxlY3RlZCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5NdWx0aW9wdGlvbldpZGdldCwgT08udWkuV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5NdWx0aW9wdGlvbldpZGdldCwgT08udWkubWl4aW4uSXRlbVdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTXVsdGlvcHRpb25XaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTXVsdGlvcHRpb25XaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGNoYW5nZVxuICpcbiAqIEEgY2hhbmdlIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIG9wdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgV2hldGhlciB0aGUgb3B0aW9uIGlzIG5vdyBzZWxlY3RlZFxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEl0ZW0gaXMgc2VsZWN0ZWRcbiAqL1xuT08udWkuTXVsdGlvcHRpb25XaWRnZXQucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnNlbGVjdGVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9wdGlvbuKAmXMgc2VsZWN0ZWQgc3RhdGUuIEluIGdlbmVyYWwsIGFsbCBtb2RpZmljYXRpb25zIHRvIHRoZSBzZWxlY3Rpb25cbiAqIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBTZWxlY3RXaWRnZXTigJlzIHtAbGluayBPTy51aS5TZWxlY3RXaWRnZXQjc2VsZWN0SXRlbSBzZWxlY3RJdGVtKCBbaXRlbV0gKX1cbiAqIG1ldGhvZCBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YXRlPWZhbHNlXSBTZWxlY3Qgb3B0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5NdWx0aW9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRzdGF0ZSA9ICEhc3RhdGU7XG5cdGlmICggdGhpcy5zZWxlY3RlZCAhPT0gc3RhdGUgKSB7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IHN0YXRlO1xuXHRcdHRoaXMuZW1pdCggJ2NoYW5nZScsIHN0YXRlICk7XG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLW11bHRpb3B0aW9uV2lkZ2V0LXNlbGVjdGVkJywgc3RhdGUgKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTXVsdGlzZWxlY3RXaWRnZXQgYWxsb3dzIHNlbGVjdGluZyBtdWx0aXBsZSBvcHRpb25zIGZyb20gYSBsaXN0LlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IG1lbnVzIGFuZCBvcHRpb25zLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL1NlbGVjdHNfYW5kX09wdGlvbnMjTWVudV9zZWxlY3RzX2FuZF9vcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cFdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPTy51aS5NdWx0aW9wdGlvbldpZGdldFtdfSBbaXRlbXNdIEFuIGFycmF5IG9mIG9wdGlvbnMgdG8gYWRkIHRvIHRoZSBtdWx0aXNlbGVjdC5cbiAqL1xuT08udWkuTXVsdGlzZWxlY3RXaWRnZXQgPSBmdW5jdGlvbiBPb1VpTXVsdGlzZWxlY3RXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk11bHRpc2VsZWN0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uR3JvdXBXaWRnZXQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuYWdncmVnYXRlKCB7IGNoYW5nZTogJ3NlbGVjdCcgfSApO1xuXHQvLyBUaGlzIGlzIG1vc3RseSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFRhZ011bHRpc2VsZWN0V2lkZ2V0Li4uIG5vcm1hbGx5LCAnY2hhbmdlJyBpcyBlbWl0dGVkXG5cdC8vIGJ5IEdyb3VwRWxlbWVudCBvbmx5IHdoZW4gaXRlbXMgYXJlIGFkZGVkL3JlbW92ZWRcblx0dGhpcy5jb25uZWN0KCB0aGlzLCB7IHNlbGVjdDogWyAnZW1pdCcsICdjaGFuZ2UnIF0gfSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdGlmICggY29uZmlnLml0ZW1zICkge1xuXHRcdHRoaXMuYWRkSXRlbXMoIGNvbmZpZy5pdGVtcyApO1xuXHR9XG5cdHRoaXMuJGdyb3VwLmFkZENsYXNzKCAnb28tdWktbXVsdGlzZWxlY3RXaWRnZXQtZ3JvdXAnICk7XG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1tdWx0aXNlbGVjdFdpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGdyb3VwICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk11bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLk11bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5taXhpbi5Hcm91cFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuTXVsdGlzZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGNoYW5nZVxuICpcbiAqIEEgY2hhbmdlIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2V0IG9mIGl0ZW1zIGNoYW5nZXMsIG9yIGFuIGl0ZW0gaXMgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAqL1xuXG4vKipcbiAqIEBldmVudCBzZWxlY3RcbiAqXG4gKiBBIHNlbGVjdCBldmVudCBpcyBlbWl0dGVkIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBGaW5kIG9wdGlvbnMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gKlxuICogQHJldHVybiB7T08udWkuTXVsdGlvcHRpb25XaWRnZXRbXX0gU2VsZWN0ZWQgb3B0aW9uc1xuICovXG5PTy51aS5NdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZmluZFNlbGVjdGVkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZW1zLmZpbHRlciggZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdHJldHVybiBpdGVtLmlzU2VsZWN0ZWQoKTtcblx0fSApO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkYXRhIG9mIG9wdGlvbnMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0W118c3RyaW5nW119IFZhbHVlcyBvZiBzZWxlY3RlZCBvcHRpb25zXG4gKi9cbk9PLnVpLk11bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5maW5kU2VsZWN0ZWRJdGVtc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmZpbmRTZWxlY3RlZEl0ZW1zKCkubWFwKCBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdFx0cmV0dXJuIGl0ZW0uZGF0YTtcblx0fSApO1xufTtcblxuLyoqXG4gKiBTZWxlY3Qgb3B0aW9ucyBieSByZWZlcmVuY2UuIE9wdGlvbnMgbm90IG1lbnRpb25lZCBpbiB0aGUgYGl0ZW1zYCBhcnJheSB3aWxsIGJlIGRlc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5NdWx0aW9wdGlvbldpZGdldFtdfSBpdGVtcyBJdGVtcyB0byBzZWxlY3RcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLk11bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5zZWxlY3RJdGVtcyA9IGZ1bmN0aW9uICggaXRlbXMgKSB7XG5cdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdHZhciBzZWxlY3RlZCA9IGl0ZW1zLmluZGV4T2YoIGl0ZW0gKSAhPT0gLTE7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZCggc2VsZWN0ZWQgKTtcblx0fSApO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VsZWN0IGl0ZW1zIGJ5IHRoZWlyIGRhdGEuIE9wdGlvbnMgbm90IG1lbnRpb25lZCBpbiB0aGUgYGRhdGFzYCBhcnJheSB3aWxsIGJlIGRlc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXXxzdHJpbmdbXX0gZGF0YXMgVmFsdWVzIG9mIGl0ZW1zIHRvIHNlbGVjdFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLnNlbGVjdEl0ZW1zQnlEYXRhID0gZnVuY3Rpb24gKCBkYXRhcyApIHtcblx0dmFyIGl0ZW1zLFxuXHRcdHdpZGdldCA9IHRoaXM7XG5cdGl0ZW1zID0gZGF0YXMubWFwKCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHdpZGdldC5maW5kSXRlbUZyb21EYXRhKCBkYXRhICk7XG5cdH0gKTtcblx0dGhpcy5zZWxlY3RJdGVtcyggaXRlbXMgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrYm94TXVsdGlvcHRpb25XaWRnZXQgaXMgYW4gb3B0aW9uIHdpZGdldCB0aGF0IGxvb2tzIGxpa2UgYSBjaGVja2JveC5cbiAqIFRoZSBjbGFzcyBpcyB1c2VkIHdpdGggT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gb2YgY2hlY2tib3ggb3B0aW9ucy5cbiAqIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL1NlbGVjdHNfYW5kX09wdGlvbnMjQnV0dG9uX3NlbGVjdHNfYW5kX29wdGlvblxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuTXVsdGlvcHRpb25XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldCA9IGZ1bmN0aW9uIE9vVWlDaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFByb3BlcnRpZXMgKG11c3QgYmUgZG9uZSBiZWZvcmUgcGFyZW50IGNvbnN0cnVjdG9yIHdoaWNoIGNhbGxzICNzZXREaXNhYmxlZClcblx0dGhpcy5jaGVja2JveCA9IG5ldyBPTy51aS5DaGVja2JveElucHV0V2lkZ2V0KCk7XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkNoZWNrYm94TXVsdGlvcHRpb25XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmNoZWNrYm94Lm9uKCAnY2hhbmdlJywgdGhpcy5vbkNoZWNrYm94Q2hhbmdlLmJpbmQoIHRoaXMgKSApO1xuXHR0aGlzLiRlbGVtZW50Lm9uKCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQoIHRoaXMgKSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1jaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0JyApXG5cdFx0LnByZXBlbmQoIHRoaXMuY2hlY2tib3guJGVsZW1lbnQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldCwgT08udWkuTXVsdGlvcHRpb25XaWRnZXQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0LnN0YXRpYy50YWdOYW1lID0gJ2xhYmVsJztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSBjaGVja2JveCBzZWxlY3RlZCBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldC5wcm90b3R5cGUub25DaGVja2JveENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZXRTZWxlY3RlZCggdGhpcy5jaGVja2JveC5pc1NlbGVjdGVkKCkgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0dGhpcy5jaGVja2JveC5zZXRTZWxlY3RlZCggc3RhdGUgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlvcHRpb25XaWRnZXQucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24gKCBkaXNhYmxlZCApIHtcblx0T08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldC5wYXJlbnQucHJvdG90eXBlLnNldERpc2FibGVkLmNhbGwoIHRoaXMsIGRpc2FibGVkICk7XG5cdHRoaXMuY2hlY2tib3guc2V0RGlzYWJsZWQoIHRoaXMuaXNEaXNhYmxlZCgpICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb2N1cyB0aGUgd2lkZ2V0LlxuICovXG5PTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5jaGVja2JveC5mb2N1cygpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUga2V5IGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlvcHRpb25XaWRnZXQucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyXG5cdFx0ZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudEdyb3VwKCksXG5cdFx0bmV4dEl0ZW07XG5cblx0aWYgKCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuTEVGVCB8fCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuVVAgKSB7XG5cdFx0bmV4dEl0ZW0gPSBlbGVtZW50LmdldFJlbGF0aXZlRm9jdXNhYmxlSXRlbSggdGhpcywgLTEgKTtcblx0fSBlbHNlIGlmICggZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLlJJR0hUIHx8IGUua2V5Q29kZSA9PT0gT08udWkuS2V5cy5ET1dOICkge1xuXHRcdG5leHRJdGVtID0gZWxlbWVudC5nZXRSZWxhdGl2ZUZvY3VzYWJsZUl0ZW0oIHRoaXMsIDEgKTtcblx0fVxuXG5cdGlmICggbmV4dEl0ZW0gKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdG5leHRJdGVtLmZvY3VzKCk7XG5cdH1cbn07XG5cbi8qKlxuICogQ2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldCBpcyBhIHtAbGluayBPTy51aS5NdWx0aXNlbGVjdFdpZGdldCBtdWx0aXNlbGVjdCB3aWRnZXR9IHRoYXQgY29udGFpbnNcbiAqIGNoZWNrYm94ZXMgYW5kIGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0LiBUaGVcbiAqIENoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBhZGRpbmcsIHJlbW92aW5nIGFuZCBzZWxlY3Rpbmcgb3B0aW9ucy5cbiAqIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgdGhpcyB3aXRoaW4gYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dCwgdXNlXG4gKiBPTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQgaW5zdGVhZC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIENoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQgd2l0aCBDaGVja2JveE11bHRpb3B0aW9ucy5cbiAqICAgICB2YXIgb3B0aW9uMSA9IG5ldyBPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBkYXRhOiAnYScsXG4gKiAgICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAqICAgICAgICAgICAgIGxhYmVsOiAnU2VsZWN0ZWQgY2hlY2tib3gnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgb3B0aW9uMiA9IG5ldyBPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBkYXRhOiAnYicsXG4gKiAgICAgICAgICAgICBsYWJlbDogJ1Vuc2VsZWN0ZWQgY2hlY2tib3gnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgbXVsdGlzZWxlY3QgPSBuZXcgT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldCgge1xuICogICAgICAgICAgICAgaXRlbXM6IFsgb3B0aW9uMSwgb3B0aW9uMiBdXG4gKiAgICAgICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBtdWx0aXNlbGVjdC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9PcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5NdWx0aXNlbGVjdFdpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUNoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkNoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kbGFzdENsaWNrZWQgPSBudWxsO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLiRncm91cC5vbiggJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQoIHRoaXMgKSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1jaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0JyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5DaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5NdWx0aXNlbGVjdFdpZGdldCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IGFuIG9wdGlvbiBieSBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHNwZWNpZmllZCBpdGVtIChvciB0byB0aGUgc3RhcnQgb2YgdGhlIG9wdGlvbiBhcnJheSxcbiAqIGlmIGl0ZW0gaXMgYG51bGxgKS4gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0byBzZWFyY2ggdGhyb3VnaCB0aGUgb3B0aW9uIGFycmF5IGlzIHNwZWNpZmllZCB3aXRoIGFcbiAqIG51bWJlcjogLTEgZm9yIHJldmVyc2UgKHRoZSBkZWZhdWx0KSBvciAxIGZvciBmb3J3YXJkLiBUaGUgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIG9wdGlvbiwgb3JcbiAqIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gb3B0aW9ucyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0fG51bGx9IGl0ZW0gSXRlbSB0byBkZXNjcmliZSB0aGUgc3RhcnQgcG9zaXRpb24sIG9yIGBudWxsYCB0byBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIG1vdmUgaW46IC0xIHRvIG1vdmUgYmFja3dhcmQsIDEgdG8gbW92ZSBmb3J3YXJkXG4gKiBAcmV0dXJuIHtPTy51aS5DaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0fG51bGx9IEl0ZW0gYXQgcG9zaXRpb24sIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIHNlbGVjdFxuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5nZXRSZWxhdGl2ZUZvY3VzYWJsZUl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0sIGRpcmVjdGlvbiApIHtcblx0dmFyIGN1cnJlbnRJbmRleCwgbmV4dEluZGV4LCBpLFxuXHRcdGluY3JlYXNlID0gZGlyZWN0aW9uID4gMCA/IDEgOiAtMSxcblx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblxuXHRpZiAoIGl0ZW0gKSB7XG5cdFx0Y3VycmVudEluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKCBpdGVtICk7XG5cdFx0bmV4dEluZGV4ID0gKCBjdXJyZW50SW5kZXggKyBpbmNyZWFzZSArIGxlbiApICUgbGVuO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQgYW5kIG1vdmluZyBmb3J3YXJkLCBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLlxuXHRcdC8vIElmIG1vdmluZyBiYWNrd2FyZCwgc3RhcnQgYXQgdGhlIGVuZC5cblx0XHRuZXh0SW5kZXggPSBkaXJlY3Rpb24gPiAwID8gMCA6IGxlbiAtIDE7XG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBuZXh0SW5kZXggXTtcblx0XHRpZiAoIGl0ZW0gJiYgIWl0ZW0uaXNEaXNhYmxlZCgpICkge1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fVxuXHRcdG5leHRJbmRleCA9ICggbmV4dEluZGV4ICsgaW5jcmVhc2UgKyBsZW4gKSAlIGxlbjtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogSGFuZGxlIGNsaWNrIGV2ZW50cyBvbiBjaGVja2JveGVzLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciAkb3B0aW9ucywgbGFzdENsaWNrZWRJbmRleCwgbm93Q2xpY2tlZEluZGV4LCBpLCBkaXJlY3Rpb24sIHdhc1NlbGVjdGVkLCBpdGVtcyxcblx0XHQkbGFzdENsaWNrZWQgPSB0aGlzLiRsYXN0Q2xpY2tlZCxcblx0XHQkbm93Q2xpY2tlZCA9ICQoIGUudGFyZ2V0ICkuY2xvc2VzdCggJy5vby11aS1jaGVja2JveE11bHRpb3B0aW9uV2lkZ2V0JyApXG5cdFx0XHQubm90KCAnLm9vLXVpLXdpZGdldC1kaXNhYmxlZCcgKTtcblxuXHQvLyBBbGxvdyBzZWxlY3RpbmcgbXVsdGlwbGUgb3B0aW9ucyBhdCBvbmNlIGJ5IFNoaWZ0LWNsaWNraW5nIHRoZW1cblx0aWYgKCAkbGFzdENsaWNrZWQgJiYgJG5vd0NsaWNrZWQubGVuZ3RoICYmIGUuc2hpZnRLZXkgKSB7XG5cdFx0JG9wdGlvbnMgPSB0aGlzLiRncm91cC5maW5kKCAnLm9vLXVpLWNoZWNrYm94TXVsdGlvcHRpb25XaWRnZXQnICk7XG5cdFx0bGFzdENsaWNrZWRJbmRleCA9ICRvcHRpb25zLmluZGV4KCAkbGFzdENsaWNrZWQgKTtcblx0XHRub3dDbGlja2VkSW5kZXggPSAkb3B0aW9ucy5pbmRleCggJG5vd0NsaWNrZWQgKTtcblx0XHQvLyBJZiBpdCdzIHRoZSBzYW1lIGl0ZW0sIGVpdGhlciB0aGUgdXNlciBpcyBiZWluZyBzaWxseSwgb3IgaXQncyBhIGZha2UgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZVxuXHRcdC8vIGJyb3dzZXIuIEluIGVpdGhlciBjYXNlIHdlIGRvbid0IG5lZWQgY3VzdG9tIGhhbmRsaW5nLlxuXHRcdGlmICggbm93Q2xpY2tlZEluZGV4ICE9PSBsYXN0Q2xpY2tlZEluZGV4ICkge1xuXHRcdFx0aXRlbXMgPSB0aGlzLml0ZW1zO1xuXHRcdFx0d2FzU2VsZWN0ZWQgPSBpdGVtc1sgbm93Q2xpY2tlZEluZGV4IF0uaXNTZWxlY3RlZCgpO1xuXHRcdFx0ZGlyZWN0aW9uID0gbm93Q2xpY2tlZEluZGV4ID4gbGFzdENsaWNrZWRJbmRleCA/IDEgOiAtMTtcblxuXHRcdFx0Ly8gVGhpcyBkZXBlbmRzIG9uIHRoZSBET00gb3JkZXIgb2YgdGhlIGl0ZW1zIGFuZCB0aGUgb3JkZXIgb2YgdGhlIC5pdGVtcyBhcnJheSBiZWluZyB0aGUgc2FtZS5cblx0XHRcdGZvciAoIGkgPSBsYXN0Q2xpY2tlZEluZGV4OyBpICE9PSBub3dDbGlja2VkSW5kZXg7IGkgKz0gZGlyZWN0aW9uICkge1xuXHRcdFx0XHRpZiAoICFpdGVtc1sgaSBdLmlzRGlzYWJsZWQoKSApIHtcblx0XHRcdFx0XHRpdGVtc1sgaSBdLnNldFNlbGVjdGVkKCAhd2FzU2VsZWN0ZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gRm9yIHRoZSBub3ctY2xpY2tlZCBlbGVtZW50LCB1c2UgaW1tZWRpYXRlIHRpbWVvdXQgdG8gYWxsb3cgdGhlIGJyb3dzZXIgdG8gZG8gaXRzIG93blxuXHRcdFx0Ly8gaGFuZGxpbmcgZmlyc3QsIHRoZW4gc2V0IG91ciB2YWx1ZS4gVGhlIG9yZGVyIGluIHdoaWNoIGV2ZW50cyBoYXBwZW4gaXMgZGlmZmVyZW50IGZvclxuXHRcdFx0Ly8gY2xpY2tzIG9uIHRoZSA8aW5wdXQ+IGFuZCBvbiB0aGUgPGxhYmVsPiBhbmQgdGhlcmUgYXJlIGFkZGl0aW9uYWwgZmFrZSBjbGlja3MgZmlyZWQgZm9yXG5cdFx0XHQvLyBub24tY2xpY2sgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGUgY2hlY2tib3hlcy5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCAhaXRlbXNbIG5vd0NsaWNrZWRJbmRleCBdLmlzRGlzYWJsZWQoKSApIHtcblx0XHRcdFx0XHRpdGVtc1sgbm93Q2xpY2tlZEluZGV4IF0uc2V0U2VsZWN0ZWQoICF3YXNTZWxlY3RlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAkbm93Q2xpY2tlZC5sZW5ndGggKSB7XG5cdFx0dGhpcy4kbGFzdENsaWNrZWQgPSAkbm93Q2xpY2tlZDtcblx0fVxufTtcblxuLyoqXG4gKiBGb2N1cyB0aGUgd2lkZ2V0XG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpdGVtO1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHRpdGVtID0gdGhpcy5nZXRSZWxhdGl2ZUZvY3VzYWJsZUl0ZW0oIG51bGwsIDEgKTtcblx0XHRpZiAoIGl0ZW0gKSB7XG5cdFx0XHRpdGVtLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5zaW11bGF0ZUxhYmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuZm9jdXMoKTtcbn07XG5cbi8qKlxuICogUHJvZ3Jlc3MgYmFycyB2aXN1YWxseSBkaXNwbGF5IHRoZSBzdGF0dXMgb2YgYW4gb3BlcmF0aW9uLCBzdWNoIGFzIGEgZG93bmxvYWQsXG4gKiBhbmQgY2FuIGJlIGVpdGhlciBkZXRlcm1pbmF0ZSBvciBpbmRldGVybWluYXRlOlxuICpcbiAqIC0gKipkZXRlcm1pbmF0ZSoqIHByb2Nlc3MgYmFycyBzaG93IHRoZSBwZXJjZW50IG9mIGFuIG9wZXJhdGlvbiB0aGF0IGlzIGNvbXBsZXRlLlxuICpcbiAqIC0gKippbmRldGVybWluYXRlKiogcHJvY2VzcyBiYXJzIHVzZSBhIHZpc3VhbCBkaXNwbGF5IG9mIG1vdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvblxuICogICBpcyB0YWtpbmcgcGxhY2UuIEJlY2F1c2UgdGhlIGV4dGVudCBvZiBhbiBpbmRldGVybWluYXRlIG9wZXJhdGlvbiBpcyB1bmtub3duLCB0aGUgYmFyIGRvZXNcbiAqICAgbm90IHVzZSBwZXJjZW50YWdlcy5cbiAqXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGBwcm9ncmVzc2AgY29uZmlndXJhdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJhciBpcyBkZXRlcm1pbmF0ZSBvciBpbmRldGVybWluYXRlLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEV4YW1wbGVzIG9mIGRldGVybWluYXRlIGFuZCBpbmRldGVybWluYXRlIHByb2dyZXNzIGJhcnMuXG4gKiAgICAgdmFyIHByb2dyZXNzQmFyMSA9IG5ldyBPTy51aS5Qcm9ncmVzc0JhcldpZGdldCgge1xuICogICAgICAgICBwcm9ncmVzczogMzNcbiAqICAgICB9ICk7XG4gKiAgICAgdmFyIHByb2dyZXNzQmFyMiA9IG5ldyBPTy51aS5Qcm9ncmVzc0JhcldpZGdldCgpO1xuICpcbiAqICAgICAvLyBDcmVhdGUgYSBGaWVsZHNldExheW91dCB0byBsYXlvdXQgcHJvZ3Jlc3MgYmFycy5cbiAqICAgICB2YXIgZmllbGRzZXQgPSBuZXcgT08udWkuRmllbGRzZXRMYXlvdXQ7XG4gKiAgICAgZmllbGRzZXQuYWRkSXRlbXMoIFtcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBwcm9ncmVzc0JhcjEsIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnRGV0ZXJtaW5hdGUnLFxuICogICAgICAgICAgICAgYWxpZ246ICd0b3AnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBwcm9ncmVzc0JhcjIsIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnSW5kZXRlcm1pbmF0ZScsXG4gKiAgICAgICAgICAgICBhbGlnbjogJ3RvcCdcbiAqICAgICAgICAgfSApXG4gKiAgICAgXSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGZpZWxkc2V0LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge251bWJlcnxib29sZWFufSBbcHJvZ3Jlc3M9ZmFsc2VdIFRoZSB0eXBlIG9mIHByb2dyZXNzIGJhciAoZGV0ZXJtaW5hdGUgb3IgaW5kZXRlcm1pbmF0ZSkuXG4gKiAgVG8gY3JlYXRlIGEgZGV0ZXJtaW5hdGUgcHJvZ3Jlc3MgYmFyLCBzcGVjaWZ5IGEgbnVtYmVyIHRoYXQgcmVmbGVjdHMgdGhlIGluaXRpYWwgcGVyY2VudCBjb21wbGV0ZS5cbiAqICBCeSBkZWZhdWx0LCB0aGUgcHJvZ3Jlc3MgYmFyIGlzIGluZGV0ZXJtaW5hdGUuXG4gKi9cbk9PLnVpLlByb2dyZXNzQmFyV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVByb2dyZXNzQmFyV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Qcm9ncmVzc0JhcldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiRiYXIgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMucHJvZ3Jlc3MgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuc2V0UHJvZ3Jlc3MoIGNvbmZpZy5wcm9ncmVzcyAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnByb2dyZXNzIDogZmFsc2UgKTtcblx0dGhpcy4kYmFyLmFkZENsYXNzKCAnb28tdWktcHJvZ3Jlc3NCYXJXaWRnZXQtYmFyJyApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmF0dHIoIHtcblx0XHRcdHJvbGU6ICdwcm9ncmVzc2JhcicsXG5cdFx0XHQnYXJpYS12YWx1ZW1pbic6IDAsXG5cdFx0XHQnYXJpYS12YWx1ZW1heCc6IDEwMFxuXHRcdH0gKVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXByb2dyZXNzQmFyV2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kYmFyICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlByb2dyZXNzQmFyV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qcm9ncmVzc0JhcldpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdkaXYnO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IHRoZSBwZXJjZW50IG9mIHRoZSBwcm9ncmVzcyB0aGF0IGhhcyBiZWVuIGNvbXBsZXRlZC4gSW5kZXRlcm1pbmF0ZSBwcm9ncmVzc2VzIHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IFByb2dyZXNzIHBlcmNlbnRcbiAqL1xuT08udWkuUHJvZ3Jlc3NCYXJXaWRnZXQucHJvdG90eXBlLmdldFByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5wcm9ncmVzcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwZXJjZW50IG9mIHRoZSBwcm9jZXNzIGNvbXBsZXRlZCBvciBgZmFsc2VgIGZvciBhbiBpbmRldGVybWluYXRlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gcHJvZ3Jlc3MgUHJvZ3Jlc3MgcGVyY2VudCBvciBgZmFsc2VgIGZvciBpbmRldGVybWluYXRlXG4gKi9cbk9PLnVpLlByb2dyZXNzQmFyV2lkZ2V0LnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uICggcHJvZ3Jlc3MgKSB7XG5cdHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcblxuXHRpZiAoIHByb2dyZXNzICE9PSBmYWxzZSApIHtcblx0XHR0aGlzLiRiYXIuY3NzKCAnd2lkdGgnLCB0aGlzLnByb2dyZXNzICsgJyUnICk7XG5cdFx0dGhpcy4kZWxlbWVudC5hdHRyKCAnYXJpYS12YWx1ZW5vdycsIHRoaXMucHJvZ3Jlc3MgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRiYXIuY3NzKCAnd2lkdGgnLCAnJyApO1xuXHRcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0ciggJ2FyaWEtdmFsdWVub3cnICk7XG5cdH1cblx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLXByb2dyZXNzQmFyV2lkZ2V0LWluZGV0ZXJtaW5hdGUnLCBwcm9ncmVzcyA9PT0gZmFsc2UgKTtcbn07XG5cbi8qKlxuICogSW5wdXRXaWRnZXQgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBpbnB1dCB3aWRnZXRzLCB3aGljaFxuICogaW5jbHVkZSB7QGxpbmsgT08udWkuVGV4dElucHV0V2lkZ2V0IHRleHQgaW5wdXRzfSwge0BsaW5rIE9PLnVpLkNoZWNrYm94SW5wdXRXaWRnZXQgY2hlY2tib3ggaW5wdXRzfSxcbiAqIHtAbGluayBPTy51aS5SYWRpb0lucHV0V2lkZ2V0IHJhZGlvIGlucHV0c30sIGFuZCB7QGxpbmsgT08udWkuQnV0dG9uSW5wdXRXaWRnZXQgYnV0dG9uIGlucHV0c30uXG4gKiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9JbnB1dHNcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uQWNjZXNzS2V5ZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtzdHJpbmd9IFtuYW1lPScnXSBUaGUgdmFsdWUgb2YgdGhlIGlucHV04oCZcyBIVE1MIGBuYW1lYCBhdHRyaWJ1dGUuXG4gKiBAY2ZnIHtzdHJpbmd9IFt2YWx1ZT0nJ10gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAqIEBjZmcge3N0cmluZ30gW2Rpcl0gVGhlIGRpcmVjdGlvbmFsaXR5IG9mIHRoZSBpbnB1dCAobHRyL3J0bCkuXG4gKiBAY2ZnIHtzdHJpbmd9IFtpbnB1dElkXSBUaGUgdmFsdWUgb2YgdGhlIGlucHV04oCZcyBIVE1MIGBpZGAgYXR0cmlidXRlLlxuICogQGNmZyB7RnVuY3Rpb259IFtpbnB1dEZpbHRlcl0gVGhlIG5hbWUgb2YgYW4gaW5wdXQgZmlsdGVyIGZ1bmN0aW9uLiBJbnB1dCBmaWx0ZXJzIG1vZGlmeSB0aGUgdmFsdWUgb2YgYW4gaW5wdXRcbiAqICBiZWZvcmUgaXQgaXMgYWNjZXB0ZWQuXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUlucHV0V2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5JbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHQvLyBTZWUgI3JldXNlUHJlSW5mdXNlRE9NIGFib3V0IGNvbmZpZy4kaW5wdXRcblx0dGhpcy4kaW5wdXQgPSBjb25maWcuJGlucHV0IHx8IHRoaXMuZ2V0SW5wdXRFbGVtZW50KCBjb25maWcgKTtcblx0dGhpcy52YWx1ZSA9ICcnO1xuXHR0aGlzLmlucHV0RmlsdGVyID0gY29uZmlnLmlucHV0RmlsdGVyO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRhYkluZGV4ZWQ6IHRoaXMuJGlucHV0IH0gKSApO1xuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICR0aXRsZWQ6IHRoaXMuJGlucHV0IH0gKSApO1xuXHRPTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJGFjY2Vzc0tleWVkOiB0aGlzLiRpbnB1dCB9ICkgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kaW5wdXQub24oICdrZXlkb3duIG1vdXNldXAgY3V0IHBhc3RlIGNoYW5nZSBpbnB1dCBzZWxlY3QnLCB0aGlzLm9uRWRpdC5iaW5kKCB0aGlzICkgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRpbnB1dFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWlucHV0V2lkZ2V0LWlucHV0JyApXG5cdFx0LmF0dHIoICduYW1lJywgY29uZmlnLm5hbWUgKVxuXHRcdC5wcm9wKCAnZGlzYWJsZWQnLCB0aGlzLmlzRGlzYWJsZWQoKSApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktaW5wdXRXaWRnZXQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRpbnB1dCApO1xuXHR0aGlzLnNldFZhbHVlKCBjb25maWcudmFsdWUgKTtcblx0aWYgKCBjb25maWcuZGlyICkge1xuXHRcdHRoaXMuc2V0RGlyKCBjb25maWcuZGlyICk7XG5cdH1cblx0aWYgKCBjb25maWcuaW5wdXRJZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXMuc2V0SW5wdXRJZCggY29uZmlnLmlucHV0SWQgKTtcblx0fVxufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5JbnB1dFdpZGdldCwgT08udWkuV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5JbnB1dFdpZGdldCwgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLklucHV0V2lkZ2V0LCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuSW5wdXRXaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLklucHV0V2lkZ2V0LCBPTy51aS5taXhpbi5BY2Nlc3NLZXllZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5JbnB1dFdpZGdldC5zdGF0aWMucmV1c2VQcmVJbmZ1c2VET00gPSBmdW5jdGlvbiAoIG5vZGUsIGNvbmZpZyApIHtcblx0Y29uZmlnID0gT08udWkuSW5wdXRXaWRnZXQucGFyZW50LnN0YXRpYy5yZXVzZVByZUluZnVzZURPTSggbm9kZSwgY29uZmlnICk7XG5cdC8vIFJldXNpbmcgYCRpbnB1dGAgbGV0cyBicm93c2VycyBwcmVzZXJ2ZSBpbnB1dHRlZCB2YWx1ZXMgYWNyb3NzIHBhZ2UgcmVsb2Fkcywgc2VlIFQxMTQxMzQuXG5cdGNvbmZpZy4kaW5wdXQgPSAkKCBub2RlICkuZmluZCggJy5vby11aS1pbnB1dFdpZGdldC1pbnB1dCcgKTtcblx0cmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuSW5wdXRXaWRnZXQuc3RhdGljLmdhdGhlclByZUluZnVzZVN0YXRlID0gZnVuY3Rpb24gKCBub2RlLCBjb25maWcgKSB7XG5cdHZhciBzdGF0ZSA9IE9PLnVpLklucHV0V2lkZ2V0LnBhcmVudC5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUoIG5vZGUsIGNvbmZpZyApO1xuXHRpZiAoIGNvbmZpZy4kaW5wdXQgJiYgY29uZmlnLiRpbnB1dC5sZW5ndGggKSB7XG5cdFx0c3RhdGUudmFsdWUgPSBjb25maWcuJGlucHV0LnZhbCgpO1xuXHRcdC8vIE1pZ2h0IGJlIGJldHRlciBpbiBUYWJJbmRleGVkRWxlbWVudCwgYnV0IGl0J3MgYXdrd2FyZCB0byBkbyB0aGVyZSBiZWNhdXNlIG1peGlucyBhcmUgYXdrd2FyZFxuXHRcdHN0YXRlLmZvY3VzID0gY29uZmlnLiRpbnB1dC5pcyggJzpmb2N1cycgKTtcblx0fVxuXHRyZXR1cm4gc3RhdGU7XG59O1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBAZXZlbnQgY2hhbmdlXG4gKlxuICogQSBjaGFuZ2UgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IGlucHV0IGVsZW1lbnQuXG4gKlxuICogU3ViY2xhc3NlcyBvZiBPTy51aS5JbnB1dFdpZGdldCB1c2UgdGhlIGBjb25maWdgIHBhcmFtZXRlciB0byBwcm9kdWNlIGRpZmZlcmVudCBlbGVtZW50cyBpblxuICogZGlmZmVyZW50IGNpcmN1bXN0YW5jZXMuIFRoZSBlbGVtZW50IG11c3QgaGF2ZSBhIGB2YWx1ZWAgcHJvcGVydHkgKGxpa2UgZm9ybSBlbGVtZW50cykuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge2pRdWVyeX0gSW5wdXQgZWxlbWVudFxuICovXG5PTy51aS5JbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJCggJzxpbnB1dD4nICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBwb3RlbnRpYWxseSB2YWx1ZS1jaGFuZ2luZyBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBkb3duLCBtb3VzZSB1cCwgY3V0LCBwYXN0ZSwgY2hhbmdlLCBpbnB1dCwgb3Igc2VsZWN0IGV2ZW50XG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5vbkVkaXQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB3aWRnZXQgPSB0aGlzO1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHQvLyBBbGxvdyB0aGUgc3RhY2sgdG8gY2xlYXIgc28gdGhlIHZhbHVlIHdpbGwgYmUgdXBkYXRlZFxuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHdpZGdldC5zZXRWYWx1ZSggd2lkZ2V0LiRpbnB1dC52YWwoKSApO1xuXHRcdH0gKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElucHV0IHZhbHVlXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gUmVzeW5jaHJvbml6ZSBvdXIgaW50ZXJuYWwgZGF0YSB3aXRoIERPTSBkYXRhLiBPdGhlciBzY3JpcHRzIGV4ZWN1dGluZyBvbiB0aGUgcGFnZSBjYW4gbW9kaWZ5XG5cdC8vIGl0LCBhbmQgd2Ugd29uJ3Qga25vdyB1bmxlc3MgdGhleSdyZSBraW5kIGVub3VnaCB0byB0cmlnZ2VyIGEgJ2NoYW5nZScgZXZlbnQuXG5cdHZhciB2YWx1ZSA9IHRoaXMuJGlucHV0LnZhbCgpO1xuXHRpZiAoIHRoaXMudmFsdWUgIT09IHZhbHVlICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgVGV4dCBkaXJlY3Rpb25hbGl0eTogJ2x0cicsICdydGwnIG9yICdhdXRvJ1xuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuSW5wdXRXaWRnZXQucHJvdG90eXBlLnNldERpciA9IGZ1bmN0aW9uICggZGlyICkge1xuXHR0aGlzLiRpbnB1dC5wcm9wKCAnZGlyJywgZGlyICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgTmV3IHZhbHVlXG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5JbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR2YWx1ZSA9IHRoaXMuY2xlYW5VcFZhbHVlKCB2YWx1ZSApO1xuXHQvLyBVcGRhdGUgdGhlIERPTSBpZiBpdCBoYXMgY2hhbmdlZC4gTm90ZSB0aGF0IHdpdGggY2xlYW5VcFZhbHVlLCBpdFxuXHQvLyBpcyBwb3NzaWJsZSBmb3IgdGhlIERPTSB2YWx1ZSB0byBjaGFuZ2Ugd2l0aG91dCB0aGlzLnZhbHVlIGNoYW5naW5nLlxuXHRpZiAoIHRoaXMuJGlucHV0LnZhbCgpICE9PSB2YWx1ZSApIHtcblx0XHR0aGlzLiRpbnB1dC52YWwoIHZhbHVlICk7XG5cdH1cblx0aWYgKCB0aGlzLnZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5lbWl0KCAnY2hhbmdlJywgdGhpcy52YWx1ZSApO1xuXHR9XG5cdC8vIFRoZSBmaXJzdCB0aW1lIHRoYXQgdGhlIHZhbHVlIGlzIHNldCAocHJvYmFibHkgd2hpbGUgY29uc3RydWN0aW5nIHRoZSB3aWRnZXQpLFxuXHQvLyByZW1lbWJlciBpdCBpbiBkZWZhdWx0VmFsdWUuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGxhdGVyIHVzZWQgdG8gY2hlY2sgd2hldGhlclxuXHQvLyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgaXQgd2FzIGNyZWF0ZWQuXG5cdGlmICggdGhpcy5kZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0dGhpcy4kaW5wdXRbIDAgXS5kZWZhdWx0VmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgaW5jb21pbmcgdmFsdWUuXG4gKlxuICogRW5zdXJlcyB2YWx1ZSBpcyBhIHN0cmluZywgYW5kIGNvbnZlcnRzIHVuZGVmaW5lZCBhbmQgbnVsbCB0byBlbXB0eSBzdHJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBPcmlnaW5hbCB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfSBDbGVhbmVkIHVwIHZhbHVlXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5jbGVhblVwVmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9IGVsc2UgaWYgKCB0aGlzLmlucHV0RmlsdGVyICkge1xuXHRcdHJldHVybiB0aGlzLmlucHV0RmlsdGVyKCBTdHJpbmcoIHZhbHVlICkgKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gU3RyaW5nKCB2YWx1ZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdE9PLnVpLklucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0RGlzYWJsZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0aWYgKCB0aGlzLiRpbnB1dCApIHtcblx0XHR0aGlzLiRpbnB1dC5wcm9wKCAnZGlzYWJsZWQnLCB0aGlzLmlzRGlzYWJsZWQoKSApO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlICdpZCcgYXR0cmlidXRlIG9mIHRoZSBgPGlucHV0PmAgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRJbnB1dElkID0gZnVuY3Rpb24gKCBpZCApIHtcblx0dGhpcy4kaW5wdXQuYXR0ciggJ2lkJywgaWQgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLklucHV0V2lkZ2V0LnByb3RvdHlwZS5yZXN0b3JlUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5JbnB1dFdpZGdldC5wYXJlbnQucHJvdG90eXBlLnJlc3RvcmVQcmVJbmZ1c2VTdGF0ZS5jYWxsKCB0aGlzLCBzdGF0ZSApO1xuXHRpZiAoIHN0YXRlLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKSApIHtcblx0XHR0aGlzLnNldFZhbHVlKCBzdGF0ZS52YWx1ZSApO1xuXHR9XG5cdGlmICggc3RhdGUuZm9jdXMgKSB7XG5cdFx0dGhpcy5mb2N1cygpO1xuXHR9XG59O1xuXG4vKipcbiAqIERhdGEgd2lkZ2V0IGludGVuZGVkIGZvciBjcmVhdGluZyBgPGlucHV0IHR5cGU9XCJoaWRkZW5cIj5gIGlucHV0cy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7c3RyaW5nfSBbdmFsdWU9JyddIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXG4gKiBAY2ZnIHtzdHJpbmd9IFtuYW1lPScnXSBUaGUgdmFsdWUgb2YgdGhlIGlucHV04oCZcyBIVE1MIGBuYW1lYCBhdHRyaWJ1dGUuXG4gKi9cbk9PLnVpLkhpZGRlbklucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUhpZGRlbklucHV0V2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgdmFsdWU6ICcnLCBuYW1lOiAnJyB9LCBjb25maWcgKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuSGlkZGVuSW5wdXRXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYXR0cigge1xuXHRcdHR5cGU6ICdoaWRkZW4nLFxuXHRcdHZhbHVlOiBjb25maWcudmFsdWUsXG5cdFx0bmFtZTogY29uZmlnLm5hbWVcblx0fSApO1xuXHR0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoICdhcmlhLWRpc2FibGVkJyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5IaWRkZW5JbnB1dFdpZGdldCwgT08udWkuV2lkZ2V0ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuSGlkZGVuSW5wdXRXaWRnZXQuc3RhdGljLnRhZ05hbWUgPSAnaW5wdXQnO1xuXG4vKipcbiAqIEJ1dHRvbklucHV0V2lkZ2V0IGlzIHVzZWQgdG8gc3VibWl0IEhUTUwgZm9ybXMgYW5kIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluXG4gKiBhIE9PLnVpLkZvcm1MYXlvdXQuIElmIHlvdSBkbyBub3QgbmVlZCB0aGUgYnV0dG9uIHRvIHdvcmsgd2l0aCBIVE1MIGZvcm1zLCB5b3UgcHJvYmFibHlcbiAqIHdhbnQgdG8gdXNlIE9PLnVpLkJ1dHRvbldpZGdldCBpbnN0ZWFkLiBCdXR0b24gaW5wdXQgd2lkZ2V0cyBjYW4gYmUgcmVuZGVyZWQgYXMgZWl0aGVyIGFuXG4gKiBIVE1MIGA8YnV0dG9uPmAgKHRoZSBkZWZhdWx0KSBvciBhbiBIVE1MIGA8aW5wdXQ+YCB0YWdzLiBTZWUgdGhlXG4gKiBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEEgQnV0dG9uSW5wdXRXaWRnZXQgcmVuZGVyZWQgYXMgYW4gSFRNTCBidXR0b24sIHRoZSBkZWZhdWx0LlxuICogICAgIHZhciBidXR0b24gPSBuZXcgT08udWkuQnV0dG9uSW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgbGFiZWw6ICdJbnB1dCBidXR0b24nLFxuICogICAgICAgICBpY29uOiAnY2hlY2snLFxuICogICAgICAgICB2YWx1ZTogJ2NoZWNrJ1xuICogICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBidXR0b24uJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSW5wdXRzI0J1dHRvbl9pbnB1dHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLklucHV0V2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSWNvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ30gW3R5cGU9J2J1dHRvbiddIFRoZSB2YWx1ZSBvZiB0aGUgSFRNTCBgJ3R5cGUnYCBhdHRyaWJ1dGU6ICdidXR0b24nLCAnc3VibWl0JyBvciAncmVzZXQnLlxuICogQGNmZyB7Ym9vbGVhbn0gW3VzZUlucHV0VGFnPWZhbHNlXSBVc2UgYW4gYDxpbnB1dD5gIHRhZyBpbnN0ZWFkIG9mIGEgYDxidXR0b24+YCB0YWcsIHRoZSBkZWZhdWx0LlxuICogIFdpZGdldHMgY29uZmlndXJlZCB0byBiZSBhbiBgPGlucHV0PmAgZG8gbm90IHN1cHBvcnQge0BsaW5rICNpY29uIGljb25zfSBhbmQge0BsaW5rICNpbmRpY2F0b3IgaW5kaWNhdG9yc30sXG4gKiAgbm9uLXBsYWludGV4dCB7QGxpbmsgI2xhYmVsIGxhYmVsc30sIG9yIHtAbGluayAjdmFsdWUgdmFsdWVzfS4gSW4gZ2VuZXJhbCwgdXNlSW5wdXRUYWcgc2hvdWxkIG9ubHlcbiAqICBiZSBzZXQgdG8gYHRydWVgIHdoZW4gdGhlcmXigJlzIG5lZWQgdG8gc3VwcG9ydCBJRSA2IGluIGEgZm9ybSB3aXRoIG11bHRpcGxlIGJ1dHRvbnMuXG4gKi9cbk9PLnVpLkJ1dHRvbklucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUJ1dHRvbklucHV0V2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgdHlwZTogJ2J1dHRvbicsIHVzZUlucHV0VGFnOiBmYWxzZSB9LCBjb25maWcgKTtcblxuXHQvLyBTZWUgSW5wdXRXaWRnZXQjcmV1c2VQcmVJbmZ1c2VET00gYWJvdXQgY29uZmlnLiRpbnB1dFxuXHRpZiAoIGNvbmZpZy4kaW5wdXQgKSB7XG5cdFx0Y29uZmlnLiRpbnB1dC5lbXB0eSgpO1xuXHR9XG5cblx0Ly8gUHJvcGVydGllcyAobXVzdCBiZSBzZXQgYmVmb3JlIHBhcmVudCBjb25zdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgI3NldFZhbHVlKVxuXHR0aGlzLnVzZUlucHV0VGFnID0gY29uZmlnLnVzZUlucHV0VGFnO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5CdXR0b25JbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJGJ1dHRvbjogdGhpcy4kaW5wdXQgfSApICk7XG5cdE9PLnVpLm1peGluLkljb25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0aWYgKCAhY29uZmlnLnVzZUlucHV0VGFnICkge1xuXHRcdHRoaXMuJGlucHV0LmFwcGVuZCggdGhpcy4kaWNvbiwgdGhpcy4kbGFiZWwsIHRoaXMuJGluZGljYXRvciApO1xuXHR9XG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1idXR0b25JbnB1dFdpZGdldCcgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQnV0dG9uSW5wdXRXaWRnZXQsIE9PLnVpLklucHV0V2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5CdXR0b25JbnB1dFdpZGdldCwgT08udWkubWl4aW4uQnV0dG9uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uSW5wdXRXaWRnZXQsIE9PLnVpLm1peGluLkljb25FbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5CdXR0b25JbnB1dFdpZGdldCwgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uSW5wdXRXaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkJ1dHRvbklucHV0V2lkZ2V0LnN0YXRpYy50YWdOYW1lID0gJ3NwYW4nO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuQnV0dG9uSW5wdXRXaWRnZXQucHJvdG90eXBlLmdldElucHV0RWxlbWVudCA9IGZ1bmN0aW9uICggY29uZmlnICkge1xuXHR2YXIgdHlwZTtcblx0dHlwZSA9IFsgJ2J1dHRvbicsICdzdWJtaXQnLCAncmVzZXQnIF0uaW5kZXhPZiggY29uZmlnLnR5cGUgKSAhPT0gLTEgPyBjb25maWcudHlwZSA6ICdidXR0b24nO1xuXHRyZXR1cm4gJCggJzwnICsgKCBjb25maWcudXNlSW5wdXRUYWcgPyAnaW5wdXQnIDogJ2J1dHRvbicgKSArICcgdHlwZT1cIicgKyB0eXBlICsgJ1wiPicgKTtcbn07XG5cbi8qKlxuICogU2V0IGxhYmVsIHZhbHVlLlxuICpcbiAqIElmICN1c2VJbnB1dFRhZyBpcyBgdHJ1ZWAsIHRoZSBsYWJlbCBpcyBzZXQgYXMgdGhlIGB2YWx1ZWAgb2YgdGhlIGA8aW5wdXQ+YCB0YWcuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9IGxhYmVsIExhYmVsIG5vZGVzLCB0ZXh0LCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlcyBvclxuICogIHRleHQsIG9yIGBudWxsYCBmb3Igbm8gbGFiZWxcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJ1dHRvbklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwgKSB7XG5cdGlmICggdHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGxhYmVsID0gT08udWkucmVzb2x2ZU1zZyggbGFiZWwgKTtcblx0fVxuXG5cdGlmICggdGhpcy51c2VJbnB1dFRhZyApIHtcblx0XHQvLyBEaXNjYXJkIG5vbi1wbGFpbnRleHQgbGFiZWxzXG5cdFx0aWYgKCB0eXBlb2YgbGFiZWwgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0bGFiZWwgPSAnJztcblx0XHR9XG5cblx0XHR0aGlzLiRpbnB1dC52YWwoIGxhYmVsICk7XG5cdH1cblxuXHRyZXR1cm4gT08udWkubWl4aW4uTGFiZWxFbGVtZW50LnByb3RvdHlwZS5zZXRMYWJlbC5jYWxsKCB0aGlzLCBsYWJlbCApO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBkaXNhYmxlZCBmb3IgYnV0dG9uIGlucHV0cyBjb25maWd1cmVkIGFzIHtAbGluayAjdXNlSW5wdXRUYWcgPGlucHV0PiB0YWdzfSwgYXNcbiAqIHRoZXkgZG8gbm90IHN1cHBvcnQge0BsaW5rICN2YWx1ZSB2YWx1ZXN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBOZXcgdmFsdWVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJ1dHRvbklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdGlmICggIXRoaXMudXNlSW5wdXRUYWcgKSB7XG5cdFx0T08udWkuQnV0dG9uSW5wdXRXaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKCB0aGlzLCB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CdXR0b25JbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRJZCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gRGlzYWJsZSBnZW5lcmF0aW5nIGA8bGFiZWw+YCBlbGVtZW50cyBmb3IgYnV0dG9ucy4gT25lIHdvdWxkIHZlcnkgcmFyZWx5IG5lZWQgYWRkaXRpb25hbCBsYWJlbFxuXHQvLyBmb3IgYSBidXR0b24sIGFuZCBpdCdzIGFscmVhZHkgYSBiaWcgY2xpY2thYmxlIHRhcmdldCwgYW5kIGl0IGNhdXNlcyB1bmV4cGVjdGVkIHJlbmRlcmluZy5cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrYm94SW5wdXRXaWRnZXRzLCBsaWtlIEhUTUwgY2hlY2tib3hlcywgY2FuIGJlIHNlbGVjdGVkIGFuZC9vciBjb25maWd1cmVkIHdpdGggYSB2YWx1ZS5cbiAqIE5vdGUgdGhhdCB0aGVzZSB7QGxpbmsgT08udWkuSW5wdXRXaWRnZXQgaW5wdXQgd2lkZ2V0c30gYXJlIGJlc3QgbGFpZCBvdXRcbiAqIGluIHtAbGluayBPTy51aS5GaWVsZExheW91dCBmaWVsZCBsYXlvdXRzfSB0aGF0IHVzZSB0aGUge0BsaW5rIE9PLnVpLkZpZWxkTGF5b3V0I2FsaWduIGlubGluZX1cbiAqIGFsaWdubWVudC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiBUaGlzIHdpZGdldCBjYW4gYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBbiBleGFtcGxlIG9mIHNlbGVjdGVkLCB1bnNlbGVjdGVkLCBhbmQgZGlzYWJsZWQgY2hlY2tib3ggaW5wdXRzLlxuICogICAgIHZhciBjaGVja2JveDEgPSBuZXcgT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldCgge1xuICogICAgICAgICAgICAgdmFsdWU6ICdhJyxcbiAqICAgICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZVxuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIGNoZWNrYm94MiA9IG5ldyBPTy51aS5DaGVja2JveElucHV0V2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICB2YWx1ZTogJ2InXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgY2hlY2tib3gzID0gbmV3IE9PLnVpLkNoZWNrYm94SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgICAgIHZhbHVlOidjJyxcbiAqICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgLy8gQ3JlYXRlIGEgZmllbGRzZXQgbGF5b3V0IHdpdGggZmllbGRzIGZvciBlYWNoIGNoZWNrYm94LlxuICogICAgICAgICBmaWVsZHNldCA9IG5ldyBPTy51aS5GaWVsZHNldExheW91dCgge1xuICogICAgICAgICAgICAgbGFiZWw6ICdDaGVja2JveGVzJ1xuICogICAgICAgICB9ICk7XG4gKiAgICAgZmllbGRzZXQuYWRkSXRlbXMoIFtcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBjaGVja2JveDEsIHsgbGFiZWw6ICdTZWxlY3RlZCBjaGVja2JveCcsIGFsaWduOiAnaW5saW5lJyB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggY2hlY2tib3gyLCB7IGxhYmVsOiAnVW5zZWxlY3RlZCBjaGVja2JveCcsIGFsaWduOiAnaW5saW5lJyB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggY2hlY2tib3gzLCB7IGxhYmVsOiAnRGlzYWJsZWQgY2hlY2tib3gnLCBhbGlnbjogJ2lubGluZScgfSApLFxuICogICAgIF0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBmaWVsZHNldC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9JbnB1dHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLklucHV0V2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbc2VsZWN0ZWQ9ZmFsc2VdIFNlbGVjdCB0aGUgY2hlY2tib3ggaW5pdGlhbGx5LiBCeSBkZWZhdWx0LCB0aGUgY2hlY2tib3ggaXMgbm90IHNlbGVjdGVkLlxuICovXG5PTy51aS5DaGVja2JveElucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUNoZWNrYm94SW5wdXRXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkNoZWNrYm94SW5wdXRXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5jaGVja0ljb24gPSBuZXcgT08udWkuSWNvbldpZGdldCgge1xuXHRcdGljb246ICdjaGVjaycsXG5cdFx0Y2xhc3NlczogWyAnb28tdWktY2hlY2tib3hJbnB1dFdpZGdldC1jaGVja0ljb24nIF1cblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1jaGVja2JveElucHV0V2lkZ2V0JyApXG5cdFx0Ly8gUmVxdWlyZWQgZm9yIHByZXR0eSBzdHlsaW5nIGluIFdpa2ltZWRpYVVJIHRoZW1lXG5cdFx0LmFwcGVuZCggdGhpcy5jaGVja0ljb24uJGVsZW1lbnQgKTtcblx0dGhpcy5zZXRTZWxlY3RlZCggY29uZmlnLnNlbGVjdGVkICE9PSB1bmRlZmluZWQgPyBjb25maWcuc2VsZWN0ZWQgOiBmYWxzZSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5DaGVja2JveElucHV0V2lkZ2V0LCBPTy51aS5JbnB1dFdpZGdldCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkNoZWNrYm94SW5wdXRXaWRnZXQuc3RhdGljLnRhZ05hbWUgPSAnc3Bhbic7XG5cbi8qIFN0YXRpYyBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldC5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoIG5vZGUsIGNvbmZpZyApIHtcblx0dmFyIHN0YXRlID0gT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldC5wYXJlbnQuc3RhdGljLmdhdGhlclByZUluZnVzZVN0YXRlKCBub2RlLCBjb25maWcgKTtcblx0c3RhdGUuY2hlY2tlZCA9IGNvbmZpZy4kaW5wdXQucHJvcCggJ2NoZWNrZWQnICk7XG5cdHJldHVybiBzdGF0ZTtcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICogQHByb3RlY3RlZFxuICovXG5PTy51aS5DaGVja2JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRJbnB1dEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAkKCAnPGlucHV0PicgKS5hdHRyKCAndHlwZScsICdjaGVja2JveCcgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldC5wcm90b3R5cGUub25FZGl0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgd2lkZ2V0ID0gdGhpcztcblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0Ly8gQWxsb3cgdGhlIHN0YWNrIHRvIGNsZWFyIHNvIHRoZSB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWRcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR3aWRnZXQuc2V0U2VsZWN0ZWQoIHdpZGdldC4kaW5wdXQucHJvcCggJ2NoZWNrZWQnICkgKTtcblx0XHR9ICk7XG5cdH1cbn07XG5cbi8qKlxuICogU2V0IHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGlzIGNoZWNrYm94LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgYHRydWVgIGZvciBzZWxlY3RlZFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRzdGF0ZSA9ICEhc3RhdGU7XG5cdGlmICggdGhpcy5zZWxlY3RlZCAhPT0gc3RhdGUgKSB7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IHN0YXRlO1xuXHRcdHRoaXMuJGlucHV0LnByb3AoICdjaGVja2VkJywgdGhpcy5zZWxlY3RlZCApO1xuXHRcdHRoaXMuZW1pdCggJ2NoYW5nZScsIHRoaXMuc2VsZWN0ZWQgKTtcblx0fVxuXHQvLyBUaGUgZmlyc3QgdGltZSB0aGF0IHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IChwcm9iYWJseSB3aGlsZSBjb25zdHJ1Y3RpbmcgdGhlIHdpZGdldCksXG5cdC8vIHJlbWVtYmVyIGl0IGluIGRlZmF1bHRTZWxlY3RlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgbGF0ZXIgdXNlZCB0byBjaGVjayB3aGV0aGVyXG5cdC8vIHRoZSBzZWxlY3Rpb24gc3RhdGUgb2YgdGhlIGlucHV0IGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgaXQgd2FzIGNyZWF0ZWQuXG5cdGlmICggdGhpcy5kZWZhdWx0U2VsZWN0ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLmRlZmF1bHRTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG5cdFx0dGhpcy4kaW5wdXRbIDAgXS5kZWZhdWx0Q2hlY2tlZCA9IHRoaXMuZGVmYXVsdFNlbGVjdGVkO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGNoZWNrYm94IGlzIHNlbGVjdGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IENoZWNrYm94IGlzIHNlbGVjdGVkXG4gKi9cbk9PLnVpLkNoZWNrYm94SW5wdXRXaWRnZXQucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFJlc3luY2hyb25pemUgb3VyIGludGVybmFsIGRhdGEgd2l0aCBET00gZGF0YS4gT3RoZXIgc2NyaXB0cyBleGVjdXRpbmcgb24gdGhlIHBhZ2UgY2FuIG1vZGlmeVxuXHQvLyBpdCwgYW5kIHdlIHdvbid0IGtub3cgdW5sZXNzIHRoZXkncmUga2luZCBlbm91Z2ggdG8gdHJpZ2dlciBhICdjaGFuZ2UnIGV2ZW50LlxuXHR2YXIgc2VsZWN0ZWQgPSB0aGlzLiRpbnB1dC5wcm9wKCAnY2hlY2tlZCcgKTtcblx0aWYgKCB0aGlzLnNlbGVjdGVkICE9PSBzZWxlY3RlZCApIHtcblx0XHR0aGlzLnNldFNlbGVjdGVkKCBzZWxlY3RlZCApO1xuXHR9XG5cdHJldHVybiB0aGlzLnNlbGVjdGVkO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5zaW11bGF0ZUxhYmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdHRoaXMuJGlucHV0LmNsaWNrKCk7XG5cdH1cblx0dGhpcy5mb2N1cygpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5yZXN0b3JlUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5DaGVja2JveElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUucmVzdG9yZVByZUluZnVzZVN0YXRlLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cdGlmICggc3RhdGUuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLmNoZWNrZWQgIT09IHRoaXMuaXNTZWxlY3RlZCgpICkge1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoIHN0YXRlLmNoZWNrZWQgKTtcblx0fVxufTtcblxuLyoqXG4gKiBEcm9wZG93bklucHV0V2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLkRyb3Bkb3duV2lkZ2V0IERyb3Bkb3duV2lkZ2V0fSBpbnRlbmRlZCB0byBiZSB1c2VkXG4gKiB3aXRoaW4gYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dC4gVGhlIHNlbGVjdGVkIHZhbHVlIGlzIHN5bmNocm9uaXplZCB3aXRoIHRoZSB2YWx1ZVxuICogb2YgYSBoaWRkZW4gSFRNTCBgaW5wdXRgIHRhZy4gUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdIGZvclxuICogbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCB3aWRnZXRzLlxuICpcbiAqIEEgRHJvcGRvd25JbnB1dFdpZGdldCBhbHdheXMgaGFzIGEgdmFsdWUgKG9uZSBvZiB0aGUgb3B0aW9ucyBpcyBhbHdheXMgc2VsZWN0ZWQpLCB1bmxlc3MgdGhlcmVcbiAqIGFyZSBubyBvcHRpb25zLiBJZiBubyBgdmFsdWVgIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGUgZmlyc3Qgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICogSWYgeW91IG5lZWQgYSBzdGF0ZSByZXByZXNlbnRpbmcgbm8gdmFsdWUgKG5vIG9wdGlvbiBiZWluZyBzZWxlY3RlZCksIHVzZSBhIERyb3Bkb3duV2lkZ2V0LlxuICpcbiAqIFRoaXMgYW5kIE9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQgc3VwcG9ydCBzaW1pbGFyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIERyb3Bkb3duSW5wdXRXaWRnZXQgd2l0aCB0aHJlZSBvcHRpb25zLlxuICogICAgIHZhciBkcm9wZG93bklucHV0ID0gbmV3IE9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgb3B0aW9uczogW1xuICogICAgICAgICAgICAgeyBkYXRhOiAnYScsIGxhYmVsOiAnRmlyc3QnIH0sXG4gKiAgICAgICAgICAgICB7IGRhdGE6ICdiJywgbGFiZWw6ICdTZWNvbmQnLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICogICAgICAgICAgICAgeyBvcHRncm91cDogJ0dyb3VwIGxhYmVsJyB9LFxuICogICAgICAgICAgICAgeyBkYXRhOiAnYycsIGxhYmVsOiAnRmlyc3Qgc3ViLWl0ZW0pJyB9XG4gKiAgICAgICAgIF1cbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggZHJvcGRvd25JbnB1dC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9JbnB1dHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLklucHV0V2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPYmplY3RbXX0gW29wdGlvbnM9W11dIEFycmF5IG9mIG1lbnUgb3B0aW9ucyBpbiB0aGUgZm9ybWF0IGRlc2NyaWJlZCBhYm92ZS5cbiAqIEBjZmcge09iamVjdH0gW2Ryb3Bkb3duXSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHtAbGluayBPTy51aS5Ecm9wZG93bldpZGdldCBEcm9wZG93bldpZGdldH1cbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBSZW5kZXIgdGhlIG1lbnUgaW50byBhIHNlcGFyYXRlIGxheWVyLiBUaGlzIGNvbmZpZ3VyYXRpb24gaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gKiAgdGhlIGV4cGFuZGVkIG1lbnUgaXMgbGFyZ2VyIHRoYW4gaXRzIGNvbnRhaW5pbmcgYDxkaXY+YC4gVGhlIHNwZWNpZmllZCBvdmVybGF5IGxheWVyIGlzIHVzdWFsbHkgb24gdG9wIG9mIHRoZVxuICogIGNvbnRhaW5pbmcgYDxkaXY+YCBhbmQgaGFzIGEgbGFyZ2VyIGFyZWEuIEJ5IGRlZmF1bHQsIHRoZSBtZW51IHVzZXMgcmVsYXRpdmUgcG9zaXRpb25pbmcuXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKi9cbk9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQgPSBmdW5jdGlvbiBPb1VpRHJvcGRvd25JbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzIChtdXN0IGJlIGRvbmUgYmVmb3JlIHBhcmVudCBjb25zdHJ1Y3RvciB3aGljaCBjYWxscyAjc2V0RGlzYWJsZWQpXG5cdHRoaXMuZHJvcGRvd25XaWRnZXQgPSBuZXcgT08udWkuRHJvcGRvd25XaWRnZXQoICQuZXh0ZW5kKFxuXHRcdHtcblx0XHRcdCRvdmVybGF5OiBjb25maWcuJG92ZXJsYXlcblx0XHR9LFxuXHRcdGNvbmZpZy5kcm9wZG93blxuXHQpICk7XG5cdC8vIFNldCB1cCB0aGUgb3B0aW9ucyBiZWZvcmUgcGFyZW50IGNvbnN0cnVjdG9yLCB3aGljaCB1c2VzIHRoZW0gdG8gdmFsaWRhdGUgY29uZmlnLnZhbHVlLlxuXHQvLyBVc2UgdGhpcyBpbnN0ZWFkIG9mIHNldE9wdGlvbnMoKSBiZWNhdXNlIHRoaXMuJGlucHV0IGlzIG5vdCBzZXQgdXAgeWV0LlxuXHR0aGlzLnNldE9wdGlvbnNEYXRhKCBjb25maWcub3B0aW9ucyB8fCBbXSApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5kcm9wZG93bldpZGdldC5nZXRNZW51KCkuY29ubmVjdCggdGhpcywgeyBzZWxlY3Q6ICdvbk1lbnVTZWxlY3QnIH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktZHJvcGRvd25JbnB1dFdpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuZHJvcGRvd25XaWRnZXQuJGVsZW1lbnQgKTtcblx0dGhpcy5zZXRUYWJJbmRleGVkRWxlbWVudCggdGhpcy5kcm9wZG93bldpZGdldC4kdGFiSW5kZXhlZCApO1xuXHR0aGlzLnNldFRpdGxlZEVsZW1lbnQoIHRoaXMuZHJvcGRvd25XaWRnZXQuJGhhbmRsZSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LCBPTy51aS5JbnB1dFdpZGdldCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuRHJvcGRvd25JbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJCggJzxzZWxlY3Q+JyApO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIG1lbnUgc2VsZWN0IGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5NZW51T3B0aW9uV2lkZ2V0fG51bGx9IGl0ZW0gU2VsZWN0ZWQgbWVudSBpdGVtXG4gKi9cbk9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQucHJvdG90eXBlLm9uTWVudVNlbGVjdCA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0dGhpcy5zZXRWYWx1ZSggaXRlbSA/IGl0ZW0uZ2V0RGF0YSgpIDogJycgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRHJvcGRvd25JbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR2YXIgc2VsZWN0ZWQ7XG5cdHZhbHVlID0gdGhpcy5jbGVhblVwVmFsdWUoIHZhbHVlICk7XG5cdC8vIE9ubHkgYWxsb3cgc2V0dGluZyB2YWx1ZXMgdGhhdCBhcmUgYWN0dWFsbHkgcHJlc2VudCBpbiB0aGUgZHJvcGRvd25cblx0c2VsZWN0ZWQgPSB0aGlzLmRyb3Bkb3duV2lkZ2V0LmdldE1lbnUoKS5maW5kSXRlbUZyb21EYXRhKCB2YWx1ZSApIHx8XG5cdFx0dGhpcy5kcm9wZG93bldpZGdldC5nZXRNZW51KCkuZmluZEZpcnN0U2VsZWN0YWJsZUl0ZW0oKTtcblx0dGhpcy5kcm9wZG93bldpZGdldC5nZXRNZW51KCkuc2VsZWN0SXRlbSggc2VsZWN0ZWQgKTtcblx0dmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLmdldERhdGEoKSA6ICcnO1xuXHRPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCggdGhpcywgdmFsdWUgKTtcblx0aWYgKCB0aGlzLm9wdGlvbnNEaXJ0eSApIHtcblx0XHQvLyBXZSByZWFjaGVkIHRoaXMgZnJvbSB0aGUgY29uc3RydWN0b3Igb3IgZnJvbSAjc2V0T3B0aW9ucy5cblx0XHQvLyBXZSBoYXZlIHRvIHVwZGF0ZSB0aGUgPHNlbGVjdD4gZWxlbWVudC5cblx0XHR0aGlzLnVwZGF0ZU9wdGlvbnNJbnRlcmZhY2UoKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRHJvcGRvd25JbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHR0aGlzLmRyb3Bkb3duV2lkZ2V0LnNldERpc2FibGVkKCBzdGF0ZSApO1xuXHRPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0RGlzYWJsZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoaXMgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucyBBcnJheSBvZiBtZW51IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgeyBkYXRhOiDigKYsIGxhYmVsOiDigKYgfWBcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHR0aGlzLnNldE9wdGlvbnNEYXRhKCBvcHRpb25zICk7XG5cblx0Ly8gUmUtc2V0IHRoZSB2YWx1ZSB0byB1cGRhdGUgdGhlIHZpc2libGUgaW50ZXJmYWNlIChEcm9wZG93bldpZGdldCBhbmQgPHNlbGVjdD4pLlxuXHQvLyBJbiBjYXNlIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBubyBsb25nZXIgYW4gYXZhaWxhYmxlIG9wdGlvbiwgc2VsZWN0IHRoZSBmaXJzdCB2YWxpZCBvbmUuXG5cdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW50ZXJuYWwgbGlzdCBvZiBvcHRpb25zLCB1c2VkIGUuZy4gYnkgc2V0VmFsdWUoKSB0byBzZWUgd2hpY2ggb3B0aW9ucyBhcmUgYWxsb3dlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLCBzbyB2YXJpb3VzIHByb3BlcnRpZXMgbWF5IG5vdCBiZVxuICogaW5pdGlhbGl6ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMgQXJyYXkgb2YgbWVudSBvcHRpb25zIChzZWUgI2NvbnN0cnVjdG9yIGZvciBkZXRhaWxzKS5cbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQucHJvdG90eXBlLnNldE9wdGlvbnNEYXRhID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHR2YXIgb3B0aW9uV2lkZ2V0cywgb3B0SW5kZXgsIG9wdCwgcHJldmlvdXNPcHRncm91cCwgb3B0aW9uV2lkZ2V0LCBvcHRWYWx1ZSxcblx0XHR3aWRnZXQgPSB0aGlzO1xuXG5cdHRoaXMub3B0aW9uc0RpcnR5ID0gdHJ1ZTtcblxuXHQvLyBHbyB0aHJvdWdoIGFsbCB0aGUgc3VwcGxpZWQgb3B0aW9uIGNvbmZpZ3MgYW5kIGNyZWF0ZSBlaXRoZXJcblx0Ly8gTWVudVNlY3Rpb25PcHRpb24gb3IgTWVudU9wdGlvbiB3aWRnZXRzIGZyb20gZWFjaC5cblx0b3B0aW9uV2lkZ2V0cyA9IFtdO1xuXHRmb3IgKCBvcHRJbmRleCA9IDA7IG9wdEluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IG9wdEluZGV4KysgKSB7XG5cdFx0b3B0ID0gb3B0aW9uc1sgb3B0SW5kZXggXTtcblxuXHRcdGlmICggb3B0Lm9wdGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBDcmVhdGUgYSA8b3B0Z3JvdXA+IG1lbnUgaXRlbS5cblx0XHRcdG9wdGlvbldpZGdldCA9IHdpZGdldC5jcmVhdGVNZW51U2VjdGlvbk9wdGlvbldpZGdldCggb3B0Lm9wdGdyb3VwICk7XG5cdFx0XHRwcmV2aW91c09wdGdyb3VwID0gb3B0aW9uV2lkZ2V0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENyZWF0ZSBhIG5vcm1hbCA8b3B0aW9uPiBtZW51IGl0ZW0uXG5cdFx0XHRvcHRWYWx1ZSA9IHdpZGdldC5jbGVhblVwVmFsdWUoIG9wdC5kYXRhICk7XG5cdFx0XHRvcHRpb25XaWRnZXQgPSB3aWRnZXQuY3JlYXRlTWVudU9wdGlvbldpZGdldChcblx0XHRcdFx0b3B0VmFsdWUsXG5cdFx0XHRcdG9wdC5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0LmxhYmVsIDogb3B0VmFsdWVcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGlzYWJsZSB0aGUgbWVudSBvcHRpb24gaWYgaXQgaXMgaXRzZWxmIGRpc2FibGVkIG9yIGlmIGl0cyBwYXJlbnQgb3B0Z3JvdXAgaXMgZGlzYWJsZWQuXG5cdFx0aWYgKCBvcHQuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0cHJldmlvdXNPcHRncm91cCBpbnN0YW5jZW9mIE9PLnVpLk1lbnVTZWN0aW9uT3B0aW9uV2lkZ2V0ICYmIHByZXZpb3VzT3B0Z3JvdXAuaXNEaXNhYmxlZCgpICkge1xuXHRcdFx0b3B0aW9uV2lkZ2V0LnNldERpc2FibGVkKCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0b3B0aW9uV2lkZ2V0cy5wdXNoKCBvcHRpb25XaWRnZXQgKTtcblx0fVxuXG5cdHRoaXMuZHJvcGRvd25XaWRnZXQuZ2V0TWVudSgpLmNsZWFySXRlbXMoKS5hZGRJdGVtcyggb3B0aW9uV2lkZ2V0cyApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtZW51IG9wdGlvbiB3aWRnZXQuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgSXRlbSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgSXRlbSBsYWJlbFxuICogQHJldHVybiB7T08udWkuTWVudU9wdGlvbldpZGdldH0gT3B0aW9uIHdpZGdldFxuICovXG5PTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVNZW51T3B0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gKCBkYXRhLCBsYWJlbCApIHtcblx0cmV0dXJuIG5ldyBPTy51aS5NZW51T3B0aW9uV2lkZ2V0KCB7XG5cdFx0ZGF0YTogZGF0YSxcblx0XHRsYWJlbDogbGFiZWxcblx0fSApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtZW51IHNlY3Rpb24gb3B0aW9uIHdpZGdldC5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgU2VjdGlvbiBpdGVtIGxhYmVsXG4gKiBAcmV0dXJuIHtPTy51aS5NZW51U2VjdGlvbk9wdGlvbldpZGdldH0gTWVudSBzZWN0aW9uIG9wdGlvbiB3aWRnZXRcbiAqL1xuT08udWkuRHJvcGRvd25JbnB1dFdpZGdldC5wcm90b3R5cGUuY3JlYXRlTWVudVNlY3Rpb25PcHRpb25XaWRnZXQgPSBmdW5jdGlvbiAoIGxhYmVsICkge1xuXHRyZXR1cm4gbmV3IE9PLnVpLk1lbnVTZWN0aW9uT3B0aW9uV2lkZ2V0KCB7XG5cdFx0bGFiZWw6IGxhYmVsXG5cdH0gKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSB1c2VyLXZpc2libGUgaW50ZXJmYWNlIHRvIG1hdGNoIHRoZSBpbnRlcm5hbCBsaXN0IG9mIG9wdGlvbnMgYW5kIHZhbHVlLlxuICpcbiAqIFRoaXMgbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHBhcmVudCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnByb3RvdHlwZS51cGRhdGVPcHRpb25zSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuXHR2YXJcblx0XHQkb3B0aW9uc0NvbnRhaW5lciA9IHRoaXMuJGlucHV0LFxuXHRcdGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlLFxuXHRcdHdpZGdldCA9IHRoaXM7XG5cblx0dGhpcy4kaW5wdXQuZW1wdHkoKTtcblxuXHR0aGlzLmRyb3Bkb3duV2lkZ2V0LmdldE1lbnUoKS5nZXRJdGVtcygpLmZvckVhY2goIGZ1bmN0aW9uICggb3B0aW9uV2lkZ2V0ICkge1xuXHRcdHZhciAkb3B0aW9uTm9kZTtcblxuXHRcdGlmICggISggb3B0aW9uV2lkZ2V0IGluc3RhbmNlb2YgT08udWkuTWVudVNlY3Rpb25PcHRpb25XaWRnZXQgKSApIHtcblx0XHRcdCRvcHRpb25Ob2RlID0gJCggJzxvcHRpb24+JyApXG5cdFx0XHRcdC5hdHRyKCAndmFsdWUnLCBvcHRpb25XaWRnZXQuZ2V0RGF0YSgpIClcblx0XHRcdFx0LnRleHQoIG9wdGlvbldpZGdldC5nZXRMYWJlbCgpICk7XG5cblx0XHRcdC8vIFJlbWVtYmVyIG9yaWdpbmFsIHNlbGVjdGlvbiBzdGF0ZS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgbGF0ZXIgdXNlZCB0byBjaGVjayB3aGV0aGVyXG5cdFx0XHQvLyB0aGUgc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBoYXMgYmVlbiBjaGFuZ2VkIHNpbmNlIGl0IHdhcyBjcmVhdGVkLlxuXHRcdFx0JG9wdGlvbk5vZGVbIDAgXS5kZWZhdWx0U2VsZWN0ZWQgPSAoIG9wdGlvbldpZGdldC5nZXREYXRhKCkgPT09IGRlZmF1bHRWYWx1ZSApO1xuXG5cdFx0XHQkb3B0aW9uc0NvbnRhaW5lci5hcHBlbmQoICRvcHRpb25Ob2RlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRvcHRpb25Ob2RlID0gJCggJzxvcHRncm91cD4nIClcblx0XHRcdFx0LmF0dHIoICdsYWJlbCcsIG9wdGlvbldpZGdldC5nZXRMYWJlbCgpICk7XG5cdFx0XHR3aWRnZXQuJGlucHV0LmFwcGVuZCggJG9wdGlvbk5vZGUgKTtcblx0XHRcdCRvcHRpb25zQ29udGFpbmVyID0gJG9wdGlvbk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gRGlzYWJsZSB0aGUgb3B0aW9uIG9yIG9wdGdyb3VwIGlmIHJlcXVpcmVkLlxuXHRcdGlmICggb3B0aW9uV2lkZ2V0LmlzRGlzYWJsZWQoKSApIHtcblx0XHRcdCRvcHRpb25Ob2RlLnByb3AoICdkaXNhYmxlZCcsIHRydWUgKTtcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLm9wdGlvbnNEaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5kcm9wZG93bldpZGdldC5mb2N1cygpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRHJvcGRvd25JbnB1dFdpZGdldC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5kcm9wZG93bldpZGdldC5ibHVyKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSYWRpb0lucHV0V2lkZ2V0IGNyZWF0ZXMgYSBzaW5nbGUgcmFkaW8gYnV0dG9uLiBCZWNhdXNlIHJhZGlvIGJ1dHRvbnMgYXJlIHVzdWFsbHkgdXNlZCBhcyBhIHNldCxcbiAqIGluIG1vc3QgY2FzZXMgeW91IHdpbGwgd2FudCB0byB1c2UgYSB7QGxpbmsgT08udWkuUmFkaW9TZWxlY3RXaWRnZXQgcmFkaW8gc2VsZWN0fVxuICogd2l0aCB7QGxpbmsgT08udWkuUmFkaW9PcHRpb25XaWRnZXQgcmFkaW8gb3B0aW9uc30gaW5zdGVhZCBvZiB0aGlzIGNsYXNzLiBGb3IgbW9yZSBpbmZvcm1hdGlvbixcbiAqIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiBUaGlzIHdpZGdldCBjYW4gYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBbiBleGFtcGxlIG9mIHNlbGVjdGVkLCB1bnNlbGVjdGVkLCBhbmQgZGlzYWJsZWQgcmFkaW8gaW5wdXRzXG4gKiAgICAgdmFyIHJhZGlvMSA9IG5ldyBPTy51aS5SYWRpb0lucHV0V2lkZ2V0KCB7XG4gKiAgICAgICAgIHZhbHVlOiAnYScsXG4gKiAgICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gKiAgICAgfSApO1xuICogICAgIHZhciByYWRpbzIgPSBuZXcgT08udWkuUmFkaW9JbnB1dFdpZGdldCgge1xuICogICAgICAgICB2YWx1ZTogJ2InXG4gKiAgICAgfSApO1xuICogICAgIHZhciByYWRpbzMgPSBuZXcgT08udWkuUmFkaW9JbnB1dFdpZGdldCgge1xuICogICAgICAgICB2YWx1ZTogJ2MnLFxuICogICAgICAgICBkaXNhYmxlZDogdHJ1ZVxuICogICAgIH0gKTtcbiAqICAgICAvLyBDcmVhdGUgYSBmaWVsZHNldCBsYXlvdXQgd2l0aCBmaWVsZHMgZm9yIGVhY2ggcmFkaW8gYnV0dG9uLlxuICogICAgIHZhciBmaWVsZHNldCA9IG5ldyBPTy51aS5GaWVsZHNldExheW91dCgge1xuICogICAgICAgICBsYWJlbDogJ1JhZGlvIGlucHV0cydcbiAqICAgICB9ICk7XG4gKiAgICAgZmllbGRzZXQuYWRkSXRlbXMoIFtcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCByYWRpbzEsIHsgbGFiZWw6ICdTZWxlY3RlZCcsIGFsaWduOiAnaW5saW5lJyB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggcmFkaW8yLCB7IGxhYmVsOiAnVW5zZWxlY3RlZCcsIGFsaWduOiAnaW5saW5lJyB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggcmFkaW8zLCB7IGxhYmVsOiAnRGlzYWJsZWQnLCBhbGlnbjogJ2lubGluZScgfSApLFxuICogICAgIF0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBmaWVsZHNldC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9JbnB1dHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLklucHV0V2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbc2VsZWN0ZWQ9ZmFsc2VdIFNlbGVjdCB0aGUgcmFkaW8gYnV0dG9uIGluaXRpYWxseS4gQnkgZGVmYXVsdCwgdGhlIHJhZGlvIGJ1dHRvbiBpcyBub3Qgc2VsZWN0ZWQuXG4gKi9cbk9PLnVpLlJhZGlvSW5wdXRXaWRnZXQgPSBmdW5jdGlvbiBPb1VpUmFkaW9JbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuUmFkaW9JbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXJhZGlvSW5wdXRXaWRnZXQnIClcblx0XHQvLyBSZXF1aXJlZCBmb3IgcHJldHR5IHN0eWxpbmcgaW4gV2lraW1lZGlhVUkgdGhlbWVcblx0XHQuYXBwZW5kKCAkKCAnPHNwYW4+JyApICk7XG5cdHRoaXMuc2V0U2VsZWN0ZWQoIGNvbmZpZy5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnNlbGVjdGVkIDogZmFsc2UgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUmFkaW9JbnB1dFdpZGdldCwgT08udWkuSW5wdXRXaWRnZXQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb0lucHV0V2lkZ2V0LnN0YXRpYy50YWdOYW1lID0gJ3NwYW4nO1xuXG4vKiBTdGF0aWMgTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvSW5wdXRXaWRnZXQuc3RhdGljLmdhdGhlclByZUluZnVzZVN0YXRlID0gZnVuY3Rpb24gKCBub2RlLCBjb25maWcgKSB7XG5cdHZhciBzdGF0ZSA9IE9PLnVpLlJhZGlvSW5wdXRXaWRnZXQucGFyZW50LnN0YXRpYy5nYXRoZXJQcmVJbmZ1c2VTdGF0ZSggbm9kZSwgY29uZmlnICk7XG5cdHN0YXRlLmNoZWNrZWQgPSBjb25maWcuJGlucHV0LnByb3AoICdjaGVja2VkJyApO1xuXHRyZXR1cm4gc3RhdGU7XG59O1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuUmFkaW9JbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJCggJzxpbnB1dD4nICkuYXR0ciggJ3R5cGUnLCAncmFkaW8nICk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvSW5wdXRXaWRnZXQucHJvdG90eXBlLm9uRWRpdCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gUmFkaW9JbnB1dFdpZGdldCBkb2Vzbid0IHRyYWNrIGl0cyBzdGF0ZS5cbn07XG5cbi8qKlxuICogU2V0IHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGlzIHJhZGlvIGJ1dHRvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIGB0cnVlYCBmb3Igc2VsZWN0ZWRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlJhZGlvSW5wdXRXaWRnZXQucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKCBzdGF0ZSApIHtcblx0Ly8gUmFkaW9JbnB1dFdpZGdldCBkb2Vzbid0IHRyYWNrIGl0cyBzdGF0ZS5cblx0dGhpcy4kaW5wdXQucHJvcCggJ2NoZWNrZWQnLCBzdGF0ZSApO1xuXHQvLyBUaGUgZmlyc3QgdGltZSB0aGF0IHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IChwcm9iYWJseSB3aGlsZSBjb25zdHJ1Y3RpbmcgdGhlIHdpZGdldCksXG5cdC8vIHJlbWVtYmVyIGl0IGluIGRlZmF1bHRTZWxlY3RlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgbGF0ZXIgdXNlZCB0byBjaGVjayB3aGV0aGVyXG5cdC8vIHRoZSBzZWxlY3Rpb24gc3RhdGUgb2YgdGhlIGlucHV0IGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgaXQgd2FzIGNyZWF0ZWQuXG5cdGlmICggdGhpcy5kZWZhdWx0U2VsZWN0ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLmRlZmF1bHRTZWxlY3RlZCA9IHN0YXRlO1xuXHRcdHRoaXMuJGlucHV0WyAwIF0uZGVmYXVsdENoZWNrZWQgPSB0aGlzLmRlZmF1bHRTZWxlY3RlZDtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyByYWRpbyBidXR0b24gaXMgc2VsZWN0ZWQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmFkaW8gaXMgc2VsZWN0ZWRcbiAqL1xuT08udWkuUmFkaW9JbnB1dFdpZGdldC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuJGlucHV0LnByb3AoICdjaGVja2VkJyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb0lucHV0V2lkZ2V0LnByb3RvdHlwZS5zaW11bGF0ZUxhYmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdHRoaXMuJGlucHV0LmNsaWNrKCk7XG5cdH1cblx0dGhpcy5mb2N1cygpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb0lucHV0V2lkZ2V0LnByb3RvdHlwZS5yZXN0b3JlUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5SYWRpb0lucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUucmVzdG9yZVByZUluZnVzZVN0YXRlLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cdGlmICggc3RhdGUuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLmNoZWNrZWQgIT09IHRoaXMuaXNTZWxlY3RlZCgpICkge1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoIHN0YXRlLmNoZWNrZWQgKTtcblx0fVxufTtcblxuLyoqXG4gKiBSYWRpb1NlbGVjdElucHV0V2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLlJhZGlvU2VsZWN0V2lkZ2V0IFJhZGlvU2VsZWN0V2lkZ2V0fSBpbnRlbmRlZCB0byBiZSB1c2VkXG4gKiB3aXRoaW4gYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dC4gVGhlIHNlbGVjdGVkIHZhbHVlIGlzIHN5bmNocm9uaXplZCB3aXRoIHRoZSB2YWx1ZVxuICogb2YgYSBoaWRkZW4gSFRNTCBgaW5wdXRgIHRhZy4gUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdIGZvclxuICogbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCB3aWRnZXRzLlxuICpcbiAqIFRoaXMgYW5kIE9PLnVpLkRyb3Bkb3duSW5wdXRXaWRnZXQgc3VwcG9ydCBzaW1pbGFyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIFJhZGlvU2VsZWN0SW5wdXRXaWRnZXQgd2l0aCB0aHJlZSBvcHRpb25zXG4gKiAgICAgdmFyIHJhZGlvU2VsZWN0SW5wdXQgPSBuZXcgT08udWkuUmFkaW9TZWxlY3RJbnB1dFdpZGdldCgge1xuICogICAgICAgICBvcHRpb25zOiBbXG4gKiAgICAgICAgICAgICB7IGRhdGE6ICdhJywgbGFiZWw6ICdGaXJzdCcgfSxcbiAqICAgICAgICAgICAgIHsgZGF0YTogJ2InLCBsYWJlbDogJ1NlY29uZCd9LFxuICogICAgICAgICAgICAgeyBkYXRhOiAnYycsIGxhYmVsOiAnVGhpcmQnIH1cbiAqICAgICAgICAgXVxuICogICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCByYWRpb1NlbGVjdElucHV0LiRlbGVtZW50ICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0lucHV0c1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuSW5wdXRXaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge09iamVjdFtdfSBbb3B0aW9ucz1bXV0gQXJyYXkgb2YgbWVudSBvcHRpb25zIGluIHRoZSBmb3JtYXQgYHsgZGF0YTog4oCmLCBsYWJlbDog4oCmIH1gXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQgPSBmdW5jdGlvbiBPb1VpUmFkaW9TZWxlY3RJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzIChtdXN0IGJlIGRvbmUgYmVmb3JlIHBhcmVudCBjb25zdHJ1Y3RvciB3aGljaCBjYWxscyAjc2V0RGlzYWJsZWQpXG5cdHRoaXMucmFkaW9TZWxlY3RXaWRnZXQgPSBuZXcgT08udWkuUmFkaW9TZWxlY3RXaWRnZXQoKTtcblx0Ly8gU2V0IHVwIHRoZSBvcHRpb25zIGJlZm9yZSBwYXJlbnQgY29uc3RydWN0b3IsIHdoaWNoIHVzZXMgdGhlbSB0byB2YWxpZGF0ZSBjb25maWcudmFsdWUuXG5cdC8vIFVzZSB0aGlzIGluc3RlYWQgb2Ygc2V0T3B0aW9ucygpIGJlY2F1c2UgdGhpcy4kaW5wdXQgaXMgbm90IHNldCB1cCB5ZXRcblx0dGhpcy5zZXRPcHRpb25zRGF0YSggY29uZmlnLm9wdGlvbnMgfHwgW10gKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuUmFkaW9TZWxlY3RJbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMucmFkaW9TZWxlY3RXaWRnZXQuY29ubmVjdCggdGhpcywgeyBzZWxlY3Q6ICdvbk1lbnVTZWxlY3QnIH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktcmFkaW9TZWxlY3RJbnB1dFdpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMucmFkaW9TZWxlY3RXaWRnZXQuJGVsZW1lbnQgKTtcblx0dGhpcy5zZXRUYWJJbmRleGVkRWxlbWVudCggdGhpcy5yYWRpb1NlbGVjdFdpZGdldC4kdGFiSW5kZXhlZCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LCBPTy51aS5JbnB1dFdpZGdldCApO1xuXG4vKiBTdGF0aWMgTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQuc3RhdGljLmdhdGhlclByZUluZnVzZVN0YXRlID0gZnVuY3Rpb24gKCBub2RlLCBjb25maWcgKSB7XG5cdHZhciBzdGF0ZSA9IE9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQucGFyZW50LnN0YXRpYy5nYXRoZXJQcmVJbmZ1c2VTdGF0ZSggbm9kZSwgY29uZmlnICk7XG5cdHN0YXRlLnZhbHVlID0gJCggbm9kZSApLmZpbmQoICcub28tdWktcmFkaW9JbnB1dFdpZGdldCAub28tdWktaW5wdXRXaWRnZXQtaW5wdXQ6Y2hlY2tlZCcgKS52YWwoKTtcblx0cmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnN0YXRpYy5yZXVzZVByZUluZnVzZURPTSA9IGZ1bmN0aW9uICggbm9kZSwgY29uZmlnICkge1xuXHRjb25maWcgPSBPTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5zdGF0aWMucmV1c2VQcmVJbmZ1c2VET00oIG5vZGUsIGNvbmZpZyApO1xuXHQvLyBDYW5ub3QgcmV1c2UgdGhlIGA8aW5wdXQgdHlwZT1yYWRpbz5gIHNldFxuXHRkZWxldGUgY29uZmlnLiRpbnB1dDtcblx0cmV0dXJuIGNvbmZpZztcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICogQHByb3RlY3RlZFxuICovXG5PTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRJbnB1dEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFVzZSB0aGlzIGluc3RlYWQgb2YgPGlucHV0IHR5cGU9XCJoaWRkZW5cIj4sIGJlY2F1c2UgaGlkZGVuIGlucHV0cyBkbyBub3QgaGF2ZSBzZXBhcmF0ZVxuXHQvLyAndmFsdWUnIGFuZCAnZGVmYXVsdFZhbHVlJyBwcm9wZXJ0aWVzLCBhbmQgSW5wdXRXaWRnZXQgd2FudHMgdG8gaGFuZGxlICdkZWZhdWx0VmFsdWUnLlxuXHRyZXR1cm4gJCggJzxpbnB1dD4nICkuYWRkQ2xhc3MoICdvby11aS1lbGVtZW50LWhpZGRlbicgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBtZW51IHNlbGVjdCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T08udWkuUmFkaW9PcHRpb25XaWRnZXR9IGl0ZW0gU2VsZWN0ZWQgbWVudSBpdGVtXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uTWVudVNlbGVjdCA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0dGhpcy5zZXRWYWx1ZSggaXRlbS5nZXREYXRhKCkgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUmFkaW9TZWxlY3RJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR2YXIgc2VsZWN0ZWQ7XG5cdHZhbHVlID0gdGhpcy5jbGVhblVwVmFsdWUoIHZhbHVlICk7XG5cdC8vIE9ubHkgYWxsb3cgc2V0dGluZyB2YWx1ZXMgdGhhdCBhcmUgYWN0dWFsbHkgcHJlc2VudCBpbiB0aGUgZHJvcGRvd25cblx0c2VsZWN0ZWQgPSB0aGlzLnJhZGlvU2VsZWN0V2lkZ2V0LmZpbmRJdGVtRnJvbURhdGEoIHZhbHVlICkgfHxcblx0XHR0aGlzLnJhZGlvU2VsZWN0V2lkZ2V0LmZpbmRGaXJzdFNlbGVjdGFibGVJdGVtKCk7XG5cdHRoaXMucmFkaW9TZWxlY3RXaWRnZXQuc2VsZWN0SXRlbSggc2VsZWN0ZWQgKTtcblx0dmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLmdldERhdGEoKSA6ICcnO1xuXHRPTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCggdGhpcywgdmFsdWUgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24gKCBzdGF0ZSApIHtcblx0dGhpcy5yYWRpb1NlbGVjdFdpZGdldC5zZXREaXNhYmxlZCggc3RhdGUgKTtcblx0T08udWkuUmFkaW9TZWxlY3RJbnB1dFdpZGdldC5wYXJlbnQucHJvdG90eXBlLnNldERpc2FibGVkLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGlzIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMgQXJyYXkgb2YgbWVudSBvcHRpb25zIGluIHRoZSBmb3JtYXQgYHsgZGF0YTog4oCmLCBsYWJlbDog4oCmIH1gXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cblx0dGhpcy5zZXRPcHRpb25zRGF0YSggb3B0aW9ucyApO1xuXG5cdC8vIFJlLXNldCB0aGUgdmFsdWUgdG8gdXBkYXRlIHRoZSB2aXNpYmxlIGludGVyZmFjZSAoUmFkaW9TZWxlY3RXaWRnZXQpLlxuXHQvLyBJbiBjYXNlIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBubyBsb25nZXIgYW4gYXZhaWxhYmxlIG9wdGlvbiwgc2VsZWN0IHRoZSBmaXJzdCB2YWxpZCBvbmUuXG5cdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW50ZXJuYWwgbGlzdCBvZiBvcHRpb25zLCB1c2VkIGUuZy4gYnkgc2V0VmFsdWUoKSB0byBzZWUgd2hpY2ggb3B0aW9ucyBhcmUgYWxsb3dlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLCBzbyB2YXJpb3VzIHByb3BlcnRpZXMgbWF5IG5vdCBiZVxuICogaW50aWFsaXplZCB5ZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucyBBcnJheSBvZiBtZW51IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgeyBkYXRhOiDigKYsIGxhYmVsOiDigKYgfWBcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldE9wdGlvbnNEYXRhID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHR2YXIgd2lkZ2V0ID0gdGhpcztcblxuXHR0aGlzLnJhZGlvU2VsZWN0V2lkZ2V0XG5cdFx0LmNsZWFySXRlbXMoKVxuXHRcdC5hZGRJdGVtcyggb3B0aW9ucy5tYXAoIGZ1bmN0aW9uICggb3B0ICkge1xuXHRcdFx0dmFyIG9wdFZhbHVlID0gd2lkZ2V0LmNsZWFuVXBWYWx1ZSggb3B0LmRhdGEgKTtcblx0XHRcdHJldHVybiBuZXcgT08udWkuUmFkaW9PcHRpb25XaWRnZXQoIHtcblx0XHRcdFx0ZGF0YTogb3B0VmFsdWUsXG5cdFx0XHRcdGxhYmVsOiBvcHQubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdC5sYWJlbCA6IG9wdFZhbHVlXG5cdFx0XHR9ICk7XG5cdFx0fSApICk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlJhZGlvU2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJhZGlvU2VsZWN0V2lkZ2V0LmZvY3VzKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5SYWRpb1NlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJhZGlvU2VsZWN0V2lkZ2V0LmJsdXIoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldCBpcyBhXG4gKiB7QGxpbmsgT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldCBDaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0fSBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiBhXG4gKiBIVE1MIGZvcm0sIHN1Y2ggYXMgYSBPTy51aS5Gb3JtTGF5b3V0LiBUaGUgc2VsZWN0ZWQgdmFsdWVzIGFyZSBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgdmFsdWUgb2ZcbiAqIEhUTUwgYDxpbnB1dCB0eXBlPWNoZWNrYm94PmAgdGFncy4gUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdIGZvclxuICogbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCB3aWRnZXRzLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEEgQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0IHdpdGggdGhyZWUgb3B0aW9ucy5cbiAqICAgICB2YXIgbXVsdGlzZWxlY3RJbnB1dCA9IG5ldyBPTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgb3B0aW9uczogW1xuICogICAgICAgICAgICAgeyBkYXRhOiAnYScsIGxhYmVsOiAnRmlyc3QnIH0sXG4gKiAgICAgICAgICAgICB7IGRhdGE6ICdiJywgbGFiZWw6ICdTZWNvbmQnIH0sXG4gKiAgICAgICAgICAgICB7IGRhdGE6ICdjJywgbGFiZWw6ICdUaGlyZCcgfVxuICogICAgICAgICBdXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIG11bHRpc2VsZWN0SW5wdXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSW5wdXRzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5JbnB1dFdpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7T2JqZWN0W119IFtvcHRpb25zPVtdXSBBcnJheSBvZiBtZW51IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgeyBkYXRhOiDigKYsIGxhYmVsOiDigKYsIGRpc2FibGVkOiDigKYgfWBcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUNoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzIChtdXN0IGJlIGRvbmUgYmVmb3JlIHBhcmVudCBjb25zdHJ1Y3RvciB3aGljaCBjYWxscyAjc2V0RGlzYWJsZWQpXG5cdHRoaXMuY2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldCA9IG5ldyBPTy51aS5DaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0KCk7XG5cdC8vIE11c3QgYmUgc2V0IGJlZm9yZSB0aGUgI3NldE9wdGlvbnNEYXRhIGNhbGwgYmVsb3dcblx0dGhpcy5pbnB1dE5hbWUgPSBjb25maWcubmFtZTtcblx0Ly8gU2V0IHVwIHRoZSBvcHRpb25zIGJlZm9yZSBwYXJlbnQgY29uc3RydWN0b3IsIHdoaWNoIHVzZXMgdGhlbSB0byB2YWxpZGF0ZSBjb25maWcudmFsdWUuXG5cdC8vIFVzZSB0aGlzIGluc3RlYWQgb2Ygc2V0T3B0aW9ucygpIGJlY2F1c2UgdGhpcy4kaW5wdXQgaXMgbm90IHNldCB1cCB5ZXRcblx0dGhpcy5zZXRPcHRpb25zRGF0YSggY29uZmlnLm9wdGlvbnMgfHwgW10gKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5jaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LmNvbm5lY3QoIHRoaXMsIHsgc2VsZWN0OiAnb25DaGVja2JveGVzU2VsZWN0JyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWNoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuY2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldC4kZWxlbWVudCApO1xuXHQvLyBXZSBkb24ndCB1c2UgdGhpcy4kaW5wdXQsIGJ1dCByYXRoZXIgdGhlIENoZWNrYm94SW5wdXRXaWRnZXRzIGluc2lkZSBlYWNoIG9wdGlvblxuXHR0aGlzLiRpbnB1dC5kZXRhY2goKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LCBPTy51aS5JbnB1dFdpZGdldCApO1xuXG4vKiBTdGF0aWMgTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldC5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUgPSBmdW5jdGlvbiAoIG5vZGUsIGNvbmZpZyApIHtcblx0dmFyIHN0YXRlID0gT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5zdGF0aWMuZ2F0aGVyUHJlSW5mdXNlU3RhdGUoIG5vZGUsIGNvbmZpZyApO1xuXHRzdGF0ZS52YWx1ZSA9ICQoIG5vZGUgKS5maW5kKCAnLm9vLXVpLWNoZWNrYm94SW5wdXRXaWRnZXQgLm9vLXVpLWlucHV0V2lkZ2V0LWlucHV0OmNoZWNrZWQnIClcblx0XHQudG9BcnJheSgpLm1hcCggZnVuY3Rpb24gKCBlbCApIHsgcmV0dXJuIGVsLnZhbHVlOyB9ICk7XG5cdHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnN0YXRpYy5yZXVzZVByZUluZnVzZURPTSA9IGZ1bmN0aW9uICggbm9kZSwgY29uZmlnICkge1xuXHRjb25maWcgPSBPTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucGFyZW50LnN0YXRpYy5yZXVzZVByZUluZnVzZURPTSggbm9kZSwgY29uZmlnICk7XG5cdC8vIENhbm5vdCByZXVzZSB0aGUgYDxpbnB1dCB0eXBlPWNoZWNrYm94PmAgc2V0XG5cdGRlbGV0ZSBjb25maWcuJGlucHV0O1xuXHRyZXR1cm4gY29uZmlnO1xufTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQvLyBBY3R1YWxseSB1bnVzZWRcblx0cmV0dXJuICQoICc8dW51c2VkPicgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBDaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0IHNlbGVjdCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbkNoZWNrYm94ZXNTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuc2V0VmFsdWUoIHRoaXMuY2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldC5maW5kU2VsZWN0ZWRJdGVtc0RhdGEoKSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdmFsdWUgPSB0aGlzLiRlbGVtZW50LmZpbmQoICcub28tdWktY2hlY2tib3hJbnB1dFdpZGdldCAub28tdWktaW5wdXRXaWRnZXQtaW5wdXQ6Y2hlY2tlZCcgKVxuXHRcdC50b0FycmF5KCkubWFwKCBmdW5jdGlvbiAoIGVsICkgeyByZXR1cm4gZWwudmFsdWU7IH0gKTtcblx0aWYgKCB0aGlzLnZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0dmFsdWUgPSB0aGlzLmNsZWFuVXBWYWx1ZSggdmFsdWUgKTtcblx0dGhpcy5jaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LnNlbGVjdEl0ZW1zQnlEYXRhKCB2YWx1ZSApO1xuXHRPTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKCB0aGlzLCB2YWx1ZSApO1xuXHRpZiAoIHRoaXMub3B0aW9uc0RpcnR5ICkge1xuXHRcdC8vIFdlIHJlYWNoZWQgdGhpcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciBvciBmcm9tICNzZXRPcHRpb25zLlxuXHRcdC8vIFdlIGhhdmUgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PiBlbGVtZW50LlxuXHRcdHRoaXMudXBkYXRlT3B0aW9uc0ludGVyZmFjZSgpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBpbmNvbWluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB2YWx1ZSBPcmlnaW5hbCB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nW119IENsZWFuZWQgdXAgdmFsdWVcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5jbGVhblVwVmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR2YXIgaSwgc2luZ2xlVmFsdWUsXG5cdFx0Y2xlYW5WYWx1ZSA9IFtdO1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBjbGVhblZhbHVlO1xuXHR9XG5cdGZvciAoIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKysgKSB7XG5cdFx0c2luZ2xlVmFsdWUgPVxuXHRcdFx0T08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuY2xlYW5VcFZhbHVlLmNhbGwoIHRoaXMsIHZhbHVlWyBpIF0gKTtcblx0XHQvLyBSZW1vdmUgb3B0aW9ucyB0aGF0IHdlIGRvbid0IGhhdmUgaGVyZVxuXHRcdGlmICggIXRoaXMuY2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldC5maW5kSXRlbUZyb21EYXRhKCBzaW5nbGVWYWx1ZSApICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGNsZWFuVmFsdWUucHVzaCggc2luZ2xlVmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2xlYW5WYWx1ZTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdHRoaXMuY2hlY2tib3hNdWx0aXNlbGVjdFdpZGdldC5zZXREaXNhYmxlZCggc3RhdGUgKTtcblx0T08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0RGlzYWJsZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoaXMgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucyBBcnJheSBvZiBtZW51IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgeyBkYXRhOiDigKYsIGxhYmVsOiDigKYsIGRpc2FibGVkOiDigKYgfWBcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkNoZWNrYm94TXVsdGlzZWxlY3RJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG5cdHRoaXMuc2V0T3B0aW9uc0RhdGEoIG9wdGlvbnMgKTtcblxuXHQvLyBSZS1zZXQgdGhlIHZhbHVlIHRvIHVwZGF0ZSB0aGUgdmlzaWJsZSBpbnRlcmZhY2UgKENoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQpLlxuXHQvLyBUaGlzIHdpbGwgYWxzbyBnZXQgcmlkIG9mIGFueSBzdGFsZSBvcHRpb25zIHRoYXQgd2UganVzdCByZW1vdmVkLlxuXHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGludGVybmFsIGxpc3Qgb2Ygb3B0aW9ucywgdXNlZCBlLmcuIGJ5IHNldFZhbHVlKCkgdG8gc2VlIHdoaWNoIG9wdGlvbnMgYXJlIGFsbG93ZWQuXG4gKlxuICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25zdHJ1Y3Rvciwgc28gdmFyaW91cyBwcm9wZXJ0aWVzIG1heSBub3QgYmVcbiAqIGludGlhbGl6ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMgQXJyYXkgb2YgbWVudSBvcHRpb25zIGluIHRoZSBmb3JtYXQgYHsgZGF0YTog4oCmLCBsYWJlbDog4oCmIH1gXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldE9wdGlvbnNEYXRhID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHR2YXIgd2lkZ2V0ID0gdGhpcztcblxuXHR0aGlzLm9wdGlvbnNEaXJ0eSA9IHRydWU7XG5cblx0dGhpcy5jaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0XG5cdFx0LmNsZWFySXRlbXMoKVxuXHRcdC5hZGRJdGVtcyggb3B0aW9ucy5tYXAoIGZ1bmN0aW9uICggb3B0ICkge1xuXHRcdFx0dmFyIG9wdFZhbHVlLCBpdGVtLCBvcHREaXNhYmxlZDtcblx0XHRcdG9wdFZhbHVlID1cblx0XHRcdFx0T08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuY2xlYW5VcFZhbHVlLmNhbGwoIHdpZGdldCwgb3B0LmRhdGEgKTtcblx0XHRcdG9wdERpc2FibGVkID0gb3B0LmRpc2FibGVkICE9PSB1bmRlZmluZWQgPyBvcHQuZGlzYWJsZWQgOiBmYWxzZTtcblx0XHRcdGl0ZW0gPSBuZXcgT08udWkuQ2hlY2tib3hNdWx0aW9wdGlvbldpZGdldCgge1xuXHRcdFx0XHRkYXRhOiBvcHRWYWx1ZSxcblx0XHRcdFx0bGFiZWw6IG9wdC5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0LmxhYmVsIDogb3B0VmFsdWUsXG5cdFx0XHRcdGRpc2FibGVkOiBvcHREaXNhYmxlZFxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gU2V0IHRoZSAnbmFtZScgYW5kICd2YWx1ZScgZm9yIGZvcm0gc3VibWlzc2lvblxuXHRcdFx0aXRlbS5jaGVja2JveC4kaW5wdXQuYXR0ciggJ25hbWUnLCB3aWRnZXQuaW5wdXROYW1lICk7XG5cdFx0XHRpdGVtLmNoZWNrYm94LnNldFZhbHVlKCBvcHRWYWx1ZSApO1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSApICk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdXNlci12aXNpYmxlIGludGVyZmFjZSB0byBtYXRjaCB0aGUgaW50ZXJuYWwgbGlzdCBvZiBvcHRpb25zIGFuZCB2YWx1ZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuQ2hlY2tib3hNdWx0aXNlbGVjdElucHV0V2lkZ2V0LnByb3RvdHlwZS51cGRhdGVPcHRpb25zSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG5cblx0dGhpcy5jaGVja2JveE11bHRpc2VsZWN0V2lkZ2V0LmdldEl0ZW1zKCkuZm9yRWFjaCggZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdC8vIFJlbWVtYmVyIG9yaWdpbmFsIHNlbGVjdGlvbiBzdGF0ZS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgbGF0ZXIgdXNlZCB0byBjaGVjayB3aGV0aGVyXG5cdFx0Ly8gdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgaW5wdXQgaGFzIGJlZW4gY2hhbmdlZCBzaW5jZSBpdCB3YXMgY3JlYXRlZC5cblx0XHR2YXIgaXNEZWZhdWx0ID0gZGVmYXVsdFZhbHVlLmluZGV4T2YoIGl0ZW0uZ2V0RGF0YSgpICkgIT09IC0xO1xuXHRcdGl0ZW0uY2hlY2tib3guZGVmYXVsdFNlbGVjdGVkID0gaXNEZWZhdWx0O1xuXHRcdGl0ZW0uY2hlY2tib3guJGlucHV0WyAwIF0uZGVmYXVsdENoZWNrZWQgPSBpc0RlZmF1bHQ7XG5cdH0gKTtcblxuXHR0aGlzLm9wdGlvbnNEaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5DaGVja2JveE11bHRpc2VsZWN0SW5wdXRXaWRnZXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmNoZWNrYm94TXVsdGlzZWxlY3RXaWRnZXQuZm9jdXMoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRleHRJbnB1dFdpZGdldHMsIGxpa2UgSFRNTCB0ZXh0IGlucHV0cywgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCBvcHRpb25zIHRoYXQgY3VzdG9taXplIHRoZVxuICogc2l6ZSBvZiB0aGUgZmllbGQgYXMgd2VsbCBhcyBpdHMgcHJlc2VudGF0aW9uLiBJbiBhZGRpdGlvbiwgdGhlc2Ugd2lkZ2V0cyBjYW4gYmUgY29uZmlndXJlZFxuICogd2l0aCB7QGxpbmsgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgaWNvbnN9LCB7QGxpbmsgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudCBpbmRpY2F0b3JzfSwgYW4gb3B0aW9uYWxcbiAqIHZhbGlkYXRpb24tcGF0dGVybiAodXNlZCB0byBkZXRlcm1pbmUgaWYgYW4gaW5wdXQgdmFsdWUgaXMgdmFsaWQgb3Igbm90KSBhbmQgYW4gaW5wdXQgZmlsdGVyLFxuICogd2hpY2ggbW9kaWZpZXMgaW5jb21pbmcgdmFsdWVzIHJhdGhlciB0aGFuIHZhbGlkYXRpbmcgdGhlbS5cbiAqIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLlxuICpcbiAqIFRoaXMgd2lkZ2V0IGNhbiBiZSB1c2VkIGluc2lkZSBhbiBIVE1MIGZvcm0sIHN1Y2ggYXMgYSBPTy51aS5Gb3JtTGF5b3V0LlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEEgVGV4dElucHV0V2lkZ2V0LlxuICogICAgIHZhciB0ZXh0SW5wdXQgPSBuZXcgT08udWkuVGV4dElucHV0V2lkZ2V0KCB7XG4gKiAgICAgICAgIHZhbHVlOiAnVGV4dCBpbnB1dCdcbiAqICAgICB9IClcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCB0ZXh0SW5wdXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSW5wdXRzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5JbnB1dFdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5JY29uRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7c3RyaW5nfSBbdHlwZT0ndGV4dCddIFRoZSB2YWx1ZSBvZiB0aGUgSFRNTCBgdHlwZWAgYXR0cmlidXRlOiAndGV4dCcsICdwYXNzd29yZCdcbiAqICAnZW1haWwnLCAndXJsJyBvciAnbnVtYmVyJy5cbiAqIEBjZmcge3N0cmluZ30gW3BsYWNlaG9sZGVyXSBQbGFjZWhvbGRlciB0ZXh0XG4gKiBAY2ZnIHtib29sZWFufSBbYXV0b2ZvY3VzPWZhbHNlXSBVc2UgYW4gSFRNTCBgYXV0b2ZvY3VzYCBhdHRyaWJ1dGUgdG9cbiAqICBpbnN0cnVjdCB0aGUgYnJvd3NlciB0byBmb2N1cyB0aGlzIHdpZGdldC5cbiAqIEBjZmcge2Jvb2xlYW59IFtyZWFkT25seT1mYWxzZV0gUHJldmVudCBjaGFuZ2VzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgdGV4dCBpbnB1dC5cbiAqIEBjZmcge251bWJlcn0gW21heExlbmd0aF0gTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBhbGxvd2VkIGluIHRoZSBpbnB1dC5cbiAqXG4gKiAgRm9yIHVuZm9ydHVuYXRlIGhpc3RvcmljYWwgcmVhc29ucywgdGhpcyBjb3VudHMgdGhlIG51bWJlciBvZiBVVEYtMTYgY29kZSB1bml0cyByYXRoZXIgdGhhblxuICogIFVuaWNvZGUgY29kZXBvaW50cywgd2hpY2ggbWVhbnMgdGhhdCBjb2RlcG9pbnRzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoZS5nLlxuICogIG1hbnkgZW1vamlzKSBjb3VudCBhcyAyIGNoYXJhY3RlcnMgZWFjaC5cbiAqIEBjZmcge3N0cmluZ30gW2xhYmVsUG9zaXRpb249J2FmdGVyJ10gVGhlIHBvc2l0aW9uIG9mIHRoZSBpbmxpbmUgbGFiZWwgcmVsYXRpdmUgdG8gdGhhdCBvZlxuICogIHRoZSB2YWx1ZSBvciBwbGFjZWhvbGRlciB0ZXh0OiBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYFxuICogQGNmZyB7Ym9vbGVhbn0gW3JlcXVpcmVkPWZhbHNlXSBNYXJrIHRoZSBmaWVsZCBhcyByZXF1aXJlZCB3aXRoIGB0cnVlYC4gSW1wbGllcyBgaW5kaWNhdG9yOiAncmVxdWlyZWQnYC5cbiAqICBOb3RlIHRoYXQgYGZhbHNlYCAmIHNldHRpbmcgYGluZGljYXRvcjogJ3JlcXVpcmVkJyB3aWxsIHJlc3VsdCBpbiBubyBpbmRpY2F0b3Igc2hvd24uXG4gKiBAY2ZnIHtib29sZWFufSBbYXV0b2NvbXBsZXRlPXRydWVdIFNob3VsZCB0aGUgYnJvd3NlciBzdXBwb3J0IGF1dG9jb21wbGV0ZSBmb3IgdGhpcyBmaWVsZFxuICogQGNmZyB7Ym9vbGVhbn0gW3NwZWxsY2hlY2tdIFNob3VsZCB0aGUgYnJvd3NlciBzdXBwb3J0IHNwZWxsY2hlY2sgZm9yIHRoaXMgZmllbGQgKGB1bmRlZmluZWRgIG1lYW5zXG4gKiAgbGVhdmluZyBpdCB1cCB0byB0aGUgYnJvd3NlcikuXG4gKiBAY2ZnIHtSZWdFeHB8RnVuY3Rpb258c3RyaW5nfSBbdmFsaWRhdGVdIFZhbGlkYXRpb24gcGF0dGVybjogd2hlbiBzdHJpbmcsIGEgc3ltYm9saWMgbmFtZSBvZiBhXG4gKiAgcGF0dGVybiBkZWZpbmVkIGJ5IHRoZSBjbGFzczogJ25vbi1lbXB0eScgKHRoZSB2YWx1ZSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nKSBvciAnaW50ZWdlcidcbiAqICAodGhlIHZhbHVlIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMpOyB3aGVuIFJlZ0V4cCwgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZVxuICogIHZhbHVlIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIHZhbGlkOyB3aGVuIEZ1bmN0aW9uLCBhIGZ1bmN0aW9uIHJlY2VpdmluZyB0aGUgdmFsdWUgYXMgcGFyYW1ldGVyXG4gKiAgdGhhdCBtdXN0IHJldHVybiB0cnVlLCBvciBwcm9taXNlIHJlc29sdmluZyB0byB0cnVlLCBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRleHRJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7XG5cdFx0dHlwZTogJ3RleHQnLFxuXHRcdGxhYmVsUG9zaXRpb246ICdhZnRlcidcblx0fSwgY29uZmlnICk7XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlRleHRJbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkljb25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5QZW5kaW5nRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkcGVuZGluZzogdGhpcy4kaW5wdXQgfSApICk7XG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMudHlwZSA9IHRoaXMuZ2V0U2FuZVR5cGUoIGNvbmZpZyApO1xuXHR0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG5cdHRoaXMucmVxdWlyZWQgPSBmYWxzZTtcblx0dGhpcy52YWxpZGF0ZSA9IG51bGw7XG5cdHRoaXMuc2Nyb2xsV2lkdGggPSBudWxsO1xuXG5cdHRoaXMuc2V0VmFsaWRhdGlvbiggY29uZmlnLnZhbGlkYXRlICk7XG5cdHRoaXMuc2V0TGFiZWxQb3NpdGlvbiggY29uZmlnLmxhYmVsUG9zaXRpb24gKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kaW5wdXQub24oIHtcblx0XHRrZXlwcmVzczogdGhpcy5vbktleVByZXNzLmJpbmQoIHRoaXMgKSxcblx0XHRibHVyOiB0aGlzLm9uQmx1ci5iaW5kKCB0aGlzICksXG5cdFx0Zm9jdXM6IHRoaXMub25Gb2N1cy5iaW5kKCB0aGlzIClcblx0fSApO1xuXHR0aGlzLiRpY29uLm9uKCAnbW91c2Vkb3duJywgdGhpcy5vbkljb25Nb3VzZURvd24uYmluZCggdGhpcyApICk7XG5cdHRoaXMuJGluZGljYXRvci5vbiggJ21vdXNlZG93bicsIHRoaXMub25JbmRpY2F0b3JNb3VzZURvd24uYmluZCggdGhpcyApICk7XG5cdHRoaXMub24oICdsYWJlbENoYW5nZScsIHRoaXMudXBkYXRlUG9zaXRpb24uYmluZCggdGhpcyApICk7XG5cdHRoaXMub24oICdjaGFuZ2UnLCBPTy51aS5kZWJvdW5jZSggdGhpcy5vbkRlYm91bmNlZENoYW5nZS5iaW5kKCB0aGlzICksIDI1MCApICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRleHRJbnB1dFdpZGdldCBvby11aS10ZXh0SW5wdXRXaWRnZXQtdHlwZS0nICsgdGhpcy50eXBlIClcblx0XHQuYXBwZW5kKCB0aGlzLiRpY29uLCB0aGlzLiRpbmRpY2F0b3IgKTtcblx0dGhpcy5zZXRSZWFkT25seSggISFjb25maWcucmVhZE9ubHkgKTtcblx0dGhpcy5zZXRSZXF1aXJlZCggISFjb25maWcucmVxdWlyZWQgKTtcblx0aWYgKCBjb25maWcucGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLiRpbnB1dC5hdHRyKCAncGxhY2Vob2xkZXInLCBjb25maWcucGxhY2Vob2xkZXIgKTtcblx0fVxuXHRpZiAoIGNvbmZpZy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLiRpbnB1dC5hdHRyKCAnbWF4bGVuZ3RoJywgY29uZmlnLm1heExlbmd0aCApO1xuXHR9XG5cdGlmICggY29uZmlnLmF1dG9mb2N1cyApIHtcblx0XHR0aGlzLiRpbnB1dC5hdHRyKCAnYXV0b2ZvY3VzJywgJ2F1dG9mb2N1cycgKTtcblx0fVxuXHRpZiAoIGNvbmZpZy5hdXRvY29tcGxldGUgPT09IGZhbHNlICkge1xuXHRcdHRoaXMuJGlucHV0LmF0dHIoICdhdXRvY29tcGxldGUnLCAnb2ZmJyApO1xuXHRcdC8vIFR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0aW9uIGFsc28gZGlzYWJsZXMgXCJmb3JtIGNhY2hpbmdcIiB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyB0byBhXG5cdFx0Ly8gZGlmZmVyZW50IHBhZ2UgYW5kIHRoZW4gY2xpY2tzIFwiQmFja1wiLiBSZS1lbmFibGUgaXQgd2hlbiBsZWF2aW5nLiBCb3Jyb3dlZCBmcm9tIGpRdWVyeSBVSS5cblx0XHQkKCB3aW5kb3cgKS5vbigge1xuXHRcdFx0YmVmb3JldW5sb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnJlbW92ZUF0dHIoICdhdXRvY29tcGxldGUnICk7XG5cdFx0XHR9LmJpbmQoIHRoaXMgKSxcblx0XHRcdHBhZ2VzaG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIEJyb3dzZXJzIGRvbid0IHNlZW0gdG8gYWN0dWFsbHkgZmlyZSB0aGlzIGV2ZW50IG9uIFwiQmFja1wiLCB0aGV5IGluc3RlYWQganVzdCByZWxvYWQgdGhlXG5cdFx0XHRcdC8vIHdob2xlIHBhZ2UuLi4gaXQgc2hvdWxkbid0IGh1cnQsIHRob3VnaC5cblx0XHRcdFx0dGhpcy4kaW5wdXQuYXR0ciggJ2F1dG9jb21wbGV0ZScsICdvZmYnICk7XG5cdFx0XHR9LmJpbmQoIHRoaXMgKVxuXHRcdH0gKTtcblx0fVxuXHRpZiAoIGNvbmZpZy5zcGVsbGNoZWNrICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy4kaW5wdXQuYXR0ciggJ3NwZWxsY2hlY2snLCBjb25maWcuc3BlbGxjaGVjayA/ICd0cnVlJyA6ICdmYWxzZScgKTtcblx0fVxuXHRpZiAoIHRoaXMubGFiZWwgKSB7XG5cdFx0dGhpcy5pc1dhaXRpbmdUb0JlQXR0YWNoZWQgPSB0cnVlO1xuXHRcdHRoaXMuaW5zdGFsbFBhcmVudENoYW5nZURldGVjdG9yKCk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVGV4dElucHV0V2lkZ2V0LCBPTy51aS5JbnB1dFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGV4dElucHV0V2lkZ2V0LCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGV4dElucHV0V2lkZ2V0LCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5UZXh0SW5wdXRXaWRnZXQsIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5UZXh0SW5wdXRXaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQuc3RhdGljLnZhbGlkYXRpb25QYXR0ZXJucyA9IHtcblx0J25vbi1lbXB0eSc6IC8uKy8sXG5cdGludGVnZXI6IC9eXFxkKyQvXG59O1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBBbiBgZW50ZXJgIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzICdlbnRlcicgaW5zaWRlIHRoZSB0ZXh0IGJveC5cbiAqXG4gKiBAZXZlbnQgZW50ZXJcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGljb24gbW91c2UgZG93biBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGRvd24gZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uSWNvbk1vdXNlRG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCBlLndoaWNoID09PSBPTy51aS5Nb3VzZUJ1dHRvbnMuTEVGVCApIHtcblx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBpbmRpY2F0b3IgbW91c2UgZG93biBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGRvd24gZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uSW5kaWNhdG9yTW91c2VEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUICkge1xuXHRcdHRoaXMuZm9jdXMoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGtleSBwcmVzcyBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBwcmVzcyBldmVudFxuICogQGZpcmVzIGVudGVyIElmIGVudGVyIGtleSBpcyBwcmVzc2VkXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCBlLndoaWNoID09PSBPTy51aS5LZXlzLkVOVEVSICkge1xuXHRcdHRoaXMuZW1pdCggJ2VudGVyJywgZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBibHVyIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgQmx1ciBldmVudFxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZXRWYWxpZGl0eUZsYWcoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGZvY3VzIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgRm9jdXMgZXZlbnRcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuaXNXYWl0aW5nVG9CZUF0dGFjaGVkICkge1xuXHRcdC8vIElmIHdlJ3ZlIHJlY2VpdmVkIGZvY3VzLCB0aGVuIHdlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCBhbmQgaWZcblx0XHQvLyBpc1dhaXRpbmdUb0JlQXR0YWNoZWQgaXMgc3RpbGwgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgaGFuZGxlciBuZXZlciBmaXJlZC4gRmlyZSBpdCBub3cuXG5cdFx0dGhpcy5vbkVsZW1lbnRBdHRhY2goKTtcblx0fVxuXHR0aGlzLnNldFZhbGlkaXR5RmxhZyggdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgZWxlbWVudCBhdHRhY2ggZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBFbGVtZW50IGF0dGFjaCBldmVudFxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uRWxlbWVudEF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5pc1dhaXRpbmdUb0JlQXR0YWNoZWQgPSBmYWxzZTtcblx0Ly8gQW55IHByZXZpb3VzbHkgY2FsY3VsYXRlZCBzaXplIGlzIG5vdyBwcm9iYWJseSBpbnZhbGlkIGlmIHdlIHJlYXR0YWNoZWQgZWxzZXdoZXJlXG5cdHRoaXMudmFsQ2FjaGUgPSBudWxsO1xuXHR0aGlzLnBvc2l0aW9uTGFiZWwoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGRlYm91bmNlZCBjaGFuZ2UgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbkRlYm91bmNlZENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZXRWYWxpZGl0eUZsYWcoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGlucHV0IGlzIHtAbGluayAjcmVhZE9ubHkgcmVhZC1vbmx5fS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLmlzUmVhZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnJlYWRPbmx5O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHtAbGluayAjcmVhZE9ubHkgcmVhZC1vbmx5fSBzdGF0ZSBvZiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSBNYWtlIGlucHV0IHJlYWQtb25seVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRSZWFkT25seSA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdHRoaXMucmVhZE9ubHkgPSAhIXN0YXRlO1xuXHR0aGlzLiRpbnB1dC5wcm9wKCAncmVhZE9ubHknLCB0aGlzLnJlYWRPbmx5ICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5wdXQgaXMge0BsaW5rICNyZXF1aXJlZCByZXF1aXJlZH0uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5pc1JlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5yZXF1aXJlZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB7QGxpbmsgI3JlcXVpcmVkIHJlcXVpcmVkfSBzdGF0ZSBvZiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSBNYWtlIGlucHV0IHJlcXVpcmVkXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldFJlcXVpcmVkID0gZnVuY3Rpb24gKCBzdGF0ZSApIHtcblx0dGhpcy5yZXF1aXJlZCA9ICEhc3RhdGU7XG5cdGlmICggdGhpcy5yZXF1aXJlZCApIHtcblx0XHR0aGlzLiRpbnB1dFxuXHRcdFx0LnByb3AoICdyZXF1aXJlZCcsIHRydWUgKVxuXHRcdFx0LmF0dHIoICdhcmlhLXJlcXVpcmVkJywgJ3RydWUnICk7XG5cdFx0aWYgKCB0aGlzLmdldEluZGljYXRvcigpID09PSBudWxsICkge1xuXHRcdFx0dGhpcy5zZXRJbmRpY2F0b3IoICdyZXF1aXJlZCcgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kaW5wdXRcblx0XHRcdC5wcm9wKCAncmVxdWlyZWQnLCBmYWxzZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggJ2FyaWEtcmVxdWlyZWQnICk7XG5cdFx0aWYgKCB0aGlzLmdldEluZGljYXRvcigpID09PSAncmVxdWlyZWQnICkge1xuXHRcdFx0dGhpcy5zZXRJbmRpY2F0b3IoIG51bGwgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1cHBvcnQgZnVuY3Rpb24gZm9yIG1ha2luZyAjb25FbGVtZW50QXR0YWNoIHdvcmsgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFRoaXMgd2hvbGUgZnVuY3Rpb24gY291bGQgYmUgcmVwbGFjZWQgd2l0aCBvbmUgbGluZSBvZiBjb2RlIHVzaW5nIHRoZSBET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnRcbiAqIGV2ZW50LCBidXQgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IEZpcmVmb3ggYW5kIGFsbGVnZWRseSBkZXByZWNhdGVkLCBzbyB3ZSBvbmx5IHVzZSBpdCBhcyBmYWxsYmFjay5cbiAqXG4gKiBEdWUgdG8gTXV0YXRpb25PYnNlcnZlciBwZXJmb3JtYW5jZSB3b2VzLCAjb25FbGVtZW50QXR0YWNoIGlzIG9ubHkgc29tZXdoYXQgcmVsaWFibHkgY2FsbGVkIHRoZVxuICogZmlyc3QgdGltZSB0aGF0IHRoZSBlbGVtZW50IGdldHMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50ZWQuXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuaW5zdGFsbFBhcmVudENoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbXV0YXRpb25PYnNlcnZlciwgb25SZW1vdmUsIHRvcG1vc3ROb2RlLCBmYWtlUGFyZW50Tm9kZSxcblx0XHRNdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXIsXG5cdFx0d2lkZ2V0ID0gdGhpcztcblxuXHRpZiAoIE11dGF0aW9uT2JzZXJ2ZXIgKSB7XG5cdFx0Ly8gVGhlIG5ldyB3YXkuIElmIG9ubHkgaXQgd2Fzbid0IHNvIHVnbHkuXG5cblx0XHRpZiAoIHRoaXMuaXNFbGVtZW50QXR0YWNoZWQoKSApIHtcblx0XHRcdC8vIFdpZGdldCBpcyBhdHRhY2hlZCBhbHJlYWR5LCBkbyBub3RoaW5nLiBUaGlzIGJyZWFrcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIGZ1bmN0aW9uIHdoZW5cblx0XHRcdC8vIHRoZSB3aWRnZXQgaXMgZGV0YWNoZWQgYW5kIHJlYXR0YWNoZWQuIEFsYXMsIGRvaW5nIHRoaXMgY29ycmVjdGx5IHdpdGggTXV0YXRpb25PYnNlcnZlclxuXHRcdFx0Ly8gd291bGQgcmVxdWlyZSBvYnNlcnZhdGlvbiBvZiB0aGUgd2hvbGUgZG9jdW1lbnQsIHdoaWNoIHdvdWxkIGh1cnQgcGVyZm9ybWFuY2Ugb2Ygb3RoZXIsXG5cdFx0XHQvLyBtb3JlIGltcG9ydGFudCBjb2RlLlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZpbmQgdG9wbW9zdCBub2RlIGluIHRoZSB0cmVlXG5cdFx0dG9wbW9zdE5vZGUgPSB0aGlzLiRlbGVtZW50WyAwIF07XG5cdFx0d2hpbGUgKCB0b3Btb3N0Tm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0dG9wbW9zdE5vZGUgPSB0b3Btb3N0Tm9kZS5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIFdlIGhhdmUgbm8gd2F5IHRvIGRldGVjdCB0aGUgJGVsZW1lbnQgYmVpbmcgYXR0YWNoZWQgc29tZXdoZXJlIHdpdGhvdXQgb2JzZXJ2aW5nIHRoZSBlbnRpcmVcblx0XHQvLyBET00gd2l0aCBzdWJ0cmVlIG1vZGlmaWNhdGlvbnMsIHdoaWNoIHdvdWxkIGh1cnQgcGVyZm9ybWFuY2UuIFNvIHdlIGNoZWF0OiB3ZSBob29rIHRvIHRoZVxuXHRcdC8vIHBhcmVudCBub2RlIG9mICRlbGVtZW50LCBhbmQgaW5zdGVhZCBkZXRlY3Qgd2hlbiAkZWxlbWVudCBpcyByZW1vdmVkIGZyb20gaXQgKGFuZCB0aHVzXG5cdFx0Ly8gcHJvYmFibHkgYXR0YWNoZWQgc29tZXdoZXJlIGVsc2UpLiBJZiB0aGVyZSBpcyBubyBwYXJlbnQsIHdlIGNyZWF0ZSBhIFwiZmFrZVwiIG9uZS4gSWYgaXRcblx0XHQvLyBkb2Vzbid0IGdldCBhdHRhY2hlZCwgd2UgZW5kIHVwIGJhY2sgaGVyZSBhbmQgY3JlYXRlIHRoZSBwYXJlbnQuXG5cblx0XHRtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIGZ1bmN0aW9uICggbXV0YXRpb25zICkge1xuXHRcdFx0dmFyIGksIGosIHJlbW92ZWROb2Rlcztcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRyZW1vdmVkTm9kZXMgPSBtdXRhdGlvbnNbIGkgXS5yZW1vdmVkTm9kZXM7XG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgcmVtb3ZlZE5vZGVzLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHRcdGlmICggcmVtb3ZlZE5vZGVzWyBqIF0gPT09IHRvcG1vc3ROb2RlICkge1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggb25SZW1vdmUsIDAgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRvblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIElmIHRoZSBub2RlIHdhcyBhdHRhY2hlZCBzb21ld2hlcmUgZWxzZSwgcmVwb3J0IGl0XG5cdFx0XHRpZiAoIHdpZGdldC5pc0VsZW1lbnRBdHRhY2hlZCgpICkge1xuXHRcdFx0XHR3aWRnZXQub25FbGVtZW50QXR0YWNoKCk7XG5cdFx0XHR9XG5cdFx0XHRtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHRcdHdpZGdldC5pbnN0YWxsUGFyZW50Q2hhbmdlRGV0ZWN0b3IoKTtcblx0XHR9O1xuXG5cdFx0Ly8gQ3JlYXRlIGEgZmFrZSBwYXJlbnQgYW5kIG9ic2VydmUgaXRcblx0XHRmYWtlUGFyZW50Tm9kZSA9ICQoICc8ZGl2PicgKS5hcHBlbmQoIHRvcG1vc3ROb2RlIClbIDAgXTtcblx0XHRtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoIGZha2VQYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVXNpbmcgdGhlIERPTU5vZGVJbnNlcnRlZEludG9Eb2N1bWVudCBldmVudCBpcyBtdWNoIG5pY2VyIGFuZCBsZXNzIG1hZ2ljYWwsIGFuZCB3b3JrcyBmb3Jcblx0XHQvLyBkZXRhY2htZW50IGFuZCByZWF0dGFjaG1lbnQsIGJ1dCBpdCdzIG5vdCBzdXBwb3J0ZWQgYnkgRmlyZWZveCBhbmQgYWxsZWdlZGx5IGRlcHJlY2F0ZWQuXG5cdFx0dGhpcy4kZWxlbWVudC5vbiggJ0RPTU5vZGVJbnNlcnRlZEludG9Eb2N1bWVudCcsIHRoaXMub25FbGVtZW50QXR0YWNoLmJpbmQoIHRoaXMgKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCBjb25maWcgKSB7XG5cdGlmICggdGhpcy5nZXRTYW5lVHlwZSggY29uZmlnICkgPT09ICdudW1iZXInICkge1xuXHRcdHJldHVybiAkKCAnPGlucHV0PicgKVxuXHRcdFx0LmF0dHIoICdzdGVwJywgJ2FueScgKVxuXHRcdFx0LmF0dHIoICd0eXBlJywgJ251bWJlcicgKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJCggJzxpbnB1dD4nICkuYXR0ciggJ3R5cGUnLCB0aGlzLmdldFNhbmVUeXBlKCBjb25maWcgKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCBzYW5pdGl6ZWQgdmFsdWUgZm9yICd0eXBlJyBmb3IgZ2l2ZW4gY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRTYW5lVHlwZSA9IGZ1bmN0aW9uICggY29uZmlnICkge1xuXHR2YXIgYWxsb3dlZFR5cGVzID0gW1xuXHRcdCd0ZXh0Jyxcblx0XHQncGFzc3dvcmQnLFxuXHRcdCdlbWFpbCcsXG5cdFx0J3VybCcsXG5cdFx0J251bWJlcidcblx0XTtcblx0cmV0dXJuIGFsbG93ZWRUeXBlcy5pbmRleE9mKCBjb25maWcudHlwZSApICE9PSAtMSA/IGNvbmZpZy50eXBlIDogJ3RleHQnO1xufTtcblxuLyoqXG4gKiBGb2N1cyB0aGUgaW5wdXQgYW5kIHNlbGVjdCBhIHNwZWNpZmllZCByYW5nZSB3aXRoaW4gdGhlIHRleHQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb20gU2VsZWN0IGZyb20gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gW3RvXSBTZWxlY3QgdG8gb2Zmc2V0LCBkZWZhdWx0cyB0byBmcm9tXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNlbGVjdFJhbmdlID0gZnVuY3Rpb24gKCBmcm9tLCB0byApIHtcblx0dmFyIGlzQmFja3dhcmRzLCBzdGFydCwgZW5kLFxuXHRcdGlucHV0ID0gdGhpcy4kaW5wdXRbIDAgXTtcblxuXHR0byA9IHRvIHx8IGZyb207XG5cblx0aXNCYWNrd2FyZHMgPSB0byA8IGZyb207XG5cdHN0YXJ0ID0gaXNCYWNrd2FyZHMgPyB0byA6IGZyb207XG5cdGVuZCA9IGlzQmFja3dhcmRzID8gZnJvbSA6IHRvO1xuXG5cdHRoaXMuZm9jdXMoKTtcblxuXHR0cnkge1xuXHRcdGlucHV0LnNldFNlbGVjdGlvblJhbmdlKCBzdGFydCwgZW5kLCBpc0JhY2t3YXJkcyA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0Ly8gSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB5b3UgY2FsbCBzZXRTZWxlY3Rpb25SYW5nZSBvbiBhIHVuYXR0YWNoZWQgRE9NIG5vZGUuXG5cdFx0Ly8gUmF0aGVyIHRoYW4gZXhwZW5zaXZlbHkgY2hlY2sgaWYgdGhlIGlucHV0IGlzIGF0dGFjaGVkIGV2ZXJ5IHRpbWUsIGp1c3QgY2hlY2tcblx0XHQvLyBpZiBpdCB3YXMgdGhlIGNhdXNlIG9mIGFuIGVycm9yIGJlaW5nIHRocm93bi4gSWYgbm90LCByZXRocm93IHRoZSBlcnJvci5cblx0XHRpZiAoIHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYm9keS5jb250YWlucyggaW5wdXQgKSApIHtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHJhbmdlIGluIGEgZGlyZWN0aW9uYWwgbWFubmVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyAnZnJvbScgYW5kICd0bycgb2Zmc2V0c1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLiRpbnB1dFsgMCBdLFxuXHRcdHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG5cdFx0ZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kLFxuXHRcdGlzQmFja3dhcmRzID0gaW5wdXQuc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnYmFja3dhcmQnO1xuXG5cdHJldHVybiB7XG5cdFx0ZnJvbTogaXNCYWNrd2FyZHMgPyBlbmQgOiBzdGFydCxcblx0XHR0bzogaXNCYWNrd2FyZHMgPyBzdGFydCA6IGVuZFxuXHR9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdGV4dCBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGNvdWxkIGRpZmZlciBmcm9tIHRoZSBsZW5ndGggb2YgI2dldFZhbHVlIGlmIHRoZVxuICogdmFsdWUgZ2V0cyBmaWx0ZXJlZFxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gSW5wdXQgbGVuZ3RoXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLiRpbnB1dFsgMCBdLnZhbHVlLmxlbmd0aDtcbn07XG5cbi8qKlxuICogRm9jdXMgdGhlIGlucHV0IGFuZCBzZWxlY3QgdGhlIGVudGlyZSB0ZXh0LlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zZWxlY3RSYW5nZSggMCwgdGhpcy5nZXRJbnB1dExlbmd0aCgpICk7XG59O1xuXG4vKipcbiAqIEZvY3VzIHRoZSBpbnB1dCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm1vdmVDdXJzb3JUb1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zZWxlY3RSYW5nZSggMCApO1xufTtcblxuLyoqXG4gKiBGb2N1cyB0aGUgaW5wdXQgYW5kIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgZW5kLlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUubW92ZUN1cnNvclRvRW5kID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zZWxlY3RSYW5nZSggdGhpcy5nZXRJbnB1dExlbmd0aCgpICk7XG59O1xuXG4vKipcbiAqIEluc2VydCBuZXcgY29udGVudCBpbnRvIHRoZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBDb250ZW50IHRvIGJlIGluc2VydGVkXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLmluc2VydENvbnRlbnQgPSBmdW5jdGlvbiAoIGNvbnRlbnQgKSB7XG5cdHZhciBzdGFydCwgZW5kLFxuXHRcdHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpLFxuXHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG5cdHN0YXJ0ID0gTWF0aC5taW4oIHJhbmdlLmZyb20sIHJhbmdlLnRvICk7XG5cdGVuZCA9IE1hdGgubWF4KCByYW5nZS5mcm9tLCByYW5nZS50byApO1xuXG5cdHRoaXMuc2V0VmFsdWUoIHZhbHVlLnNsaWNlKCAwLCBzdGFydCApICsgY29udGVudCArIHZhbHVlLnNsaWNlKCBlbmQgKSApO1xuXHR0aGlzLnNlbGVjdFJhbmdlKCBzdGFydCArIGNvbnRlbnQubGVuZ3RoICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnNlcnQgbmV3IGNvbnRlbnQgZWl0aGVyIHNpZGUgb2YgYSBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZSBDb250ZW50IHRvIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zdCBDb250ZW50IHRvIGJlIGluc2VydGVkIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuZW5jYXBzdWxhdGVDb250ZW50ID0gZnVuY3Rpb24gKCBwcmUsIHBvc3QgKSB7XG5cdHZhciBzdGFydCwgZW5kLFxuXHRcdHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpLFxuXHRcdG9mZnNldCA9IHByZS5sZW5ndGg7XG5cblx0c3RhcnQgPSBNYXRoLm1pbiggcmFuZ2UuZnJvbSwgcmFuZ2UudG8gKTtcblx0ZW5kID0gTWF0aC5tYXgoIHJhbmdlLmZyb20sIHJhbmdlLnRvICk7XG5cblx0dGhpcy5zZWxlY3RSYW5nZSggc3RhcnQgKS5pbnNlcnRDb250ZW50KCBwcmUgKTtcblx0dGhpcy5zZWxlY3RSYW5nZSggb2Zmc2V0ICsgZW5kICkuaW5zZXJ0Q29udGVudCggcG9zdCApO1xuXG5cdHRoaXMuc2VsZWN0UmFuZ2UoIG9mZnNldCArIHN0YXJ0LCBvZmZzZXQgKyBlbmQgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsaWRhdGlvbiBwYXR0ZXJuLlxuICpcbiAqIFRoZSB2YWxpZGF0aW9uIHBhdHRlcm4gaXMgZWl0aGVyIGEgcmVndWxhciBleHByZXNzaW9uLCBhIGZ1bmN0aW9uLCBvciB0aGUgc3ltYm9saWMgbmFtZSBvZiBhXG4gKiBwYXR0ZXJuIGRlZmluZWQgYnkgdGhlIGNsYXNzOiAnbm9uLWVtcHR5JyAodGhlIHZhbHVlIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcpIG9yICdpbnRlZ2VyJyAodGhlXG4gKiB2YWx1ZSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzKS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbnxzdHJpbmd8bnVsbH0gdmFsaWRhdGUgUmVndWxhciBleHByZXNzaW9uLCBmdW5jdGlvbiwgb3IgdGhlIHN5bWJvbGljIG5hbWVcbiAqICBvZiBhIHBhdHRlcm4gKGVpdGhlciDigJhpbnRlZ2Vy4oCZIG9yIOKAmG5vbi1lbXB0eeKAmSkgZGVmaW5lZCBieSB0aGUgY2xhc3MuXG4gKi9cbk9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0VmFsaWRhdGlvbiA9IGZ1bmN0aW9uICggdmFsaWRhdGUgKSB7XG5cdGlmICggdmFsaWRhdGUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdmFsaWRhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbiApIHtcblx0XHR0aGlzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52YWxpZGF0ZSA9IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLnZhbGlkYXRpb25QYXR0ZXJuc1sgdmFsaWRhdGUgXSB8fCAvLiovO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlICdpbnZhbGlkJyBmbGFnIGFwcHJvcHJpYXRlbHkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbaXNWYWxpZF0gT3B0aW9uYWxseSBvdmVycmlkZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldFZhbGlkaXR5RmxhZyA9IGZ1bmN0aW9uICggaXNWYWxpZCApIHtcblx0dmFyIHdpZGdldCA9IHRoaXMsXG5cdFx0c2V0RmxhZyA9IGZ1bmN0aW9uICggdmFsaWQgKSB7XG5cdFx0XHRpZiAoICF2YWxpZCApIHtcblx0XHRcdFx0d2lkZ2V0LiRpbnB1dC5hdHRyKCAnYXJpYS1pbnZhbGlkJywgJ3RydWUnICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aWRnZXQuJGlucHV0LnJlbW92ZUF0dHIoICdhcmlhLWludmFsaWQnICk7XG5cdFx0XHR9XG5cdFx0XHR3aWRnZXQuc2V0RmxhZ3MoIHsgaW52YWxpZDogIXZhbGlkIH0gKTtcblx0XHR9O1xuXG5cdGlmICggaXNWYWxpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHNldEZsYWcoIGlzVmFsaWQgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmdldFZhbGlkaXR5KCkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdFx0c2V0RmxhZyggdHJ1ZSApO1xuXHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHNldEZsYWcoIGZhbHNlICk7XG5cdFx0fSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsaWRpdHkgb2YgY3VycmVudCB2YWx1ZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBhbmQgcmVqZWN0cyBpZlxuICogaXQgaXNuJ3QuIFVzZXMgdGhlIHtAbGluayAjdmFsaWRhdGUgdmFsaWRhdGlvbiBwYXR0ZXJufSAgdG8gY2hlY2sgZm9yIHZhbGlkaXR5LlxuICpcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZiB0aGUgdmFsdWUgaXMgdmFsaWQsIHJlamVjdHMgaWYgbm90LlxuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLmdldFZhbGlkaXR5ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmVzdWx0O1xuXG5cdGZ1bmN0aW9uIHJlamVjdE9yUmVzb2x2ZSggdmFsaWQgKSB7XG5cdFx0aWYgKCB2YWxpZCApIHtcblx0XHRcdHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSgpLnByb21pc2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICQuRGVmZXJyZWQoKS5yZWplY3QoKS5wcm9taXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgYnJvd3NlciB2YWxpZGl0eSBhbmQgcmVqZWN0IGlmIGl0IGlzIGludmFsaWRcblx0aWYgKFxuXHRcdHRoaXMuJGlucHV0WyAwIF0uY2hlY2tWYWxpZGl0eSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0dGhpcy4kaW5wdXRbIDAgXS5jaGVja1ZhbGlkaXR5KCkgPT09IGZhbHNlXG5cdCkge1xuXHRcdHJldHVybiByZWplY3RPclJlc29sdmUoIGZhbHNlICk7XG5cdH1cblxuXHQvLyBSdW4gb3VyIGNoZWNrcyBpZiB0aGUgYnJvd3NlciB0aGlua3MgdGhlIGZpZWxkIGlzIHZhbGlkXG5cdGlmICggdGhpcy52YWxpZGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICkge1xuXHRcdHJlc3VsdCA9IHRoaXMudmFsaWRhdGUoIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdGlmICggcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQucHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiByZXN1bHQucHJvbWlzZSgpLnRoZW4oIGZ1bmN0aW9uICggdmFsaWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWplY3RPclJlc29sdmUoIHZhbGlkICk7XG5cdFx0XHR9ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZWplY3RPclJlc29sdmUoIHJlc3VsdCApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcmVqZWN0T3JSZXNvbHZlKCB0aGlzLmdldFZhbHVlKCkubWF0Y2goIHRoaXMudmFsaWRhdGUgKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGlubGluZSBsYWJlbCByZWxhdGl2ZSB0byB0aGF0IG9mIHRoZSB2YWx1ZTogYOKAmGJlZm9yZeKAmWAgb3IgYOKAmGFmdGVy4oCZYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxQb3NpdGlvbiBMYWJlbCBwb3NpdGlvbiwgJ2JlZm9yZScgb3IgJ2FmdGVyJ1xuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRMYWJlbFBvc2l0aW9uID0gZnVuY3Rpb24gKCBsYWJlbFBvc2l0aW9uICkge1xuXHR0aGlzLmxhYmVsUG9zaXRpb24gPSBsYWJlbFBvc2l0aW9uO1xuXHRpZiAoIHRoaXMubGFiZWwgKSB7XG5cdFx0Ly8gSWYgdGhlcmUgaXMgbm8gbGFiZWwgYW5kIHdlIG9ubHkgY2hhbmdlIHRoZSBwb3NpdGlvbiwgI3VwZGF0ZVBvc2l0aW9uIGlzIGEgbm8tb3AsXG5cdFx0Ly8gYnV0IGl0IHRha2VzIHJlYWxseSBhIGxvdCBvZiB3b3JrIHRvIGRvIG5vdGhpbmcuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbmxpbmUgbGFiZWwuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5ICNzZXRMYWJlbFBvc2l0aW9uLCBhbmQgY2FuIGFsc28gYmUgY2FsbGVkIG9uIGl0cyBvd24gaWZcbiAqIHNvbWV0aGluZyBjYXVzZXMgdGhlIGxhYmVsIHRvIGJlIG1pc3Bvc2l0aW9uZWQuXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFmdGVyID0gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnYWZ0ZXInO1xuXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS10ZXh0SW5wdXRXaWRnZXQtbGFiZWxQb3NpdGlvbi1hZnRlcicsICEhdGhpcy5sYWJlbCAmJiBhZnRlciApXG5cdFx0LnRvZ2dsZUNsYXNzKCAnb28tdWktdGV4dElucHV0V2lkZ2V0LWxhYmVsUG9zaXRpb24tYmVmb3JlJywgISF0aGlzLmxhYmVsICYmICFhZnRlciApO1xuXG5cdHRoaXMudmFsQ2FjaGUgPSBudWxsO1xuXHR0aGlzLnNjcm9sbFdpZHRoID0gbnVsbDtcblx0dGhpcy5wb3NpdGlvbkxhYmVsKCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBvc2l0aW9uIHRoZSBsYWJlbCBieSBzZXR0aW5nIHRoZSBjb3JyZWN0IHBhZGRpbmcgb24gdGhlIGlucHV0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLnBvc2l0aW9uTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhZnRlciwgcnRsLCBwcm9wZXJ0eSwgbmV3Q3NzO1xuXG5cdGlmICggdGhpcy5pc1dhaXRpbmdUb0JlQXR0YWNoZWQgKSB7XG5cdFx0Ly8gI29uRWxlbWVudEF0dGFjaCB3aWxsIGJlIGNhbGxlZCBzb29uLCB3aGljaCBjYWxscyB0aGlzIG1ldGhvZFxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bmV3Q3NzID0ge1xuXHRcdCdwYWRkaW5nLXJpZ2h0JzogJycsXG5cdFx0J3BhZGRpbmctbGVmdCc6ICcnXG5cdH07XG5cblx0aWYgKCB0aGlzLmxhYmVsICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKCB0aGlzLiRsYWJlbCApO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuJGxhYmVsLmRldGFjaCgpO1xuXHRcdC8vIENsZWFyIG9sZCB2YWx1ZXMgaWYgcHJlc2VudFxuXHRcdHRoaXMuJGlucHV0LmNzcyggbmV3Q3NzICk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YWZ0ZXIgPSB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdhZnRlcic7XG5cdHJ0bCA9IHRoaXMuJGVsZW1lbnQuY3NzKCAnZGlyZWN0aW9uJyApID09PSAncnRsJztcblx0cHJvcGVydHkgPSBhZnRlciA9PT0gcnRsID8gJ3BhZGRpbmctbGVmdCcgOiAncGFkZGluZy1yaWdodCc7XG5cblx0bmV3Q3NzWyBwcm9wZXJ0eSBdID0gdGhpcy4kbGFiZWwub3V0ZXJXaWR0aCggdHJ1ZSApICsgKCBhZnRlciA/IHRoaXMuc2Nyb2xsV2lkdGggOiAwICk7XG5cdC8vIFdlIGhhdmUgdG8gY2xlYXIgdGhlIHBhZGRpbmcgb24gdGhlIG90aGVyIHNpZGUsIGluIGNhc2UgdGhlIGVsZW1lbnQgZGlyZWN0aW9uIGNoYW5nZWRcblx0dGhpcy4kaW5wdXQuY3NzKCBuZXdDc3MgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VhcmNoSW5wdXRXaWRnZXRzIGFyZSBUZXh0SW5wdXRXaWRnZXRzIHdpdGggYHR5cGU9XCJzZWFyY2hcImAgYXNzaWduZWQgYW5kIGZlYXR1cmUgYVxuICoge0BsaW5rIE9PLnVpLm1peGluLkljb25FbGVtZW50IHNlYXJjaCBpY29ufSBieSBkZWZhdWx0LlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMuXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0lucHV0cyNTZWFyY2hJbnB1dFdpZGdldFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVGV4dElucHV0V2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbk9PLnVpLlNlYXJjaElucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaVNlYXJjaElucHV0V2lkZ2V0KCBjb25maWcgKSB7XG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7XG5cdFx0aWNvbjogJ3NlYXJjaCdcblx0fSwgY29uZmlnICk7XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5jb25uZWN0KCB0aGlzLCB7XG5cdFx0Y2hhbmdlOiAnb25DaGFuZ2UnXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnVwZGF0ZVNlYXJjaEluZGljYXRvcigpO1xuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHtcblx0XHRkaXNhYmxlOiAnb25EaXNhYmxlJ1xuXHR9ICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LCBPTy51aS5UZXh0SW5wdXRXaWRnZXQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRTYW5lVHlwZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICdzZWFyY2gnO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5TZWFyY2hJbnB1dFdpZGdldC5wcm90b3R5cGUub25JbmRpY2F0b3JNb3VzZURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGlmICggZS53aGljaCA9PT0gT08udWkuTW91c2VCdXR0b25zLkxFRlQgKSB7XG5cdFx0Ly8gQ2xlYXIgdGhlIHRleHQgZmllbGRcblx0XHR0aGlzLnNldFZhbHVlKCAnJyApO1xuXHRcdHRoaXMuZm9jdXMoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAnY2xlYXInIGluZGljYXRvciBkaXNwbGF5ZWQgb24gdHlwZTogJ3NlYXJjaCcgdGV4dFxuICogZmllbGRzLCBoaWRpbmcgaXQgd2hlbiB0aGUgZmllbGQgaXMgYWxyZWFkeSBlbXB0eSBvciB3aGVuIGl0J3Mgbm90XG4gKiBlZGl0YWJsZS5cbiAqL1xuT08udWkuU2VhcmNoSW5wdXRXaWRnZXQucHJvdG90eXBlLnVwZGF0ZVNlYXJjaEluZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmdldFZhbHVlKCkgPT09ICcnIHx8IHRoaXMuaXNEaXNhYmxlZCgpIHx8IHRoaXMuaXNSZWFkT25seSgpICkge1xuXHRcdHRoaXMuc2V0SW5kaWNhdG9yKCBudWxsICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5zZXRJbmRpY2F0b3IoICdjbGVhcicgKTtcblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5TZWFyY2hJbnB1dFdpZGdldC5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMudXBkYXRlU2VhcmNoSW5kaWNhdG9yKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBkaXNhYmxlIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIEVsZW1lbnQgaXMgZGlzYWJsZWRcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbkRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMudXBkYXRlU2VhcmNoSW5kaWNhdG9yKCk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRSZWFkT25seSA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdE9PLnVpLlNlYXJjaElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0UmVhZE9ubHkuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0dGhpcy51cGRhdGVTZWFyY2hJbmRpY2F0b3IoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpbGluZVRleHRJbnB1dFdpZGdldHMsIGxpa2UgSFRNTCB0ZXh0YXJlYXMsIGFyZSBmZWF0dXJpbmcgY3VzdG9taXphdGlvbiBvcHRpb25zIHRvXG4gKiBjb25maWd1cmUgbnVtYmVyIG9mIHJvd3MgdmlzaWJsZS4gSW4gYWRkaXRpb24sIHRoZXNlIHdpZGdldHMgY2FuIGJlIGF1dG9zaXplZCB0byBmaXQgdXNlclxuICogaW5wdXRzIGFuZCBjYW4gc2hvdyB7QGxpbmsgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgaWNvbnN9IGFuZFxuICoge0BsaW5rIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgaW5kaWNhdG9yc30uXG4gKiBQbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBUaGlzIHdpZGdldCBjYW4gYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBmb3JtLCBzdWNoIGFzIGEgT08udWkuRm9ybUxheW91dC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIE11bHRpbGluZVRleHRJbnB1dFdpZGdldC5cbiAqICAgICB2YXIgbXVsdGlsaW5lVGV4dElucHV0ID0gbmV3IE9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldCgge1xuICogICAgICAgICB2YWx1ZTogJ1RleHQgaW5wdXQgb24gbXVsdGlwbGUgbGluZXMnXG4gKiAgICAgfSApXG4gKiAgICAgJCggJ2JvZHknICkuYXBwZW5kKCBtdWx0aWxpbmVUZXh0SW5wdXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvSW5wdXRzI011bHRpbGluZVRleHRJbnB1dFdpZGdldFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVGV4dElucHV0V2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtudW1iZXJ9IFtyb3dzXSBOdW1iZXIgb2YgdmlzaWJsZSBsaW5lcyBpbiB0ZXh0YXJlYS4gSWYgdXNlZCB3aXRoIGBhdXRvc2l6ZWAsXG4gKiAgc3BlY2lmaWVzIG1pbmltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAqIEBjZmcge2Jvb2xlYW59IFthdXRvc2l6ZT1mYWxzZV0gQXV0b21hdGljYWxseSByZXNpemUgdGhlIHRleHQgaW5wdXQgdG8gZml0IGl0cyBjb250ZW50LlxuICogIFVzZSB0aGUgI21heFJvd3MgY29uZmlnIHRvIHNwZWNpZnkgYSBtYXhpbXVtIG51bWJlciBvZiBkaXNwbGF5ZWQgcm93cy5cbiAqIEBjZmcge251bWJlcn0gW21heFJvd3NdIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuICNhdXRvc2l6ZSBpcyBzZXQgdG8gdHJ1ZS5cbiAqICBEZWZhdWx0cyB0byB0aGUgbWF4aW11bSBvZiBgMTBgIGFuZCBgMiAqIHJvd3NgLCBvciBgMTBgIGlmIGByb3dzYCBpc24ndCBwcm92aWRlZC5cbiAqL1xuT08udWkuTXVsdGlsaW5lVGV4dElucHV0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaU11bHRpbGluZVRleHRJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHRjb25maWcgPSAkLmV4dGVuZCgge1xuXHRcdHR5cGU6ICd0ZXh0J1xuXHR9LCBjb25maWcgKTtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmF1dG9zaXplID0gISFjb25maWcuYXV0b3NpemU7XG5cdHRoaXMuc3R5bGVIZWlnaHQgPSBudWxsO1xuXHR0aGlzLm1pblJvd3MgPSBjb25maWcucm93cyAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnJvd3MgOiAnJztcblx0dGhpcy5tYXhSb3dzID0gY29uZmlnLm1heFJvd3MgfHwgTWF0aC5tYXgoIDIgKiAoIHRoaXMubWluUm93cyB8fCAwICksIDEwICk7XG5cblx0Ly8gQ2xvbmUgZm9yIHJlc2l6aW5nXG5cdGlmICggdGhpcy5hdXRvc2l6ZSApIHtcblx0XHR0aGlzLiRjbG9uZSA9IHRoaXMuJGlucHV0XG5cdFx0XHQuY2xvbmUoKVxuXHRcdFx0LnJlbW92ZUF0dHIoICdpZCcgKVxuXHRcdFx0LnJlbW92ZUF0dHIoICduYW1lJyApXG5cdFx0XHQuaW5zZXJ0QWZ0ZXIoIHRoaXMuJGlucHV0IClcblx0XHRcdC5hdHRyKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKVxuXHRcdFx0LmFkZENsYXNzKCAnb28tdWktZWxlbWVudC1oaWRkZW4nICk7XG5cdH1cblxuXHQvLyBFdmVudHNcblx0dGhpcy5jb25uZWN0KCB0aGlzLCB7XG5cdFx0Y2hhbmdlOiAnb25DaGFuZ2UnXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHRpZiAoIGNvbmZpZy5yb3dzICkge1xuXHRcdHRoaXMuJGlucHV0LmF0dHIoICdyb3dzJywgY29uZmlnLnJvd3MgKTtcblx0fVxuXHRpZiAoIHRoaXMuYXV0b3NpemUgKSB7XG5cdFx0dGhpcy4kaW5wdXQuYWRkQ2xhc3MoICdvby11aS10ZXh0SW5wdXRXaWRnZXQtYXV0b3NpemVkJyApO1xuXHRcdHRoaXMuaXNXYWl0aW5nVG9CZUF0dGFjaGVkID0gdHJ1ZTtcblx0XHR0aGlzLmluc3RhbGxQYXJlbnRDaGFuZ2VEZXRlY3RvcigpO1xuXHR9XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldCwgT08udWkuVGV4dElucHV0V2lkZ2V0ICk7XG5cbi8qIFN0YXRpYyBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuTXVsdGlsaW5lVGV4dElucHV0V2lkZ2V0LnN0YXRpYy5nYXRoZXJQcmVJbmZ1c2VTdGF0ZSA9IGZ1bmN0aW9uICggbm9kZSwgY29uZmlnICkge1xuXHR2YXIgc3RhdGUgPSBPTy51aS5NdWx0aWxpbmVUZXh0SW5wdXRXaWRnZXQucGFyZW50LnN0YXRpYy5nYXRoZXJQcmVJbmZ1c2VTdGF0ZSggbm9kZSwgY29uZmlnICk7XG5cdHN0YXRlLnNjcm9sbFRvcCA9IGNvbmZpZy4kaW5wdXQuc2Nyb2xsVG9wKCk7XG5cdHJldHVybiBzdGF0ZTtcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NdWx0aWxpbmVUZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLm9uRWxlbWVudEF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkuTXVsdGlsaW5lVGV4dElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUub25FbGVtZW50QXR0YWNoLmNhbGwoIHRoaXMgKTtcblx0dGhpcy5hZGp1c3RTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2UgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuYWRqdXN0U2l6ZSgpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NdWx0aWxpbmVUZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS5NdWx0aWxpbmVUZXh0SW5wdXRXaWRnZXQucGFyZW50LnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbi5jYWxsKCB0aGlzICk7XG5cdHRoaXMuYWRqdXN0U2l6ZSgpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICpcbiAqIE1vZGlmeSB0byBlbWl0ICdlbnRlcicgb24gQ3RybC9NZXRhK0VudGVyLCBpbnN0ZWFkIG9mIHBsYWluIEVudGVyXG4gKi9cbk9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKFxuXHRcdCggZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiAmJiAoIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgKSApIHx8XG5cdFx0Ly8gU29tZSBwbGF0Zm9ybXMgZW1pdCBrZXljb2RlIDEwIGZvciBjdHJsK2VudGVyIGluIGEgdGV4dGFyZWFcblx0XHRlLndoaWNoID09PSAxMFxuXHQpIHtcblx0XHR0aGlzLmVtaXQoICdlbnRlcicsIGUgKTtcblx0fVxufTtcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZSBvZiB0aGUgdGV4dCBpbnB1dC5cbiAqXG4gKiBUaGlzIG9ubHkgYWZmZWN0cyBtdWx0aWxpbmUgaW5wdXRzIHRoYXQgYXJlIHtAbGluayAjYXV0b3NpemUgYXV0b3NpemVkfS5cbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICogQGZpcmVzIHJlc2l6ZVxuICovXG5PTy51aS5NdWx0aWxpbmVUZXh0SW5wdXRXaWRnZXQucHJvdG90eXBlLmFkanVzdFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzY3JvbGxIZWlnaHQsIGlubmVySGVpZ2h0LCBvdXRlckhlaWdodCwgbWF4SW5uZXJIZWlnaHQsIG1lYXN1cmVtZW50RXJyb3IsXG5cdFx0aWRlYWxIZWlnaHQsIG5ld0hlaWdodCwgc2Nyb2xsV2lkdGgsIHByb3BlcnR5O1xuXG5cdGlmICggdGhpcy4kaW5wdXQudmFsKCkgIT09IHRoaXMudmFsQ2FjaGUgKSB7XG5cdFx0aWYgKCB0aGlzLmF1dG9zaXplICkge1xuXHRcdFx0dGhpcy4kY2xvbmVcblx0XHRcdFx0LnZhbCggdGhpcy4kaW5wdXQudmFsKCkgKVxuXHRcdFx0XHQuYXR0ciggJ3Jvd3MnLCB0aGlzLm1pblJvd3MgKVxuXHRcdFx0XHQvLyBTZXQgaW5saW5lIGhlaWdodCBwcm9wZXJ0eSB0byAwIHRvIG1lYXN1cmUgc2Nyb2xsIGhlaWdodFxuXHRcdFx0XHQuY3NzKCAnaGVpZ2h0JywgMCApO1xuXG5cdFx0XHR0aGlzLiRjbG9uZS5yZW1vdmVDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXG5cdFx0XHR0aGlzLnZhbENhY2hlID0gdGhpcy4kaW5wdXQudmFsKCk7XG5cblx0XHRcdHNjcm9sbEhlaWdodCA9IHRoaXMuJGNsb25lWyAwIF0uc2Nyb2xsSGVpZ2h0O1xuXG5cdFx0XHQvLyBSZW1vdmUgaW5saW5lIGhlaWdodCBwcm9wZXJ0eSB0byBtZWFzdXJlIG5hdHVyYWwgaGVpZ2h0c1xuXHRcdFx0dGhpcy4kY2xvbmUuY3NzKCAnaGVpZ2h0JywgJycgKTtcblx0XHRcdGlubmVySGVpZ2h0ID0gdGhpcy4kY2xvbmUuaW5uZXJIZWlnaHQoKTtcblx0XHRcdG91dGVySGVpZ2h0ID0gdGhpcy4kY2xvbmUub3V0ZXJIZWlnaHQoKTtcblxuXHRcdFx0Ly8gTWVhc3VyZSBtYXggcm93cyBoZWlnaHRcblx0XHRcdHRoaXMuJGNsb25lXG5cdFx0XHRcdC5hdHRyKCAncm93cycsIHRoaXMubWF4Um93cyApXG5cdFx0XHRcdC5jc3MoICdoZWlnaHQnLCAnYXV0bycgKVxuXHRcdFx0XHQudmFsKCAnJyApO1xuXHRcdFx0bWF4SW5uZXJIZWlnaHQgPSB0aGlzLiRjbG9uZS5pbm5lckhlaWdodCgpO1xuXG5cdFx0XHQvLyBEaWZmZXJlbmNlIGJldHdlZW4gcmVwb3J0ZWQgaW5uZXJIZWlnaHQgYW5kIHNjcm9sbEhlaWdodCB3aXRoIG5vIHNjcm9sbGJhcnMgcHJlc2VudC5cblx0XHRcdC8vIFRoaXMgaXMgc29tZXRpbWVzIG5vbi16ZXJvIG9uIEJsaW5rLWJhc2VkIGJyb3dzZXJzLCBkZXBlbmRpbmcgb24gem9vbSBsZXZlbC5cblx0XHRcdG1lYXN1cmVtZW50RXJyb3IgPSBtYXhJbm5lckhlaWdodCAtIHRoaXMuJGNsb25lWyAwIF0uc2Nyb2xsSGVpZ2h0O1xuXHRcdFx0aWRlYWxIZWlnaHQgPSBNYXRoLm1pbiggbWF4SW5uZXJIZWlnaHQsIHNjcm9sbEhlaWdodCArIG1lYXN1cmVtZW50RXJyb3IgKTtcblxuXHRcdFx0dGhpcy4kY2xvbmUuYWRkQ2xhc3MoICdvby11aS1lbGVtZW50LWhpZGRlbicgKTtcblxuXHRcdFx0Ly8gT25seSBhcHBseSBpbmxpbmUgaGVpZ2h0IHdoZW4gZXhwYW5zaW9uIGJleW9uZCBuYXR1cmFsIGhlaWdodCBpcyBuZWVkZWRcblx0XHRcdC8vIFVzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBpbm5lciBhbmQgb3V0ZXIgaGVpZ2h0IGFzIGEgYnVmZmVyXG5cdFx0XHRuZXdIZWlnaHQgPSBpZGVhbEhlaWdodCA+IGlubmVySGVpZ2h0ID8gaWRlYWxIZWlnaHQgKyAoIG91dGVySGVpZ2h0IC0gaW5uZXJIZWlnaHQgKSA6ICcnO1xuXHRcdFx0aWYgKCBuZXdIZWlnaHQgIT09IHRoaXMuc3R5bGVIZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LmNzcyggJ2hlaWdodCcsIG5ld0hlaWdodCApO1xuXHRcdFx0XHR0aGlzLnN0eWxlSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdFx0XHR0aGlzLmVtaXQoICdyZXNpemUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNjcm9sbFdpZHRoID0gdGhpcy4kaW5wdXRbIDAgXS5vZmZzZXRXaWR0aCAtIHRoaXMuJGlucHV0WyAwIF0uY2xpZW50V2lkdGg7XG5cdFx0aWYgKCBzY3JvbGxXaWR0aCAhPT0gdGhpcy5zY3JvbGxXaWR0aCApIHtcblx0XHRcdHByb3BlcnR5ID0gdGhpcy4kZWxlbWVudC5jc3MoICdkaXJlY3Rpb24nICkgPT09ICdydGwnID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdC8vIFJlc2V0XG5cdFx0XHR0aGlzLiRsYWJlbC5jc3MoIHsgcmlnaHQ6ICcnLCBsZWZ0OiAnJyB9ICk7XG5cdFx0XHR0aGlzLiRpbmRpY2F0b3IuY3NzKCB7IHJpZ2h0OiAnJywgbGVmdDogJycgfSApO1xuXG5cdFx0XHRpZiAoIHNjcm9sbFdpZHRoICkge1xuXHRcdFx0XHR0aGlzLiRpbmRpY2F0b3IuY3NzKCBwcm9wZXJ0eSwgc2Nyb2xsV2lkdGggKTtcblx0XHRcdFx0aWYgKCB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdhZnRlcicgKSB7XG5cdFx0XHRcdFx0dGhpcy4kbGFiZWwuY3NzKCBwcm9wZXJ0eSwgc2Nyb2xsV2lkdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFdpZHRoID0gc2Nyb2xsV2lkdGg7XG5cdFx0XHR0aGlzLnBvc2l0aW9uTGFiZWwoKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJCggJzx0ZXh0YXJlYT4nICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbnB1dCBhdXRvbWF0aWNhbGx5IGFkanVzdHMgaXRzIHNpemUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT08udWkuTXVsdGlsaW5lVGV4dElucHV0V2lkZ2V0LnByb3RvdHlwZS5pc0F1dG9zaXppbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAhIXRoaXMuYXV0b3NpemU7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk11bHRpbGluZVRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUucmVzdG9yZVByZUluZnVzZVN0YXRlID0gZnVuY3Rpb24gKCBzdGF0ZSApIHtcblx0T08udWkuTXVsdGlsaW5lVGV4dElucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUucmVzdG9yZVByZUluZnVzZVN0YXRlLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cdGlmICggc3RhdGUuc2Nyb2xsVG9wICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy4kaW5wdXQuc2Nyb2xsVG9wKCBzdGF0ZS5zY3JvbGxUb3AgKTtcblx0fVxufTtcblxuLyoqXG4gKiBDb21ib0JveElucHV0V2lkZ2V0cyBjb21iaW5lIGEge0BsaW5rIE9PLnVpLlRleHRJbnB1dFdpZGdldCB0ZXh0IGlucHV0fSAod2hlcmUgYSB2YWx1ZVxuICogY2FuIGJlIGVudGVyZWQgbWFudWFsbHkpIGFuZCBhIHtAbGluayBPTy51aS5NZW51U2VsZWN0V2lkZ2V0IG1lbnUgb2Ygb3B0aW9uc30gKGZyb20gd2hpY2hcbiAqIGEgdmFsdWUgY2FuIGJlIGNob3NlbiBpbnN0ZWFkKS4gVXNlcnMgY2FuIGNob29zZSBvcHRpb25zIGZyb20gdGhlIGNvbWJvIGJveCBpbiBvbmUgb2YgdHdvIHdheXM6XG4gKlxuICogLSBieSB0eXBpbmcgYSB2YWx1ZSBpbiB0aGUgdGV4dCBpbnB1dCBmaWVsZC4gSWYgdGhlIHZhbHVlIGV4YWN0bHkgbWF0Y2hlcyB0aGUgdmFsdWUgb2YgYSBtZW51XG4gKiAgIG9wdGlvbiwgdGhhdCBvcHRpb24gd2lsbCBhcHBlYXIgdG8gYmUgc2VsZWN0ZWQuXG4gKiAtIGJ5IGNob29zaW5nIGEgdmFsdWUgZnJvbSB0aGUgbWVudS4gVGhlIHZhbHVlIG9mIHRoZSBjaG9zZW4gb3B0aW9uIHdpbGwgdGhlbiBhcHBlYXIgaW4gdGhlIHRleHRcbiAqICAgaW5wdXQgZmllbGQuXG4gKlxuICogQWZ0ZXIgdGhlIHVzZXIgY2hvb3NlcyBhbiBvcHRpb24sIGl0cyBgZGF0YWAgd2lsbCBiZSB1c2VkIGFzIGEgbmV3IHZhbHVlIGZvciB0aGUgd2lkZ2V0LlxuICogQSBgbGFiZWxgIGFsc28gY2FuIGJlIHNwZWNpZmllZCBmb3IgZWFjaCBvcHRpb246IGlmIGdpdmVuLCBpdCB3aWxsIGJlIHNob3duIGluc3RlYWQgb2YgdGhlXG4gKiBgZGF0YWAgaW4gdGhlIGRyb3Bkb3duIG1lbnUuXG4gKlxuICogVGhpcyB3aWRnZXQgY2FuIGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZm9ybSwgc3VjaCBhcyBhIE9PLnVpLkZvcm1MYXlvdXQuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgbWVudXMgYW5kIG9wdGlvbnMsIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIENvbWJvQm94SW5wdXRXaWRnZXQuXG4gKiAgICAgdmFyIGNvbWJvQm94ID0gbmV3IE9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgdmFsdWU6ICdPcHRpb24gMScsXG4gKiAgICAgICAgIG9wdGlvbnM6IFtcbiAqICAgICAgICAgICAgIHsgZGF0YTogJ09wdGlvbiAxJyB9LFxuICogICAgICAgICAgICAgeyBkYXRhOiAnT3B0aW9uIDInIH0sXG4gKiAgICAgICAgICAgICB7IGRhdGE6ICdPcHRpb24gMycgfVxuICogICAgICAgICBdXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGNvbWJvQm94LiRlbGVtZW50ICk7XG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZTogQSBDb21ib0JveElucHV0V2lkZ2V0IHdpdGggYWRkaXRpb25hbCBvcHRpb24gbGFiZWxzLlxuICogICAgIHZhciBjb21ib0JveCA9IG5ldyBPTy51aS5Db21ib0JveElucHV0V2lkZ2V0KCB7XG4gKiAgICAgICAgIHZhbHVlOiAnT3B0aW9uIDEnLFxuICogICAgICAgICBvcHRpb25zOiBbXG4gKiAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgZGF0YTogJ09wdGlvbiAxJyxcbiAqICAgICAgICAgICAgICAgICBsYWJlbDogJ09wdGlvbiBPbmUnXG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIGRhdGE6ICdPcHRpb24gMicsXG4gKiAgICAgICAgICAgICAgICAgbGFiZWw6ICdPcHRpb24gVHdvJ1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICBkYXRhOiAnT3B0aW9uIDMnLFxuICogICAgICAgICAgICAgICAgIGxhYmVsOiAnT3B0aW9uIFRocmVlJ1xuICogICAgICAgICAgICAgfVxuICogICAgICAgICBdXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGNvbWJvQm94LiRlbGVtZW50ICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL1NlbGVjdHNfYW5kX09wdGlvbnMjTWVudV9zZWxlY3RzX2FuZF9vcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5UZXh0SW5wdXRXaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge09iamVjdFtdfSBbb3B0aW9ucz1bXV0gQXJyYXkgb2YgbWVudSBvcHRpb25zIGluIHRoZSBmb3JtYXQgYHsgZGF0YTog4oCmLCBsYWJlbDog4oCmIH1gXG4gKiBAY2ZnIHtPYmplY3R9IFttZW51XSBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUge0BsaW5rIE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQgbWVudSBzZWxlY3Qgd2lkZ2V0fS5cbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBSZW5kZXIgdGhlIG1lbnUgaW50byBhIHNlcGFyYXRlIGxheWVyLiBUaGlzIGNvbmZpZ3VyYXRpb24gaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gKiAgdGhlIGV4cGFuZGVkIG1lbnUgaXMgbGFyZ2VyIHRoYW4gaXRzIGNvbnRhaW5pbmcgYDxkaXY+YC4gVGhlIHNwZWNpZmllZCBvdmVybGF5IGxheWVyIGlzIHVzdWFsbHkgb24gdG9wIG9mIHRoZVxuICogIGNvbnRhaW5pbmcgYDxkaXY+YCBhbmQgaGFzIGEgbGFyZ2VyIGFyZWEuIEJ5IGRlZmF1bHQsIHRoZSBtZW51IHVzZXMgcmVsYXRpdmUgcG9zaXRpb25pbmcuXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKi9cbk9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQgPSBmdW5jdGlvbiBPb1VpQ29tYm9Cb3hJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7XG5cdFx0YXV0b2NvbXBsZXRlOiBmYWxzZVxuXHR9LCBjb25maWcgKTtcblxuXHQvLyBDb21ib0JveElucHV0V2lkZ2V0IHNob3VsZG4ndCBzdXBwb3J0IGBtdWx0aWxpbmVgXG5cdGNvbmZpZy5tdWx0aWxpbmUgPSBmYWxzZTtcblxuXHQvLyBTZWUgSW5wdXRXaWRnZXQjcmV1c2VQcmVJbmZ1c2VET00gYWJvdXQgYGNvbmZpZy4kaW5wdXRgXG5cdGlmICggY29uZmlnLiRpbnB1dCApIHtcblx0XHRjb25maWcuJGlucHV0LnJlbW92ZUF0dHIoICdsaXN0JyApO1xuXHR9XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kb3ZlcmxheSA9ICggY29uZmlnLiRvdmVybGF5ID09PSB0cnVlID8gT08udWkuZ2V0RGVmYXVsdE92ZXJsYXkoKSA6IGNvbmZpZy4kb3ZlcmxheSApIHx8IHRoaXMuJGVsZW1lbnQ7XG5cdHRoaXMuZHJvcGRvd25CdXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG5cdFx0Y2xhc3NlczogWyAnb28tdWktY29tYm9Cb3hJbnB1dFdpZGdldC1kcm9wZG93bkJ1dHRvbicgXSxcblx0XHRsYWJlbDogT08udWkubXNnKCAnb291aS1jb21ib2JveC1idXR0b24tbGFiZWwnICksXG5cdFx0aW5kaWNhdG9yOiAnZG93bicsXG5cdFx0aW52aXNpYmxlTGFiZWw6IHRydWUsXG5cdFx0ZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcblx0fSApO1xuXHR0aGlzLm1lbnUgPSBuZXcgT08udWkuTWVudVNlbGVjdFdpZGdldCggJC5leHRlbmQoXG5cdFx0e1xuXHRcdFx0d2lkZ2V0OiB0aGlzLFxuXHRcdFx0aW5wdXQ6IHRoaXMsXG5cdFx0XHQkZmxvYXRhYmxlQ29udGFpbmVyOiB0aGlzLiRlbGVtZW50LFxuXHRcdFx0ZGlzYWJsZWQ6IHRoaXMuaXNEaXNhYmxlZCgpXG5cdFx0fSxcblx0XHRjb25maWcubWVudVxuXHQpICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuY29ubmVjdCggdGhpcywge1xuXHRcdGNoYW5nZTogJ29uSW5wdXRDaGFuZ2UnLFxuXHRcdGVudGVyOiAnb25JbnB1dEVudGVyJ1xuXHR9ICk7XG5cdHRoaXMuZHJvcGRvd25CdXR0b24uY29ubmVjdCggdGhpcywge1xuXHRcdGNsaWNrOiAnb25Ecm9wZG93bkJ1dHRvbkNsaWNrJ1xuXHR9ICk7XG5cdHRoaXMubWVudS5jb25uZWN0KCB0aGlzLCB7XG5cdFx0Y2hvb3NlOiAnb25NZW51Q2hvb3NlJyxcblx0XHRhZGQ6ICdvbk1lbnVJdGVtc0NoYW5nZScsXG5cdFx0cmVtb3ZlOiAnb25NZW51SXRlbXNDaGFuZ2UnLFxuXHRcdHRvZ2dsZTogJ29uTWVudVRvZ2dsZSdcblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGlucHV0LmF0dHIoIHtcblx0XHRyb2xlOiAnY29tYm9ib3gnLFxuXHRcdCdhcmlhLW93bnMnOiB0aGlzLm1lbnUuZ2V0RWxlbWVudElkKCksXG5cdFx0J2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnXG5cdH0gKTtcblx0dGhpcy5kcm9wZG93bkJ1dHRvbi4kYnV0dG9uLmF0dHIoIHtcblx0XHQnYXJpYS1jb250cm9scyc6IHRoaXMubWVudS5nZXRFbGVtZW50SWQoKVxuXHR9ICk7XG5cdC8vIERvIG5vdCBvdmVycmlkZSBvcHRpb25zIHNldCB2aWEgY29uZmlnLm1lbnUuaXRlbXNcblx0aWYgKCBjb25maWcub3B0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXMuc2V0T3B0aW9ucyggY29uZmlnLm9wdGlvbnMgKTtcblx0fVxuXHR0aGlzLiRmaWVsZCA9ICQoICc8ZGl2PicgKVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWNvbWJvQm94SW5wdXRXaWRnZXQtZmllbGQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRpbnB1dCwgdGhpcy5kcm9wZG93bkJ1dHRvbi4kZWxlbWVudCApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktY29tYm9Cb3hJbnB1dFdpZGdldCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGZpZWxkICk7XG5cdHRoaXMuJG92ZXJsYXkuYXBwZW5kKCB0aGlzLm1lbnUuJGVsZW1lbnQgKTtcblx0dGhpcy5vbk1lbnVJdGVtc0NoYW5nZSgpO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Db21ib0JveElucHV0V2lkZ2V0LCBPTy51aS5UZXh0SW5wdXRXaWRnZXQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEdldCB0aGUgY29tYm9ib3gncyBtZW51LlxuICpcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVTZWxlY3RXaWRnZXR9IE1lbnUgd2lkZ2V0XG4gKi9cbk9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQucHJvdG90eXBlLmdldE1lbnUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1lbnU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29tYm9ib3gncyB0ZXh0IGlucHV0IHdpZGdldC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5UZXh0SW5wdXRXaWRnZXR9IFRleHQgaW5wdXQgd2lkZ2V0XG4gKi9cbk9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGFuZGxlIGlucHV0IGNoYW5nZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBOZXcgdmFsdWVcbiAqL1xuT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldC5wcm90b3R5cGUub25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdHZhciBtYXRjaCA9IHRoaXMubWVudS5maW5kSXRlbUZyb21EYXRhKCB2YWx1ZSApO1xuXG5cdHRoaXMubWVudS5zZWxlY3RJdGVtKCBtYXRjaCApO1xuXHRpZiAoIHRoaXMubWVudS5maW5kSGlnaGxpZ2h0ZWRJdGVtKCkgKSB7XG5cdFx0dGhpcy5tZW51LmhpZ2hsaWdodEl0ZW0oIG1hdGNoICk7XG5cdH1cblxuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHR0aGlzLm1lbnUudG9nZ2xlKCB0cnVlICk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGlucHV0IGVudGVyIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Db21ib0JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbklucHV0RW50ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdHRoaXMubWVudS50b2dnbGUoIGZhbHNlICk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGJ1dHRvbiBjbGljayBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldC5wcm90b3R5cGUub25Ecm9wZG93bkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLm1lbnUudG9nZ2xlKCk7XG5cdHRoaXMuZm9jdXMoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1lbnUgY2hvb3NlIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR9IGl0ZW0gQ2hvc2VuIGl0ZW1cbiAqL1xuT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldC5wcm90b3R5cGUub25NZW51Q2hvb3NlID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR0aGlzLnNldFZhbHVlKCBpdGVtLmdldERhdGEoKSApO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgbWVudSBpdGVtIGNoYW5nZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldC5wcm90b3R5cGUub25NZW51SXRlbXNDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXRjaCA9IHRoaXMubWVudS5maW5kSXRlbUZyb21EYXRhKCB0aGlzLmdldFZhbHVlKCkgKTtcblx0dGhpcy5tZW51LnNlbGVjdEl0ZW0oIG1hdGNoICk7XG5cdGlmICggdGhpcy5tZW51LmZpbmRIaWdobGlnaHRlZEl0ZW0oKSApIHtcblx0XHR0aGlzLm1lbnUuaGlnaGxpZ2h0SXRlbSggbWF0Y2ggKTtcblx0fVxuXHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCAnb28tdWktY29tYm9Cb3hJbnB1dFdpZGdldC1lbXB0eScsIHRoaXMubWVudS5pc0VtcHR5KCkgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1lbnUgdG9nZ2xlIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGUgT3BlbiBzdGF0ZSBvZiB0aGUgbWVudVxuICovXG5PTy51aS5Db21ib0JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5vbk1lbnVUb2dnbGUgPSBmdW5jdGlvbiAoIGlzVmlzaWJsZSApIHtcblx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLWNvbWJvQm94SW5wdXRXaWRnZXQtb3BlbicsIGlzVmlzaWJsZSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Db21ib0JveElucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggZGlzYWJsZWQgKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldC5wYXJlbnQucHJvdG90eXBlLnNldERpc2FibGVkLmNhbGwoIHRoaXMsIGRpc2FibGVkICk7XG5cblx0aWYgKCB0aGlzLmRyb3Bkb3duQnV0dG9uICkge1xuXHRcdHRoaXMuZHJvcGRvd25CdXR0b24uc2V0RGlzYWJsZWQoIHRoaXMuaXNEaXNhYmxlZCgpICk7XG5cdH1cblx0aWYgKCB0aGlzLm1lbnUgKSB7XG5cdFx0dGhpcy5tZW51LnNldERpc2FibGVkKCB0aGlzLmlzRGlzYWJsZWQoKSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoaXMgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucyBBcnJheSBvZiBtZW51IG9wdGlvbnMgaW4gdGhlIGZvcm1hdCBgeyBkYXRhOiDigKYsIGxhYmVsOiDigKYgfWBcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkNvbWJvQm94SW5wdXRXaWRnZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cdHRoaXMuZ2V0TWVudSgpXG5cdFx0LmNsZWFySXRlbXMoKVxuXHRcdC5hZGRJdGVtcyggb3B0aW9ucy5tYXAoIGZ1bmN0aW9uICggb3B0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBPTy51aS5NZW51T3B0aW9uV2lkZ2V0KCB7XG5cdFx0XHRcdGRhdGE6IG9wdC5kYXRhLFxuXHRcdFx0XHRsYWJlbDogb3B0LmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHQubGFiZWwgOiBvcHQuZGF0YVxuXHRcdFx0fSApO1xuXHRcdH0gKSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaWVsZExheW91dHMgYXJlIHVzZWQgd2l0aCBPTy51aS5GaWVsZHNldExheW91dC4gRWFjaCBGaWVsZExheW91dCByZXF1aXJlcyBhIGZpZWxkLXdpZGdldCxcbiAqIHdoaWNoIGlzIGEgd2lkZ2V0IHRoYXQgaXMgc3BlY2lmaWVkIGJ5IHJlZmVyZW5jZSBiZWZvcmUgYW55IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gKlxuICogRmllbGQgbGF5b3V0cyBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGhlbHAgdGV4dCBhbmQvb3IgbGFiZWxzLiBMYWJlbHMgYXJlIGFsaWduZWQgaW4gb25lIG9mIGZvdXIgd2F5czpcbiAqXG4gKiAtICoqbGVmdCoqOiBUaGUgbGFiZWwgaXMgcGxhY2VkIGJlZm9yZSB0aGUgZmllbGQtd2lkZ2V0IGFuZCBhbGlnbmVkIHdpdGggdGhlIGxlZnQgbWFyZ2luLlxuICogICBBIGxlZnQtYWxpZ25tZW50IGlzIHVzZWQgZm9yIGZvcm1zIHdpdGggbWFueSBmaWVsZHMuXG4gKiAtICoqcmlnaHQqKjogVGhlIGxhYmVsIGlzIHBsYWNlZCBiZWZvcmUgdGhlIGZpZWxkLXdpZGdldCBhbmQgYWxpZ25lZCB0byB0aGUgcmlnaHQgbWFyZ2luLlxuICogICBBIHJpZ2h0LWFsaWdubWVudCBpcyB1c2VkIGZvciBsb25nIGJ1dCBmYW1pbGlhciBmb3JtcyB3aGljaCB1c2VycyB0YWIgdGhyb3VnaCxcbiAqICAgdmVyaWZ5aW5nIHRoZSBjdXJyZW50IGZpZWxkIHdpdGggYSBxdWljayBnbGFuY2UgYXQgdGhlIGxhYmVsLlxuICogLSAqKnRvcCoqOiBUaGUgbGFiZWwgaXMgcGxhY2VkIGFib3ZlIHRoZSBmaWVsZC13aWRnZXQuIEEgdG9wLWFsaWdubWVudCBpcyB1c2VkIGZvciBicmllZiBmb3Jtc1xuICogICB0aGF0IHVzZXJzIGZpbGwgb3V0IGZyb20gdG9wIHRvIGJvdHRvbS5cbiAqIC0gKippbmxpbmUqKjogVGhlIGxhYmVsIGlzIHBsYWNlZCBhZnRlciB0aGUgZmllbGQtd2lkZ2V0IGFuZCBhbGlnbmVkIHRvIHRoZSBsZWZ0LlxuICogICBBbiBpbmxpbmUtYWxpZ25tZW50IGlzIGJlc3QgdXNlZCB3aXRoIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucy5cbiAqXG4gKiBIZWxwIHRleHQgY2FuIGVpdGhlciBiZTpcbiAqXG4gKiAtIGFjY2Vzc2VkIHZpYSBhIGhlbHAgaWNvbiB0aGF0IGFwcGVhcnMgaW4gdGhlIHVwcGVyIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVuZGVyZWQgZmllbGQgbGF5b3V0LCBvclxuICogLSBzaG93biBhcyBhIHN1YnRsZSBleHBsYW5hdGlvbiBiZWxvdyB0aGUgbGFiZWwuXG4gKlxuICogSWYgdGhlIGhlbHAgdGV4dCBpcyBicmllZiwgb3IgaXMgZXNzZW50aWFsIHRvIGFsd2F5cyBleHBvc2UgaXQsIHNldCBgaGVscElubGluZWAgdG8gYHRydWVgLiBJZiBpdFxuICogaXMgbG9uZyBvciBub3QgZXNzZW50aWFsLCBsZWF2ZSBgaGVscElubGluZWAgdG8gaXRzIGRlZmF1bHQsIGBmYWxzZWAuXG4gKlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgZXhhbXBsZXMgYW5kIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9MYXlvdXRzL0ZpZWxkc19hbmRfRmllbGRzZXRzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5MYXlvdXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uTGFiZWxFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T08udWkuV2lkZ2V0fSBmaWVsZFdpZGdldCBGaWVsZCB3aWRnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ30gW2FsaWduPSdsZWZ0J10gQWxpZ25tZW50IG9mIHRoZSBsYWJlbDogJ2xlZnQnLCAncmlnaHQnLCAndG9wJ1xuICogIG9yICdpbmxpbmUnXG4gKiBAY2ZnIHtBcnJheX0gW2Vycm9yc10gRXJyb3IgbWVzc2FnZXMgYWJvdXQgdGhlIHdpZGdldCwgd2hpY2ggd2lsbCBiZVxuICogIGRpc3BsYXllZCBiZWxvdyB0aGUgd2lkZ2V0LlxuICogIFRoZSBhcnJheSBtYXkgY29udGFpbiBzdHJpbmdzIG9yIE9PLnVpLkh0bWxTbmlwcGV0IGluc3RhbmNlcy5cbiAqIEBjZmcge0FycmF5fSBbbm90aWNlc10gTm90aWNlcyBhYm91dCB0aGUgd2lkZ2V0LCB3aGljaCB3aWxsIGJlIGRpc3BsYXllZFxuICogIGJlbG93IHRoZSB3aWRnZXQuXG4gKiAgVGhlIGFycmF5IG1heSBjb250YWluIHN0cmluZ3Mgb3IgT08udWkuSHRtbFNuaXBwZXQgaW5zdGFuY2VzLlxuICogIFRoZXNlIGFyZSBtb3JlIHZpc2libGUgdGhhbiBgaGVscGAgbWVzc2FnZXMgd2hlbiBgaGVscElubGluZWAgaXMgc2V0LCBhbmQgc29cbiAqICBtaWdodCBiZSBnb29kIGZvciB0cmFuc2llbnQgbWVzc2FnZXMuXG4gKiBAY2ZnIHtzdHJpbmd8T08udWkuSHRtbFNuaXBwZXR9IFtoZWxwXSBIZWxwIHRleHQuIFdoZW4gaGVscCB0ZXh0IGlzIHNwZWNpZmllZFxuICogIGFuZCBgaGVscElubGluZWAgaXMgYGZhbHNlYCwgYSBcImhlbHBcIiBpY29uIHdpbGwgYXBwZWFyIGluIHRoZSB1cHBlci1yaWdodFxuICogIGNvcm5lciBvZiB0aGUgcmVuZGVyZWQgZmllbGQ7IGNsaWNraW5nIGl0IHdpbGwgZGlzcGxheSB0aGUgdGV4dCBpbiBhIHBvcHVwLlxuICogIElmIGBoZWxwSW5saW5lYCBpcyBgdHJ1ZWAsIHRoZW4gYSBzdWJ0bGUgZGVzY3JpcHRpb24gd2lsbCBiZSBzaG93biBhZnRlciB0aGVcbiAqICBsYWJlbC5cbiAqIEBjZmcge2Jvb2xlYW59IFtoZWxwSW5saW5lPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0aGUgaGVscCBzaG91bGQgYmUgaW5saW5lLFxuICogIG9yIHNob3duIHdoZW4gdGhlIFwiaGVscFwiIGljb24gaXMgY2xpY2tlZC5cbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBQYXNzZWQgdG8gT08udWkuUG9wdXBCdXR0b25XaWRnZXQgZm9yIGhlbHAgcG9wdXAsIGlmXG4gKiBgaGVscGAgaXMgZ2l2ZW4uXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiBubyB3aWRnZXQgaXMgc3BlY2lmaWVkXG4gKi9cbk9PLnVpLkZpZWxkTGF5b3V0ID0gZnVuY3Rpb24gT29VaUZpZWxkTGF5b3V0KCBmaWVsZFdpZGdldCwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCBmaWVsZFdpZGdldCApICYmIGNvbmZpZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGNvbmZpZyA9IGZpZWxkV2lkZ2V0O1xuXHRcdGZpZWxkV2lkZ2V0ID0gY29uZmlnLmZpZWxkV2lkZ2V0O1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHdlIGhhdmUgcmVxdWlyZWQgY29uc3RydWN0b3IgYXJndW1lbnRzXG5cdGlmICggZmllbGRXaWRnZXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdXaWRnZXQgbm90IGZvdW5kJyApO1xuXHR9XG5cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSAkLmV4dGVuZCggeyBhbGlnbjogJ2xlZnQnLCBoZWxwSW5saW5lOiBmYWxzZSB9LCBjb25maWcgKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuRmllbGRMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHtcblx0XHQkbGFiZWw6ICQoICc8bGFiZWw+JyApXG5cdH0gKSApO1xuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICR0aXRsZWQ6IHRoaXMuJGxhYmVsIH0gKSApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5maWVsZFdpZGdldCA9IGZpZWxkV2lkZ2V0O1xuXHR0aGlzLmVycm9ycyA9IFtdO1xuXHR0aGlzLm5vdGljZXMgPSBbXTtcblx0dGhpcy4kZmllbGQgPSB0aGlzLmlzRmllbGRJbmxpbmUoKSA/ICQoICc8c3Bhbj4nICkgOiAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJG1lc3NhZ2VzID0gJCggJzx1bD4nICk7XG5cdHRoaXMuJGhlYWRlciA9ICQoICc8c3Bhbj4nICk7XG5cdHRoaXMuJGJvZHkgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuYWxpZ24gPSBudWxsO1xuXHR0aGlzLmhlbHBJbmxpbmUgPSBjb25maWcuaGVscElubGluZTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5maWVsZFdpZGdldC5jb25uZWN0KCB0aGlzLCB7IGRpc2FibGU6ICdvbkZpZWxkRGlzYWJsZScgfSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGhlbHAgPSBjb25maWcuaGVscCA/XG5cdFx0dGhpcy5jcmVhdGVIZWxwRWxlbWVudCggY29uZmlnLmhlbHAsIGNvbmZpZy4kb3ZlcmxheSApIDpcblx0XHQkKCBbXSApO1xuXHRpZiAoIHRoaXMuZmllbGRXaWRnZXQuZ2V0SW5wdXRJZCgpICkge1xuXHRcdHRoaXMuJGxhYmVsLmF0dHIoICdmb3InLCB0aGlzLmZpZWxkV2lkZ2V0LmdldElucHV0SWQoKSApO1xuXHRcdGlmICggdGhpcy5oZWxwSW5saW5lICkge1xuXHRcdFx0dGhpcy4kaGVscC5hdHRyKCAnZm9yJywgdGhpcy5maWVsZFdpZGdldC5nZXRJbnB1dElkKCkgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kbGFiZWwub24oICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZmllbGRXaWRnZXQuc2ltdWxhdGVMYWJlbENsaWNrKCk7XG5cdFx0fS5iaW5kKCB0aGlzICkgKTtcblx0XHRpZiAoIHRoaXMuaGVscElubGluZSApIHtcblx0XHRcdHRoaXMuJGhlbHAub24oICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5maWVsZFdpZGdldC5zaW11bGF0ZUxhYmVsQ2xpY2soKTtcblx0XHRcdH0uYmluZCggdGhpcyApICk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1maWVsZExheW91dCcgKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLWZpZWxkTGF5b3V0LWRpc2FibGVkJywgdGhpcy5maWVsZFdpZGdldC5pc0Rpc2FibGVkKCkgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGJvZHkgKTtcblx0dGhpcy4kYm9keS5hZGRDbGFzcyggJ29vLXVpLWZpZWxkTGF5b3V0LWJvZHknICk7XG5cdHRoaXMuJGhlYWRlci5hZGRDbGFzcyggJ29vLXVpLWZpZWxkTGF5b3V0LWhlYWRlcicgKTtcblx0dGhpcy4kbWVzc2FnZXMuYWRkQ2xhc3MoICdvby11aS1maWVsZExheW91dC1tZXNzYWdlcycgKTtcblx0dGhpcy4kZmllbGRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1maWVsZExheW91dC1maWVsZCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuZmllbGRXaWRnZXQuJGVsZW1lbnQgKTtcblxuXHR0aGlzLnNldEVycm9ycyggY29uZmlnLmVycm9ycyB8fCBbXSApO1xuXHR0aGlzLnNldE5vdGljZXMoIGNvbmZpZy5ub3RpY2VzIHx8IFtdICk7XG5cdHRoaXMuc2V0QWxpZ25tZW50KCBjb25maWcuYWxpZ24gKTtcblx0Ly8gQ2FsbCB0aGlzIGFnYWluIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSB3aWRnZXQncyBhY2Nlc3NLZXlcblx0dGhpcy51cGRhdGVUaXRsZSgpO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5GaWVsZExheW91dCwgT08udWkuTGF5b3V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5GaWVsZExheW91dCwgT08udWkubWl4aW4uTGFiZWxFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5GaWVsZExheW91dCwgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGZpZWxkIGRpc2FibGUgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIEZpZWxkIGlzIGRpc2FibGVkXG4gKi9cbk9PLnVpLkZpZWxkTGF5b3V0LnByb3RvdHlwZS5vbkZpZWxkRGlzYWJsZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1maWVsZExheW91dC1kaXNhYmxlZCcsIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgd2lkZ2V0IGNvbnRhaW5lZCBieSB0aGUgZmllbGQuXG4gKlxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBGaWVsZCB3aWRnZXRcbiAqL1xuT08udWkuRmllbGRMYXlvdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5maWVsZFdpZGdldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gZmllbGQgd2lkZ2V0IGNhbiBiZSB1c2VkIHdpdGggYCdpbmxpbmUnYCBhbGlnbm1lbnQgKHNlZVxuICogI3NldEFsaWdubWVudCkuIFJldHVybiBgZmFsc2VgIGlmIGl0IGNhbid0IG9yIGlmIHRoaXMgY2FuJ3QgYmUgZGV0ZXJtaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PTy51aS5GaWVsZExheW91dC5wcm90b3R5cGUuaXNGaWVsZElubGluZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gVGhpcyBpcyB2ZXJ5IHNpbXBsaXN0aWMsIGJ1dCBzaG91bGQgYmUgZ29vZCBlbm91Z2guXG5cdHJldHVybiB0aGlzLmdldEZpZWxkKCkuJGVsZW1lbnQucHJvcCggJ3RhZ05hbWUnICkudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nO1xufTtcblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAnZXJyb3InIG9yICdub3RpY2UnXG4gKiBAcGFyYW0ge3N0cmluZ3xPTy51aS5IdG1sU25pcHBldH0gdGV4dFxuICogQHJldHVybiB7alF1ZXJ5fVxuICovXG5PTy51aS5GaWVsZExheW91dC5wcm90b3R5cGUubWFrZU1lc3NhZ2UgPSBmdW5jdGlvbiAoIGtpbmQsIHRleHQgKSB7XG5cdHZhciAkbGlzdEl0ZW0sICRpY29uLCBtZXNzYWdlO1xuXHQkbGlzdEl0ZW0gPSAkKCAnPGxpPicgKTtcblx0aWYgKCBraW5kID09PSAnZXJyb3InICkge1xuXHRcdCRpY29uID0gbmV3IE9PLnVpLkljb25XaWRnZXQoIHsgaWNvbjogJ2FsZXJ0JywgZmxhZ3M6IFsgJ3dhcm5pbmcnIF0gfSApLiRlbGVtZW50O1xuXHRcdCRsaXN0SXRlbS5hdHRyKCAncm9sZScsICdhbGVydCcgKTtcblx0fSBlbHNlIGlmICgga2luZCA9PT0gJ25vdGljZScgKSB7XG5cdFx0JGljb24gPSBuZXcgT08udWkuSWNvbldpZGdldCggeyBpY29uOiAnbm90aWNlJyB9ICkuJGVsZW1lbnQ7XG5cdH0gZWxzZSB7XG5cdFx0JGljb24gPSAnJztcblx0fVxuXHRtZXNzYWdlID0gbmV3IE9PLnVpLkxhYmVsV2lkZ2V0KCB7IGxhYmVsOiB0ZXh0IH0gKTtcblx0JGxpc3RJdGVtXG5cdFx0LmFwcGVuZCggJGljb24sIG1lc3NhZ2UuJGVsZW1lbnQgKVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWZpZWxkTGF5b3V0LW1lc3NhZ2VzLScgKyBraW5kICk7XG5cdHJldHVybiAkbGlzdEl0ZW07XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZmllbGQgYWxpZ25tZW50IG1vZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBbGlnbm1lbnQgbW9kZSwgZWl0aGVyICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcgb3IgJ2lubGluZSdcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkJvb2tsZXRMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5GaWVsZExheW91dC5wcm90b3R5cGUuc2V0QWxpZ25tZW50ID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0aWYgKCB2YWx1ZSAhPT0gdGhpcy5hbGlnbiApIHtcblx0XHQvLyBEZWZhdWx0IHRvICdsZWZ0J1xuXHRcdGlmICggWyAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnaW5saW5lJyBdLmluZGV4T2YoIHZhbHVlICkgPT09IC0xICkge1xuXHRcdFx0dmFsdWUgPSAnbGVmdCc7XG5cdFx0fVxuXHRcdC8vIFZhbGlkYXRlXG5cdFx0aWYgKCB2YWx1ZSA9PT0gJ2lubGluZScgJiYgIXRoaXMuaXNGaWVsZElubGluZSgpICkge1xuXHRcdFx0dmFsdWUgPSAndG9wJztcblx0XHR9XG5cdFx0Ly8gUmVvcmRlciBlbGVtZW50c1xuXG5cdFx0aWYgKCB0aGlzLmhlbHBJbmxpbmUgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAndG9wJyApIHtcblx0XHRcdFx0dGhpcy4kaGVhZGVyLmFwcGVuZCggdGhpcy4kbGFiZWwgKTtcblx0XHRcdFx0dGhpcy4kYm9keS5hcHBlbmQoIHRoaXMuJGhlYWRlciwgdGhpcy4kZmllbGQsIHRoaXMuJGhlbHAgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSAnaW5saW5lJyApIHtcblx0XHRcdFx0dGhpcy4kaGVhZGVyLmFwcGVuZCggdGhpcy4kbGFiZWwsIHRoaXMuJGhlbHAgKTtcblx0XHRcdFx0dGhpcy4kYm9keS5hcHBlbmQoIHRoaXMuJGZpZWxkLCB0aGlzLiRoZWFkZXIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuJGhlYWRlci5hcHBlbmQoIHRoaXMuJGxhYmVsLCB0aGlzLiRoZWxwICk7XG5cdFx0XHRcdHRoaXMuJGJvZHkuYXBwZW5kKCB0aGlzLiRoZWFkZXIsIHRoaXMuJGZpZWxkICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdmFsdWUgPT09ICd0b3AnICkge1xuXHRcdFx0XHR0aGlzLiRoZWFkZXIuYXBwZW5kKCB0aGlzLiRoZWxwLCB0aGlzLiRsYWJlbCApO1xuXHRcdFx0XHR0aGlzLiRib2R5LmFwcGVuZCggdGhpcy4kaGVhZGVyLCB0aGlzLiRmaWVsZCApO1xuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09ICdpbmxpbmUnICkge1xuXHRcdFx0XHR0aGlzLiRoZWFkZXIuYXBwZW5kKCB0aGlzLiRoZWxwLCB0aGlzLiRsYWJlbCApO1xuXHRcdFx0XHR0aGlzLiRib2R5LmFwcGVuZCggdGhpcy4kZmllbGQsIHRoaXMuJGhlYWRlciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kaGVhZGVyLmFwcGVuZCggdGhpcy4kbGFiZWwgKTtcblx0XHRcdFx0dGhpcy4kYm9keS5hcHBlbmQoIHRoaXMuJGhlYWRlciwgdGhpcy4kaGVscCwgdGhpcy4kZmllbGQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gU2V0IGNsYXNzZXMuIFRoZSBmb2xsb3dpbmcgY2xhc3NlcyBjYW4gYmUgdXNlZCBoZXJlOlxuXHRcdC8vICogb28tdWktZmllbGRMYXlvdXQtYWxpZ24tbGVmdFxuXHRcdC8vICogb28tdWktZmllbGRMYXlvdXQtYWxpZ24tcmlnaHRcblx0XHQvLyAqIG9vLXVpLWZpZWxkTGF5b3V0LWFsaWduLXRvcFxuXHRcdC8vICogb28tdWktZmllbGRMYXlvdXQtYWxpZ24taW5saW5lXG5cdFx0aWYgKCB0aGlzLmFsaWduICkge1xuXHRcdFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLWZpZWxkTGF5b3V0LWFsaWduLScgKyB0aGlzLmFsaWduICk7XG5cdFx0fVxuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1maWVsZExheW91dC1hbGlnbi0nICsgdmFsdWUgKTtcblx0XHR0aGlzLmFsaWduID0gdmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsaXN0IG9mIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGVycm9ycyBFcnJvciBtZXNzYWdlcyBhYm91dCB0aGUgd2lkZ2V0LCB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBiZWxvdyB0aGUgd2lkZ2V0LlxuICogIFRoZSBhcnJheSBtYXkgY29udGFpbiBzdHJpbmdzIG9yIE9PLnVpLkh0bWxTbmlwcGV0IGluc3RhbmNlcy5cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkJvb2tsZXRMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5GaWVsZExheW91dC5wcm90b3R5cGUuc2V0RXJyb3JzID0gZnVuY3Rpb24gKCBlcnJvcnMgKSB7XG5cdHRoaXMuZXJyb3JzID0gZXJyb3JzLnNsaWNlKCk7XG5cdHRoaXMudXBkYXRlTWVzc2FnZXMoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGlzdCBvZiBub3RpY2UgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbm90aWNlcyBOb3RpY2VzIGFib3V0IHRoZSB3aWRnZXQsIHdoaWNoIHdpbGwgYmUgZGlzcGxheWVkIGJlbG93IHRoZSB3aWRnZXQuXG4gKiAgVGhlIGFycmF5IG1heSBjb250YWluIHN0cmluZ3Mgb3IgT08udWkuSHRtbFNuaXBwZXQgaW5zdGFuY2VzLlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQm9va2xldExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkZpZWxkTGF5b3V0LnByb3RvdHlwZS5zZXROb3RpY2VzID0gZnVuY3Rpb24gKCBub3RpY2VzICkge1xuXHR0aGlzLm5vdGljZXMgPSBub3RpY2VzLnNsaWNlKCk7XG5cdHRoaXMudXBkYXRlTWVzc2FnZXMoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcmVuZGVyaW5nIG9mIGVycm9yIGFuZCBub3RpY2UgbWVzc2FnZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuRmllbGRMYXlvdXQucHJvdG90eXBlLnVwZGF0ZU1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaTtcblx0dGhpcy4kbWVzc2FnZXMuZW1wdHkoKTtcblxuXHRpZiAoIHRoaXMuZXJyb3JzLmxlbmd0aCB8fCB0aGlzLm5vdGljZXMubGVuZ3RoICkge1xuXHRcdHRoaXMuJGJvZHkuYWZ0ZXIoIHRoaXMuJG1lc3NhZ2VzICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kbWVzc2FnZXMucmVtb3ZlKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLm5vdGljZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGhpcy4kbWVzc2FnZXMuYXBwZW5kKCB0aGlzLm1ha2VNZXNzYWdlKCAnbm90aWNlJywgdGhpcy5ub3RpY2VzWyBpIF0gKSApO1xuXHR9XG5cdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5lcnJvcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGhpcy4kbWVzc2FnZXMuYXBwZW5kKCB0aGlzLm1ha2VNZXNzYWdlKCAnZXJyb3InLCB0aGlzLmVycm9yc1sgaSBdICkgKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbmNsdWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB3aWRnZXQncyBhY2Nlc3NLZXkgaW4gb3VyIHRpdGxlLiBUaXRsZWRFbGVtZW50IGNhbGxzIHRoaXMgbWV0aG9kLlxuICogKFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLilcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgVG9vbHRpcCBsYWJlbCBmb3IgJ3RpdGxlJyBhdHRyaWJ1dGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuT08udWkuRmllbGRMYXlvdXQucHJvdG90eXBlLmZvcm1hdFRpdGxlV2l0aEFjY2Vzc0tleSA9IGZ1bmN0aW9uICggdGl0bGUgKSB7XG5cdGlmICggdGhpcy5maWVsZFdpZGdldCAmJiB0aGlzLmZpZWxkV2lkZ2V0LmZvcm1hdFRpdGxlV2l0aEFjY2Vzc0tleSApIHtcblx0XHRyZXR1cm4gdGhpcy5maWVsZFdpZGdldC5mb3JtYXRUaXRsZVdpdGhBY2Nlc3NLZXkoIHRpdGxlICk7XG5cdH1cblx0cmV0dXJuIHRpdGxlO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIHRoZSBoZWxwIGVsZW1lbnQuIEFsc28gc2V0cyB0aGUgYGFyaWEtZGVzY3JpYmVkYnlgXG4gKiBhdHRyaWJ1dGUgb24gdGhlIG1haW4gZWxlbWVudCBvZiB0aGUgYGZpZWxkV2lkZ2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd8T08udWkuSHRtbFNuaXBwZXR9IFtoZWxwXSBIZWxwIHRleHQuXG4gKiBAcGFyYW0ge2pRdWVyeX0gWyRvdmVybGF5XSBQYXNzZWQgdG8gT08udWkuUG9wdXBCdXR0b25XaWRnZXQgZm9yIGhlbHAgcG9wdXAuXG4gKiBAcmV0dXJuIHtqUXVlcnl9IFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlY29tZSBgdGhpcy4kaGVscGAuXG4gKi9cbk9PLnVpLkZpZWxkTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVIZWxwRWxlbWVudCA9IGZ1bmN0aW9uICggaGVscCwgJG92ZXJsYXkgKSB7XG5cdHZhciBoZWxwSWQsIGhlbHBXaWRnZXQ7XG5cblx0aWYgKCB0aGlzLmhlbHBJbmxpbmUgKSB7XG5cdFx0aGVscFdpZGdldCA9IG5ldyBPTy51aS5MYWJlbFdpZGdldCgge1xuXHRcdFx0bGFiZWw6IGhlbHAsXG5cdFx0XHRjbGFzc2VzOiBbICdvby11aS1pbmxpbmUtaGVscCcgXVxuXHRcdH0gKTtcblxuXHRcdGhlbHBJZCA9IGhlbHBXaWRnZXQuZ2V0RWxlbWVudElkKCk7XG5cdH0gZWxzZSB7XG5cdFx0aGVscFdpZGdldCA9IG5ldyBPTy51aS5Qb3B1cEJ1dHRvbldpZGdldCgge1xuXHRcdFx0JG92ZXJsYXk6ICRvdmVybGF5LFxuXHRcdFx0cG9wdXA6IHtcblx0XHRcdFx0cGFkZGVkOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y2xhc3NlczogWyAnb28tdWktZmllbGRMYXlvdXQtaGVscCcgXSxcblx0XHRcdGZyYW1lZDogZmFsc2UsXG5cdFx0XHRpY29uOiAnaW5mbycsXG5cdFx0XHRsYWJlbDogT08udWkubXNnKCAnb291aS1maWVsZC1oZWxwJyApLFxuXHRcdFx0aW52aXNpYmxlTGFiZWw6IHRydWVcblx0XHR9ICk7XG5cdFx0aWYgKCBoZWxwIGluc3RhbmNlb2YgT08udWkuSHRtbFNuaXBwZXQgKSB7XG5cdFx0XHRoZWxwV2lkZ2V0LmdldFBvcHVwKCkuJGJvZHkuaHRtbCggaGVscC50b1N0cmluZygpICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBXaWRnZXQuZ2V0UG9wdXAoKS4kYm9keS50ZXh0KCBoZWxwICk7XG5cdFx0fVxuXG5cdFx0aGVscElkID0gaGVscFdpZGdldC5nZXRQb3B1cCgpLmdldEJvZHlJZCgpO1xuXHR9XG5cblx0Ly8gU2V0IHRoZSAnYXJpYS1kZXNjcmliZWRieScgYXR0cmlidXRlIG9uIHRoZSBmaWVsZFdpZGdldFxuXHQvLyBQcmVmZXJlbmNlIGdpdmVuIHRvIGFuIGlucHV0IG9yIGEgYnV0dG9uXG5cdChcblx0XHR0aGlzLmZpZWxkV2lkZ2V0LiRpbnB1dCB8fFxuXHRcdHRoaXMuZmllbGRXaWRnZXQuJGJ1dHRvbiB8fFxuXHRcdHRoaXMuZmllbGRXaWRnZXQuJGVsZW1lbnRcblx0KS5hdHRyKCAnYXJpYS1kZXNjcmliZWRieScsIGhlbHBJZCApO1xuXG5cdHJldHVybiBoZWxwV2lkZ2V0LiRlbGVtZW50O1xufTtcblxuLyoqXG4gKiBBY3Rpb25GaWVsZExheW91dHMgYXJlIHVzZWQgd2l0aCBPTy51aS5GaWVsZHNldExheW91dC4gVGhlIGxheW91dCBjb25zaXN0cyBvZiBhIGZpZWxkLXdpZGdldCwgYSBidXR0b24sXG4gKiBhbmQgYW4gb3B0aW9uYWwgbGFiZWwgYW5kL29yIGhlbHAgdGV4dC4gVGhlIGZpZWxkLXdpZGdldCAoZS5nLiwgYSB7QGxpbmsgT08udWkuVGV4dElucHV0V2lkZ2V0IFRleHRJbnB1dFdpZGdldH0pLFxuICogaXMgcmVxdWlyZWQgYW5kIGlzIHNwZWNpZmllZCBiZWZvcmUgYW55IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gKlxuICogTGFiZWxzIGNhbiBiZSBhbGlnbmVkIGluIG9uZSBvZiBmb3VyIHdheXM6XG4gKlxuICogLSAqKmxlZnQqKjogVGhlIGxhYmVsIGlzIHBsYWNlZCBiZWZvcmUgdGhlIGZpZWxkLXdpZGdldCBhbmQgYWxpZ25lZCB3aXRoIHRoZSBsZWZ0IG1hcmdpbi5cbiAqICAgQSBsZWZ0LWFsaWdubWVudCBpcyB1c2VkIGZvciBmb3JtcyB3aXRoIG1hbnkgZmllbGRzLlxuICogLSAqKnJpZ2h0Kio6IFRoZSBsYWJlbCBpcyBwbGFjZWQgYmVmb3JlIHRoZSBmaWVsZC13aWRnZXQgYW5kIGFsaWduZWQgdG8gdGhlIHJpZ2h0IG1hcmdpbi5cbiAqICAgQSByaWdodC1hbGlnbm1lbnQgaXMgdXNlZCBmb3IgbG9uZyBidXQgZmFtaWxpYXIgZm9ybXMgd2hpY2ggdXNlcnMgdGFiIHRocm91Z2gsXG4gKiAgIHZlcmlmeWluZyB0aGUgY3VycmVudCBmaWVsZCB3aXRoIGEgcXVpY2sgZ2xhbmNlIGF0IHRoZSBsYWJlbC5cbiAqIC0gKip0b3AqKjogVGhlIGxhYmVsIGlzIHBsYWNlZCBhYm92ZSB0aGUgZmllbGQtd2lkZ2V0LiBBIHRvcC1hbGlnbm1lbnQgaXMgdXNlZCBmb3IgYnJpZWYgZm9ybXNcbiAqICAgdGhhdCB1c2VycyBmaWxsIG91dCBmcm9tIHRvcCB0byBib3R0b20uXG4gKiAtICoqaW5saW5lKio6IFRoZSBsYWJlbCBpcyBwbGFjZWQgYWZ0ZXIgdGhlIGZpZWxkLXdpZGdldCBhbmQgYWxpZ25lZCB0byB0aGUgbGVmdC5cbiAqICAgQW4gaW5saW5lLWFsaWdubWVudCBpcyBiZXN0IHVzZWQgd2l0aCBjaGVja2JveGVzIG9yIHJhZGlvIGJ1dHRvbnMuXG4gKlxuICogSGVscCB0ZXh0IGlzIGFjY2Vzc2VkIHZpYSBhIGhlbHAgaWNvbiB0aGF0IGFwcGVhcnMgaW4gdGhlIHVwcGVyIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVuZGVyZWQgZmllbGQgbGF5b3V0IHdoZW4gaGVscFxuICogdGV4dCBpcyBzcGVjaWZpZWQuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZSBvZiBhbiBBY3Rpb25GaWVsZExheW91dFxuICogICAgIHZhciBhY3Rpb25GaWVsZExheW91dCA9IG5ldyBPTy51aS5BY3Rpb25GaWVsZExheW91dChcbiAqICAgICAgICAgbmV3IE9PLnVpLlRleHRJbnB1dFdpZGdldCgge1xuICogICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdGaWVsZCB3aWRnZXQnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgbmV3IE9PLnVpLkJ1dHRvbldpZGdldCgge1xuICogICAgICAgICAgICAgbGFiZWw6ICdCdXR0b24nXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgbGFiZWw6ICdBbiBBY3Rpb25GaWVsZExheW91dC4gVGhpcyBsYWJlbCBpcyBhbGlnbmVkIHRvcCcsXG4gKiAgICAgICAgICAgICBhbGlnbjogJ3RvcCcsXG4gKiAgICAgICAgICAgICBoZWxwOiAnVGhpcyBpcyBoZWxwIHRleHQnXG4gKiAgICAgICAgIH1cbiAqICAgICApO1xuICpcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBhY3Rpb25GaWVsZExheW91dC4kZWxlbWVudCApO1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuRmllbGRMYXlvdXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T08udWkuV2lkZ2V0fSBmaWVsZFdpZGdldCBGaWVsZCB3aWRnZXRcbiAqIEBwYXJhbSB7T08udWkuQnV0dG9uV2lkZ2V0fSBidXR0b25XaWRnZXQgQnV0dG9uIHdpZGdldFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICovXG5PTy51aS5BY3Rpb25GaWVsZExheW91dCA9IGZ1bmN0aW9uIE9vVWlBY3Rpb25GaWVsZExheW91dCggZmllbGRXaWRnZXQsIGJ1dHRvbldpZGdldCwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCBmaWVsZFdpZGdldCApICYmIGNvbmZpZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGNvbmZpZyA9IGZpZWxkV2lkZ2V0O1xuXHRcdGZpZWxkV2lkZ2V0ID0gY29uZmlnLmZpZWxkV2lkZ2V0O1xuXHRcdGJ1dHRvbldpZGdldCA9IGNvbmZpZy5idXR0b25XaWRnZXQ7XG5cdH1cblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuQWN0aW9uRmllbGRMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIGZpZWxkV2lkZ2V0LCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuYnV0dG9uV2lkZ2V0ID0gYnV0dG9uV2lkZ2V0O1xuXHR0aGlzLiRidXR0b24gPSAkKCAnPHNwYW4+JyApO1xuXHR0aGlzLiRpbnB1dCA9IHRoaXMuaXNGaWVsZElubGluZSgpID8gJCggJzxzcGFuPicgKSA6ICQoICc8ZGl2PicgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktYWN0aW9uRmllbGRMYXlvdXQnICk7XG5cdHRoaXMuJGJ1dHRvblxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWFjdGlvbkZpZWxkTGF5b3V0LWJ1dHRvbicgKVxuXHRcdC5hcHBlbmQoIHRoaXMuYnV0dG9uV2lkZ2V0LiRlbGVtZW50ICk7XG5cdHRoaXMuJGlucHV0XG5cdFx0LmFkZENsYXNzKCAnb28tdWktYWN0aW9uRmllbGRMYXlvdXQtaW5wdXQnIClcblx0XHQuYXBwZW5kKCB0aGlzLmZpZWxkV2lkZ2V0LiRlbGVtZW50ICk7XG5cdHRoaXMuJGZpZWxkXG5cdFx0LmFwcGVuZCggdGhpcy4kaW5wdXQsIHRoaXMuJGJ1dHRvbiApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5BY3Rpb25GaWVsZExheW91dCwgT08udWkuRmllbGRMYXlvdXQgKTtcblxuLyoqXG4gKiBGaWVsZHNldExheW91dHMgYXJlIGNvbXBvc2VkIG9mIG9uZSBvciBtb3JlIHtAbGluayBPTy51aS5GaWVsZExheW91dCBGaWVsZExheW91dHN9LFxuICogd2hpY2ggZWFjaCBjb250YWluIGFuIGluZGl2aWR1YWwgd2lkZ2V0IGFuZCwgb3B0aW9uYWxseSwgYSBsYWJlbC4gRWFjaCBGaWVsZHNldCBjYW4gYmVcbiAqIGNvbmZpZ3VyZWQgd2l0aCBhIGxhYmVsIGFzIHdlbGwuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcyxcbiAqIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBFeGFtcGxlIG9mIGEgZmllbGRzZXQgbGF5b3V0XG4gKiAgICAgdmFyIGlucHV0MSA9IG5ldyBPTy51aS5UZXh0SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgcGxhY2Vob2xkZXI6ICdBIHRleHQgaW5wdXQgZmllbGQnXG4gKiAgICAgfSApO1xuICpcbiAqICAgICB2YXIgaW5wdXQyID0gbmV3IE9PLnVpLlRleHRJbnB1dFdpZGdldCgge1xuICogICAgICAgICBwbGFjZWhvbGRlcjogJ0EgdGV4dCBpbnB1dCBmaWVsZCdcbiAqICAgICB9ICk7XG4gKlxuICogICAgIHZhciBmaWVsZHNldCA9IG5ldyBPTy51aS5GaWVsZHNldExheW91dCgge1xuICogICAgICAgICBsYWJlbDogJ0V4YW1wbGUgb2YgYSBmaWVsZHNldCBsYXlvdXQnXG4gKiAgICAgfSApO1xuICpcbiAqICAgICBmaWVsZHNldC5hZGRJdGVtcyggW1xuICogICAgICAgICBuZXcgT08udWkuRmllbGRMYXlvdXQoIGlucHV0MSwge1xuICogICAgICAgICAgICAgbGFiZWw6ICdGaWVsZCBPbmUnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgbmV3IE9PLnVpLkZpZWxkTGF5b3V0KCBpbnB1dDIsIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnRmllbGQgVHdvJ1xuICogICAgICAgICB9IClcbiAqICAgICBdICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggZmllbGRzZXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL0xheW91dHMvRmllbGRzX2FuZF9GaWVsZHNldHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkxheW91dFxuICogQG1peGlucyBPTy51aS5taXhpbi5JY29uRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uR3JvdXBFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPTy51aS5GaWVsZExheW91dFtdfSBbaXRlbXNdIEFuIGFycmF5IG9mIGZpZWxkcyB0byBhZGQgdG8gdGhlIGZpZWxkc2V0LiBTZWUgT08udWkuRmllbGRMYXlvdXQgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZmllbGRzLlxuICogQGNmZyB7c3RyaW5nfE9PLnVpLkh0bWxTbmlwcGV0fSBbaGVscF0gSGVscCB0ZXh0LiBXaGVuIGhlbHAgdGV4dCBpcyBzcGVjaWZpZWQsIGEgXCJoZWxwXCIgaWNvbiB3aWxsIGFwcGVhclxuICogIGluIHRoZSB1cHBlci1yaWdodCBjb3JuZXIgb2YgdGhlIHJlbmRlcmVkIGZpZWxkOyBjbGlja2luZyBpdCB3aWxsIGRpc3BsYXkgdGhlIHRleHQgaW4gYSBwb3B1cC5cbiAqICBGb3IgaW1wb3J0YW50IG1lc3NhZ2VzLCB5b3UgYXJlIGFkdmlzZWQgdG8gdXNlIGBub3RpY2VzYCwgYXMgdGhleSBhcmUgYWx3YXlzIHNob3duLlxuICogQGNmZyB7alF1ZXJ5fSBbJG92ZXJsYXldIFBhc3NlZCB0byBPTy51aS5Qb3B1cEJ1dHRvbldpZGdldCBmb3IgaGVscCBwb3B1cCwgaWYgYGhlbHBgIGlzIGdpdmVuLlxuICogIFNlZSA8aHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvQ29uY2VwdHMjT3ZlcmxheXM+LlxuICovXG5PTy51aS5GaWVsZHNldExheW91dCA9IGZ1bmN0aW9uIE9vVWlGaWVsZHNldExheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuRmllbGRzZXRMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5JY29uRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uTGFiZWxFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiRoZWFkZXIgPSAkKCAnPGxlZ2VuZD4nICk7XG5cdGlmICggY29uZmlnLmhlbHAgKSB7XG5cdFx0dGhpcy5wb3B1cEJ1dHRvbldpZGdldCA9IG5ldyBPTy51aS5Qb3B1cEJ1dHRvbldpZGdldCgge1xuXHRcdFx0JG92ZXJsYXk6IGNvbmZpZy4kb3ZlcmxheSxcblx0XHRcdHBvcHVwOiB7XG5cdFx0XHRcdHBhZGRlZDogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzZXM6IFsgJ29vLXVpLWZpZWxkc2V0TGF5b3V0LWhlbHAnIF0sXG5cdFx0XHRmcmFtZWQ6IGZhbHNlLFxuXHRcdFx0aWNvbjogJ2luZm8nLFxuXHRcdFx0bGFiZWw6IE9PLnVpLm1zZyggJ29vdWktZmllbGQtaGVscCcgKSxcblx0XHRcdGludmlzaWJsZUxhYmVsOiB0cnVlXG5cdFx0fSApO1xuXHRcdGlmICggY29uZmlnLmhlbHAgaW5zdGFuY2VvZiBPTy51aS5IdG1sU25pcHBldCApIHtcblx0XHRcdHRoaXMucG9wdXBCdXR0b25XaWRnZXQuZ2V0UG9wdXAoKS4kYm9keS5odG1sKCBjb25maWcuaGVscC50b1N0cmluZygpICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9wdXBCdXR0b25XaWRnZXQuZ2V0UG9wdXAoKS4kYm9keS50ZXh0KCBjb25maWcuaGVscCApO1xuXHRcdH1cblx0XHR0aGlzLiRoZWxwID0gdGhpcy5wb3B1cEJ1dHRvbldpZGdldC4kZWxlbWVudDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRoZWxwID0gJCggW10gKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGhlYWRlclxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWZpZWxkc2V0TGF5b3V0LWhlYWRlcicgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGljb24sIHRoaXMuJGxhYmVsLCB0aGlzLiRoZWxwICk7XG5cdHRoaXMuJGdyb3VwLmFkZENsYXNzKCAnb28tdWktZmllbGRzZXRMYXlvdXQtZ3JvdXAnICk7XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1maWVsZHNldExheW91dCcgKVxuXHRcdC5wcmVwZW5kKCB0aGlzLiRoZWFkZXIsIHRoaXMuJGdyb3VwICk7XG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnLml0ZW1zICkgKSB7XG5cdFx0dGhpcy5hZGRJdGVtcyggY29uZmlnLml0ZW1zICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuRmllbGRzZXRMYXlvdXQsIE9PLnVpLkxheW91dCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuRmllbGRzZXRMYXlvdXQsIE9PLnVpLm1peGluLkljb25FbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5GaWVsZHNldExheW91dCwgT08udWkubWl4aW4uTGFiZWxFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5GaWVsZHNldExheW91dCwgT08udWkubWl4aW4uR3JvdXBFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRmllbGRzZXRMYXlvdXQuc3RhdGljLnRhZ05hbWUgPSAnZmllbGRzZXQnO1xuXG4vKipcbiAqIEZvcm1MYXlvdXRzIGFyZSB1c2VkIHRvIHdyYXAge0BsaW5rIE9PLnVpLkZpZWxkc2V0TGF5b3V0IEZpZWxkc2V0TGF5b3V0c30gd2hlbiB5b3UgaW50ZW5kIHRvIHVzZSBicm93c2VyLWJhc2VkXG4gKiBmb3JtIHN1Ym1pc3Npb24gZm9yIHRoZSBmaWVsZHMgaW5zdGVhZCBvZiBoYW5kbGluZyB0aGVtIGluIEphdmFTY3JpcHQuIEZvcm0gbGF5b3V0cyBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGFuXG4gKiBIVE1MIGZvcm0gYWN0aW9uLCBhbiBlbmNvZGluZyB0eXBlLCBhbmQgYSBtZXRob2QgdXNpbmcgdGhlICNhY3Rpb24sICNlbmN0eXBlLCBhbmQgI21ldGhvZCBjb25maWdzLCByZXNwZWN0aXZlbHkuXG4gKiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLlxuICpcbiAqIE9ubHkgd2lkZ2V0cyBmcm9tIHRoZSB7QGxpbmsgT08udWkuSW5wdXRXaWRnZXQgSW5wdXRXaWRnZXR9IGZhbWlseSBzdXBwb3J0IGZvcm0gc3VibWlzc2lvbi4gSXRcbiAqIGluY2x1ZGVzIHN0YW5kYXJkIGZvcm0gZWxlbWVudHMgbGlrZSB7QGxpbmsgT08udWkuQ2hlY2tib3hJbnB1dFdpZGdldCBjaGVja2JveGVzfSwge0BsaW5rXG4gKiBPTy51aS5SYWRpb0lucHV0V2lkZ2V0IHJhZGlvIGJ1dHRvbnN9IGFuZCB7QGxpbmsgT08udWkuVGV4dElucHV0V2lkZ2V0IHRleHQgZmllbGRzfSwgYXMgd2VsbCBhc1xuICogc29tZSBmYW5jaWVyIGNvbnRyb2xzLiBTb21lIGNvbnRyb2xzIGhhdmUgYm90aCByZWd1bGFyIGFuZCBJbnB1dFdpZGdldCB2YXJpYW50cywgZm9yIGV4YW1wbGVcbiAqIE9PLnVpLkRyb3Bkb3duV2lkZ2V0IGFuZCBPTy51aS5Ecm9wZG93bklucHV0V2lkZ2V0IOKAkyBvbmx5IHRoZSBsYXR0ZXIgc3VwcG9ydCBmb3JtIHN1Ym1pc3Npb24gYW5kXG4gKiBvZnRlbiBoYXZlIHNpbXBsaWZpZWQgQVBJcyB0byBtYXRjaCB0aGUgY2FwYWJpbGl0aWVzIG9mIEhUTUwgZm9ybXMuXG4gKiBTZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMl0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgSW5wdXRXaWRnZXRzLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvTGF5b3V0cy9Gb3Jtc1xuICogWzJdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaWRnZXRzL0lucHV0c1xuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEV4YW1wbGUgb2YgYSBmb3JtIGxheW91dCB0aGF0IHdyYXBzIGEgZmllbGRzZXQgbGF5b3V0XG4gKiAgICAgdmFyIGlucHV0MSA9IG5ldyBPTy51aS5UZXh0SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgcGxhY2Vob2xkZXI6ICdVc2VybmFtZSdcbiAqICAgICB9ICk7XG4gKiAgICAgdmFyIGlucHV0MiA9IG5ldyBPTy51aS5UZXh0SW5wdXRXaWRnZXQoIHtcbiAqICAgICAgICAgcGxhY2Vob2xkZXI6ICdQYXNzd29yZCcsXG4gKiAgICAgICAgIHR5cGU6ICdwYXNzd29yZCdcbiAqICAgICB9ICk7XG4gKiAgICAgdmFyIHN1Ym1pdCA9IG5ldyBPTy51aS5CdXR0b25JbnB1dFdpZGdldCgge1xuICogICAgICAgICBsYWJlbDogJ1N1Ym1pdCdcbiAqICAgICB9ICk7XG4gKlxuICogICAgIHZhciBmaWVsZHNldCA9IG5ldyBPTy51aS5GaWVsZHNldExheW91dCgge1xuICogICAgICAgICBsYWJlbDogJ0EgZm9ybSBsYXlvdXQnXG4gKiAgICAgfSApO1xuICogICAgIGZpZWxkc2V0LmFkZEl0ZW1zKCBbXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggaW5wdXQxLCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1VzZXJuYW1lJyxcbiAqICAgICAgICAgICAgIGFsaWduOiAndG9wJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggaW5wdXQyLCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1Bhc3N3b3JkJyxcbiAqICAgICAgICAgICAgIGFsaWduOiAndG9wJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggc3VibWl0IClcbiAqICAgICBdICk7XG4gKiAgICAgdmFyIGZvcm0gPSBuZXcgT08udWkuRm9ybUxheW91dCgge1xuICogICAgICAgICBpdGVtczogWyBmaWVsZHNldCBdLFxuICogICAgICAgICBhY3Rpb246ICcvYXBpL2Zvcm1oYW5kbGVyJyxcbiAqICAgICAgICAgbWV0aG9kOiAnZ2V0J1xuICogICAgIH0gKVxuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGZvcm0uJGVsZW1lbnQgKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkxheW91dFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ30gW21ldGhvZF0gSFRNTCBmb3JtIGBtZXRob2RgIGF0dHJpYnV0ZVxuICogQGNmZyB7c3RyaW5nfSBbYWN0aW9uXSBIVE1MIGZvcm0gYGFjdGlvbmAgYXR0cmlidXRlXG4gKiBAY2ZnIHtzdHJpbmd9IFtlbmN0eXBlXSBIVE1MIGZvcm0gYGVuY3R5cGVgIGF0dHJpYnV0ZVxuICogQGNmZyB7T08udWkuRmllbGRzZXRMYXlvdXRbXX0gW2l0ZW1zXSBGaWVsZHNldCBsYXlvdXRzIHRvIGFkZCB0byB0aGUgZm9ybSBsYXlvdXQuXG4gKi9cbk9PLnVpLkZvcm1MYXlvdXQgPSBmdW5jdGlvbiBPb1VpRm9ybUxheW91dCggY29uZmlnICkge1xuXHR2YXIgYWN0aW9uO1xuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Gb3JtTGF5b3V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uR3JvdXBFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRncm91cDogdGhpcy4kZWxlbWVudCB9ICkgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kZWxlbWVudC5vbiggJ3N1Ym1pdCcsIHRoaXMub25Gb3JtU3VibWl0LmJpbmQoIHRoaXMgKSApO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGUgYWN0aW9uIGlzIHNhZmVcblx0YWN0aW9uID0gY29uZmlnLmFjdGlvbjtcblx0aWYgKCBhY3Rpb24gIT09IHVuZGVmaW5lZCAmJiAhT08udWkuaXNTYWZlVXJsKCBhY3Rpb24gKSApIHtcblx0XHRhY3Rpb24gPSAnLi8nICsgYWN0aW9uO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWZvcm1MYXlvdXQnIClcblx0XHQuYXR0cigge1xuXHRcdFx0bWV0aG9kOiBjb25maWcubWV0aG9kLFxuXHRcdFx0YWN0aW9uOiBhY3Rpb24sXG5cdFx0XHRlbmN0eXBlOiBjb25maWcuZW5jdHlwZVxuXHRcdH0gKTtcblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb25maWcuaXRlbXMgKSApIHtcblx0XHR0aGlzLmFkZEl0ZW1zKCBjb25maWcuaXRlbXMgKTtcblx0fVxufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Gb3JtTGF5b3V0LCBPTy51aS5MYXlvdXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkZvcm1MYXlvdXQsIE9PLnVpLm1peGluLkdyb3VwRWxlbWVudCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBBICdzdWJtaXQnIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuXG4gKlxuICogQGV2ZW50IHN1Ym1pdFxuICovXG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRm9ybUxheW91dC5zdGF0aWMudGFnTmFtZSA9ICdmb3JtJztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSBmb3JtIHN1Ym1pdCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIFN1Ym1pdCBldmVudFxuICogQGZpcmVzIHN1Ym1pdFxuICogQHJldHVybiB7T08udWkuRm9ybUxheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkZvcm1MYXlvdXQucHJvdG90eXBlLm9uRm9ybVN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmVtaXQoICdzdWJtaXQnICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIFBhbmVsTGF5b3V0cyBleHBhbmQgdG8gY292ZXIgdGhlIGVudGlyZSBhcmVhIG9mIHRoZWlyIHBhcmVudC4gVGhleSBjYW4gYmUgY29uZmlndXJlZCB3aXRoIHNjcm9sbGluZywgcGFkZGluZyxcbiAqIGFuZCBhIGZyYW1lLCBhbmQgYXJlIG9mdGVuIHVzZWQgdG9nZXRoZXIgd2l0aCB7QGxpbmsgT08udWkuU3RhY2tMYXlvdXQgU3RhY2tMYXlvdXRzfS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBFeGFtcGxlIG9mIGEgcGFuZWwgbGF5b3V0XG4gKiAgICAgdmFyIHBhbmVsID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG4gKiAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAqICAgICAgICAgZnJhbWVkOiB0cnVlLFxuICogICAgICAgICBwYWRkZWQ6IHRydWUsXG4gKiAgICAgICAgICRjb250ZW50OiAkKCAnPHA+QSBwYW5lbCBsYXlvdXQgd2l0aCBwYWRkaW5nIGFuZCBhIGZyYW1lLjwvcD4nIClcbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggcGFuZWwuJGVsZW1lbnQgKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkxheW91dFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7Ym9vbGVhbn0gW3Njcm9sbGFibGU9ZmFsc2VdIEFsbG93IHZlcnRpY2FsIHNjcm9sbGluZ1xuICogQGNmZyB7Ym9vbGVhbn0gW3BhZGRlZD1mYWxzZV0gQWRkIHBhZGRpbmcgYmV0d2VlbiB0aGUgY29udGVudCBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBwYW5lbC5cbiAqIEBjZmcge2Jvb2xlYW59IFtleHBhbmRlZD10cnVlXSBFeHBhbmQgdGhlIHBhbmVsIHRvIGZpbGwgdGhlIGVudGlyZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBjZmcge2Jvb2xlYW59IFtmcmFtZWQ9ZmFsc2VdIFJlbmRlciB0aGUgcGFuZWwgd2l0aCBhIGZyYW1lIHRvIHZpc3VhbGx5IHNlcGFyYXRlIGl0IGZyb20gb3V0c2lkZSBjb250ZW50LlxuICovXG5PTy51aS5QYW5lbExheW91dCA9IGZ1bmN0aW9uIE9vVWlQYW5lbExheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7XG5cdFx0c2Nyb2xsYWJsZTogZmFsc2UsXG5cdFx0cGFkZGVkOiBmYWxzZSxcblx0XHRleHBhbmRlZDogdHJ1ZSxcblx0XHRmcmFtZWQ6IGZhbHNlXG5cdH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5QYW5lbExheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXBhbmVsTGF5b3V0JyApO1xuXHRpZiAoIGNvbmZpZy5zY3JvbGxhYmxlICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1wYW5lbExheW91dC1zY3JvbGxhYmxlJyApO1xuXHR9XG5cdGlmICggY29uZmlnLnBhZGRlZCApIHtcblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcGFuZWxMYXlvdXQtcGFkZGVkJyApO1xuXHR9XG5cdGlmICggY29uZmlnLmV4cGFuZGVkICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1wYW5lbExheW91dC1leHBhbmRlZCcgKTtcblx0fVxuXHRpZiAoIGNvbmZpZy5mcmFtZWQgKSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXBhbmVsTGF5b3V0LWZyYW1lZCcgKTtcblx0fVxufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5QYW5lbExheW91dCwgT08udWkuTGF5b3V0ICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBGb2N1cyB0aGUgcGFuZWwgbGF5b3V0XG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCBmb2N1c2VzIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBpbiB0aGUgcGFuZWxcbiAqL1xuT08udWkuUGFuZWxMYXlvdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHRPTy51aS5maW5kRm9jdXNhYmxlKCB0aGlzLiRlbGVtZW50ICkuZm9jdXMoKTtcbn07XG5cbi8qKlxuICogSG9yaXpvbnRhbExheW91dCBhcnJhbmdlcyBpdHMgY29udGVudHMgaW4gYSBzaW5nbGUgbGluZSAodXNpbmcgYGRpc3BsYXk6IGlubGluZS1ibG9ja2AgZm9yIGl0c1xuICogaXRlbXMpLCB3aXRoIHNtYWxsIG1hcmdpbnMgYmV0d2VlbiB0aGVtLiBDb252ZW5pZW50IHdoZW4geW91IG5lZWQgdG8gcHV0IGEgbnVtYmVyIG9mIGJsb2NrLWxldmVsXG4gKiB3aWRnZXRzIG9uIGEgc2luZ2xlIGxpbmUgbmV4dCB0byBlYWNoIG90aGVyLlxuICpcbiAqIE5vdGUgdGhhdCBpbmxpbmUgZWxlbWVudHMsIHN1Y2ggYXMgT08udWkuQnV0dG9uV2lkZ2V0cywgZG8gbm90IG5lZWQgdGhpcyB3cmFwcGVyLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEhvcml6b250YWxMYXlvdXQgd2l0aCBhIHRleHQgaW5wdXQgYW5kIGEgbGFiZWxcbiAqICAgICB2YXIgbGF5b3V0ID0gbmV3IE9PLnVpLkhvcml6b250YWxMYXlvdXQoIHtcbiAqICAgICAgIGl0ZW1zOiBbXG4gKiAgICAgICAgIG5ldyBPTy51aS5MYWJlbFdpZGdldCggeyBsYWJlbDogJ0xhYmVsJyB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5UZXh0SW5wdXRXaWRnZXQoIHsgdmFsdWU6ICdUZXh0JyB9IClcbiAqICAgICAgIF1cbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggbGF5b3V0LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5MYXlvdXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uR3JvdXBFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtPTy51aS5XaWRnZXRbXXxPTy51aS5MYXlvdXRbXX0gW2l0ZW1zXSBXaWRnZXRzIG9yIG90aGVyIGxheW91dHMgdG8gYWRkIHRvIHRoZSBsYXlvdXQuXG4gKi9cbk9PLnVpLkhvcml6b250YWxMYXlvdXQgPSBmdW5jdGlvbiBPb1VpSG9yaXpvbnRhbExheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuSG9yaXpvbnRhbExheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkZ3JvdXA6IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWhvcml6b250YWxMYXlvdXQnICk7XG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnLml0ZW1zICkgKSB7XG5cdFx0dGhpcy5hZGRJdGVtcyggY29uZmlnLml0ZW1zICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuSG9yaXpvbnRhbExheW91dCwgT08udWkuTGF5b3V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Ib3Jpem9udGFsTGF5b3V0LCBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgKTtcblxuLyoqXG4gKiBOdW1iZXJJbnB1dFdpZGdldHMgY29tYmluZSBhIHtAbGluayBPTy51aS5UZXh0SW5wdXRXaWRnZXQgdGV4dCBpbnB1dH0gKHdoZXJlIGEgdmFsdWVcbiAqIGNhbiBiZSBlbnRlcmVkIG1hbnVhbGx5KSBhbmQgdHdvIHtAbGluayBPTy51aS5CdXR0b25XaWRnZXQgYnV0dG9uIHdpZGdldHN9XG4gKiAodG8gYWRqdXN0IHRoZSB2YWx1ZSBpbiBpbmNyZW1lbnRzKSB0byBhbGxvdyB0aGUgdXNlciB0byBlbnRlciBhIG51bWJlci5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIE51bWJlcklucHV0V2lkZ2V0LlxuICogICAgIHZhciBudW1iZXJJbnB1dCA9IG5ldyBPTy51aS5OdW1iZXJJbnB1dFdpZGdldCgge1xuICogICAgICAgICBsYWJlbDogJ051bWJlcklucHV0V2lkZ2V0JyxcbiAqICAgICAgICAgaW5wdXQ6IHsgdmFsdWU6IDUgfSxcbiAqICAgICAgICAgbWluOiAxLFxuICogICAgICAgICBtYXg6IDEwXG4gKiAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIG51bWJlcklucHV0LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5UZXh0SW5wdXRXaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge09iamVjdH0gW21pbnVzQnV0dG9uXSBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gcGFzcyB0byB0aGVcbiAqICB7QGxpbmsgT08udWkuQnV0dG9uV2lkZ2V0IGRlY3JlbWVudGluZyBidXR0b24gd2lkZ2V0fS5cbiAqIEBjZmcge09iamVjdH0gW3BsdXNCdXR0b25dIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byBwYXNzIHRvIHRoZVxuICogIHtAbGluayBPTy51aS5CdXR0b25XaWRnZXQgaW5jcmVtZW50aW5nIGJ1dHRvbiB3aWRnZXR9LlxuICogQGNmZyB7bnVtYmVyfSBbbWluPS1JbmZpbml0eV0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gKiBAY2ZnIHtudW1iZXJ9IFttYXg9SW5maW5pdHldIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICogQGNmZyB7bnVtYmVyfG51bGx9IFtzdGVwXSBJZiBzcGVjaWZpZWQsIHRoZSBmaWVsZCBvbmx5IGFjY2VwdHMgdmFsdWVzIHRoYXQgYXJlIG11bHRpcGxlcyBvZiB0aGlzLlxuICogQGNmZyB7bnVtYmVyfSBbYnV0dG9uU3RlcD1zdGVwfHwxXSBEZWx0YSB3aGVuIHVzaW5nIHRoZSBidXR0b25zIG9yIHVwL2Rvd24gYXJyb3cga2V5cy5cbiAqICBEZWZhdWx0cyB0byBgc3RlcGAgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2UgYDFgLlxuICogQGNmZyB7bnVtYmVyfSBbcGFnZVN0ZXA9MTAqYnV0dG9uU3RlcF0gRGVsdGEgd2hlbiB1c2luZyB0aGUgcGFnZS11cC9wYWdlLWRvd24ga2V5cy5cbiAqICBEZWZhdWx0cyB0byAxMCB0aW1lcyBgYnV0dG9uU3RlcGAuXG4gKiBAY2ZnIHtib29sZWFufSBbc2hvd0J1dHRvbnM9dHJ1ZV0gV2hldGhlciB0byBzaG93IHRoZSBwbHVzIGFuZCBtaW51cyBidXR0b25zLlxuICovXG5PTy51aS5OdW1iZXJJbnB1dFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlOdW1iZXJJbnB1dFdpZGdldCggY29uZmlnICkge1xuXHR2YXIgJGZpZWxkID0gJCggJzxkaXY+JyApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktbnVtYmVySW5wdXRXaWRnZXQtZmllbGQnICk7XG5cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSAkLmV4dGVuZCgge1xuXHRcdG1pbjogLUluZmluaXR5LFxuXHRcdG1heDogSW5maW5pdHksXG5cdFx0c2hvd0J1dHRvbnM6IHRydWVcblx0fSwgY29uZmlnICk7XG5cblx0Ly8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0JC5leHRlbmQoIGNvbmZpZywgY29uZmlnLmlucHV0ICk7XG5cdHRoaXMuaW5wdXQgPSB0aGlzO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5OdW1iZXJJbnB1dFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIGNvbmZpZywge1xuXHRcdHR5cGU6ICdudW1iZXInXG5cdH0gKSApO1xuXG5cdGlmICggY29uZmlnLnNob3dCdXR0b25zICkge1xuXHRcdHRoaXMubWludXNCdXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCAkLmV4dGVuZChcblx0XHRcdHtcblx0XHRcdFx0ZGlzYWJsZWQ6IHRoaXMuaXNEaXNhYmxlZCgpLFxuXHRcdFx0XHR0YWJJbmRleDogLTEsXG5cdFx0XHRcdGNsYXNzZXM6IFsgJ29vLXVpLW51bWJlcklucHV0V2lkZ2V0LW1pbnVzQnV0dG9uJyBdLFxuXHRcdFx0XHRpY29uOiAnc3VidHJhY3QnXG5cdFx0XHR9LFxuXHRcdFx0Y29uZmlnLm1pbnVzQnV0dG9uXG5cdFx0KSApO1xuXHRcdHRoaXMubWludXNCdXR0b24uJGVsZW1lbnQuYXR0ciggJ2FyaWEtaGlkZGVuJywgJ3RydWUnICk7XG5cdFx0dGhpcy5wbHVzQnV0dG9uID0gbmV3IE9PLnVpLkJ1dHRvbldpZGdldCggJC5leHRlbmQoXG5cdFx0XHR7XG5cdFx0XHRcdGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQoKSxcblx0XHRcdFx0dGFiSW5kZXg6IC0xLFxuXHRcdFx0XHRjbGFzc2VzOiBbICdvby11aS1udW1iZXJJbnB1dFdpZGdldC1wbHVzQnV0dG9uJyBdLFxuXHRcdFx0XHRpY29uOiAnYWRkJ1xuXHRcdFx0fSxcblx0XHRcdGNvbmZpZy5wbHVzQnV0dG9uXG5cdFx0KSApO1xuXHRcdHRoaXMucGx1c0J1dHRvbi4kZWxlbWVudC5hdHRyKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblx0fVxuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLiRpbnB1dC5vbigge1xuXHRcdGtleWRvd246IHRoaXMub25LZXlEb3duLmJpbmQoIHRoaXMgKSxcblx0XHQnd2hlZWwgbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCc6IHRoaXMub25XaGVlbC5iaW5kKCB0aGlzIClcblx0fSApO1xuXHRpZiAoIGNvbmZpZy5zaG93QnV0dG9ucyApIHtcblx0XHR0aGlzLnBsdXNCdXR0b24uY29ubmVjdCggdGhpcywge1xuXHRcdFx0Y2xpY2s6IFsgJ29uQnV0dG9uQ2xpY2snLCArMSBdXG5cdFx0fSApO1xuXHRcdHRoaXMubWludXNCdXR0b24uY29ubmVjdCggdGhpcywge1xuXHRcdFx0Y2xpY2s6IFsgJ29uQnV0dG9uQ2xpY2snLCAtMSBdXG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQnVpbGQgdGhlIGZpZWxkXG5cdCRmaWVsZC5hcHBlbmQoIHRoaXMuJGlucHV0ICk7XG5cdGlmICggY29uZmlnLnNob3dCdXR0b25zICkge1xuXHRcdCRmaWVsZFxuXHRcdFx0LnByZXBlbmQoIHRoaXMubWludXNCdXR0b24uJGVsZW1lbnQgKVxuXHRcdFx0LmFwcGVuZCggdGhpcy5wbHVzQnV0dG9uLiRlbGVtZW50ICk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHRpZiAoIGNvbmZpZy5hbGxvd0ludGVnZXIgfHwgY29uZmlnLmlzSW50ZWdlciApIHtcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0Y29uZmlnLnN0ZXAgPSAxO1xuXHR9XG5cdHRoaXMuc2V0UmFuZ2UoIGNvbmZpZy5taW4sIGNvbmZpZy5tYXggKTtcblx0dGhpcy5zZXRTdGVwKCBjb25maWcuYnV0dG9uU3RlcCwgY29uZmlnLnBhZ2VTdGVwLCBjb25maWcuc3RlcCApO1xuXHQvLyBTZXQgdGhlIHZhbGlkYXRpb24gbWV0aG9kIGFmdGVyIHdlIHNldCBzdGVwIGFuZCByYW5nZVxuXHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgaW1tZWRpYXRlbHkgY2FsbCBzZXRWYWxpZGl0eUZsYWdcblx0dGhpcy5zZXRWYWxpZGF0aW9uKCB0aGlzLnZhbGlkYXRlTnVtYmVyLmJpbmQoIHRoaXMgKSApO1xuXG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1udW1iZXJJbnB1dFdpZGdldCcgKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLW51bWJlcklucHV0V2lkZ2V0LWJ1dHRvbmVkJywgY29uZmlnLnNob3dCdXR0b25zIClcblx0XHQuYXBwZW5kKCAkZmllbGQgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuTnVtYmVySW5wdXRXaWRnZXQsIE9PLnVpLlRleHRJbnB1dFdpZGdldCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRBbGxvd0ludGVnZXIgPSBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdHRoaXMuc2V0U3RlcCggZmxhZyA/IDEgOiBudWxsICk7XG59O1xuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLnNldElzSW50ZWdlciA9IE9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRBbGxvd0ludGVnZXI7XG5cbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRBbGxvd0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnN0ZXAgPT09IDE7XG59O1xuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLmdldElzSW50ZWdlciA9IE9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRBbGxvd0ludGVnZXI7XG5cbi8qKlxuICogU2V0IHRoZSByYW5nZSBvZiBhbGxvd2VkIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICovXG5PTy51aS5OdW1iZXJJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXHRpZiAoIG1pbiA+IG1heCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdNaW5pbXVtICgnICsgbWluICsgJykgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heGltdW0gKCcgKyBtYXggKyAnKScgKTtcblx0fVxuXHR0aGlzLm1pbiA9IG1pbjtcblx0dGhpcy5tYXggPSBtYXg7XG5cdHRoaXMuJGlucHV0LmF0dHIoICdtaW4nLCB0aGlzLm1pbiApO1xuXHR0aGlzLiRpbnB1dC5hdHRyKCAnbWF4JywgdGhpcy5tYXggKTtcblx0dGhpcy5zZXRWYWxpZGl0eUZsYWcoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHJhbmdlXG4gKlxuICogQHJldHVybiB7bnVtYmVyW119IE1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzXG4gKi9cbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIFsgdGhpcy5taW4sIHRoaXMubWF4IF07XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RlcHBpbmcgZGVsdGFzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtidXR0b25TdGVwPXN0ZXB8fDFdIERlbHRhIHdoZW4gdXNpbmcgdGhlIGJ1dHRvbnMgb3IgdXAvZG93biBhcnJvdyBrZXlzLlxuICogIERlZmF1bHRzIHRvIGBzdGVwYCBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBgMWAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTdGVwPTEwKmJ1dHRvblN0ZXBdIERlbHRhIHdoZW4gdXNpbmcgdGhlIHBhZ2UtdXAvcGFnZS1kb3duIGtleXMuXG4gKiAgRGVmYXVsdHMgdG8gMTAgdGltZXMgYGJ1dHRvblN0ZXBgLlxuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW3N0ZXBdIElmIHNwZWNpZmllZCwgdGhlIGZpZWxkIG9ubHkgYWNjZXB0cyB2YWx1ZXMgdGhhdCBhcmUgbXVsdGlwbGVzIG9mIHRoaXMuXG4gKi9cbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRTdGVwID0gZnVuY3Rpb24gKCBidXR0b25TdGVwLCBwYWdlU3RlcCwgc3RlcCApIHtcblx0aWYgKCBidXR0b25TdGVwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0YnV0dG9uU3RlcCA9IHN0ZXAgfHwgMTtcblx0fVxuXHRpZiAoIHBhZ2VTdGVwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cGFnZVN0ZXAgPSAxMCAqIGJ1dHRvblN0ZXA7XG5cdH1cblx0aWYgKCBzdGVwICE9PSBudWxsICYmIHN0ZXAgPD0gMCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdTdGVwIHZhbHVlLCBpZiBnaXZlbiwgbXVzdCBiZSBwb3NpdGl2ZScgKTtcblx0fVxuXHRpZiAoIGJ1dHRvblN0ZXAgPD0gMCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdCdXR0b24gc3RlcCB2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlJyApO1xuXHR9XG5cdGlmICggcGFnZVN0ZXAgPD0gMCApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdQYWdlIHN0ZXAgdmFsdWUgbXVzdCBiZSBwb3NpdGl2ZScgKTtcblx0fVxuXHR0aGlzLnN0ZXAgPSBzdGVwO1xuXHR0aGlzLmJ1dHRvblN0ZXAgPSBidXR0b25TdGVwO1xuXHR0aGlzLnBhZ2VTdGVwID0gcGFnZVN0ZXA7XG5cdHRoaXMuJGlucHV0LmF0dHIoICdzdGVwJywgdGhpcy5zdGVwIHx8ICdhbnknICk7XG5cdHRoaXMuc2V0VmFsaWRpdHlGbGFnKCk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdGlmICggdmFsdWUgPT09ICcnICkge1xuXHRcdC8vIFNvbWUgYnJvd3NlcnMgYWxsb3cgYSB2YWx1ZSBpbiB0aGUgaW5wdXQgZXZlbiBpZiB0aGVyZSBpc24ndCBvbmUgcmVwb3J0ZWQgYnkgJGlucHV0LnZhbCgpXG5cdFx0Ly8gc28gaGVyZSB3ZSBtYWtlIHN1cmUgYW4gJ2VtcHR5JyB2YWx1ZSBpcyBhY3R1YWxseSBkaXNwbGF5ZWQgYXMgc3VjaC5cblx0XHR0aGlzLiRpbnB1dC52YWwoICcnICk7XG5cdH1cblx0cmV0dXJuIE9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCggdGhpcywgdmFsdWUgKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHN0ZXBwaW5nIHZhbHVlc1xuICpcbiAqIEByZXR1cm4ge251bWJlcltdfSBCdXR0b24gc3RlcCwgcGFnZSBzdGVwLCBhbmQgdmFsaWRpdHkgc3RlcFxuICovXG5PTy51aS5OdW1iZXJJbnB1dFdpZGdldC5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIFsgdGhpcy5idXR0b25TdGVwLCB0aGlzLnBhZ2VTdGVwLCB0aGlzLnN0ZXAgXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB3aWRnZXQgYXMgYSBudW1iZXJcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heSBiZSBOYU4sIG9yIGFuIGludmFsaWQgbnVtYmVyXG4gKi9cbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5nZXROdW1lcmljVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiArdGhpcy5nZXRWYWx1ZSgpO1xufTtcblxuLyoqXG4gKiBBZGp1c3QgdGhlIHZhbHVlIG9mIHRoZSB3aWRnZXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgQWRqdXN0bWVudCBhbW91bnRcbiAqL1xuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLmFkanVzdFZhbHVlID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcblx0dmFyIG4sIHYgPSB0aGlzLmdldE51bWVyaWNWYWx1ZSgpO1xuXG5cdGRlbHRhID0gK2RlbHRhO1xuXHRpZiAoIGlzTmFOKCBkZWx0YSApIHx8ICFpc0Zpbml0ZSggZGVsdGEgKSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZWx0YSBtdXN0IGJlIGEgZmluaXRlIG51bWJlcicgKTtcblx0fVxuXG5cdGlmICggaXNOYU4oIHYgKSApIHtcblx0XHRuID0gMDtcblx0fSBlbHNlIHtcblx0XHRuID0gdiArIGRlbHRhO1xuXHRcdG4gPSBNYXRoLm1heCggTWF0aC5taW4oIG4sIHRoaXMubWF4ICksIHRoaXMubWluICk7XG5cdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRuID0gTWF0aC5yb3VuZCggbiAvIHRoaXMuc3RlcCApICogdGhpcy5zdGVwO1xuXHRcdH1cblx0fVxuXG5cdGlmICggbiAhPT0gdiApIHtcblx0XHR0aGlzLnNldFZhbHVlKCBuICk7XG5cdH1cbn07XG4vKipcbiAqIFZhbGlkYXRlIGlucHV0XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBGaWVsZCB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLnZhbGlkYXRlTnVtYmVyID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0dmFyIG4gPSArdmFsdWU7XG5cdGlmICggdmFsdWUgPT09ICcnICkge1xuXHRcdHJldHVybiAhdGhpcy5pc1JlcXVpcmVkKCk7XG5cdH1cblxuXHRpZiAoIGlzTmFOKCBuICkgfHwgIWlzRmluaXRlKCBuICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCB0aGlzLnN0ZXAgJiYgTWF0aC5mbG9vciggbiAvIHRoaXMuc3RlcCApICE9PSBuIC8gdGhpcy5zdGVwICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggbiA8IHRoaXMubWluIHx8IG4gPiB0aGlzLm1heCApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGNsaWNrIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRpciArMSBvciAtMVxuICovXG5PTy51aS5OdW1iZXJJbnB1dFdpZGdldC5wcm90b3R5cGUub25CdXR0b25DbGljayA9IGZ1bmN0aW9uICggZGlyICkge1xuXHR0aGlzLmFkanVzdFZhbHVlKCBkaXIgKiB0aGlzLmJ1dHRvblN0ZXAgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIHdoZWVsIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLm9uV2hlZWwgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHR2YXIgZGVsdGEgPSAwO1xuXG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICYmIHRoaXMuJGlucHV0LmlzKCAnOmZvY3VzJyApICkge1xuXHRcdC8vIFN0YW5kYXJkICd3aGVlbCcgZXZlbnRcblx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFNb2RlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNhd1doZWVsRXZlbnQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFZICkge1xuXHRcdFx0ZGVsdGEgPSAtZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVk7XG5cdFx0fSBlbHNlIGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVggKSB7XG5cdFx0XHRkZWx0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFYO1xuXHRcdH1cblxuXHRcdC8vIE5vbi1zdGFuZGFyZCBldmVudHNcblx0XHRpZiAoICF0aGlzLnNhd1doZWVsRXZlbnQgKSB7XG5cdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVggKSB7XG5cdFx0XHRcdGRlbHRhID0gLWV2ZW50Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVg7XG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFZICkge1xuXHRcdFx0XHRkZWx0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVk7XG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEgKSB7XG5cdFx0XHRcdGRlbHRhID0gZXZlbnQub3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5kZXRhaWwgKSB7XG5cdFx0XHRcdGRlbHRhID0gLWV2ZW50Lm9yaWdpbmFsRXZlbnQuZGV0YWlsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZGVsdGEgKSB7XG5cdFx0XHRkZWx0YSA9IGRlbHRhIDwgMCA/IC0xIDogMTtcblx0XHRcdHRoaXMuYWRqdXN0VmFsdWUoIGRlbHRhICogdGhpcy5idXR0b25TdGVwICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBrZXkgZG93biBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuTnVtYmVySW5wdXRXaWRnZXQucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0c3dpdGNoICggZS53aGljaCApIHtcblx0XHRcdGNhc2UgT08udWkuS2V5cy5VUDpcblx0XHRcdFx0dGhpcy5hZGp1c3RWYWx1ZSggdGhpcy5idXR0b25TdGVwICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGNhc2UgT08udWkuS2V5cy5ET1dOOlxuXHRcdFx0XHR0aGlzLmFkanVzdFZhbHVlKCAtdGhpcy5idXR0b25TdGVwICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGNhc2UgT08udWkuS2V5cy5QQUdFVVA6XG5cdFx0XHRcdHRoaXMuYWRqdXN0VmFsdWUoIHRoaXMucGFnZVN0ZXAgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0Y2FzZSBPTy51aS5LZXlzLlBBR0VET1dOOlxuXHRcdFx0XHR0aGlzLmFkanVzdFZhbHVlKCAtdGhpcy5wYWdlU3RlcCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk51bWJlcklucHV0V2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggZGlzYWJsZWQgKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuTnVtYmVySW5wdXRXaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXREaXNhYmxlZC5jYWxsKCB0aGlzLCBkaXNhYmxlZCApO1xuXG5cdGlmICggdGhpcy5taW51c0J1dHRvbiApIHtcblx0XHR0aGlzLm1pbnVzQnV0dG9uLnNldERpc2FibGVkKCB0aGlzLmlzRGlzYWJsZWQoKSApO1xuXHR9XG5cdGlmICggdGhpcy5wbHVzQnV0dG9uICkge1xuXHRcdHRoaXMucGx1c0J1dHRvbi5zZXREaXNhYmxlZCggdGhpcy5pc0Rpc2FibGVkKCkgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxufSggT08gKSApO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vb2pzLXVpLWNvcmUuanMubWFwLmpzb25cbi8qIVxuICogT09VSSB2MC4zMC4yXG4gKiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSVxuICpcbiAqIENvcHlyaWdodCAyMDEx4oCTMjAxOSBPT1VJIFRlYW0gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL29vanMubWl0LWxpY2Vuc2Uub3JnXG4gKlxuICogRGF0ZTogMjAxOS0wMS0yM1QwMToxNDoyMFpcbiAqL1xuKCBmdW5jdGlvbiAoIE9PICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRHJhZ2dhYmxlRWxlbWVudCBpcyBhIG1peGluIGNsYXNzIHVzZWQgdG8gY3JlYXRlIGVsZW1lbnRzIHRoYXQgY2FuIGJlIGNsaWNrZWRcbiAqIGFuZCBkcmFnZ2VkIGJ5IGEgbW91c2UgdG8gYSBuZXcgcG9zaXRpb24gd2l0aGluIGEgZ3JvdXAuIFRoaXMgY2xhc3MgbXVzdCBiZSB1c2VkXG4gKiBpbiBjb25qdW5jdGlvbiB3aXRoIE9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudCwgd2hpY2ggcHJvdmlkZXMgYSBjb250YWluZXIgZm9yXG4gKiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRzLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtqUXVlcnl9IFskaGFuZGxlXSBUaGUgcGFydCBvZiB0aGUgZWxlbWVudCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgZHJhZ2dpbmcsIGRlZmF1bHRzIHRvIHRoZSB3aG9sZSBlbGVtZW50XG4gKiBAY2ZnIHtib29sZWFufSBbZHJhZ2dhYmxlXSBUaGUgaXRlbXMgYXJlIGRyYWdnYWJsZS4gVGhpcyBjYW4gY2hhbmdlIHdpdGggI3RvZ2dsZURyYWdnYWJsZVxuICogIGJ1dCB0aGUgZHJhZ2dhYmxlIHN0YXRlIHNob3VsZCBiZSBjYWxsZWQgZnJvbSB0aGUgRHJhZ2dhYmxlR3JvdXBFbGVtZW50LCB3aGljaCB1cGRhdGVzXG4gKiAgdGhlIHdob2xlIGdyb3VwXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiBPb1VpTWl4aW5EcmFnZ2FibGVFbGVtZW50KCBjb25maWcgKSB7XG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuaW5kZXggPSBudWxsO1xuXHR0aGlzLiRoYW5kbGUgPSBjb25maWcuJGhhbmRsZSB8fCB0aGlzLiRlbGVtZW50O1xuXHR0aGlzLndhc0hhbmRsZVVzZWQgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemUgYW5kIGV2ZW50c1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktZHJhZ2dhYmxlRWxlbWVudCcgKVxuXHRcdC5vbigge1xuXHRcdFx0bW91c2Vkb3duOiB0aGlzLm9uRHJhZ01vdXNlRG93bi5iaW5kKCB0aGlzICksXG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMub25EcmFnU3RhcnQuYmluZCggdGhpcyApLFxuXHRcdFx0ZHJhZ292ZXI6IHRoaXMub25EcmFnT3Zlci5iaW5kKCB0aGlzICksXG5cdFx0XHRkcmFnZW5kOiB0aGlzLm9uRHJhZ0VuZC5iaW5kKCB0aGlzICksXG5cdFx0XHRkcm9wOiB0aGlzLm9uRHJvcC5iaW5kKCB0aGlzIClcblx0XHR9ICk7XG5cdHRoaXMuJGhhbmRsZS5hZGRDbGFzcyggJ29vLXVpLWRyYWdnYWJsZUVsZW1lbnQtaGFuZGxlJyApO1xuXHR0aGlzLnRvZ2dsZURyYWdnYWJsZSggY29uZmlnLmRyYWdnYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhY29uZmlnLmRyYWdnYWJsZSApO1xufTtcblxuT08uaW5pdENsYXNzKCBPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50ICk7XG5cbi8qIEV2ZW50cyAqL1xuXG4vKipcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqXG4gKiBBIGRyYWdzdGFydCBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFuZCBiZWdpbnMgZHJhZ2dpbmcgYW4gaXRlbS5cbiAqIEBwYXJhbSB7T08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudH0gaXRlbSBUaGUgaXRlbSB0aGUgdXNlciBoYXMgY2xpY2tlZCBhbmQgaXMgZHJhZ2dpbmcgd2l0aCB0aGUgbW91c2UuXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQSBkcmFnZW5kIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpdGVtIGFuZCByZWxlYXNlcyB0aGUgbW91c2UsXG4gKiB0aHVzIHRlcm1pbmF0aW5nIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBldmVudCBkcm9wXG4gKiBBIGRyb3AgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGl0ZW0gYW5kIHRoZW4gcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvblxuICogb3ZlciBhIHZhbGlkIHRhcmdldC5cbiAqL1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnRcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5zdGF0aWMuY2FuY2VsQnV0dG9uTW91c2VEb3duRXZlbnRzID0gZmFsc2U7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRyYWdnYWJsZSBzdGF0ZSBvZiB0aGlzIHdpZGdldC5cbiAqIFRoaXMgYWxsb3dzIHVzZXJzIHRvIHRlbXBvcmFyaWx5IGhhbHQgdGhlIGRyYWdnaW5nIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBpc0RyYWdnYWJsZSBXaWRnZXQgc3VwcG9ydHMgZHJhZ2dhYmxlIG9wZXJhdGlvbnNcbiAqIEBmaXJlcyBkcmFnZ2FibGVcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5wcm90b3R5cGUudG9nZ2xlRHJhZ2dhYmxlID0gZnVuY3Rpb24gKCBpc0RyYWdnYWJsZSApIHtcblx0aXNEcmFnZ2FibGUgPSBpc0RyYWdnYWJsZSAhPT0gdW5kZWZpbmVkID8gISFpc0RyYWdnYWJsZSA6ICF0aGlzLmRyYWdnYWJsZTtcblxuXHRpZiAoIHRoaXMuZHJhZ2dhYmxlICE9PSBpc0RyYWdnYWJsZSApIHtcblx0XHR0aGlzLmRyYWdnYWJsZSA9IGlzRHJhZ2dhYmxlO1xuXG5cdFx0dGhpcy4kaGFuZGxlLnRvZ2dsZUNsYXNzKCAnb28tdWktZHJhZ2dhYmxlRWxlbWVudC11bmRyYWdnYWJsZScsICF0aGlzLmRyYWdnYWJsZSApO1xuXG5cdFx0Ly8gV2UgbWFrZSB0aGUgZW50aXJlIGVsZW1lbnQgZHJhZ2dhYmxlLCBub3QganVzdCB0aGUgaGFuZGxlLCBzbyB0aGF0XG5cdFx0Ly8gdGhlIHdob2xlIGVsZW1lbnQgYXBwZWFycyB0byBtb3ZlLiB3YXNIYW5kbGVVc2VkIHByZXZlbnRzIGRyYWdzIGZyb21cblx0XHQvLyBzdGFydGluZyBvdXRzaWRlIHRoZSBoYW5kbGVcblx0XHR0aGlzLiRlbGVtZW50LnByb3AoICdkcmFnZ2FibGUnLCB0aGlzLmRyYWdnYWJsZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBkcmFnZ2FibGUgc3RhdGUgb2YgdGhpcyB3aWRnZXRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaWRnZXQgc3VwcG9ydHMgZHJhZ2dhYmxlIG9wZXJhdGlvbnNcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5wcm90b3R5cGUuaXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmRyYWdnYWJsZTtcbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byBtb3VzZWRvd24gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIERyYWcgZXZlbnRcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5wcm90b3R5cGUub25EcmFnTW91c2VEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoICF0aGlzLmlzRHJhZ2dhYmxlKCkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy53YXNIYW5kbGVVc2VkID1cblx0XHQvLyBPcHRpbWl6YXRpb246IGlmIHRoZSBoYW5kbGUgaXMgdGhlIHdob2xlIGVsZW1lbnQgdGhpcyBpcyBhbHdheXMgdHJ1ZVxuXHRcdHRoaXMuJGhhbmRsZVsgMCBdID09PSB0aGlzLiRlbGVtZW50WyAwIF0gfHxcblx0XHQvLyBDaGVjayB0aGUgbW91c2Vkb3duIG9jY3VycmVkIGluc2lkZSB0aGUgaGFuZGxlXG5cdFx0T08udWkuY29udGFpbnMoIHRoaXMuJGhhbmRsZVsgMCBdLCBlLnRhcmdldCwgdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGRyYWdzdGFydCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgRHJhZyBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgdGhlIGV2ZW50IGlzIGNhbmNlbGxlZFxuICogQGZpcmVzIGRyYWdzdGFydFxuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50LnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIGVsZW1lbnQgPSB0aGlzLFxuXHRcdGRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7XG5cblx0aWYgKCAhdGhpcy53YXNIYW5kbGVVc2VkIHx8ICF0aGlzLmlzRHJhZ2dhYmxlKCkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gRGVmaW5lIGRyb3AgZWZmZWN0XG5cdGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xuXHRkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcblx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHQvLyBXZSBtdXN0IHNldCB1cCBhIGRhdGFUcmFuc2ZlciBkYXRhIHByb3BlcnR5IG9yIEZpcmVmb3ggc2VlbXMgdG9cblx0Ly8gaWdub3JlIHRoZSBmYWN0IHRoZSBlbGVtZW50IGlzIGRyYWdnYWJsZS5cblx0dHJ5IHtcblx0XHRkYXRhVHJhbnNmZXIuc2V0RGF0YSggJ2FwcGxpY2F0aW9uLXgvT09VSS1kcmFnZ2FibGUnLCB0aGlzLmdldEluZGV4KCkgKTtcblx0fSBjYXRjaCAoIGVyciApIHtcblx0XHQvLyBUaGUgYWJvdmUgaXMgb25seSBmb3IgRmlyZWZveC4gTW92ZSBvbiBpZiBpdCBmYWlscy5cblx0fVxuXHQvLyBCcmllZmx5IGFkZCBhICdjbG9uZScgY2xhc3MgdG8gc3R5bGUgdGhlIGJyb3dzZXIncyBuYXRpdmUgZHJhZyBpbWFnZVxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktZHJhZ2dhYmxlRWxlbWVudC1jbG9uZScgKTtcblx0Ly8gQWRkIHBsYWNlaG9sZGVyIGNsYXNzIGFmdGVyIHRoZSBicm93c2VyIGhhcyByZW5kZXJlZCB0aGUgY2xvbmVcblx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdGVsZW1lbnQuJGVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggJ29vLXVpLWRyYWdnYWJsZUVsZW1lbnQtY2xvbmUnIClcblx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLWRyYWdnYWJsZUVsZW1lbnQtcGxhY2Vob2xkZXInICk7XG5cdH0gKTtcblx0Ly8gRW1pdCBldmVudFxuXHR0aGlzLmVtaXQoICdkcmFnc3RhcnQnLCB0aGlzICk7XG5cdHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGRyYWdlbmQgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmaXJlcyBkcmFnZW5kXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnQucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLWRyYWdnYWJsZUVsZW1lbnQtcGxhY2Vob2xkZXInICk7XG5cdHRoaXMuZW1pdCggJ2RyYWdlbmQnICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBkcm9wIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBEcm9wIGV2ZW50XG4gKiBAZmlyZXMgZHJvcFxuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50LnByb3RvdHlwZS5vbkRyb3AgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGUucHJldmVudERlZmF1bHQoKTtcblx0dGhpcy5lbWl0KCAnZHJvcCcsIGUgKTtcbn07XG5cbi8qKlxuICogSW4gb3JkZXIgZm9yIGRyYWcvZHJvcCB0byB3b3JrLCB0aGUgZHJhZ292ZXIgZXZlbnQgbXVzdFxuICogcmV0dXJuIGZhbHNlIGFuZCBzdG9wIHByb3BvZ2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIERyYWcgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnQucHJvdG90eXBlLm9uRHJhZ092ZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGUucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogU2V0IGl0ZW0gaW5kZXguXG4gKiBTdG9yZSBpdCBpbiB0aGUgRE9NIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSB0aGUgd2lkZ2V0IGRyYWcgZXZlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEl0ZW0gaW5kZXhcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5wcm90b3R5cGUuc2V0SW5kZXggPSBmdW5jdGlvbiAoIGluZGV4ICkge1xuXHRpZiAoIHRoaXMuaW5kZXggIT09IGluZGV4ICkge1xuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLiRlbGVtZW50LmRhdGEoICdpbmRleCcsIGluZGV4ICk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGl0ZW0gaW5kZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7bnVtYmVyfSBJdGVtIGluZGV4XG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnQucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pbmRleDtcbn07XG5cbi8qKlxuICogRHJhZ2dhYmxlR3JvdXBFbGVtZW50IGlzIGEgbWl4aW4gY2xhc3MgdXNlZCB0byBjcmVhdGUgYSBncm91cCBlbGVtZW50IHRvXG4gKiBjb250YWluIGRyYWdnYWJsZSBlbGVtZW50cywgd2hpY2ggYXJlIGl0ZW1zIHRoYXQgY2FuIGJlIGNsaWNrZWQgYW5kIGRyYWdnZWQgYnkgYSBtb3VzZS5cbiAqIFRoZSBjbGFzcyBpcyB1c2VkIHdpdGggT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ30gW29yaWVudGF0aW9uXSBJdGVtIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJy4gVGhlIG9yaWVudGF0aW9uXG4gKiAgc2hvdWxkIG1hdGNoIHRoZSBsYXlvdXQgb2YgdGhlIGl0ZW1zLiBJdGVtcyBkaXNwbGF5ZWQgaW4gYSBzaW5nbGUgcm93XG4gKiAgb3IgaW4gc2V2ZXJhbCByb3dzIHNob3VsZCB1c2UgaG9yaXpvbnRhbCBvcmllbnRhdGlvbi4gVGhlIHZlcnRpY2FsIG9yaWVudGF0aW9uIHNob3VsZCBvbmx5IGJlXG4gKiAgdXNlZCB3aGVuIHRoZSBpdGVtcyBhcmUgZGlzcGxheWVkIGluIGEgc2luZ2xlIGNvbHVtbi4gRGVmYXVsdHMgdG8gJ3ZlcnRpY2FsJ1xuICogQGNmZyB7Ym9vbGVhbn0gW2RyYWdnYWJsZV0gVGhlIGl0ZW1zIGFyZSBkcmFnZ2FibGUuIFRoaXMgY2FuIGNoYW5nZSB3aXRoICN0b2dnbGVEcmFnZ2FibGVcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluRHJhZ2dhYmxlR3JvdXBFbGVtZW50KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLm9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uIHx8ICd2ZXJ0aWNhbCc7XG5cdHRoaXMuZHJhZ0l0ZW0gPSBudWxsO1xuXHR0aGlzLml0ZW1LZXlzID0ge307XG5cdHRoaXMuZGlyID0gbnVsbDtcblx0dGhpcy5pdGVtc09yZGVyID0gbnVsbDtcblx0dGhpcy5kcmFnZ2FibGUgPSBjb25maWcuZHJhZ2dhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFjb25maWcuZHJhZ2dhYmxlO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmFnZ3JlZ2F0ZSgge1xuXHRcdGRyYWdzdGFydDogJ2l0ZW1EcmFnU3RhcnQnLFxuXHRcdGRyYWdlbmQ6ICdpdGVtRHJhZ0VuZCcsXG5cdFx0ZHJvcDogJ2l0ZW1Ecm9wJ1xuXHR9ICk7XG5cdHRoaXMuY29ubmVjdCggdGhpcywge1xuXHRcdGl0ZW1EcmFnU3RhcnQ6ICdvbkl0ZW1EcmFnU3RhcnQnLFxuXHRcdGl0ZW1Ecm9wOiAnb25JdGVtRHJvcE9yRHJhZ0VuZCcsXG5cdFx0aXRlbURyYWdFbmQ6ICdvbkl0ZW1Ecm9wT3JEcmFnRW5kJ1xuXHR9ICk7XG5cblx0Ly8gSW5pdGlhbGl6ZVxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGNvbmZpZy5pdGVtcyApICkge1xuXHRcdHRoaXMuYWRkSXRlbXMoIGNvbmZpZy5pdGVtcyApO1xuXHR9XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1kcmFnZ2FibGVHcm91cEVsZW1lbnQnIClcblx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1kcmFnZ2FibGVHcm91cEVsZW1lbnQtaG9yaXpvbnRhbCcsIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyApO1xufTtcblxuLyogU2V0dXAgKi9cbk9PLm1peGluQ2xhc3MoIE9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudCwgT08udWkubWl4aW4uR3JvdXBFbGVtZW50ICk7XG5cbi8qIEV2ZW50cyAqL1xuXG4vKipcbiAqIEFuIGl0ZW0gaGFzIGJlZW4gZHJhZ2dlZCB0byBhIG5ldyBwb3NpdGlvbiwgYnV0IG5vdCB5ZXQgZHJvcHBlZC5cbiAqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50fSBpdGVtIERyYWdnZWQgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IFtuZXdJbmRleF0gTmV3IGluZGV4IGZvciB0aGUgaXRlbVxuICovXG5cbi8qKlxuICogQW4gaXRlbSBoYXMgYmVlbiBkcm9wcGVkIGF0IGEgbmV3IHBvc2l0aW9uLlxuICpcbiAqIEBldmVudCByZW9yZGVyXG4gKiBAcGFyYW0ge09PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnR9IGl0ZW0gUmVvcmRlcmVkIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3SW5kZXhdIE5ldyBpbmRleCBmb3IgdGhlIGl0ZW1cbiAqL1xuXG4vKipcbiAqIERyYWdnYWJsZSBzdGF0ZSBvZiB0aGlzIHdpZGdldCBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAZXZlbnQgZHJhZ2dhYmxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkcmFnZ2FibGVdIFdpZGdldCBpcyBkcmFnZ2FibGVcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQ2hhbmdlIHRoZSBkcmFnZ2FibGUgc3RhdGUgb2YgdGhpcyB3aWRnZXQuXG4gKiBUaGlzIGFsbG93cyB1c2VycyB0byB0ZW1wb3JhcmlseSBoYWx0IHRoZSBkcmFnZ2luZyBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEcmFnZ2FibGUgV2lkZ2V0IHN1cHBvcnRzIGRyYWdnYWJsZSBvcGVyYXRpb25zXG4gKiBAZmlyZXMgZHJhZ2dhYmxlXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudC5wcm90b3R5cGUudG9nZ2xlRHJhZ2dhYmxlID0gZnVuY3Rpb24gKCBpc0RyYWdnYWJsZSApIHtcblx0aXNEcmFnZ2FibGUgPSBpc0RyYWdnYWJsZSAhPT0gdW5kZWZpbmVkID8gISFpc0RyYWdnYWJsZSA6ICF0aGlzLmRyYWdnYWJsZTtcblxuXHRpZiAoIHRoaXMuZHJhZ2dhYmxlICE9PSBpc0RyYWdnYWJsZSApIHtcblx0XHR0aGlzLmRyYWdnYWJsZSA9IGlzRHJhZ2dhYmxlO1xuXG5cdFx0Ly8gVGVsbCB0aGUgaXRlbXMgdGhlaXIgZHJhZ2dhYmxlIHN0YXRlIGNoYW5nZWRcblx0XHR0aGlzLmdldEl0ZW1zKCkuZm9yRWFjaCggZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdFx0aXRlbS50b2dnbGVEcmFnZ2FibGUoIHRoaXMuZHJhZ2dhYmxlICk7XG5cdFx0fS5iaW5kKCB0aGlzICkgKTtcblxuXHRcdC8vIEVtaXQgZXZlbnRcblx0XHR0aGlzLmVtaXQoICdkcmFnZ2FibGUnLCB0aGlzLmRyYWdnYWJsZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBkcmFnZ2FibGUgc3RhdGUgb2YgdGhpcyB3aWRnZXRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaWRnZXQgc3VwcG9ydHMgZHJhZ2dhYmxlIG9wZXJhdGlvbnNcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlR3JvdXBFbGVtZW50LnByb3RvdHlwZS5pc0RyYWdnYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZHJhZ2dhYmxlO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGl0ZW0gZHJhZyBzdGFydCBldmVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09PLnVpLm1peGluLkRyYWdnYWJsZUVsZW1lbnR9IGl0ZW0gRHJhZ2dlZCBpdGVtXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudC5wcm90b3R5cGUub25JdGVtRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoICF0aGlzLmlzRHJhZ2dhYmxlKCkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIE1ha2UgYSBzaGFsbG93IGNvcHkgb2YgdGhpcy5pdGVtcyBzbyB3ZSBjYW4gcmUtb3JkZXIgaXQgZHVyaW5nIHByZXZpZXdzXG5cdC8vIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBvcmlnaW5hbCBhcnJheS5cblx0dGhpcy5pdGVtc09yZGVyID0gdGhpcy5pdGVtcy5zbGljZSgpO1xuXHR0aGlzLnVwZGF0ZUluZGV4ZXMoKTtcblx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0Ly8gQ2FsY3VsYXRlIGFuZCBjYWNoZSBkaXJlY3Rpb25hbGl0eSBvbiBkcmFnIHN0YXJ0IC0gaXQncyBhIGxpdHRsZVxuXHRcdC8vIGV4cGVuc2l2ZSBhbmQgaXQgc2hvdWxkbid0IGNoYW5nZSB3aGlsZSBkcmFnZ2luZy5cblx0XHR0aGlzLmRpciA9IHRoaXMuJGVsZW1lbnQuY3NzKCAnZGlyZWN0aW9uJyApO1xuXHR9XG5cdHRoaXMuc2V0RHJhZ0l0ZW0oIGl0ZW0gKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBpbmRleCBwcm9wZXJ0aWVzIG9mIHRoZSBpdGVtc1xuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVHcm91cEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZUluZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpLCBsZW47XG5cblx0Ly8gTWFwIHRoZSBpbmRleCBvZiBlYWNoIG9iamVjdFxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5pdGVtc09yZGVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHRoaXMuaXRlbXNPcmRlclsgaSBdLnNldEluZGV4KCBpICk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGRyb3Agb3IgZHJhZ2VuZCBldmVudCBhbmQgc3dpdGNoIHRoZSBvcmRlciBvZiB0aGUgaXRlbXMgYWNjb3JkaW5nbHlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50fSBpdGVtIERyb3BwZWQgaXRlbVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVHcm91cEVsZW1lbnQucHJvdG90eXBlLm9uSXRlbURyb3BPckRyYWdFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB0YXJnZXRJbmRleCwgb3JpZ2luYWxJbmRleCxcblx0XHRpdGVtID0gdGhpcy5nZXREcmFnSXRlbSgpO1xuXG5cdC8vIFRPRE86IEZpZ3VyZSBvdXQgYSB3YXkgdG8gY29uZmlndXJlIGEgbGlzdCBvZiBsZWdhbGx5IGRyb3BwYWJsZVxuXHQvLyBlbGVtZW50cyBldmVuIGlmIHRoZXkgYXJlIG5vdCB5ZXQgaW4gdGhlIGxpc3Rcblx0aWYgKCBpdGVtICkge1xuXHRcdG9yaWdpbmFsSW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKTtcblx0XHQvLyBJZiB0aGUgaXRlbSBoYXMgbW92ZWQgZm9yd2FyZCwgYWRkIG9uZSB0byB0aGUgaW5kZXggdG8gYWNjb3VudCBmb3IgdGhlIGxlZnQgc2hpZnRcblx0XHR0YXJnZXRJbmRleCA9IGl0ZW0uZ2V0SW5kZXgoKSArICggaXRlbS5nZXRJbmRleCgpID4gb3JpZ2luYWxJbmRleCA/IDEgOiAwICk7XG5cdFx0aWYgKCB0YXJnZXRJbmRleCAhPT0gb3JpZ2luYWxJbmRleCApIHtcblx0XHRcdHRoaXMucmVvcmRlciggdGhpcy5nZXREcmFnSXRlbSgpLCB0YXJnZXRJbmRleCApO1xuXHRcdFx0dGhpcy5lbWl0KCAncmVvcmRlcicsIHRoaXMuZ2V0RHJhZ0l0ZW0oKSwgdGFyZ2V0SW5kZXggKTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVJbmRleGVzKCk7XG5cdH1cblx0dGhpcy51bnNldERyYWdJdGVtKCk7XG5cdC8vIFJldHVybiBmYWxzZSB0byBwcmV2ZW50IHByb3BvZ2F0aW9uXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byBkcmFnb3ZlciBldmVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBEcmFnb3ZlciBldmVudFxuICogQGZpcmVzIHJlb3JkZXJcbiAqL1xuT08udWkubWl4aW4uRHJhZ2dhYmxlR3JvdXBFbGVtZW50LnByb3RvdHlwZS5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgb3ZlckluZGV4LCB0YXJnZXRJbmRleCxcblx0XHRpdGVtID0gdGhpcy5nZXREcmFnSXRlbSgpLFxuXHRcdGRyYWdJdGVtSW5kZXggPSBpdGVtLmdldEluZGV4KCk7XG5cblx0Ly8gR2V0IHRoZSBPcHRpb25XaWRnZXQgaXRlbSB3ZSBhcmUgZHJhZ2dpbmcgb3ZlclxuXHRvdmVySW5kZXggPSAkKCBlLnRhcmdldCApLmNsb3Nlc3QoICcub28tdWktZHJhZ2dhYmxlRWxlbWVudCcgKS5kYXRhKCAnaW5kZXgnICk7XG5cblx0aWYgKCBvdmVySW5kZXggIT09IHVuZGVmaW5lZCAmJiBvdmVySW5kZXggIT09IGRyYWdJdGVtSW5kZXggKSB7XG5cdFx0dGFyZ2V0SW5kZXggPSBvdmVySW5kZXggKyAoIG92ZXJJbmRleCA+IGRyYWdJdGVtSW5kZXggPyAxIDogMCApO1xuXG5cdFx0aWYgKCB0YXJnZXRJbmRleCA+IDAgKSB7XG5cdFx0XHR0aGlzLiRncm91cC5jaGlsZHJlbigpLmVxKCB0YXJnZXRJbmRleCAtIDEgKS5hZnRlciggaXRlbS4kZWxlbWVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRncm91cC5wcmVwZW5kKCBpdGVtLiRlbGVtZW50ICk7XG5cdFx0fVxuXHRcdC8vIE1vdmUgaXRlbSBpbiBpdGVtc09yZGVyIGFycmF5XG5cdFx0dGhpcy5pdGVtc09yZGVyLnNwbGljZSggb3ZlckluZGV4LCAwLFxuXHRcdFx0dGhpcy5pdGVtc09yZGVyLnNwbGljZSggZHJhZ0l0ZW1JbmRleCwgMSApWyAwIF1cblx0XHQpO1xuXHRcdHRoaXMudXBkYXRlSW5kZXhlcygpO1xuXHRcdHRoaXMuZW1pdCggJ2RyYWcnLCBpdGVtLCB0YXJnZXRJbmRleCApO1xuXHR9XG5cdC8vIFByZXZlbnQgZGVmYXVsdFxuXHRlLnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgdGhlIGl0ZW1zIGluIHRoZSBncm91cFxuICpcbiAqIEBwYXJhbSB7T08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudH0gaXRlbSBSZW9yZGVyZWQgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IE5ldyBpbmRleFxuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVHcm91cEVsZW1lbnQucHJvdG90eXBlLnJlb3JkZXIgPSBmdW5jdGlvbiAoIGl0ZW0sIG5ld0luZGV4ICkge1xuXHR0aGlzLmFkZEl0ZW1zKCBbIGl0ZW0gXSwgbmV3SW5kZXggKTtcbn07XG5cbi8qKlxuICogU2V0IGEgZHJhZ2dlZCBpdGVtXG4gKlxuICogQHBhcmFtIHtPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50fSBpdGVtIERyYWdnZWQgaXRlbVxuICovXG5PTy51aS5taXhpbi5EcmFnZ2FibGVHcm91cEVsZW1lbnQucHJvdG90eXBlLnNldERyYWdJdGVtID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoIHRoaXMuZHJhZ0l0ZW0gIT09IGl0ZW0gKSB7XG5cdFx0dGhpcy5kcmFnSXRlbSA9IGl0ZW07XG5cdFx0dGhpcy4kZWxlbWVudC5vbiggJ2RyYWdvdmVyJywgdGhpcy5vbkRyYWdPdmVyLmJpbmQoIHRoaXMgKSApO1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1kcmFnZ2FibGVHcm91cEVsZW1lbnQtZHJhZ2dpbmcnICk7XG5cdH1cbn07XG5cbi8qKlxuICogVW5zZXQgdGhlIGN1cnJlbnQgZHJhZ2dlZCBpdGVtXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudC5wcm90b3R5cGUudW5zZXREcmFnSXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmRyYWdJdGVtICkge1xuXHRcdHRoaXMuZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdHRoaXMuJGVsZW1lbnQub2ZmKCAnZHJhZ292ZXInICk7XG5cdFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLWRyYWdnYWJsZUdyb3VwRWxlbWVudC1kcmFnZ2luZycgKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50fG51bGx9IFRoZSBjdXJyZW50bHkgZHJhZ2dlZCBpdGVtLCBvciBgbnVsbGAgaWYgbm8gaXRlbSBpcyBiZWluZyBkcmFnZ2VkXG4gKi9cbk9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudC5wcm90b3R5cGUuZ2V0RHJhZ0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmRyYWdJdGVtO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0TWFuYWdlciBpcyBhIG1peGluIHRoYXQgbWFuYWdlcyB0aGUgbGlmZWN5Y2xlIG9mIGEgcHJvbWlzZS1iYWNrZWQgcmVxdWVzdCBmb3IgYSB3aWRnZXQsIHN1Y2ggYXNcbiAqIHRoZSB7QGxpbmsgT08udWkubWl4aW4uTG9va3VwRWxlbWVudH0uXG4gKlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuT08udWkubWl4aW4uUmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiBPb1VpTWl4aW5SZXF1ZXN0TWFuYWdlcigpIHtcblx0dGhpcy5yZXF1ZXN0Q2FjaGUgPSB7fTtcblx0dGhpcy5yZXF1ZXN0UXVlcnkgPSBudWxsO1xuXHR0aGlzLnJlcXVlc3RSZXF1ZXN0ID0gbnVsbDtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaXRDbGFzcyggT08udWkubWl4aW4uUmVxdWVzdE1hbmFnZXIgKTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCByZXN1bHRzIGZvciB0aGUgY3VycmVudCBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtqUXVlcnkuUHJvbWlzZX0gUHJvbWlzZSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBwYXNzZWQgcmVzcG9uc2UgZGF0YSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2ZcbiAqICAgdGhlIGRvbmUgZXZlbnQuIElmIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkIHRvIG1ha2Ugd2F5IGZvciBhIHN1YnNlcXVlbnQgcmVxdWVzdCwgdGhpcyBwcm9taXNlXG4gKiAgIG1heSBub3QgYmUgcmVqZWN0ZWQsIGRlcGVuZGluZyBvbiB3aGF0IGpRdWVyeSBmZWVscyBsaWtlIGRvaW5nLlxuICovXG5PTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuZ2V0UmVxdWVzdERhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB3aWRnZXQgPSB0aGlzLFxuXHRcdHZhbHVlID0gdGhpcy5nZXRSZXF1ZXN0UXVlcnkoKSxcblx0XHRkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcblx0XHRvdXJSZXF1ZXN0O1xuXG5cdHRoaXMuYWJvcnRSZXF1ZXN0KCk7XG5cdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0aGlzLnJlcXVlc3RDYWNoZSwgdmFsdWUgKSApIHtcblx0XHRkZWZlcnJlZC5yZXNvbHZlKCB0aGlzLnJlcXVlc3RDYWNoZVsgdmFsdWUgXSApO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdGhpcy5wdXNoUGVuZGluZyApIHtcblx0XHRcdHRoaXMucHVzaFBlbmRpbmcoKTtcblx0XHR9XG5cdFx0dGhpcy5yZXF1ZXN0UXVlcnkgPSB2YWx1ZTtcblx0XHRvdXJSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0UmVxdWVzdCA9IHRoaXMuZ2V0UmVxdWVzdCgpO1xuXHRcdG91clJlcXVlc3Rcblx0XHRcdC5hbHdheXMoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBwb3AgcGVuZGluZyBldmVuIGlmIHRoaXMgaXMgYW4gb2xkIHJlcXVlc3QsIG90aGVyd2lzZVxuXHRcdFx0XHQvLyB0aGUgd2lkZ2V0IHdpbGwgcmVtYWluIHBlbmRpbmcgZm9yZXZlci5cblx0XHRcdFx0Ly8gVE9ETzogdGhpcyBhc3N1bWVzIHRoYXQgYW4gYWJvcnRlZCByZXF1ZXN0IHdpbGwgZmFpbCBvciBzdWNjZWVkIHNvb24gYWZ0ZXJcblx0XHRcdFx0Ly8gYmVpbmcgYWJvcnRlZCwgb3IgYXQgbGVhc3QgZXZlbnR1YWxseS4gSXQgd291bGQgYmUgbmljZSBpZiB3ZSBjb3VsZCBwb3BQZW5kaW5nKClcblx0XHRcdFx0Ly8gYXQgYWJvcnQgdGltZSwgYnV0IG9ubHkgaWYgd2Uga25ldyB0aGF0IHdlIGhhZG4ndCBhbHJlYWR5IGNhbGxlZCBwb3BQZW5kaW5nKClcblx0XHRcdFx0Ly8gZm9yIHRoYXQgcmVxdWVzdC5cblx0XHRcdFx0aWYgKCB3aWRnZXQucG9wUGVuZGluZyApIHtcblx0XHRcdFx0XHR3aWRnZXQucG9wUGVuZGluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdC5kb25lKCBmdW5jdGlvbiAoIHJlc3BvbnNlICkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIG9sZCByZXF1ZXN0IChhbmQgYWJvcnRpbmcgaXQgc29tZWhvdyBjYXVzZWQgaXQgdG8gc3RpbGwgc3VjY2VlZCksXG5cdFx0XHRcdC8vIGlnbm9yZSBpdHMgc3VjY2VzcyBjb21wbGV0ZWx5XG5cdFx0XHRcdGlmICggb3VyUmVxdWVzdCA9PT0gd2lkZ2V0LnJlcXVlc3RSZXF1ZXN0ICkge1xuXHRcdFx0XHRcdHdpZGdldC5yZXF1ZXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0XHRcdHdpZGdldC5yZXF1ZXN0UmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdFx0d2lkZ2V0LnJlcXVlc3RDYWNoZVsgdmFsdWUgXSA9IHdpZGdldC5nZXRSZXF1ZXN0Q2FjaGVEYXRhRnJvbVJlc3BvbnNlKCByZXNwb25zZSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUoIHdpZGdldC5yZXF1ZXN0Q2FjaGVbIHZhbHVlIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQuZmFpbCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIG9sZCByZXF1ZXN0IChvciBhIHJlcXVlc3QgZmFpbGluZyBiZWNhdXNlIGl0J3MgYmVpbmcgYWJvcnRlZCksXG5cdFx0XHRcdC8vIGlnbm9yZSBpdHMgZmFpbHVyZSBjb21wbGV0ZWx5XG5cdFx0XHRcdGlmICggb3VyUmVxdWVzdCA9PT0gd2lkZ2V0LnJlcXVlc3RSZXF1ZXN0ICkge1xuXHRcdFx0XHRcdHdpZGdldC5yZXF1ZXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0XHRcdHdpZGdldC5yZXF1ZXN0UmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fVxuXHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgY3VycmVudGx5IHBlbmRpbmcgcmVxdWVzdCwgaWYgYW55LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLm1peGluLlJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5hYm9ydFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvbGRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0UmVxdWVzdDtcblx0aWYgKCBvbGRSZXF1ZXN0ICkge1xuXHRcdC8vIEZpcnN0IHVuc2V0IHRoaXMucmVxdWVzdFJlcXVlc3QgdG8gdGhlIGZhaWwgaGFuZGxlciB3aWxsIG5vdGljZVxuXHRcdC8vIHRoYXQgdGhlIHJlcXVlc3QgaXMgbm8gbG9uZ2VyIGN1cnJlbnRcblx0XHR0aGlzLnJlcXVlc3RSZXF1ZXN0ID0gbnVsbDtcblx0XHR0aGlzLnJlcXVlc3RRdWVyeSA9IG51bGw7XG5cdFx0b2xkUmVxdWVzdC5hYm9ydCgpO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVlcnkgdG8gYmUgbWFkZS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAbWV0aG9kXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gcXVlcnkgdG8gYmUgdXNlZFxuICovXG5PTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuZ2V0UmVxdWVzdFF1ZXJ5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgYSBuZXcgcmVxdWVzdCBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgcXVlcnkgdmFsdWUuXG4gKlxuICogQHByb3RlY3RlZFxuICogQG1ldGhvZFxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtqUXVlcnkuUHJvbWlzZX0galF1ZXJ5IEFKQVggb2JqZWN0LCBvciBwcm9taXNlIG9iamVjdCB3aXRoIGFuIC5hYm9ydCgpIG1ldGhvZFxuICovXG5PTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuZ2V0UmVxdWVzdCA9IG51bGw7XG5cbi8qKlxuICogUHJlLXByb2Nlc3MgZGF0YSByZXR1cm5lZCBieSB0aGUgcmVxdWVzdCBmcm9tICNnZXRSZXF1ZXN0LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhY2hlZCwgYW5kIGFueSBmdXJ0aGVyIHF1ZXJpZXMgZm9yIHRoZSBnaXZlbiB2YWx1ZVxuICogd2lsbCB1c2UgdGhlIGNhY2hlIHJhdGhlciB0aGFuIGRvaW5nIEFQSSByZXF1ZXN0cy5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAbWV0aG9kXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7TWl4ZWR9IHJlc3BvbnNlIFJlc3BvbnNlIGZyb20gc2VydmVyXG4gKiBAcmV0dXJuIHtNaXhlZH0gQ2FjaGVkIHJlc3VsdCBkYXRhXG4gKi9cbk9PLnVpLm1peGluLlJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZXF1ZXN0Q2FjaGVEYXRhRnJvbVJlc3BvbnNlID0gbnVsbDtcblxuLyoqXG4gKiBMb29rdXBFbGVtZW50IGlzIGEgbWl4aW4gdGhhdCBjcmVhdGVzIGEge0BsaW5rIE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQgbWVudX0gb2Ygc3VnZ2VzdGVkIHZhbHVlcyBmb3JcbiAqIGEge0BsaW5rIE9PLnVpLlRleHRJbnB1dFdpZGdldCB0ZXh0IGlucHV0IHdpZGdldH0uIFN1Z2dlc3RlZCB2YWx1ZXMgYXJlIGJhc2VkIG9uIHRoZSBjaGFyYWN0ZXJzIHRoZSB1c2VyIHR5cGVzXG4gKiBpbnRvIHRoZSB0ZXh0IGlucHV0IGZpZWxkIGFuZCwgaW4gZ2VuZXJhbCwgdGhlIG1lbnUgaXMgb25seSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciB0eXBlcy4gSWYgYSBzdWdnZXN0ZWQgdmFsdWUgaXMgY2hvc2VuXG4gKiBmcm9tIHRoZSBsb29rdXAgbWVudSwgdGhhdCB2YWx1ZSBiZWNvbWVzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gKlxuICogTm90ZSB0aGF0IGEgbmV3IG1lbnUgb2Ygc3VnZ2VzdGVkIGl0ZW1zIGlzIGRpc3BsYXllZCB3aGVuIGEgdmFsdWUgaXMgY2hvc2VuIGZyb20gdGhlIGxvb2t1cCBtZW51LiBJZiB0aGlzIGlzXG4gKiBub3QgdGhlIGRlc2lyZWQgYmVoYXZpb3IsIGRpc2FibGUgbG9va3VwIG1lbnVzIHdpdGggdGhlICNzZXRMb29rdXBzRGlzYWJsZWQgbWV0aG9kLCB0aGVuIHNldCB0aGUgdmFsdWUsIHRoZW5cbiAqIHJlLWVuYWJsZSBsb29rdXBzLlxuICpcbiAqIFNlZSB0aGUgW09PVUkgZGVtb3NdWzFdIGZvciBhbiBleGFtcGxlLlxuICpcbiAqIFsxXTogaHR0cHM6Ly9kb2Mud2lraW1lZGlhLm9yZy9vb2pzLXVpL21hc3Rlci9kZW1vcy8jTG9va3VwRWxlbWVudC10cnktaW5wdXR0aW5nLWFuLWludGVnZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQG1peGlucyBPTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fSBbJG92ZXJsYXldIE92ZXJsYXkgZm9yIHRoZSBsb29rdXAgbWVudTsgZGVmYXVsdHMgdG8gcmVsYXRpdmUgcG9zaXRpb25pbmcuXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKiBAY2ZnIHtqUXVlcnl9IFskY29udGFpbmVyPXRoaXMuJGVsZW1lbnRdIFRoZSBjb250YWluZXIgZWxlbWVudC4gVGhlIGxvb2t1cCBtZW51IGlzIHJlbmRlcmVkIGJlbmVhdGggdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICogQGNmZyB7T2JqZWN0fSBbbWVudV0gQ29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIE9PLnVpLk1lbnVTZWxlY3RXaWRnZXQgbWVudSBzZWxlY3Qgd2lkZ2V0fVxuICogQGNmZyB7Ym9vbGVhbn0gW2FsbG93U3VnZ2VzdGlvbnNXaGVuRW1wdHk9ZmFsc2VdIFJlcXVlc3QgYW5kIGRpc3BsYXkgYSBsb29rdXAgbWVudSB3aGVuIHRoZSB0ZXh0IGlucHV0IGlzIGVtcHR5LlxuICogIEJ5IGRlZmF1bHQsIHRoZSBsb29rdXAgbWVudSBpcyBub3QgZ2VuZXJhdGVkIGFuZCBkaXNwbGF5ZWQgdW50aWwgdGhlIHVzZXIgYmVnaW5zIHRvIHR5cGUuXG4gKiBAY2ZnIHtib29sZWFufSBbaGlnaGxpZ2h0Rmlyc3Q9dHJ1ZV0gV2hldGhlciB0aGUgZmlyc3QgbG9va3VwIHJlc3VsdCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQgKHNvLCB0aGF0IHRoZSB1c2VyIGNhblxuICogIHRha2UgaXQgb3ZlciBpbnRvIHRoZSBpbnB1dCB3aXRoIHNpbXBseSBwcmVzc2luZyByZXR1cm4pIGF1dG9tYXRpY2FsbHkgb3Igbm90LlxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50ID0gZnVuY3Rpb24gT29VaU1peGluTG9va3VwRWxlbWVudCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7IGhpZ2hsaWdodEZpcnN0OiB0cnVlIH0sIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlci5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuJG92ZXJsYXkgPSAoIGNvbmZpZy4kb3ZlcmxheSA9PT0gdHJ1ZSA/IE9PLnVpLmdldERlZmF1bHRPdmVybGF5KCkgOiBjb25maWcuJG92ZXJsYXkgKSB8fCB0aGlzLiRlbGVtZW50O1xuXHR0aGlzLmxvb2t1cE1lbnUgPSBuZXcgT08udWkuTWVudVNlbGVjdFdpZGdldCggJC5leHRlbmQoIHtcblx0XHR3aWRnZXQ6IHRoaXMsXG5cdFx0aW5wdXQ6IHRoaXMsXG5cdFx0JGZsb2F0YWJsZUNvbnRhaW5lcjogY29uZmlnLiRjb250YWluZXIgfHwgdGhpcy4kZWxlbWVudFxuXHR9LCBjb25maWcubWVudSApICk7XG5cblx0dGhpcy5hbGxvd1N1Z2dlc3Rpb25zV2hlbkVtcHR5ID0gY29uZmlnLmFsbG93U3VnZ2VzdGlvbnNXaGVuRW1wdHkgfHwgZmFsc2U7XG5cblx0dGhpcy5sb29rdXBzRGlzYWJsZWQgPSBmYWxzZTtcblx0dGhpcy5sb29rdXBJbnB1dEZvY3VzZWQgPSBmYWxzZTtcblx0dGhpcy5sb29rdXBIaWdobGlnaHRGaXJzdEl0ZW0gPSBjb25maWcuaGlnaGxpZ2h0Rmlyc3Q7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGlucHV0Lm9uKCB7XG5cdFx0Zm9jdXM6IHRoaXMub25Mb29rdXBJbnB1dEZvY3VzLmJpbmQoIHRoaXMgKSxcblx0XHRibHVyOiB0aGlzLm9uTG9va3VwSW5wdXRCbHVyLmJpbmQoIHRoaXMgKSxcblx0XHRtb3VzZWRvd246IHRoaXMub25Mb29rdXBJbnB1dE1vdXNlRG93bi5iaW5kKCB0aGlzIClcblx0fSApO1xuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHsgY2hhbmdlOiAnb25Mb29rdXBJbnB1dENoYW5nZScgfSApO1xuXHR0aGlzLmxvb2t1cE1lbnUuY29ubmVjdCggdGhpcywge1xuXHRcdHRvZ2dsZTogJ29uTG9va3VwTWVudVRvZ2dsZScsXG5cdFx0Y2hvb3NlOiAnb25Mb29rdXBNZW51SXRlbUNob29zZSdcblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGlucHV0LmF0dHIoIHtcblx0XHRyb2xlOiAnY29tYm9ib3gnLFxuXHRcdCdhcmlhLW93bnMnOiB0aGlzLmxvb2t1cE1lbnUuZ2V0RWxlbWVudElkKCksXG5cdFx0J2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnXG5cdH0gKTtcblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWxvb2t1cEVsZW1lbnQnICk7XG5cdHRoaXMubG9va3VwTWVudS4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWxvb2t1cEVsZW1lbnQtbWVudScgKTtcblx0dGhpcy4kb3ZlcmxheS5hcHBlbmQoIHRoaXMubG9va3VwTWVudS4kZWxlbWVudCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08ubWl4aW5DbGFzcyggT08udWkubWl4aW4uTG9va3VwRWxlbWVudCwgT08udWkubWl4aW4uUmVxdWVzdE1hbmFnZXIgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSBpbnB1dCBmb2N1cyBldmVudC5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBJbnB1dCBmb2N1cyBldmVudFxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5vbkxvb2t1cElucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMubG9va3VwSW5wdXRGb2N1c2VkID0gdHJ1ZTtcblx0dGhpcy5wb3B1bGF0ZUxvb2t1cE1lbnUoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGlucHV0IGJsdXIgZXZlbnQuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgSW5wdXQgYmx1ciBldmVudFxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5vbkxvb2t1cElucHV0Qmx1ciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5jbG9zZUxvb2t1cE1lbnUoKTtcblx0dGhpcy5sb29rdXBJbnB1dEZvY3VzZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGlucHV0IG1vdXNlIGRvd24gZXZlbnQuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgSW5wdXQgbW91c2UgZG93biBldmVudFxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5vbkxvb2t1cElucHV0TW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xuXHQvLyBPbmx5IG9wZW4gdGhlIG1lbnUgaWYgdGhlIGlucHV0IHdhcyBhbHJlYWR5IGZvY3VzZWQuXG5cdC8vIFRoaXMgd2F5IHdlIGFsbG93IHRoZSB1c2VyIHRvIG9wZW4gdGhlIG1lbnUgYWdhaW4gYWZ0ZXIgY2xvc2luZyBpdCB3aXRoIEVzY1xuXHQvLyBieSBjbGlja2luZyBpbiB0aGUgaW5wdXQuIE9wZW5pbmcgKGFuZCBwb3B1bGF0aW5nKSB0aGUgbWVudSB3aGVuIGluaXRpYWxseVxuXHQvLyBjbGlja2luZyBpbnRvIHRoZSBpbnB1dCBpcyBoYW5kbGVkIGJ5IHRoZSBmb2N1cyBoYW5kbGVyLlxuXHRpZiAoIHRoaXMubG9va3VwSW5wdXRGb2N1c2VkICYmICF0aGlzLmxvb2t1cE1lbnUuaXNWaXNpYmxlKCkgKSB7XG5cdFx0dGhpcy5wb3B1bGF0ZUxvb2t1cE1lbnUoKTtcblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGUgaW5wdXQgY2hhbmdlIGV2ZW50LlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBOZXcgaW5wdXQgdmFsdWVcbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUub25Mb29rdXBJbnB1dENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmxvb2t1cElucHV0Rm9jdXNlZCApIHtcblx0XHR0aGlzLnBvcHVsYXRlTG9va3VwTWVudSgpO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgbG9va3VwIG1lbnUgYmVpbmcgc2hvd24vaGlkZGVuLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZSBXaGV0aGVyIHRoZSBsb29rdXAgbWVudSBpcyBub3cgdmlzaWJsZS5cbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUub25Mb29rdXBNZW51VG9nZ2xlID0gZnVuY3Rpb24gKCB2aXNpYmxlICkge1xuXHRpZiAoICF2aXNpYmxlICkge1xuXHRcdC8vIFdoZW4gdGhlIG1lbnUgaXMgaGlkZGVuLCBhYm9ydCBhbnkgYWN0aXZlIHJlcXVlc3QgYW5kIGNsZWFyIHRoZSBtZW51LlxuXHRcdC8vIFRoaXMgaGFzIHRvIGJlIGRvbmUgaGVyZSBpbiBhZGRpdGlvbiB0byBjbG9zZUxvb2t1cE1lbnUoKSwgYmVjYXVzZVxuXHRcdC8vIE1lbnVTZWxlY3RXaWRnZXQgd2lsbCBjbG9zZSBpdHNlbGYgd2hlbiB0aGUgdXNlciBwcmVzc2VzIEVzYy5cblx0XHR0aGlzLmFib3J0TG9va3VwUmVxdWVzdCgpO1xuXHRcdHRoaXMubG9va3VwTWVudS5jbGVhckl0ZW1zKCk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIG1lbnUgaXRlbSAnY2hvb3NlJyBldmVudCwgdXBkYXRpbmcgdGhlIHRleHQgaW5wdXQgdmFsdWUgdG8gdGhlIHZhbHVlIG9mIHRoZSBjbGlja2VkIGl0ZW0uXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtPTy51aS5NZW51T3B0aW9uV2lkZ2V0fSBpdGVtIFNlbGVjdGVkIGl0ZW1cbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUub25Mb29rdXBNZW51SXRlbUNob29zZSA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0dGhpcy5zZXRWYWx1ZSggaXRlbS5nZXREYXRhKCkgKTtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCBtZW51LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtPTy51aS5NZW51U2VsZWN0V2lkZ2V0fVxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5nZXRMb29rdXBNZW51ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5sb29rdXBNZW51O1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIG9yIHJlLWVuYWJsZSBsb29rdXBzLlxuICpcbiAqIFdoZW4gbG9va3VwcyBhcmUgZGlzYWJsZWQsIGNhbGxzIHRvICNwb3B1bGF0ZUxvb2t1cE1lbnUgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgRGlzYWJsZSBsb29rdXBzXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLnNldExvb2t1cHNEaXNhYmxlZCA9IGZ1bmN0aW9uICggZGlzYWJsZWQgKSB7XG5cdHRoaXMubG9va3Vwc0Rpc2FibGVkID0gISFkaXNhYmxlZDtcbn07XG5cbi8qKlxuICogT3BlbiB0aGUgbWVudS4gSWYgdGhlcmUgYXJlIG5vIGVudHJpZXMgaW4gdGhlIG1lbnUsIHRoaXMgZG9lcyBub3RoaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5FbGVtZW50fSBUaGUgZWxlbWVudCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLm9wZW5Mb29rdXBNZW51ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLmxvb2t1cE1lbnUuaXNFbXB0eSgpICkge1xuXHRcdHRoaXMubG9va3VwTWVudS50b2dnbGUoIHRydWUgKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIG1lbnUsIGVtcHR5IGl0LCBhbmQgYWJvcnQgYW55IHBlbmRpbmcgcmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5jbG9zZUxvb2t1cE1lbnUgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMubG9va3VwTWVudS50b2dnbGUoIGZhbHNlICk7XG5cdHRoaXMuYWJvcnRMb29rdXBSZXF1ZXN0KCk7XG5cdHRoaXMubG9va3VwTWVudS5jbGVhckl0ZW1zKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IG1lbnUgaXRlbXMgYmFzZWQgb24gdGhlIGlucHV0J3MgY3VycmVudCB2YWx1ZSwgYW5kIHdoZW4gdGhleSBhcnJpdmUsXG4gKiBwb3B1bGF0ZSB0aGUgbWVudSB3aXRoIHRoZXNlIGl0ZW1zIGFuZCBzaG93IHRoZSBtZW51LlxuICpcbiAqIElmIGxvb2t1cHMgaGF2ZSBiZWVuIGRpc2FibGVkIHdpdGggI3NldExvb2t1cHNEaXNhYmxlZCwgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkVsZW1lbnR9IFRoZSBlbGVtZW50LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUucG9wdWxhdGVMb29rdXBNZW51ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgd2lkZ2V0ID0gdGhpcyxcblx0XHR2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRpZiAoIHRoaXMubG9va3Vwc0Rpc2FibGVkIHx8IHRoaXMuaXNSZWFkT25seSgpICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIElmIHRoZSBpbnB1dCBpcyBlbXB0eSwgY2xlYXIgdGhlIG1lbnUsIHVubGVzcyBzdWdnZXN0aW9ucyB3aGVuIGVtcHR5IGFyZSBhbGxvd2VkLlxuXHRpZiAoICF0aGlzLmFsbG93U3VnZ2VzdGlvbnNXaGVuRW1wdHkgJiYgdmFsdWUgPT09ICcnICkge1xuXHRcdHRoaXMuY2xvc2VMb29rdXBNZW51KCk7XG5cdC8vIFNraXAgcG9wdWxhdGlvbiBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgcmVxdWVzdCBwZW5kaW5nIGZvciB0aGUgY3VycmVudCB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdGhpcy5sb29rdXBRdWVyeSApIHtcblx0XHR0aGlzLmdldExvb2t1cE1lbnVJdGVtcygpXG5cdFx0XHQuZG9uZSggZnVuY3Rpb24gKCBpdGVtcyApIHtcblx0XHRcdFx0d2lkZ2V0Lmxvb2t1cE1lbnUuY2xlYXJJdGVtcygpO1xuXHRcdFx0XHRpZiAoIGl0ZW1zLmxlbmd0aCApIHtcblx0XHRcdFx0XHR3aWRnZXQubG9va3VwTWVudVxuXHRcdFx0XHRcdFx0LmFkZEl0ZW1zKCBpdGVtcyApXG5cdFx0XHRcdFx0XHQudG9nZ2xlKCB0cnVlICk7XG5cdFx0XHRcdFx0d2lkZ2V0LmluaXRpYWxpemVMb29rdXBNZW51U2VsZWN0aW9uKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2lkZ2V0Lmxvb2t1cE1lbnUudG9nZ2xlKCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdC5mYWlsKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHdpZGdldC5sb29rdXBNZW51LmNsZWFySXRlbXMoKTtcblx0XHRcdFx0d2lkZ2V0Lmxvb2t1cE1lbnUudG9nZ2xlKCBmYWxzZSApO1xuXHRcdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhpZ2hsaWdodCB0aGUgZmlyc3Qgc2VsZWN0YWJsZSBpdGVtIGluIHRoZSBtZW51LCBpZiBjb25maWd1cmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLmluaXRpYWxpemVMb29rdXBNZW51U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMubG9va3VwSGlnaGxpZ2h0Rmlyc3RJdGVtICYmICF0aGlzLmxvb2t1cE1lbnUuZmluZFNlbGVjdGVkSXRlbSgpICkge1xuXHRcdHRoaXMubG9va3VwTWVudS5oaWdobGlnaHRJdGVtKCB0aGlzLmxvb2t1cE1lbnUuZmluZEZpcnN0U2VsZWN0YWJsZUl0ZW0oKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgbWVudSBpdGVtcyBmb3IgdGhlIGN1cnJlbnQgcXVlcnkuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIG9iamVjdCB3aGljaCB3aWxsIGJlIHBhc3NlZCBtZW51IGl0ZW1zIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZlxuICogICB0aGUgZG9uZSBldmVudC4gSWYgdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQgdG8gbWFrZSB3YXkgZm9yIGEgc3Vic2VxdWVudCByZXF1ZXN0LCB0aGlzIHByb21pc2VcbiAqICAgd2lsbCBub3QgYmUgcmVqZWN0ZWQ6IGl0IHdpbGwgcmVtYWluIHBlbmRpbmcgZm9yZXZlci5cbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUuZ2V0TG9va3VwTWVudUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5nZXRSZXF1ZXN0RGF0YSgpLnRoZW4oIGZ1bmN0aW9uICggZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb29rdXBNZW51T3B0aW9uc0Zyb21EYXRhKCBkYXRhICk7XG5cdH0uYmluZCggdGhpcyApICk7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSBjdXJyZW50bHkgcGVuZGluZyBsb29rdXAgcmVxdWVzdCwgaWYgYW55LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLmFib3J0TG9va3VwUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5hYm9ydFJlcXVlc3QoKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbmV3IHJlcXVlc3Qgb2JqZWN0IG9mIHRoZSBjdXJyZW50IGxvb2t1cCBxdWVyeSB2YWx1ZS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAbWV0aG9kXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBqUXVlcnkgQUpBWCBvYmplY3QsIG9yIHByb21pc2Ugb2JqZWN0IHdpdGggYW4gLmFib3J0KCkgbWV0aG9kXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLmdldExvb2t1cFJlcXVlc3QgPSBudWxsO1xuXG4vKipcbiAqIFByZS1wcm9jZXNzIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHJlcXVlc3QgZnJvbSAjZ2V0TG9va3VwUmVxdWVzdC5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWNoZWQsIGFuZCBhbnkgZnVydGhlciBxdWVyaWVzIGZvciB0aGUgZ2l2ZW4gdmFsdWVcbiAqIHdpbGwgdXNlIHRoZSBjYWNoZSByYXRoZXIgdGhhbiBkb2luZyBBUEkgcmVxdWVzdHMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQG1ldGhvZFxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge01peGVkfSByZXNwb25zZSBSZXNwb25zZSBmcm9tIHNlcnZlclxuICogQHJldHVybiB7TWl4ZWR9IENhY2hlZCByZXN1bHQgZGF0YVxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5nZXRMb29rdXBDYWNoZURhdGFGcm9tUmVzcG9uc2UgPSBudWxsO1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgbWVudSBvcHRpb24gd2lkZ2V0cyBmcm9tIHRoZSAocG9zc2libHkgY2FjaGVkKSBkYXRhIHJldHVybmVkIGJ5XG4gKiAjZ2V0TG9va3VwQ2FjaGVEYXRhRnJvbVJlc3BvbnNlLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBtZXRob2RcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YSBDYWNoZWQgcmVzdWx0IGRhdGEsIHVzdWFsbHkgYW4gYXJyYXlcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVPcHRpb25XaWRnZXRbXX0gTWVudSBpdGVtc1xuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5nZXRMb29rdXBNZW51T3B0aW9uc0Zyb21EYXRhID0gbnVsbDtcblxuLyoqXG4gKiBTZXQgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgd2lkZ2V0LlxuICpcbiAqIFRoaXMgd2lsbCBhbHNvIGRpc2FibGUvZW5hYmxlIHRoZSBsb29rdXBzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSByZWFkT25seSBNYWtlIGlucHV0IHJlYWQtb25seVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRWxlbWVudH0gVGhlIGVsZW1lbnQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5zZXRSZWFkT25seSA9IGZ1bmN0aW9uICggcmVhZE9ubHkgKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0Ly8gTm90ZTogQ2FsbGluZyAjc2V0UmVhZE9ubHkgdGhpcyB3YXkgYXNzdW1lcyB0aGlzIGlzIG1peGVkIGludG8gYW4gT08udWkuVGV4dElucHV0V2lkZ2V0XG5cdE9PLnVpLlRleHRJbnB1dFdpZGdldC5wcm90b3R5cGUuc2V0UmVhZE9ubHkuY2FsbCggdGhpcywgcmVhZE9ubHkgKTtcblxuXHQvLyBEdXJpbmcgY29uc3RydWN0aW9uLCAjc2V0UmVhZE9ubHkgaXMgY2FsbGVkIGJlZm9yZSB0aGUgT08udWkubWl4aW4uTG9va3VwRWxlbWVudCBjb25zdHJ1Y3RvclxuXHRpZiAoIHRoaXMuaXNSZWFkT25seSgpICYmIHRoaXMubG9va3VwTWVudSApIHtcblx0XHR0aGlzLmNsb3NlTG9va3VwTWVudSgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jIE9PLnVpLm1peGluLlJlcXVlc3RNYW5hZ2VyXG4gKi9cbk9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQucHJvdG90eXBlLmdldFJlcXVlc3RRdWVyeSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2MgT08udWkubWl4aW4uUmVxdWVzdE1hbmFnZXJcbiAqL1xuT08udWkubWl4aW4uTG9va3VwRWxlbWVudC5wcm90b3R5cGUuZ2V0UmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZ2V0TG9va3VwUmVxdWVzdCgpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvYyBPTy51aS5taXhpbi5SZXF1ZXN0TWFuYWdlclxuICovXG5PTy51aS5taXhpbi5Mb29rdXBFbGVtZW50LnByb3RvdHlwZS5nZXRSZXF1ZXN0Q2FjaGVEYXRhRnJvbVJlc3BvbnNlID0gZnVuY3Rpb24gKCByZXNwb25zZSApIHtcblx0cmV0dXJuIHRoaXMuZ2V0TG9va3VwQ2FjaGVEYXRhRnJvbVJlc3BvbnNlKCByZXNwb25zZSApO1xufTtcblxuLyoqXG4gKiBUYWJQYW5lbExheW91dHMgYXJlIHVzZWQgd2l0aGluIHtAbGluayBPTy51aS5JbmRleExheW91dCBpbmRleCBsYXlvdXRzfSB0byBjcmVhdGUgdGFiIHBhbmVscyB0aGF0XG4gKiB1c2VycyBjYW4gc2VsZWN0IGFuZCBkaXNwbGF5IGZyb20gdGhlIGluZGV4J3Mgb3B0aW9uYWwge0BsaW5rIE9PLnVpLlRhYlNlbGVjdFdpZGdldCB0YWJ9XG4gKiBuYXZpZ2F0aW9uLiBUYWJQYW5lbHMgYXJlIHVzdWFsbHkgbm90IGluc3RhbnRpYXRlZCBkaXJlY3RseSwgcmF0aGVyIGV4dGVuZGVkIHRvIGluY2x1ZGUgdGhlXG4gKiByZXF1aXJlZCBjb250ZW50IGFuZCBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEVhY2ggdGFiIHBhbmVsIG11c3QgaGF2ZSBhIHVuaXF1ZSBzeW1ib2xpYyBuYW1lLCB3aGljaCBpcyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJbiBhZGRpdGlvbixcbiAqIHRoZSB0YWIgcGFuZWwncyB0YWIgaXRlbSBpcyBjdXN0b21pemVkICh3aXRoIGEgbGFiZWwpIHVzaW5nIHRoZSAjc2V0dXBUYWJJdGVtIG1ldGhvZC4gU2VlXG4gKiB7QGxpbmsgT08udWkuSW5kZXhMYXlvdXQgSW5kZXhMYXlvdXR9IGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuUGFuZWxMYXlvdXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBzeW1ib2xpYyBuYW1lIG9mIHRhYiBwYW5lbFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7alF1ZXJ5fHN0cmluZ3xGdW5jdGlvbnxPTy51aS5IdG1sU25pcHBldH0gW2xhYmVsXSBMYWJlbCBmb3IgdGFiIHBhbmVsJ3MgdGFiXG4gKi9cbk9PLnVpLlRhYlBhbmVsTGF5b3V0ID0gZnVuY3Rpb24gT29VaVRhYlBhbmVsTGF5b3V0KCBuYW1lLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIG5hbWUgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSBuYW1lO1xuXHRcdG5hbWUgPSBjb25maWcubmFtZTtcblx0fVxuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgc2Nyb2xsYWJsZTogdHJ1ZSB9LCBjb25maWcgKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVGFiUGFuZWxMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbDtcblx0dGhpcy50YWJJdGVtID0gbnVsbDtcblx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktdGFiUGFuZWxMYXlvdXQnIClcblx0XHQuYXR0ciggJ3JvbGUnLCAndGFicGFuZWwnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlRhYlBhbmVsTGF5b3V0LCBPTy51aS5QYW5lbExheW91dCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBBbiAnYWN0aXZlJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHRhYiBwYW5lbCBiZWNvbWVzIGFjdGl2ZS4gVGFiIHBhbmVscyBiZWNvbWUgYWN0aXZlIHdoZW4gdGhleSBhcmVcbiAqIHNob3duIGluIGEgaW5kZXggbGF5b3V0IHRoYXQgaXMgY29uZmlndXJlZCB0byBkaXNwbGF5IG9ubHkgb25lIHRhYiBwYW5lbCBhdCBhIHRpbWUuXG4gKlxuICogQGV2ZW50IGFjdGl2ZVxuICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgVGFiIHBhbmVsIGlzIGFjdGl2ZVxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgdGhlIHN5bWJvbGljIG5hbWUgb2YgdGhlIHRhYiBwYW5lbC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN5bWJvbGljIG5hbWUgb2YgdGFiIHBhbmVsXG4gKi9cbk9PLnVpLlRhYlBhbmVsTGF5b3V0LnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5uYW1lO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0YWIgcGFuZWwgaXMgYWN0aXZlLlxuICpcbiAqIFRhYiBwYW5lbHMgYmVjb21lIGFjdGl2ZSB3aGVuIHRoZXkgYXJlIHNob3duIGluIGEge0BsaW5rIE9PLnVpLkluZGV4TGF5b3V0IGluZGV4IGxheW91dH0gdGhhdCBpcyBjb25maWd1cmVkIHRvXG4gKiBkaXNwbGF5IG9ubHkgb25lIHRhYiBwYW5lbCBhdCBhIHRpbWUuIEFkZGl0aW9uYWwgQ1NTIGlzIGFwcGxpZWQgdG8gdGhlIHRhYiBwYW5lbCdzIHRhYiBpdGVtIHRvIHJlZmxlY3QgdGhlXG4gKiBhY3RpdmUgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGFiIHBhbmVsIGlzIGFjdGl2ZVxuICovXG5PTy51aS5UYWJQYW5lbExheW91dC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmFjdGl2ZTtcbn07XG5cbi8qKlxuICogR2V0IHRhYiBpdGVtLlxuICpcbiAqIFRoZSB0YWIgaXRlbSBhbGxvd3MgdXNlcnMgdG8gYWNjZXNzIHRoZSB0YWIgcGFuZWwgZnJvbSB0aGUgaW5kZXgncyB0YWJcbiAqIG5hdmlnYXRpb24uIFRoZSB0YWIgaXRlbSBpdHNlbGYgY2FuIGJlIGN1c3RvbWl6ZWQgKHdpdGggYSBsYWJlbCwgbGV2ZWwsIGV0Yy4pIHVzaW5nIHRoZSAjc2V0dXBUYWJJdGVtIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5UYWJPcHRpb25XaWRnZXR8bnVsbH0gVGFiIG9wdGlvbiB3aWRnZXRcbiAqL1xuT08udWkuVGFiUGFuZWxMYXlvdXQucHJvdG90eXBlLmdldFRhYkl0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnRhYkl0ZW07XG59O1xuXG4vKipcbiAqIFNldCBvciB1bnNldCB0aGUgdGFiIGl0ZW0uXG4gKlxuICogU3BlY2lmeSBhIHtAbGluayBPTy51aS5UYWJPcHRpb25XaWRnZXQgdGFiIG9wdGlvbn0gdG8gc2V0IGl0LFxuICogb3IgYG51bGxgIHRvIGNsZWFyIHRoZSB0YWIgaXRlbS4gVG8gY3VzdG9taXplIHRoZSB0YWIgaXRlbSBpdHNlbGYgKGUuZy4sIHRvIHNldCBhIGxhYmVsIG9yIHRhYlxuICogbGV2ZWwpLCB1c2UgI3NldHVwVGFiSXRlbSBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T08udWkuVGFiT3B0aW9uV2lkZ2V0fG51bGx9IHRhYkl0ZW0gVGFiIG9wdGlvbiB3aWRnZXQsIG51bGwgdG8gY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLlRhYlBhbmVsTGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuVGFiUGFuZWxMYXlvdXQucHJvdG90eXBlLnNldFRhYkl0ZW0gPSBmdW5jdGlvbiAoIHRhYkl0ZW0gKSB7XG5cdHRoaXMudGFiSXRlbSA9IHRhYkl0ZW0gfHwgbnVsbDtcblx0aWYgKCB0YWJJdGVtICkge1xuXHRcdHRoaXMuc2V0dXBUYWJJdGVtKCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB1cCB0aGUgdGFiIGl0ZW0uXG4gKlxuICogVXNlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgdGFiIGl0ZW0gKGUuZy4sIHRvIGFkZCBhIGxhYmVsIG9yIHRhYiBsZXZlbCkuIFRvIHNldCBvciB1bnNldFxuICogdGhlIHRhYiBpdGVtIGl0c2VsZiAod2l0aCBhIHtAbGluayBPTy51aS5UYWJPcHRpb25XaWRnZXQgdGFiIG9wdGlvbn0gb3IgYG51bGxgKSwgdXNlXG4gKiB0aGUgI3NldFRhYkl0ZW0gbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5UYWJPcHRpb25XaWRnZXR9IHRhYkl0ZW0gVGFiIG9wdGlvbiB3aWRnZXQgdG8gc2V0IHVwXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5UYWJQYW5lbExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlRhYlBhbmVsTGF5b3V0LnByb3RvdHlwZS5zZXR1cFRhYkl0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuJGVsZW1lbnQuYXR0ciggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMudGFiSXRlbS5nZXRFbGVtZW50SWQoKSApO1xuXG5cdHRoaXMudGFiSXRlbS4kZWxlbWVudC5hdHRyKCAnYXJpYS1jb250cm9scycsIHRoaXMuZ2V0RWxlbWVudElkKCkgKTtcblxuXHRpZiAoIHRoaXMubGFiZWwgKSB7XG5cdFx0dGhpcy50YWJJdGVtLnNldExhYmVsKCB0aGlzLmxhYmVsICk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGFiIHBhbmVsIHRvIGl0cyAnYWN0aXZlJyBzdGF0ZS5cbiAqXG4gKiBUYWIgcGFuZWxzIGJlY29tZSBhY3RpdmUgd2hlbiB0aGV5IGFyZSBzaG93biBpbiBhIGluZGV4IGxheW91dCB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gZGlzcGxheSBvbmx5XG4gKiBvbmUgdGFiIHBhbmVsIGF0IGEgdGltZS4gQWRkaXRpb25hbCBDU1MgaXMgYXBwbGllZCB0byB0aGUgdGFiIGl0ZW0gdG8gcmVmbGVjdCB0aGUgdGFiIHBhbmVsJ3NcbiAqIGFjdGl2ZSBzdGF0ZS4gT3V0c2lkZSBvZiB0aGUgaW5kZXggY29udGV4dCwgc2V0dGluZyB0aGUgYWN0aXZlIHN0YXRlIG9uIGEgdGFiIHBhbmVsIGRvZXMgbm90aGluZy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBUYWIgcGFuZWwgaXMgYWN0aXZlXG4gKiBAZmlyZXMgYWN0aXZlXG4gKi9cbk9PLnVpLlRhYlBhbmVsTGF5b3V0LnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiAoIGFjdGl2ZSApIHtcblx0YWN0aXZlID0gISFhY3RpdmU7XG5cblx0aWYgKCBhY3RpdmUgIT09IHRoaXMuYWN0aXZlICkge1xuXHRcdHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS10YWJQYW5lbExheW91dC1hY3RpdmUnLCB0aGlzLmFjdGl2ZSApO1xuXHRcdHRoaXMuZW1pdCggJ2FjdGl2ZScsIHRoaXMuYWN0aXZlICk7XG5cdH1cbn07XG5cbi8qKlxuICogUGFnZUxheW91dHMgYXJlIHVzZWQgd2l0aGluIHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IGJvb2tsZXQgbGF5b3V0c30gdG8gY3JlYXRlIHBhZ2VzIHRoYXQgdXNlcnMgY2FuIHNlbGVjdCBhbmQgZGlzcGxheVxuICogZnJvbSB0aGUgYm9va2xldCdzIG9wdGlvbmFsIHtAbGluayBPTy51aS5PdXRsaW5lU2VsZWN0V2lkZ2V0IG91dGxpbmV9IG5hdmlnYXRpb24uIFBhZ2VzIGFyZSB1c3VhbGx5IG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHksXG4gKiByYXRoZXIgZXh0ZW5kZWQgdG8gaW5jbHVkZSB0aGUgcmVxdWlyZWQgY29udGVudCBhbmQgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBFYWNoIHBhZ2UgbXVzdCBoYXZlIGEgdW5pcXVlIHN5bWJvbGljIG5hbWUsIHdoaWNoIGlzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIEluIGFkZGl0aW9uLCB0aGUgcGFnZSdzIG91dGxpbmVcbiAqIGl0ZW0gaXMgY3VzdG9taXplZCAod2l0aCBhIGxhYmVsLCBvdXRsaW5lIGxldmVsLCBldGMuKSB1c2luZyB0aGUgI3NldHVwT3V0bGluZUl0ZW0gbWV0aG9kLiBTZWVcbiAqIHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IEJvb2tsZXRMYXlvdXR9IGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuUGFuZWxMYXlvdXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBzeW1ib2xpYyBuYW1lIG9mIHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuUGFnZUxheW91dCA9IGZ1bmN0aW9uIE9vVWlQYWdlTGF5b3V0KCBuYW1lLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIG5hbWUgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSBuYW1lO1xuXHRcdG5hbWUgPSBjb25maWcubmFtZTtcblx0fVxuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgc2Nyb2xsYWJsZTogdHJ1ZSB9LCBjb25maWcgKTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuUGFnZUxheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLm5hbWUgPSBuYW1lO1xuXHR0aGlzLm91dGxpbmVJdGVtID0gbnVsbDtcblx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcGFnZUxheW91dCcgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUGFnZUxheW91dCwgT08udWkuUGFuZWxMYXlvdXQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQW4gJ2FjdGl2ZScgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBwYWdlIGJlY29tZXMgYWN0aXZlLiBQYWdlcyBiZWNvbWUgYWN0aXZlIHdoZW4gdGhleSBhcmVcbiAqIHNob3duIGluIGEgYm9va2xldCBsYXlvdXQgdGhhdCBpcyBjb25maWd1cmVkIHRvIGRpc3BsYXkgb25seSBvbmUgcGFnZSBhdCBhIHRpbWUuXG4gKlxuICogQGV2ZW50IGFjdGl2ZVxuICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgUGFnZSBpcyBhY3RpdmVcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpYyBuYW1lIG9mIHRoZSBwYWdlLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gU3ltYm9saWMgbmFtZSBvZiBwYWdlXG4gKi9cbk9PLnVpLlBhZ2VMYXlvdXQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHBhZ2UgaXMgYWN0aXZlLlxuICpcbiAqIFBhZ2VzIGJlY29tZSBhY3RpdmUgd2hlbiB0aGV5IGFyZSBzaG93biBpbiBhIHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IGJvb2tsZXQgbGF5b3V0fSB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gZGlzcGxheVxuICogb25seSBvbmUgcGFnZSBhdCBhIHRpbWUuIEFkZGl0aW9uYWwgQ1NTIGlzIGFwcGxpZWQgdG8gdGhlIHBhZ2UncyBvdXRsaW5lIGl0ZW0gdG8gcmVmbGVjdCB0aGUgYWN0aXZlIHN0YXRlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFBhZ2UgaXMgYWN0aXZlXG4gKi9cbk9PLnVpLlBhZ2VMYXlvdXQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5hY3RpdmU7XG59O1xuXG4vKipcbiAqIEdldCBvdXRsaW5lIGl0ZW0uXG4gKlxuICogVGhlIG91dGxpbmUgaXRlbSBhbGxvd3MgdXNlcnMgdG8gYWNjZXNzIHRoZSBwYWdlIGZyb20gdGhlIGJvb2tsZXQncyBvdXRsaW5lXG4gKiBuYXZpZ2F0aW9uLiBUaGUgb3V0bGluZSBpdGVtIGl0c2VsZiBjYW4gYmUgY3VzdG9taXplZCAod2l0aCBhIGxhYmVsLCBsZXZlbCwgZXRjLikgdXNpbmcgdGhlICNzZXR1cE91dGxpbmVJdGVtIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5PdXRsaW5lT3B0aW9uV2lkZ2V0fG51bGx9IE91dGxpbmUgb3B0aW9uIHdpZGdldFxuICovXG5PTy51aS5QYWdlTGF5b3V0LnByb3RvdHlwZS5nZXRPdXRsaW5lSXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMub3V0bGluZUl0ZW07XG59O1xuXG4vKipcbiAqIFNldCBvciB1bnNldCB0aGUgb3V0bGluZSBpdGVtLlxuICpcbiAqIFNwZWNpZnkgYW4ge0BsaW5rIE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQgb3V0bGluZSBvcHRpb259IHRvIHNldCBpdCxcbiAqIG9yIGBudWxsYCB0byBjbGVhciB0aGUgb3V0bGluZSBpdGVtLiBUbyBjdXN0b21pemUgdGhlIG91dGxpbmUgaXRlbSBpdHNlbGYgKGUuZy4sIHRvIHNldCBhIGxhYmVsIG9yIG91dGxpbmVcbiAqIGxldmVsKSwgdXNlICNzZXR1cE91dGxpbmVJdGVtIGluc3RlYWQgb2YgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtPTy51aS5PdXRsaW5lT3B0aW9uV2lkZ2V0fG51bGx9IG91dGxpbmVJdGVtIE91dGxpbmUgb3B0aW9uIHdpZGdldCwgbnVsbCB0byBjbGVhclxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuUGFnZUxheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLlBhZ2VMYXlvdXQucHJvdG90eXBlLnNldE91dGxpbmVJdGVtID0gZnVuY3Rpb24gKCBvdXRsaW5lSXRlbSApIHtcblx0dGhpcy5vdXRsaW5lSXRlbSA9IG91dGxpbmVJdGVtIHx8IG51bGw7XG5cdGlmICggb3V0bGluZUl0ZW0gKSB7XG5cdFx0dGhpcy5zZXR1cE91dGxpbmVJdGVtKCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB1cCB0aGUgb3V0bGluZSBpdGVtLlxuICpcbiAqIFVzZSB0aGlzIG1ldGhvZCB0byBjdXN0b21pemUgdGhlIG91dGxpbmUgaXRlbSAoZS5nLiwgdG8gYWRkIGEgbGFiZWwgb3Igb3V0bGluZSBsZXZlbCkuIFRvIHNldCBvciB1bnNldFxuICogdGhlIG91dGxpbmUgaXRlbSBpdHNlbGYgKHdpdGggYW4ge0BsaW5rIE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQgb3V0bGluZSBvcHRpb259IG9yIGBudWxsYCksIHVzZVxuICogdGhlICNzZXRPdXRsaW5lSXRlbSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLk91dGxpbmVPcHRpb25XaWRnZXR9IG91dGxpbmVJdGVtIE91dGxpbmUgb3B0aW9uIHdpZGdldCB0byBzZXQgdXBcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLlBhZ2VMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5QYWdlTGF5b3V0LnByb3RvdHlwZS5zZXR1cE91dGxpbmVJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYWdlIHRvIGl0cyAnYWN0aXZlJyBzdGF0ZS5cbiAqXG4gKiBQYWdlcyBiZWNvbWUgYWN0aXZlIHdoZW4gdGhleSBhcmUgc2hvd24gaW4gYSBib29rbGV0IGxheW91dCB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gZGlzcGxheSBvbmx5IG9uZSBwYWdlIGF0IGEgdGltZS4gQWRkaXRpb25hbFxuICogQ1NTIGlzIGFwcGxpZWQgdG8gdGhlIG91dGxpbmUgaXRlbSB0byByZWZsZWN0IHRoZSBwYWdlJ3MgYWN0aXZlIHN0YXRlLiBPdXRzaWRlIG9mIHRoZSBib29rbGV0XG4gKiBjb250ZXh0LCBzZXR0aW5nIHRoZSBhY3RpdmUgc3RhdGUgb24gYSBwYWdlIGRvZXMgbm90aGluZy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBQYWdlIGlzIGFjdGl2ZVxuICogQGZpcmVzIGFjdGl2ZVxuICovXG5PTy51aS5QYWdlTGF5b3V0LnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiAoIGFjdGl2ZSApIHtcblx0YWN0aXZlID0gISFhY3RpdmU7XG5cblx0aWYgKCBhY3RpdmUgIT09IHRoaXMuYWN0aXZlICkge1xuXHRcdHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1wYWdlTGF5b3V0LWFjdGl2ZScsIGFjdGl2ZSApO1xuXHRcdHRoaXMuZW1pdCggJ2FjdGl2ZScsIHRoaXMuYWN0aXZlICk7XG5cdH1cbn07XG5cbi8qKlxuICogU3RhY2tMYXlvdXRzIGNvbnRhaW4gYSBzZXJpZXMgb2Yge0BsaW5rIE9PLnVpLlBhbmVsTGF5b3V0IHBhbmVsIGxheW91dHN9LiBCeSBkZWZhdWx0LCBvbmx5IG9uZSBwYW5lbCBpcyBkaXNwbGF5ZWRcbiAqIGF0IGEgdGltZSwgdGhvdWdoIHRoZSBzdGFjayBsYXlvdXQgY2FuIGFsc28gYmUgY29uZmlndXJlZCB0byBzaG93IGFsbCBjb250YWluZWQgcGFuZWxzLCBvbmUgYWZ0ZXIgYW5vdGhlcixcbiAqIGJ5IHNldHRpbmcgdGhlICNjb250aW51b3VzIG9wdGlvbiB0byAndHJ1ZScuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBzdGFjayBsYXlvdXQgd2l0aCB0d28gcGFuZWxzLCBjb25maWd1cmVkIHRvIGJlIGRpc3BsYXllZCBjb250aW51b3VzbHlcbiAqICAgICB2YXIgbXlTdGFjayA9IG5ldyBPTy51aS5TdGFja0xheW91dCgge1xuICogICAgICAgICBpdGVtczogW1xuICogICAgICAgICAgICAgbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG4gKiAgICAgICAgICAgICAgICAgJGNvbnRlbnQ6ICQoICc8cD5QYW5lbCBPbmU8L3A+JyApLFxuICogICAgICAgICAgICAgICAgIHBhZGRlZDogdHJ1ZSxcbiAqICAgICAgICAgICAgICAgICBmcmFtZWQ6IHRydWVcbiAqICAgICAgICAgICAgIH0gKSxcbiAqICAgICAgICAgICAgIG5ldyBPTy51aS5QYW5lbExheW91dCgge1xuICogICAgICAgICAgICAgICAgICRjb250ZW50OiAkKCAnPHA+UGFuZWwgVHdvPC9wPicgKSxcbiAqICAgICAgICAgICAgICAgICBwYWRkZWQ6IHRydWUsXG4gKiAgICAgICAgICAgICAgICAgZnJhbWVkOiB0cnVlXG4gKiAgICAgICAgICAgICB9IClcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgY29udGludW91czogdHJ1ZVxuICogICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBteVN0YWNrLiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5QYW5lbExheW91dFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2Jvb2xlYW59IFtjb250aW51b3VzPWZhbHNlXSBTaG93IGFsbCBwYW5lbHMsIG9uZSBhZnRlciBhbm90aGVyLiBCeSBkZWZhdWx0LCBvbmx5IG9uZSBwYW5lbCBpcyBkaXNwbGF5ZWQgYXQgYSB0aW1lLlxuICogQGNmZyB7T08udWkuTGF5b3V0W119IFtpdGVtc10gUGFuZWwgbGF5b3V0cyB0byBhZGQgdG8gdGhlIHN0YWNrIGxheW91dC5cbiAqL1xuT08udWkuU3RhY2tMYXlvdXQgPSBmdW5jdGlvbiBPb1VpU3RhY2tMYXlvdXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHQvLyBNYWtlIHRoZSBsYXlvdXQgc2Nyb2xsYWJsZSBpbiBjb250aW51b3VzIG1vZGUsIG90aGVyd2lzZSBlYWNoXG5cdC8vIHBhbmVsIGlzIHJlc3BvbnNpYmxlIGZvciBpdHMgb3duIHNjcm9sbGluZy5cblx0Y29uZmlnID0gJC5leHRlbmQoIHsgc2Nyb2xsYWJsZTogISEoIGNvbmZpZyAmJiBjb25maWcuY29udGludW91cyApIH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5TdGFja0xheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkZ3JvdXA6IHRoaXMuJGVsZW1lbnQgfSApICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmN1cnJlbnRJdGVtID0gbnVsbDtcblx0dGhpcy5jb250aW51b3VzID0gISFjb25maWcuY29udGludW91cztcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktc3RhY2tMYXlvdXQnICk7XG5cdGlmICggdGhpcy5jb250aW51b3VzICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1zdGFja0xheW91dC1jb250aW51b3VzJyApO1xuXHRcdHRoaXMuJGVsZW1lbnQub24oICdzY3JvbGwnLCBPTy51aS5kZWJvdW5jZSggdGhpcy5vblNjcm9sbC5iaW5kKCB0aGlzICksIDI1MCApICk7XG5cdH1cblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb25maWcuaXRlbXMgKSApIHtcblx0XHR0aGlzLmFkZEl0ZW1zKCBjb25maWcuaXRlbXMgKTtcblx0fVxufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5TdGFja0xheW91dCwgT08udWkuUGFuZWxMYXlvdXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlN0YWNrTGF5b3V0LCBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQSAnc2V0JyBldmVudCBpcyBlbWl0dGVkIHdoZW4gcGFuZWxzIGFyZSB7QGxpbmsgI2FkZEl0ZW1zIGFkZGVkfSwge0BsaW5rICNyZW1vdmVJdGVtcyByZW1vdmVkfSxcbiAqIHtAbGluayAjY2xlYXJJdGVtcyBjbGVhcmVkfSBvciB7QGxpbmsgI3NldEl0ZW0gZGlzcGxheWVkfS5cbiAqXG4gKiBAZXZlbnQgc2V0XG4gKiBAcGFyYW0ge09PLnVpLkxheW91dHxudWxsfSBpdGVtIEN1cnJlbnQgcGFuZWwgb3IgYG51bGxgIGlmIG5vIHBhbmVsIGlzIHNob3duXG4gKi9cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW4gY29udGludW91cyBtb2RlLCB0aGlzIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIGRvd25cbiAqIGZhciBlbm91Z2ggc3VjaCB0aGF0IGN1cnJlbnRJdGVtIGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuICpcbiAqIEBldmVudCB2aXNpYmxlSXRlbUNoYW5nZVxuICogQHBhcmFtIHtPTy51aS5QYW5lbExheW91dH0gcGFuZWwgVGhlIG5leHQgdmlzaWJsZSBpdGVtIGluIHRoZSBsYXlvdXRcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIHNjcm9sbCBldmVudHMgZnJvbSB0aGUgbGF5b3V0IGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZVxuICogQGZpcmVzIHZpc2libGVJdGVtQ2hhbmdlXG4gKi9cbk9PLnVpLlN0YWNrTGF5b3V0LnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGN1cnJlbnRSZWN0LFxuXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoLFxuXHRcdGN1cnJlbnRJbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZiggdGhpcy5jdXJyZW50SXRlbSApLFxuXHRcdG5ld0luZGV4ID0gY3VycmVudEluZGV4LFxuXHRcdGNvbnRhaW5lclJlY3QgPSB0aGlzLiRlbGVtZW50WyAwIF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0aWYgKCAhY29udGFpbmVyUmVjdCB8fCAoICFjb250YWluZXJSZWN0LnRvcCAmJiAhY29udGFpbmVyUmVjdC5ib3R0b20gKSApIHtcblx0XHQvLyBDYW4ndCBnZXQgYm91bmRpbmcgcmVjdCwgcG9zc2libHkgbm90IGF0dGFjaGVkLlxuXHRcdHJldHVybjtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJlY3QoIGl0ZW0gKSB7XG5cdFx0cmV0dXJuIGl0ZW0uJGVsZW1lbnRbIDAgXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVmlzaWJsZSggaXRlbSApIHtcblx0XHR2YXIgcmVjdCA9IGdldFJlY3QoIGl0ZW0gKTtcblx0XHRyZXR1cm4gcmVjdC5ib3R0b20gPiBjb250YWluZXJSZWN0LnRvcCAmJiByZWN0LnRvcCA8IGNvbnRhaW5lclJlY3QuYm90dG9tO1xuXHR9XG5cblx0Y3VycmVudFJlY3QgPSBnZXRSZWN0KCB0aGlzLmN1cnJlbnRJdGVtICk7XG5cblx0aWYgKCBjdXJyZW50UmVjdC5ib3R0b20gPCBjb250YWluZXJSZWN0LnRvcCApIHtcblx0XHQvLyBTY3JvbGxlZCBkb3duIHBhc3QgY3VycmVudCBpdGVtXG5cdFx0d2hpbGUgKCArK25ld0luZGV4IDwgbGVuICkge1xuXHRcdFx0aWYgKCBpc1Zpc2libGUoIHRoaXMuaXRlbXNbIG5ld0luZGV4IF0gKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBjdXJyZW50UmVjdC50b3AgPiBjb250YWluZXJSZWN0LmJvdHRvbSApIHtcblx0XHQvLyBTY3JvbGxlZCB1cCBwYXN0IGN1cnJlbnQgaXRlbVxuXHRcdHdoaWxlICggLS1uZXdJbmRleCA+PSAwICkge1xuXHRcdFx0aWYgKCBpc1Zpc2libGUoIHRoaXMuaXRlbXNbIG5ld0luZGV4IF0gKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBuZXdJbmRleCAhPT0gY3VycmVudEluZGV4ICkge1xuXHRcdHRoaXMuZW1pdCggJ3Zpc2libGVJdGVtQ2hhbmdlJywgdGhpcy5pdGVtc1sgbmV3SW5kZXggXSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwYW5lbC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5MYXlvdXR8bnVsbH1cbiAqL1xuT08udWkuU3RhY2tMYXlvdXQucHJvdG90eXBlLmdldEN1cnJlbnRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jdXJyZW50SXRlbTtcbn07XG5cbi8qKlxuICogVW5zZXQgdGhlIGN1cnJlbnQgaXRlbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5TdGFja0xheW91dH0gbGF5b3V0XG4gKiBAZmlyZXMgc2V0XG4gKi9cbk9PLnVpLlN0YWNrTGF5b3V0LnByb3RvdHlwZS51bnNldEN1cnJlbnRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcHJldkl0ZW0gPSB0aGlzLmN1cnJlbnRJdGVtO1xuXHRpZiAoIHByZXZJdGVtID09PSBudWxsICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHRoaXMuY3VycmVudEl0ZW0gPSBudWxsO1xuXHR0aGlzLmVtaXQoICdzZXQnLCBudWxsICk7XG59O1xuXG4vKipcbiAqIEFkZCBwYW5lbCBsYXlvdXRzIHRvIHRoZSBzdGFjayBsYXlvdXQuXG4gKlxuICogUGFuZWxzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgc3RhY2sgbGF5b3V0IGFycmF5IHVubGVzcyB0aGUgb3B0aW9uYWwgaW5kZXggcGFyYW1ldGVyIHNwZWNpZmllcyBhIGRpZmZlcmVudFxuICogaW5zZXJ0aW9uIHBvaW50LiBBZGRpbmcgYSBwYW5lbCB0aGF0IGlzIGFscmVhZHkgaW4gdGhlIHN0YWNrIHdpbGwgbW92ZSBpdCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSBvciB0aGUgcG9pbnQgc3BlY2lmaWVkXG4gKiBieSB0aGUgaW5kZXguXG4gKlxuICogQHBhcmFtIHtPTy51aS5MYXlvdXRbXX0gaXRlbXMgUGFuZWxzIHRvIGFkZFxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gSW5kZXggb2YgdGhlIGluc2VydGlvbiBwb2ludFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuU3RhY2tMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5TdGFja0xheW91dC5wcm90b3R5cGUuYWRkSXRlbXMgPSBmdW5jdGlvbiAoIGl0ZW1zLCBpbmRleCApIHtcblx0Ly8gVXBkYXRlIHRoZSB2aXNpYmlsaXR5XG5cdHRoaXMudXBkYXRlSGlkZGVuU3RhdGUoIGl0ZW1zLCB0aGlzLmN1cnJlbnRJdGVtICk7XG5cblx0Ly8gTWl4aW4gbWV0aG9kXG5cdE9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5wcm90b3R5cGUuYWRkSXRlbXMuY2FsbCggdGhpcywgaXRlbXMsIGluZGV4ICk7XG5cblx0aWYgKCAhdGhpcy5jdXJyZW50SXRlbSAmJiBpdGVtcy5sZW5ndGggKSB7XG5cdFx0dGhpcy5zZXRJdGVtKCBpdGVtc1sgMCBdICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgcGFuZWxzIGZyb20gdGhlIHN0YWNrIGxheW91dC5cbiAqXG4gKiBSZW1vdmVkIHBhbmVscyBhcmUgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLCBub3QgcmVtb3ZlZCwgc28gdGhhdCB0aGV5IG1heSBiZSByZXVzZWQuIFRvIHJlbW92ZSBhbGwgcGFuZWxzLFxuICogeW91IG1heSB3aXNoIHRvIHVzZSB0aGUgI2NsZWFySXRlbXMgbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5MYXlvdXRbXX0gaXRlbXMgUGFuZWxzIHRvIHJlbW92ZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuU3RhY2tMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICogQGZpcmVzIHNldFxuICovXG5PTy51aS5TdGFja0xheW91dC5wcm90b3R5cGUucmVtb3ZlSXRlbXMgPSBmdW5jdGlvbiAoIGl0ZW1zICkge1xuXHQvLyBNaXhpbiBtZXRob2Rcblx0T08udWkubWl4aW4uR3JvdXBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVJdGVtcy5jYWxsKCB0aGlzLCBpdGVtcyApO1xuXG5cdGlmICggaXRlbXMuaW5kZXhPZiggdGhpcy5jdXJyZW50SXRlbSApICE9PSAtMSApIHtcblx0XHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5zZXRJdGVtKCB0aGlzLml0ZW1zWyAwIF0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51bnNldEN1cnJlbnRJdGVtKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFyIGFsbCBwYW5lbHMgZnJvbSB0aGUgc3RhY2sgbGF5b3V0LlxuICpcbiAqIENsZWFyZWQgcGFuZWxzIGFyZSBkZXRhY2hlZCBmcm9tIHRoZSBET00sIG5vdCByZW1vdmVkLCBzbyB0aGF0IHRoZXkgbWF5IGJlIHJldXNlZC4gVG8gcmVtb3ZlIG9ubHlcbiAqIGEgc3Vic2V0IG9mIHBhbmVscywgdXNlIHRoZSAjcmVtb3ZlSXRlbXMgbWV0aG9kLlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLlN0YWNrTGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqIEBmaXJlcyBzZXRcbiAqL1xuT08udWkuU3RhY2tMYXlvdXQucHJvdG90eXBlLmNsZWFySXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMudW5zZXRDdXJyZW50SXRlbSgpO1xuXHRPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQucHJvdG90eXBlLmNsZWFySXRlbXMuY2FsbCggdGhpcyApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBzcGVjaWZpZWQgcGFuZWwuXG4gKlxuICogSWYgYW5vdGhlciBwYW5lbCBpcyBjdXJyZW50bHkgZGlzcGxheWVkLCBpdCB3aWxsIGJlIGhpZGRlbi5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkxheW91dH0gaXRlbSBQYW5lbCB0byBzaG93XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5TdGFja0xheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKiBAZmlyZXMgc2V0XG4gKi9cbk9PLnVpLlN0YWNrTGF5b3V0LnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoIGl0ZW0gIT09IHRoaXMuY3VycmVudEl0ZW0gKSB7XG5cdFx0dGhpcy51cGRhdGVIaWRkZW5TdGF0ZSggdGhpcy5pdGVtcywgaXRlbSApO1xuXG5cdFx0aWYgKCB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKSAhPT0gLTEgKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRJdGVtID0gaXRlbTtcblx0XHRcdHRoaXMuZW1pdCggJ3NldCcsIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51bnNldEN1cnJlbnRJdGVtKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY3JvbGwgb2Zmc2V0IG9mIGFsbCBwYW5lbHMsIG9yIHRoZSBjb250YWluZXIgaWYgY29udGludW91c1xuICpcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlN0YWNrTGF5b3V0LnByb3RvdHlwZS5yZXNldFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmNvbnRpbnVvdXMgKSB7XG5cdFx0Ly8gUGFyZW50IG1ldGhvZFxuXHRcdHJldHVybiBPTy51aS5TdGFja0xheW91dC5wYXJlbnQucHJvdG90eXBlLnJlc2V0U2Nyb2xsLmNhbGwoIHRoaXMgKTtcblx0fVxuXHQvLyBSZXNldCBlYWNoIHBhbmVsXG5cdHRoaXMuZ2V0SXRlbXMoKS5mb3JFYWNoKCBmdW5jdGlvbiAoIHBhbmVsICkge1xuXHRcdHZhciBoaWRkZW4gPSBwYW5lbC4kZWxlbWVudC5oYXNDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXHRcdC8vIFNjcm9sbCBjYW4gb25seSBiZSByZXNldCB3aGVuIHBhbmVsIGlzIHZpc2libGVcblx0XHRwYW5lbC4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXHRcdHBhbmVsLnJlc2V0U2Nyb2xsKCk7XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRwYW5lbC4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgYWxsIGl0ZW1zIGluIGNhc2Ugb2Ygbm9uLWNvbnRpbnVvdXMgdmlldy5cbiAqXG4gKiBFbnN1cmUgYWxsIGl0ZW1zIGFyZSBoaWRkZW4gZXhjZXB0IGZvciB0aGUgc2VsZWN0ZWQgb25lLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3RoaW5nIHdoZW4gdGhlIHN0YWNrIGlzIGNvbnRpbnVvdXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T08udWkuTGF5b3V0W119IGl0ZW1zIEl0ZW0gbGlzdCBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7T08udWkuTGF5b3V0fSBbc2VsZWN0ZWRJdGVtXSBTZWxlY3RlZCBpdGVtIHRvIHNob3dcbiAqL1xuT08udWkuU3RhY2tMYXlvdXQucHJvdG90eXBlLnVwZGF0ZUhpZGRlblN0YXRlID0gZnVuY3Rpb24gKCBpdGVtcywgc2VsZWN0ZWRJdGVtICkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdGlmICggIXRoaXMuY29udGludW91cyApIHtcblx0XHRmb3IgKCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoICFzZWxlY3RlZEl0ZW0gfHwgc2VsZWN0ZWRJdGVtICE9PSBpdGVtc1sgaSBdICkge1xuXHRcdFx0XHRpdGVtc1sgaSBdLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktZWxlbWVudC1oaWRkZW4nICk7XG5cdFx0XHRcdGl0ZW1zWyBpIF0uJGVsZW1lbnQuYXR0ciggJ2FyaWEtaGlkZGVuJywgJ3RydWUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0ZWRJdGVtICkge1xuXHRcdFx0c2VsZWN0ZWRJdGVtLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktZWxlbWVudC1oaWRkZW4nICk7XG5cdFx0XHRzZWxlY3RlZEl0ZW0uJGVsZW1lbnQucmVtb3ZlQXR0ciggJ2FyaWEtaGlkZGVuJyApO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBNZW51TGF5b3V0cyBjb21iaW5lIGEgbWVudSBhbmQgYSBjb250ZW50IHtAbGluayBPTy51aS5QYW5lbExheW91dCBwYW5lbH0uIFRoZSBtZW51IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRlbnQgKGFmdGVyLCBiZWZvcmUsIHRvcCwgb3IgYm90dG9tKVxuICogYW5kIGl0cyBzaXplIGlzIGN1c3RvbWl6ZWQgd2l0aCB0aGUgI21lbnVTaXplIGNvbmZpZy4gVGhlIGNvbnRlbnQgYXJlYSB3aWxsIGZpbGwgYWxsIHJlbWFpbmluZyBzcGFjZS5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICB2YXIgbWVudUxheW91dCxcbiAqICAgICAgICAgbWVudVBhbmVsID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7IHBhZGRlZDogdHJ1ZSwgZXhwYW5kZWQ6IHRydWUsIHNjcm9sbGFibGU6IHRydWUgfSApLFxuICogICAgICAgICBjb250ZW50UGFuZWwgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHsgcGFkZGVkOiB0cnVlLCBleHBhbmRlZDogdHJ1ZSwgc2Nyb2xsYWJsZTogdHJ1ZSB9ICksXG4gKiAgICAgICAgIHNlbGVjdCA9IG5ldyBPTy51aS5TZWxlY3RXaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGl0ZW1zOiBbXG4gKiAgICAgICAgICAgICAgICAgbmV3IE9PLnVpLk9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgICAgICBkYXRhOiAnYmVmb3JlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdCZWZvcmUnXG4gKiAgICAgICAgICAgICAgICAgfSApLFxuICogICAgICAgICAgICAgICAgIG5ldyBPTy51aS5PcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgICAgICAgICAgZGF0YTogJ2FmdGVyJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdBZnRlcidcbiAqICAgICAgICAgICAgICAgICB9ICksXG4gKiAgICAgICAgICAgICAgICAgbmV3IE9PLnVpLk9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgICAgICAgICBkYXRhOiAndG9wJyxcbiAqICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdUb3AnXG4gKiAgICAgICAgICAgICAgICAgfSApLFxuICogICAgICAgICAgICAgICAgIG5ldyBPTy51aS5PcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgICAgICAgICAgZGF0YTogJ2JvdHRvbScsXG4gKiAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnQm90dG9tJ1xuICogICAgICAgICAgICAgICAgIH0gKVxuICogICAgICAgICAgICAgIF1cbiAqICAgICAgICAgfSApLm9uKCAnc2VsZWN0JywgZnVuY3Rpb24gKCBpdGVtICkge1xuICogICAgICAgICAgICBtZW51TGF5b3V0LnNldE1lbnVQb3NpdGlvbiggaXRlbS5nZXREYXRhKCkgKTtcbiAqICAgICAgICAgfSApO1xuICpcbiAqICAgICBtZW51TGF5b3V0ID0gbmV3IE9PLnVpLk1lbnVMYXlvdXQoIHtcbiAqICAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICogICAgICAgICBtZW51UGFuZWw6IG1lbnVQYW5lbCxcbiAqICAgICAgICAgY29udGVudFBhbmVsOiBjb250ZW50UGFuZWxcbiAqICAgICB9IClcbiAqICAgICBtZW51TGF5b3V0LiRtZW51LmFwcGVuZChcbiAqICAgICAgICAgbWVudVBhbmVsLiRlbGVtZW50LmFwcGVuZCggJzxiPk1lbnUgcGFuZWw8L2I+Jywgc2VsZWN0LiRlbGVtZW50IClcbiAqICAgICApO1xuICogICAgIG1lbnVMYXlvdXQuJGNvbnRlbnQuYXBwZW5kKFxuICogICAgICAgICBjb250ZW50UGFuZWwuJGVsZW1lbnQuYXBwZW5kKCAnPGI+Q29udGVudCBwYW5lbDwvYj4nLCAnPHA+Tm90ZSB0aGF0IHRoZSBtZW51IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRlbnQgcGFuZWw6IHRvcCwgYm90dG9tLCBhZnRlciwgYmVmb3JlLjwvcD4nKVxuICogICAgICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggbWVudUxheW91dC4kZWxlbWVudCApO1xuICpcbiAqIElmIG1lbnUgc2l6ZSBuZWVkcyB0byBiZSBvdmVycmlkZGVuLCBpdCBjYW4gYmUgYWNjb21wbGlzaGVkIHVzaW5nIENTUyBzaW1pbGFyIHRvIHRoZSBzbmlwcGV0XG4gKiBiZWxvdy4gTWVudUxheW91dCdzIENTUyB3aWxsIG92ZXJyaWRlIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXMgd2l0aCAnYXV0bycgb3IgJzAnIHRvIGRpc3BsYXkgdGhlXG4gKiBtZW51IGNvcnJlY3RseS4gSWYgYG1lbnVQb3NpdGlvbmAgaXMga25vd24gYmVmb3JlaGFuZCwgQ1NTIHJ1bGVzIGNvcnJlc3BvbmRpbmcgdG8gb3RoZXIgcG9zaXRpb25zXG4gKiBtYXkgYmUgb21pdHRlZC5cbiAqXG4gKiAgICAgLm9vLXVpLW1lbnVMYXlvdXQtbWVudSB7XG4gKiAgICAgICAgIHdpZHRoOiAyMDBweDtcbiAqICAgICAgICAgaGVpZ2h0OiAyMDBweDtcbiAqICAgICB9XG4gKlxuICogICAgIC5vby11aS1tZW51TGF5b3V0LWNvbnRlbnQge1xuICogICAgICAgICB0b3A6IDIwMHB4O1xuICogICAgICAgICBsZWZ0OiAyMDBweDtcbiAqICAgICAgICAgcmlnaHQ6IDIwMHB4O1xuICogICAgICAgICBib3R0b206IDIwMHB4O1xuICogICAgIH1cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkxheW91dFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7T08udWkuUGFuZWxMYXlvdXR9IFttZW51UGFuZWxdIE1lbnUgcGFuZWxcbiAqIEBjZmcge09PLnVpLlBhbmVsTGF5b3V0fSBbY29udGVudFBhbmVsXSBDb250ZW50IHBhbmVsXG4gKiBAY2ZnIHtib29sZWFufSBbZXhwYW5kZWQ9dHJ1ZV0gRXhwYW5kIHRoZSBsYXlvdXQgdG8gZmlsbCB0aGUgZW50aXJlIHBhcmVudCBlbGVtZW50LlxuICogQGNmZyB7Ym9vbGVhbn0gW3Nob3dNZW51PXRydWVdIFNob3cgbWVudVxuICogQGNmZyB7c3RyaW5nfSBbbWVudVBvc2l0aW9uPSdiZWZvcmUnXSBQb3NpdGlvbiBvZiBtZW51OiBgdG9wYCwgYGFmdGVyYCwgYGJvdHRvbWAgb3IgYGJlZm9yZWBcbiAqL1xuT08udWkuTWVudUxheW91dCA9IGZ1bmN0aW9uIE9vVWlNZW51TGF5b3V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHtcblx0XHRleHBhbmRlZDogdHJ1ZSxcblx0XHRzaG93TWVudTogdHJ1ZSxcblx0XHRtZW51UG9zaXRpb246ICdiZWZvcmUnXG5cdH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5NZW51TGF5b3V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHR0aGlzLm1lbnVQYW5lbCA9IG51bGw7XG5cdHRoaXMuY29udGVudFBhbmVsID0gbnVsbDtcblx0dGhpcy5leHBhbmRlZCA9ICEhY29uZmlnLmV4cGFuZGVkO1xuXHQvKipcblx0ICogTWVudSBET00gbm9kZVxuXHQgKlxuXHQgKiBAcHJvcGVydHkge2pRdWVyeX1cblx0ICovXG5cdHRoaXMuJG1lbnUgPSAkKCAnPGRpdj4nICk7XG5cdC8qKlxuXHQgKiBDb250ZW50IERPTSBub2RlXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSB7alF1ZXJ5fVxuXHQgKi9cblx0dGhpcy4kY29udGVudCA9ICQoICc8ZGl2PicgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRtZW51XG5cdFx0LmFkZENsYXNzKCAnb28tdWktbWVudUxheW91dC1tZW51JyApO1xuXHR0aGlzLiRjb250ZW50LmFkZENsYXNzKCAnb28tdWktbWVudUxheW91dC1jb250ZW50JyApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktbWVudUxheW91dCcgKTtcblx0aWYgKCBjb25maWcuZXhwYW5kZWQgKSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLW1lbnVMYXlvdXQtZXhwYW5kZWQnICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLW1lbnVMYXlvdXQtc3RhdGljJyApO1xuXHR9XG5cdGlmICggY29uZmlnLm1lbnVQYW5lbCApIHtcblx0XHR0aGlzLnNldE1lbnVQYW5lbCggY29uZmlnLm1lbnVQYW5lbCApO1xuXHR9XG5cdGlmICggY29uZmlnLmNvbnRlbnRQYW5lbCApIHtcblx0XHR0aGlzLnNldENvbnRlbnRQYW5lbCggY29uZmlnLmNvbnRlbnRQYW5lbCApO1xuXHR9XG5cdHRoaXMuc2V0TWVudVBvc2l0aW9uKCBjb25maWcubWVudVBvc2l0aW9uICk7XG5cdHRoaXMudG9nZ2xlTWVudSggY29uZmlnLnNob3dNZW51ICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk1lbnVMYXlvdXQsIE9PLnVpLkxheW91dCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogVG9nZ2xlIG1lbnUuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzaG93TWVudSBTaG93IG1lbnUsIG9taXQgdG8gdG9nZ2xlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5NZW51TGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuTWVudUxheW91dC5wcm90b3R5cGUudG9nZ2xlTWVudSA9IGZ1bmN0aW9uICggc2hvd01lbnUgKSB7XG5cdHNob3dNZW51ID0gc2hvd01lbnUgPT09IHVuZGVmaW5lZCA/ICF0aGlzLnNob3dNZW51IDogISFzaG93TWVudTtcblxuXHRpZiAoIHRoaXMuc2hvd01lbnUgIT09IHNob3dNZW51ICkge1xuXHRcdHRoaXMuc2hvd01lbnUgPSBzaG93TWVudTtcblx0XHR0aGlzLiRlbGVtZW50XG5cdFx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1tZW51TGF5b3V0LXNob3dNZW51JywgdGhpcy5zaG93TWVudSApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1tZW51TGF5b3V0LWhpZGVNZW51JywgIXRoaXMuc2hvd01lbnUgKTtcblx0XHR0aGlzLiRtZW51LmF0dHIoICdhcmlhLWhpZGRlbicsIHRoaXMuc2hvd01lbnUgPyAnZmFsc2UnIDogJ3RydWUnICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgbWVudSBpcyB2aXNpYmxlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gTWVudSBpcyB2aXNpYmxlXG4gKi9cbk9PLnVpLk1lbnVMYXlvdXQucHJvdG90eXBlLmlzTWVudVZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnNob3dNZW51O1xufTtcblxuLyoqXG4gKiBTZXQgbWVudSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gUG9zaXRpb24gb2YgbWVudSwgZWl0aGVyIGB0b3BgLCBgYWZ0ZXJgLCBgYm90dG9tYCBvciBgYmVmb3JlYFxuICogQHRocm93cyB7RXJyb3J9IElmIHBvc2l0aW9uIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5NZW51TGF5b3V0LnByb3RvdHlwZS5zZXRNZW51UG9zaXRpb24gPSBmdW5jdGlvbiAoIHBvc2l0aW9uICkge1xuXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktbWVudUxheW91dC0nICsgdGhpcy5tZW51UG9zaXRpb24gKTtcblx0dGhpcy5tZW51UG9zaXRpb24gPSBwb3NpdGlvbjtcblx0aWYgKCB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5tZW51UG9zaXRpb24gPT09ICdiZWZvcmUnICkge1xuXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKCB0aGlzLiRtZW51LCB0aGlzLiRjb250ZW50ICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hcHBlbmQoIHRoaXMuJGNvbnRlbnQsIHRoaXMuJG1lbnUgKTtcblx0fVxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktbWVudUxheW91dC0nICsgcG9zaXRpb24gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IG1lbnUgcG9zaXRpb24uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBNZW51IHBvc2l0aW9uXG4gKi9cbk9PLnVpLk1lbnVMYXlvdXQucHJvdG90eXBlLmdldE1lbnVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubWVudVBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1lbnUgcGFuZWwuXG4gKlxuICogQHBhcmFtIHtPTy51aS5QYW5lbExheW91dH0gbWVudVBhbmVsIE1lbnUgcGFuZWxcbiAqL1xuT08udWkuTWVudUxheW91dC5wcm90b3R5cGUuc2V0TWVudVBhbmVsID0gZnVuY3Rpb24gKCBtZW51UGFuZWwgKSB7XG5cdHRoaXMubWVudVBhbmVsID0gbWVudVBhbmVsO1xuXHR0aGlzLiRtZW51LmFwcGVuZCggdGhpcy5tZW51UGFuZWwuJGVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZW50IHBhbmVsLlxuICpcbiAqIEBwYXJhbSB7T08udWkuUGFuZWxMYXlvdXR9IGNvbnRlbnRQYW5lbCBDb250ZW50IHBhbmVsXG4gKi9cbk9PLnVpLk1lbnVMYXlvdXQucHJvdG90eXBlLnNldENvbnRlbnRQYW5lbCA9IGZ1bmN0aW9uICggY29udGVudFBhbmVsICkge1xuXHR0aGlzLmNvbnRlbnRQYW5lbCA9IGNvbnRlbnRQYW5lbDtcblx0dGhpcy4kY29udGVudC5hcHBlbmQoIHRoaXMuY29udGVudFBhbmVsLiRlbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBtZW51IHBhbmVsLlxuICovXG5PTy51aS5NZW51TGF5b3V0LnByb3RvdHlwZS5jbGVhck1lbnVQYW5lbCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5tZW51UGFuZWwgPSBudWxsO1xuXHR0aGlzLiRtZW51LmVtcHR5KCk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBjb250ZW50IHBhbmVsLlxuICovXG5PTy51aS5NZW51TGF5b3V0LnByb3RvdHlwZS5jbGVhckNvbnRlbnRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5jb250ZW50UGFuZWwgPSBudWxsO1xuXHR0aGlzLiRjb250ZW50LmVtcHR5KCk7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY3JvbGwgb2Zmc2V0IG9mIGFsbCBwYW5lbHMgYW5kIHRoZSB0YWIgc2VsZWN0IHdpZGdldFxuICpcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVMYXlvdXQucHJvdG90eXBlLnJlc2V0U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMubWVudVBhbmVsICkge1xuXHRcdHRoaXMubWVudVBhbmVsLnJlc2V0U2Nyb2xsKCk7XG5cdH1cblx0aWYgKCB0aGlzLmNvbnRlbnRQYW5lbCApIHtcblx0XHR0aGlzLmNvbnRlbnRQYW5lbC5yZXNldFNjcm9sbCgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEJvb2tsZXRMYXlvdXRzIGNvbnRhaW4ge0BsaW5rIE9PLnVpLlBhZ2VMYXlvdXQgcGFnZSBsYXlvdXRzfSBhcyB3ZWxsIGFzXG4gKiBhbiB7QGxpbmsgT08udWkuT3V0bGluZVNlbGVjdFdpZGdldCBvdXRsaW5lfSB0aGF0IGFsbG93cyB1c2VycyB0byBlYXNpbHkgbmF2aWdhdGVcbiAqIHRocm91Z2ggdGhlIHBhZ2VzIGFuZCBzZWxlY3Qgd2hpY2ggb25lIHRvIGRpc3BsYXkuIEJ5IGRlZmF1bHQsIG9ubHkgb25lIHBhZ2UgaXNcbiAqIGRpc3BsYXllZCBhdCBhIHRpbWUgYW5kIHRoZSBvdXRsaW5lIGlzIGhpZGRlbi4gV2hlbiBhIHVzZXIgbmF2aWdhdGVzIHRvIGEgbmV3IHBhZ2UsXG4gKiB0aGUgYm9va2xldCBsYXlvdXQgYXV0b21hdGljYWxseSBmb2N1c2VzIG9uIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCwgdW5sZXNzIHRoZVxuICogZGVmYXVsdCBzZXR0aW5nIGlzIGNoYW5nZWQuIE9wdGlvbmFsbHksIGJvb2tsZXRzIGNhbiBiZSBjb25maWd1cmVkIHRvIHNob3dcbiAqIHtAbGluayBPTy51aS5PdXRsaW5lQ29udHJvbHNXaWRnZXQgY29udHJvbHN9IGZvciBhZGRpbmcsIG1vdmluZywgYW5kIHJlbW92aW5nIGl0ZW1zLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEV4YW1wbGUgb2YgYSBCb29rbGV0TGF5b3V0IHRoYXQgY29udGFpbnMgdHdvIFBhZ2VMYXlvdXRzLlxuICpcbiAqICAgICBmdW5jdGlvbiBQYWdlT25lTGF5b3V0KCBuYW1lLCBjb25maWcgKSB7XG4gKiAgICAgICAgIFBhZ2VPbmVMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIG5hbWUsIGNvbmZpZyApO1xuICogICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCggJzxwPkZpcnN0IHBhZ2U8L3A+PHA+KFRoaXMgYm9va2xldCBoYXMgYW4gb3V0bGluZSwgZGlzcGxheWVkIG9uIHRoZSBsZWZ0KTwvcD4nICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggUGFnZU9uZUxheW91dCwgT08udWkuUGFnZUxheW91dCApO1xuICogICAgIFBhZ2VPbmVMYXlvdXQucHJvdG90eXBlLnNldHVwT3V0bGluZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHRoaXMub3V0bGluZUl0ZW0uc2V0TGFiZWwoICdQYWdlIE9uZScgKTtcbiAqICAgICB9O1xuICpcbiAqICAgICBmdW5jdGlvbiBQYWdlVHdvTGF5b3V0KCBuYW1lLCBjb25maWcgKSB7XG4gKiAgICAgICAgIFBhZ2VUd29MYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIG5hbWUsIGNvbmZpZyApO1xuICogICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCggJzxwPlNlY29uZCBwYWdlPC9wPicgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBQYWdlVHdvTGF5b3V0LCBPTy51aS5QYWdlTGF5b3V0ICk7XG4gKiAgICAgUGFnZVR3b0xheW91dC5wcm90b3R5cGUuc2V0dXBPdXRsaW5lSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdGhpcy5vdXRsaW5lSXRlbS5zZXRMYWJlbCggJ1BhZ2UgVHdvJyApO1xuICogICAgIH07XG4gKlxuICogICAgIHZhciBwYWdlMSA9IG5ldyBQYWdlT25lTGF5b3V0KCAnb25lJyApLFxuICogICAgICAgICBwYWdlMiA9IG5ldyBQYWdlVHdvTGF5b3V0KCAndHdvJyApO1xuICpcbiAqICAgICB2YXIgYm9va2xldCA9IG5ldyBPTy51aS5Cb29rbGV0TGF5b3V0KCB7XG4gKiAgICAgICAgIG91dGxpbmVkOiB0cnVlXG4gKiAgICAgfSApO1xuICpcbiAqICAgICBib29rbGV0LmFkZFBhZ2VzKCBbIHBhZ2UxLCBwYWdlMiBdICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggYm9va2xldC4kZWxlbWVudCApO1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuTWVudUxheW91dFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7Ym9vbGVhbn0gW2NvbnRpbnVvdXM9ZmFsc2VdIFNob3cgYWxsIHBhZ2VzLCBvbmUgYWZ0ZXIgYW5vdGhlclxuICogQGNmZyB7Ym9vbGVhbn0gW2F1dG9Gb2N1cz10cnVlXSBGb2N1cyBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2hlbiBhIG5ldyBwYWdlIGlzIGRpc3BsYXllZC4gRGlzYWJsZWQgb24gbW9iaWxlLlxuICogQGNmZyB7Ym9vbGVhbn0gW291dGxpbmVkPWZhbHNlXSBTaG93IHRoZSBvdXRsaW5lLiBUaGUgb3V0bGluZSBpcyB1c2VkIHRvIG5hdmlnYXRlIHRocm91Z2ggdGhlIHBhZ2VzIG9mIHRoZSBib29rbGV0LlxuICogQGNmZyB7Ym9vbGVhbn0gW2VkaXRhYmxlPWZhbHNlXSBTaG93IGNvbnRyb2xzIGZvciBhZGRpbmcsIHJlbW92aW5nIGFuZCByZW9yZGVyaW5nIHBhZ2VzXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQgPSBmdW5jdGlvbiBPb1VpQm9va2xldExheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuQm9va2xldExheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmN1cnJlbnRQYWdlTmFtZSA9IG51bGw7XG5cdHRoaXMucGFnZXMgPSB7fTtcblx0dGhpcy5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXHR0aGlzLnN0YWNrTGF5b3V0ID0gbmV3IE9PLnVpLlN0YWNrTGF5b3V0KCB7XG5cdFx0Y29udGludW91czogISFjb25maWcuY29udGludW91cyxcblx0XHRleHBhbmRlZDogdGhpcy5leHBhbmRlZFxuXHR9ICk7XG5cdHRoaXMuc2V0Q29udGVudFBhbmVsKCB0aGlzLnN0YWNrTGF5b3V0ICk7XG5cdHRoaXMuYXV0b0ZvY3VzID0gY29uZmlnLmF1dG9Gb2N1cyA9PT0gdW5kZWZpbmVkIHx8ICEhY29uZmlnLmF1dG9Gb2N1cztcblx0dGhpcy5vdXRsaW5lVmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLm91dGxpbmVkID0gISFjb25maWcub3V0bGluZWQ7XG5cdGlmICggdGhpcy5vdXRsaW5lZCApIHtcblx0XHR0aGlzLmVkaXRhYmxlID0gISFjb25maWcuZWRpdGFibGU7XG5cdFx0dGhpcy5vdXRsaW5lQ29udHJvbHNXaWRnZXQgPSBudWxsO1xuXHRcdHRoaXMub3V0bGluZVNlbGVjdFdpZGdldCA9IG5ldyBPTy51aS5PdXRsaW5lU2VsZWN0V2lkZ2V0KCk7XG5cdFx0dGhpcy5vdXRsaW5lUGFuZWwgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcblx0XHRcdGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuXHRcdFx0c2Nyb2xsYWJsZTogdHJ1ZVxuXHRcdH0gKTtcblx0XHR0aGlzLnNldE1lbnVQYW5lbCggdGhpcy5vdXRsaW5lUGFuZWwgKTtcblx0XHR0aGlzLm91dGxpbmVWaXNpYmxlID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuZWRpdGFibGUgKSB7XG5cdFx0XHR0aGlzLm91dGxpbmVDb250cm9sc1dpZGdldCA9IG5ldyBPTy51aS5PdXRsaW5lQ29udHJvbHNXaWRnZXQoXG5cdFx0XHRcdHRoaXMub3V0bGluZVNlbGVjdFdpZGdldFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0dGhpcy50b2dnbGVNZW51KCB0aGlzLm91dGxpbmVkICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuc3RhY2tMYXlvdXQuY29ubmVjdCggdGhpcywgeyBzZXQ6ICdvblN0YWNrTGF5b3V0U2V0JyB9ICk7XG5cdGlmICggdGhpcy5vdXRsaW5lZCApIHtcblx0XHR0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuY29ubmVjdCggdGhpcywgeyBzZWxlY3Q6ICdvbk91dGxpbmVTZWxlY3RXaWRnZXRTZWxlY3QnIH0gKTtcblx0XHR0aGlzLnNjcm9sbGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuc3RhY2tMYXlvdXQuY29ubmVjdCggdGhpcywgeyB2aXNpYmxlSXRlbUNoYW5nZTogJ29uU3RhY2tMYXlvdXRWaXNpYmxlSXRlbUNoYW5nZScgfSApO1xuXHR9XG5cdGlmICggdGhpcy5hdXRvRm9jdXMgKSB7XG5cdFx0Ly8gRXZlbnQgJ2ZvY3VzJyBkb2VzIG5vdCBidWJibGUsIGJ1dCAnZm9jdXNpbicgZG9lc1xuXHRcdHRoaXMuc3RhY2tMYXlvdXQuJGVsZW1lbnQub24oICdmb2N1c2luJywgdGhpcy5vblN0YWNrTGF5b3V0Rm9jdXMuYmluZCggdGhpcyApICk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYm9va2xldExheW91dCcgKTtcblx0dGhpcy5zdGFja0xheW91dC4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWJvb2tsZXRMYXlvdXQtc3RhY2tMYXlvdXQnICk7XG5cdGlmICggdGhpcy5vdXRsaW5lZCApIHtcblx0XHR0aGlzLm91dGxpbmVQYW5lbC4kZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCAnb28tdWktYm9va2xldExheW91dC1vdXRsaW5lUGFuZWwnIClcblx0XHRcdC5hcHBlbmQoIHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC4kZWxlbWVudCApO1xuXHRcdGlmICggdGhpcy5lZGl0YWJsZSApIHtcblx0XHRcdHRoaXMub3V0bGluZVBhbmVsLiRlbGVtZW50XG5cdFx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLWJvb2tsZXRMYXlvdXQtb3V0bGluZVBhbmVsLWVkaXRhYmxlJyApXG5cdFx0XHRcdC5hcHBlbmQoIHRoaXMub3V0bGluZUNvbnRyb2xzV2lkZ2V0LiRlbGVtZW50ICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLkJvb2tsZXRMYXlvdXQsIE9PLnVpLk1lbnVMYXlvdXQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQSAnc2V0JyBldmVudCBpcyBlbWl0dGVkIHdoZW4gYSBwYWdlIGlzIHtAbGluayAjc2V0UGFnZSBzZXR9IHRvIGJlIGRpc3BsYXllZCBieSB0aGUgYm9va2xldCBsYXlvdXQuXG4gKiBAZXZlbnQgc2V0XG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXR9IHBhZ2UgQ3VycmVudCBwYWdlXG4gKi9cblxuLyoqXG4gKiBBbiAnYWRkJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gcGFnZXMgYXJlIHtAbGluayAjYWRkUGFnZXMgYWRkZWR9IHRvIHRoZSBib29rbGV0IGxheW91dC5cbiAqXG4gKiBAZXZlbnQgYWRkXG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXRbXX0gcGFnZSBBZGRlZCBwYWdlc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHBhZ2VzIHdlcmUgYWRkZWQgYXRcbiAqL1xuXG4vKipcbiAqIEEgJ3JlbW92ZScgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHBhZ2VzIGFyZSB7QGxpbmsgI2NsZWFyUGFnZXMgY2xlYXJlZH0gb3JcbiAqIHtAbGluayAjcmVtb3ZlUGFnZXMgcmVtb3ZlZH0gZnJvbSB0aGUgYm9va2xldC5cbiAqXG4gKiBAZXZlbnQgcmVtb3ZlXG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXRbXX0gcGFnZXMgUmVtb3ZlZCBwYWdlc1xuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBIYW5kbGUgc3RhY2sgbGF5b3V0IGZvY3VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBGb2N1c2luIGV2ZW50XG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLm9uU3RhY2tMYXlvdXRGb2N1cyA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIG5hbWUsICR0YXJnZXQ7XG5cblx0Ly8gRmluZCB0aGUgcGFnZSB0aGF0IGFuIGVsZW1lbnQgd2FzIGZvY3VzZWQgd2l0aGluXG5cdCR0YXJnZXQgPSAkKCBlLnRhcmdldCApLmNsb3Nlc3QoICcub28tdWktcGFnZUxheW91dCcgKTtcblx0Zm9yICggbmFtZSBpbiB0aGlzLnBhZ2VzICkge1xuXHRcdC8vIENoZWNrIGZvciBwYWdlIG1hdGNoLCBleGNsdWRlIGN1cnJlbnQgcGFnZSB0byBmaW5kIG9ubHkgcGFnZSBjaGFuZ2VzXG5cdFx0aWYgKCB0aGlzLnBhZ2VzWyBuYW1lIF0uJGVsZW1lbnRbIDAgXSA9PT0gJHRhcmdldFsgMCBdICYmIG5hbWUgIT09IHRoaXMuY3VycmVudFBhZ2VOYW1lICkge1xuXHRcdFx0dGhpcy5zZXRQYWdlKCBuYW1lICk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHZpc2libGVJdGVtQ2hhbmdlIGV2ZW50cyBmcm9tIHRoZSBzdGFja0xheW91dFxuICpcbiAqIFRoZSBuZXh0IHZpc2libGUgcGFnZSBpcyBzZXQgYXMgdGhlIGN1cnJlbnQgcGFnZSBieSBzZWxlY3RpbmcgaXRcbiAqIGluIHRoZSBvdXRsaW5lXG4gKlxuICogQHBhcmFtIHtPTy51aS5QYWdlTGF5b3V0fSBwYWdlIFRoZSBuZXh0IHZpc2libGUgcGFnZSBpbiB0aGUgbGF5b3V0XG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLm9uU3RhY2tMYXlvdXRWaXNpYmxlSXRlbUNoYW5nZSA9IGZ1bmN0aW9uICggcGFnZSApIHtcblx0Ly8gU2V0IGEgZmxhZyB0byBzbyB0aGF0IHRoZSByZXN1bHRpbmcgY2FsbCB0byAjb25TdGFja0xheW91dFNldCBkb2Vzbid0XG5cdC8vIHRyeSBhbmQgc2Nyb2xsIHRoZSBpdGVtIGludG8gdmlldyBhZ2Fpbi5cblx0dGhpcy5zY3JvbGxpbmcgPSB0cnVlO1xuXHR0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuc2VsZWN0SXRlbUJ5RGF0YSggcGFnZS5nZXROYW1lKCkgKTtcblx0dGhpcy5zY3JvbGxpbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHN0YWNrIGxheW91dCBzZXQgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09PLnVpLlBhbmVsTGF5b3V0fG51bGx9IHBhZ2UgVGhlIHBhZ2UgcGFuZWwgdGhhdCBpcyBub3cgdGhlIGN1cnJlbnQgcGFuZWxcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUub25TdGFja0xheW91dFNldCA9IGZ1bmN0aW9uICggcGFnZSApIHtcblx0dmFyIHByb21pc2UsIGxheW91dCA9IHRoaXM7XG5cdC8vIElmIGV2ZXJ5dGhpbmcgaXMgdW5zZWxlY3RlZCwgZG8gbm90aGluZ1xuXHRpZiAoICFwYWdlICkge1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBGb3IgY29udGludW91cyBCb29rbGV0TGF5b3V0cywgc2Nyb2xsIHRoZSBzZWxlY3RlZCBwYWdlIGludG8gdmlldyBmaXJzdFxuXHRpZiAoIHRoaXMuc3RhY2tMYXlvdXQuY29udGludW91cyAmJiAhdGhpcy5zY3JvbGxpbmcgKSB7XG5cdFx0cHJvbWlzZSA9IHBhZ2Uuc2Nyb2xsRWxlbWVudEludG9WaWV3KCk7XG5cdH0gZWxzZSB7XG5cdFx0cHJvbWlzZSA9ICQuRGVmZXJyZWQoKS5yZXNvbHZlKCk7XG5cdH1cblx0Ly8gRm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIG5ld2x5IHNlbGVjdGVkIHBhbmVsLlxuXHQvLyBEb24ndCBmb2N1cyBpZiB0aGUgcGFnZSB3YXMgc2V0IGJ5IHNjcm9sbGluZy5cblx0aWYgKCB0aGlzLmF1dG9Gb2N1cyAmJiAhT08udWkuaXNNb2JpbGUoKSAmJiAhdGhpcy5zY3JvbGxpbmcgKSB7XG5cdFx0cHJvbWlzZS5kb25lKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRsYXlvdXQuZm9jdXMoKTtcblx0XHR9ICk7XG5cdH1cbn07XG5cbi8qKlxuICogRm9jdXMgdGhlIGZpcnN0IGlucHV0IGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogSWYgbm8gcGFnZSBpcyBzZWxlY3RlZCwgdGhlIGZpcnN0IHNlbGVjdGFibGUgcGFnZSB3aWxsIGJlIHNlbGVjdGVkLlxuICogSWYgdGhlIGZvY3VzIGlzIGFscmVhZHkgaW4gYW4gZWxlbWVudCBvbiB0aGUgY3VycmVudCBwYWdlLCBub3RoaW5nIHdpbGwgaGFwcGVuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaXRlbUluZGV4XSBBIHNwZWNpZmljIGl0ZW0gdG8gZm9jdXMgb25cbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoIGl0ZW1JbmRleCApIHtcblx0dmFyIHBhZ2UsXG5cdFx0aXRlbXMgPSB0aGlzLnN0YWNrTGF5b3V0LmdldEl0ZW1zKCk7XG5cblx0aWYgKCBpdGVtSW5kZXggIT09IHVuZGVmaW5lZCAmJiBpdGVtc1sgaXRlbUluZGV4IF0gKSB7XG5cdFx0cGFnZSA9IGl0ZW1zWyBpdGVtSW5kZXggXTtcblx0fSBlbHNlIHtcblx0XHRwYWdlID0gdGhpcy5zdGFja0xheW91dC5nZXRDdXJyZW50SXRlbSgpO1xuXHR9XG5cblx0aWYgKCAhcGFnZSAmJiB0aGlzLm91dGxpbmVkICkge1xuXHRcdHRoaXMuc2VsZWN0Rmlyc3RTZWxlY3RhYmxlUGFnZSgpO1xuXHRcdHBhZ2UgPSB0aGlzLnN0YWNrTGF5b3V0LmdldEN1cnJlbnRJdGVtKCk7XG5cdH1cblx0aWYgKCAhcGFnZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gT25seSBjaGFuZ2UgdGhlIGZvY3VzIGlmIGlzIG5vdCBhbHJlYWR5IGluIHRoZSBjdXJyZW50IHBhZ2Vcblx0aWYgKCAhT08udWkuY29udGFpbnMoIHBhZ2UuJGVsZW1lbnRbIDAgXSwgdGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hY3RpdmVFbGVtZW50LCB0cnVlICkgKSB7XG5cdFx0cGFnZS5mb2N1cygpO1xuXHR9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGZpcnN0IGZvY3VzYWJsZSBpbnB1dCBpbiB0aGUgYm9va2xldCBsYXlvdXQgYW5kIGZvY3VzXG4gKiBvbiBpdC5cbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuZm9jdXNGaXJzdEZvY3VzYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkuZmluZEZvY3VzYWJsZSggdGhpcy5zdGFja0xheW91dC4kZWxlbWVudCApLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBvdXRsaW5lIHdpZGdldCBzZWxlY3QgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09PLnVpLk9wdGlvbldpZGdldHxudWxsfSBpdGVtIFNlbGVjdGVkIGl0ZW1cbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUub25PdXRsaW5lU2VsZWN0V2lkZ2V0U2VsZWN0ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoIGl0ZW0gKSB7XG5cdFx0dGhpcy5zZXRQYWdlKCBpdGVtLmdldERhdGEoKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGJvb2tsZXQgaGFzIGFuIG91dGxpbmUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gQm9va2xldCBoYXMgYW4gb3V0bGluZVxuICovXG5PTy51aS5Cb29rbGV0TGF5b3V0LnByb3RvdHlwZS5pc091dGxpbmVkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5vdXRsaW5lZDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYm9va2xldCBoYXMgZWRpdGluZyBjb250cm9scy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBCb29rbGV0IGlzIGVkaXRhYmxlXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLmlzRWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmVkaXRhYmxlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBib29rbGV0IGhhcyBhIHZpc2libGUgb3V0bGluZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBPdXRsaW5lIGlzIHZpc2libGVcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuaXNPdXRsaW5lVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMub3V0bGluZWQgJiYgdGhpcy5vdXRsaW5lVmlzaWJsZTtcbn07XG5cbi8qKlxuICogSGlkZSBvciBzaG93IHRoZSBvdXRsaW5lLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3ddIFNob3cgb3V0bGluZSwgb21pdCB0byBpbnZlcnQgY3VycmVudCBzdGF0ZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQm9va2xldExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLnRvZ2dsZU91dGxpbmUgPSBmdW5jdGlvbiAoIHNob3cgKSB7XG5cdHZhciBib29rbGV0ID0gdGhpcztcblxuXHRpZiAoIHRoaXMub3V0bGluZWQgKSB7XG5cdFx0c2hvdyA9IHNob3cgPT09IHVuZGVmaW5lZCA/ICF0aGlzLm91dGxpbmVWaXNpYmxlIDogISFzaG93O1xuXHRcdHRoaXMub3V0bGluZVZpc2libGUgPSBzaG93O1xuXHRcdHRoaXMudG9nZ2xlTWVudSggc2hvdyApO1xuXHRcdGlmICggc2hvdyAmJiB0aGlzLmVkaXRhYmxlICkge1xuXHRcdFx0Ly8gSEFDSzogS2lsbCBkdW1iIHNjcm9sbGJhcnMgd2hlbiB0aGUgc2lkZWJhciBzdG9wcyBhbmltYXRpbmcsIHNlZSBUMTYxNzk4LiBPbmx5IG5lY2Vzc2FyeSB3aGVuXG5cdFx0XHQvLyBvdXRsaW5lIGNvbnRyb2xzIGFyZSBwcmVzZW50LCBkZWxheSBtYXRjaGVzIHRyYW5zaXRpb24gb24gYC5vby11aS1tZW51TGF5b3V0LW1lbnVgLlxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRPTy51aS5FbGVtZW50LnN0YXRpYy5yZWNvbnNpZGVyU2Nyb2xsYmFycyggYm9va2xldC5vdXRsaW5lUGFuZWwuJGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0fSwgT08udWkudGhlbWUuZ2V0RGlhbG9nVHJhbnNpdGlvbkR1cmF0aW9uKCkgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgcGFnZSBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgcGFnZS5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXR9IHBhZ2UgUGFnZSB0byB1c2UgYXMgYSByZWZlcmVuY2UgcG9pbnRcbiAqIEByZXR1cm4ge09PLnVpLlBhZ2VMYXlvdXR8bnVsbH0gUGFnZSBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgcGFnZVxuICovXG5PTy51aS5Cb29rbGV0TGF5b3V0LnByb3RvdHlwZS5maW5kQ2xvc2VzdFBhZ2UgPSBmdW5jdGlvbiAoIHBhZ2UgKSB7XG5cdHZhciBuZXh0LCBwcmV2LCBsZXZlbCxcblx0XHRwYWdlcyA9IHRoaXMuc3RhY2tMYXlvdXQuZ2V0SXRlbXMoKSxcblx0XHRpbmRleCA9IHBhZ2VzLmluZGV4T2YoIHBhZ2UgKTtcblxuXHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRuZXh0ID0gcGFnZXNbIGluZGV4ICsgMSBdO1xuXHRcdHByZXYgPSBwYWdlc1sgaW5kZXggLSAxIF07XG5cdFx0Ly8gUHJlZmVyIGFkamFjZW50IHBhZ2VzIGF0IHRoZSBzYW1lIGxldmVsXG5cdFx0aWYgKCB0aGlzLm91dGxpbmVkICkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuZmluZEl0ZW1Gcm9tRGF0YSggcGFnZS5nZXROYW1lKCkgKS5nZXRMZXZlbCgpO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRwcmV2ICYmXG5cdFx0XHRcdGxldmVsID09PSB0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuZmluZEl0ZW1Gcm9tRGF0YSggcHJldi5nZXROYW1lKCkgKS5nZXRMZXZlbCgpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHByZXY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5leHQgJiZcblx0XHRcdFx0bGV2ZWwgPT09IHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kSXRlbUZyb21EYXRhKCBuZXh0LmdldE5hbWUoKSApLmdldExldmVsKClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gbmV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHByZXYgfHwgbmV4dCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG91dGxpbmUgd2lkZ2V0LlxuICpcbiAqIElmIHRoZSBib29rbGV0IGlzIG5vdCBvdXRsaW5lZCwgdGhlIG1ldGhvZCB3aWxsIHJldHVybiBgbnVsbGAuXG4gKlxuICogQHJldHVybiB7T08udWkuT3V0bGluZVNlbGVjdFdpZGdldHxudWxsfSBPdXRsaW5lIHdpZGdldCwgb3IgbnVsbCBpZiB0aGUgYm9va2xldCBpcyBub3Qgb3V0bGluZWRcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuZ2V0T3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMub3V0bGluZVNlbGVjdFdpZGdldDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvdXRsaW5lIGNvbnRyb2xzIHdpZGdldC5cbiAqXG4gKiBJZiB0aGUgb3V0bGluZSBpcyBub3QgZWRpdGFibGUsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gYG51bGxgLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLk91dGxpbmVDb250cm9sc1dpZGdldHxudWxsfSBUaGUgb3V0bGluZSBjb250cm9scyB3aWRnZXQuXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLmdldE91dGxpbmVDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMub3V0bGluZUNvbnRyb2xzV2lkZ2V0O1xufTtcblxuLyoqXG4gKiBHZXQgYSBwYWdlIGJ5IGl0cyBzeW1ib2xpYyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN5bWJvbGljIG5hbWUgb2YgcGFnZVxuICogQHJldHVybiB7T08udWkuUGFnZUxheW91dHx1bmRlZmluZWR9IFBhZ2UsIGlmIGZvdW5kXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2UgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cdHJldHVybiB0aGlzLnBhZ2VzWyBuYW1lIF07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLlBhZ2VMYXlvdXR8dW5kZWZpbmVkfSBDdXJyZW50IHBhZ2UsIGlmIGZvdW5kXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLmdldEN1cnJlbnRQYWdlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbmFtZSA9IHRoaXMuZ2V0Q3VycmVudFBhZ2VOYW1lKCk7XG5cdHJldHVybiBuYW1lID8gdGhpcy5nZXRQYWdlKCBuYW1lICkgOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3ltYm9saWMgbmFtZSBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSBTeW1ib2xpYyBuYW1lIG9mIHRoZSBjdXJyZW50IHBhZ2VcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuZ2V0Q3VycmVudFBhZ2VOYW1lID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZU5hbWU7XG59O1xuXG4vKipcbiAqIEFkZCBwYWdlcyB0byB0aGUgYm9va2xldCBsYXlvdXRcbiAqXG4gKiBXaGVuIHBhZ2VzIGFyZSBhZGRlZCB3aXRoIHRoZSBzYW1lIG5hbWVzIGFzIGV4aXN0aW5nIHBhZ2VzLCB0aGUgZXhpc3RpbmcgcGFnZXMgd2lsbCBiZVxuICogYXV0b21hdGljYWxseSByZW1vdmVkIGJlZm9yZSB0aGUgbmV3IHBhZ2VzIGFyZSBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXRbXX0gcGFnZXMgUGFnZXMgdG8gYWRkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGluc2VydGlvbiBwb2ludFxuICogQGZpcmVzIGFkZFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQm9va2xldExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLmFkZFBhZ2VzID0gZnVuY3Rpb24gKCBwYWdlcywgaW5kZXggKSB7XG5cdHZhciBpLCBsZW4sIG5hbWUsIHBhZ2UsIGl0ZW0sIGN1cnJlbnRJbmRleCxcblx0XHRzdGFja0xheW91dFBhZ2VzID0gdGhpcy5zdGFja0xheW91dC5nZXRJdGVtcygpLFxuXHRcdHJlbW92ZSA9IFtdLFxuXHRcdGl0ZW1zID0gW107XG5cblx0Ly8gUmVtb3ZlIHBhZ2VzIHdpdGggc2FtZSBuYW1lc1xuXHRmb3IgKCBpID0gMCwgbGVuID0gcGFnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0cGFnZSA9IHBhZ2VzWyBpIF07XG5cdFx0bmFtZSA9IHBhZ2UuZ2V0TmFtZSgpO1xuXG5cdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHRoaXMucGFnZXMsIG5hbWUgKSApIHtcblx0XHRcdC8vIENvcnJlY3QgdGhlIGluc2VydGlvbiBpbmRleFxuXHRcdFx0Y3VycmVudEluZGV4ID0gc3RhY2tMYXlvdXRQYWdlcy5pbmRleE9mKCB0aGlzLnBhZ2VzWyBuYW1lIF0gKTtcblx0XHRcdGlmICggY3VycmVudEluZGV4ICE9PSAtMSAmJiBjdXJyZW50SW5kZXggKyAxIDwgaW5kZXggKSB7XG5cdFx0XHRcdGluZGV4LS07XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUucHVzaCggdGhpcy5wYWdlc1sgbmFtZSBdICk7XG5cdFx0fVxuXHR9XG5cdGlmICggcmVtb3ZlLmxlbmd0aCApIHtcblx0XHR0aGlzLnJlbW92ZVBhZ2VzKCByZW1vdmUgKTtcblx0fVxuXG5cdC8vIEFkZCBuZXcgcGFnZXNcblx0Zm9yICggaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHBhZ2UgPSBwYWdlc1sgaSBdO1xuXHRcdG5hbWUgPSBwYWdlLmdldE5hbWUoKTtcblx0XHR0aGlzLnBhZ2VzWyBwYWdlLmdldE5hbWUoKSBdID0gcGFnZTtcblx0XHRpZiAoIHRoaXMub3V0bGluZWQgKSB7XG5cdFx0XHRpdGVtID0gbmV3IE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQoIHsgZGF0YTogbmFtZSB9ICk7XG5cdFx0XHRwYWdlLnNldE91dGxpbmVJdGVtKCBpdGVtICk7XG5cdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCB0aGlzLm91dGxpbmVkICYmIGl0ZW1zLmxlbmd0aCApIHtcblx0XHR0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuYWRkSXRlbXMoIGl0ZW1zLCBpbmRleCApO1xuXHRcdHRoaXMuc2VsZWN0Rmlyc3RTZWxlY3RhYmxlUGFnZSgpO1xuXHR9XG5cdHRoaXMuc3RhY2tMYXlvdXQuYWRkSXRlbXMoIHBhZ2VzLCBpbmRleCApO1xuXHR0aGlzLmVtaXQoICdhZGQnLCBwYWdlcywgaW5kZXggKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgcGFnZXMgZnJvbSB0aGUgYm9va2xldCBsYXlvdXQuXG4gKlxuICogVG8gcmVtb3ZlIGFsbCBwYWdlcyBmcm9tIHRoZSBib29rbGV0LCB5b3UgbWF5IHdpc2ggdG8gdXNlIHRoZSAjY2xlYXJQYWdlcyBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLlBhZ2VMYXlvdXRbXX0gcGFnZXMgQW4gYXJyYXkgb2YgcGFnZXMgdG8gcmVtb3ZlXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5Cb29rbGV0TGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUucmVtb3ZlUGFnZXMgPSBmdW5jdGlvbiAoIHBhZ2VzICkge1xuXHR2YXIgaSwgbGVuLCBuYW1lLCBwYWdlLFxuXHRcdGl0ZW1zID0gW107XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHBhZ2UgPSBwYWdlc1sgaSBdO1xuXHRcdG5hbWUgPSBwYWdlLmdldE5hbWUoKTtcblx0XHRkZWxldGUgdGhpcy5wYWdlc1sgbmFtZSBdO1xuXHRcdGlmICggdGhpcy5vdXRsaW5lZCApIHtcblx0XHRcdGl0ZW1zLnB1c2goIHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kSXRlbUZyb21EYXRhKCBuYW1lICkgKTtcblx0XHRcdHBhZ2Uuc2V0T3V0bGluZUl0ZW0oIG51bGwgKTtcblx0XHR9XG5cdH1cblx0aWYgKCB0aGlzLm91dGxpbmVkICYmIGl0ZW1zLmxlbmd0aCApIHtcblx0XHR0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQucmVtb3ZlSXRlbXMoIGl0ZW1zICk7XG5cdFx0dGhpcy5zZWxlY3RGaXJzdFNlbGVjdGFibGVQYWdlKCk7XG5cdH1cblx0dGhpcy5zdGFja0xheW91dC5yZW1vdmVJdGVtcyggcGFnZXMgKTtcblx0dGhpcy5lbWl0KCAncmVtb3ZlJywgcGFnZXMgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgYWxsIHBhZ2VzIGZyb20gdGhlIGJvb2tsZXQgbGF5b3V0LlxuICpcbiAqIFRvIHJlbW92ZSBvbmx5IGEgc3Vic2V0IG9mIHBhZ2VzIGZyb20gdGhlIGJvb2tsZXQsIHVzZSB0aGUgI3JlbW92ZVBhZ2VzIG1ldGhvZC5cbiAqXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5Cb29rbGV0TGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQm9va2xldExheW91dC5wcm90b3R5cGUuY2xlYXJQYWdlcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbixcblx0XHRwYWdlcyA9IHRoaXMuc3RhY2tMYXlvdXQuZ2V0SXRlbXMoKTtcblxuXHR0aGlzLnBhZ2VzID0ge307XG5cdHRoaXMuY3VycmVudFBhZ2VOYW1lID0gbnVsbDtcblx0aWYgKCB0aGlzLm91dGxpbmVkICkge1xuXHRcdHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5jbGVhckl0ZW1zKCk7XG5cdFx0Zm9yICggaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0cGFnZXNbIGkgXS5zZXRPdXRsaW5lSXRlbSggbnVsbCApO1xuXHRcdH1cblx0fVxuXHR0aGlzLnN0YWNrTGF5b3V0LmNsZWFySXRlbXMoKTtcblxuXHR0aGlzLmVtaXQoICdyZW1vdmUnLCBwYWdlcyApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBieSBzeW1ib2xpYyBuYW1lLlxuICpcbiAqIEBmaXJlcyBzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN5bWJvbGljIG5hbWUgb2YgcGFnZVxuICovXG5PTy51aS5Cb29rbGV0TGF5b3V0LnByb3RvdHlwZS5zZXRQYWdlID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXHR2YXIgc2VsZWN0ZWRJdGVtLFxuXHRcdCRmb2N1c2VkLFxuXHRcdHBhZ2UgPSB0aGlzLnBhZ2VzWyBuYW1lIF0sXG5cdFx0cHJldmlvdXNQYWdlID0gdGhpcy5jdXJyZW50UGFnZU5hbWUgJiYgdGhpcy5wYWdlc1sgdGhpcy5jdXJyZW50UGFnZU5hbWUgXTtcblxuXHRpZiAoIG5hbWUgIT09IHRoaXMuY3VycmVudFBhZ2VOYW1lICkge1xuXHRcdGlmICggdGhpcy5vdXRsaW5lZCApIHtcblx0XHRcdHNlbGVjdGVkSXRlbSA9IHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kU2VsZWN0ZWRJdGVtKCk7XG5cdFx0XHRpZiAoIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uZ2V0RGF0YSgpICE9PSBuYW1lICkge1xuXHRcdFx0XHR0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuc2VsZWN0SXRlbUJ5RGF0YSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIHBhZ2UgKSB7XG5cdFx0XHRpZiAoIHByZXZpb3VzUGFnZSApIHtcblx0XHRcdFx0cHJldmlvdXNQYWdlLnNldEFjdGl2ZSggZmFsc2UgKTtcblx0XHRcdFx0Ly8gQmx1ciBhbnl0aGluZyBmb2N1c2VkIGlmIHRoZSBuZXh0IHBhZ2UgZG9lc24ndCBoYXZlIGFueXRoaW5nIGZvY3VzYWJsZS5cblx0XHRcdFx0Ly8gVGhpcyBpcyBub3QgbmVlZGVkIGlmIHRoZSBuZXh0IHBhZ2UgaGFzIHNvbWV0aGluZyBmb2N1c2FibGUgKGJlY2F1c2Ugb25jZSBpdCBpcyBmb2N1c2VkXG5cdFx0XHRcdC8vIHRoaXMgYmx1ciBoYXBwZW5zIGF1dG9tYXRpY2FsbHkpLiBJZiB0aGUgbGF5b3V0IGlzIG5vbi1jb250aW51b3VzLCB0aGlzIGNoZWNrIGlzXG5cdFx0XHRcdC8vIG1lYW5pbmdsZXNzIGJlY2F1c2UgdGhlIG5leHQgcGFnZSBpcyBub3QgdmlzaWJsZSB5ZXQgYW5kIHRodXMgY2FuJ3QgaG9sZCBmb2N1cy5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuYXV0b0ZvY3VzICYmXG5cdFx0XHRcdFx0IU9PLnVpLmlzTW9iaWxlKCkgJiZcblx0XHRcdFx0XHR0aGlzLnN0YWNrTGF5b3V0LmNvbnRpbnVvdXMgJiZcblx0XHRcdFx0XHRPTy51aS5maW5kRm9jdXNhYmxlKCBwYWdlLiRlbGVtZW50ICkubGVuZ3RoICE9PSAwXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdCRmb2N1c2VkID0gcHJldmlvdXNQYWdlLiRlbGVtZW50LmZpbmQoICc6Zm9jdXMnICk7XG5cdFx0XHRcdFx0aWYgKCAkZm9jdXNlZC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganF1ZXJ5L25vLWV2ZW50LXNob3J0aGFuZFxuXHRcdFx0XHRcdFx0JGZvY3VzZWRbIDAgXS5ibHVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRQYWdlTmFtZSA9IG5hbWU7XG5cdFx0XHRwYWdlLnNldEFjdGl2ZSggdHJ1ZSApO1xuXHRcdFx0dGhpcy5zdGFja0xheW91dC5zZXRJdGVtKCBwYWdlICk7XG5cdFx0XHRpZiAoICF0aGlzLnN0YWNrTGF5b3V0LmNvbnRpbnVvdXMgJiYgcHJldmlvdXNQYWdlICkge1xuXHRcdFx0XHQvLyBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5LCBzaW5jZSBhbnkgaW5wdXRzIG9uIHRoZSBwcmV2aW91cyBwYWdlIHNob3VsZCBoYXZlIGJlZW5cblx0XHRcdFx0Ly8gYmx1cnJlZCB3aGVuIGl0IHdhcyBoaWRkZW4sIGJ1dCBicm93c2VycyBhcmUgbm90IHZlcnkgY29uc2lzdGVudCBhYm91dCB0aGlzLlxuXHRcdFx0XHQkZm9jdXNlZCA9IHByZXZpb3VzUGFnZS4kZWxlbWVudC5maW5kKCAnOmZvY3VzJyApO1xuXHRcdFx0XHRpZiAoICRmb2N1c2VkLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganF1ZXJ5L25vLWV2ZW50LXNob3J0aGFuZFxuXHRcdFx0XHRcdCRmb2N1c2VkWyAwIF0uYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoICdzZXQnLCBwYWdlICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEZvciBvdXRsaW5lZC1jb250aW51b3VzIGJvb2tsZXRzLCBhbHNvIHJlc2V0IHRoZSBvdXRsaW5lU2VsZWN0V2lkZ2V0IHRvIHRoZSBmaXJzdCBpdGVtLlxuICpcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLnJlc2V0U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLkJvb2tsZXRMYXlvdXQucGFyZW50LnByb3RvdHlwZS5yZXNldFNjcm9sbC5jYWxsKCB0aGlzICk7XG5cblx0aWYgKCB0aGlzLm91dGxpbmVkICYmIHRoaXMuc3RhY2tMYXlvdXQuY29udGludW91cyAmJiB0aGlzLm91dGxpbmVTZWxlY3RXaWRnZXQuZmluZEZpcnN0U2VsZWN0YWJsZUl0ZW0oKSApIHtcblx0XHR0aGlzLnNjcm9sbGluZyA9IHRydWU7XG5cdFx0dGhpcy5vdXRsaW5lU2VsZWN0V2lkZ2V0LnNlbGVjdEl0ZW0oIHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kRmlyc3RTZWxlY3RhYmxlSXRlbSgpICk7XG5cdFx0dGhpcy5zY3JvbGxpbmcgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VsZWN0IHRoZSBmaXJzdCBzZWxlY3RhYmxlIHBhZ2UuXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQm9va2xldExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkJvb2tsZXRMYXlvdXQucHJvdG90eXBlLnNlbGVjdEZpcnN0U2VsZWN0YWJsZVBhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kU2VsZWN0ZWRJdGVtKCkgKSB7XG5cdFx0dGhpcy5vdXRsaW5lU2VsZWN0V2lkZ2V0LnNlbGVjdEl0ZW0oIHRoaXMub3V0bGluZVNlbGVjdFdpZGdldC5maW5kRmlyc3RTZWxlY3RhYmxlSXRlbSgpICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5kZXhMYXlvdXRzIGNvbnRhaW4ge0BsaW5rIE9PLnVpLlRhYlBhbmVsTGF5b3V0IHRhYiBwYW5lbCBsYXlvdXRzfSBhcyB3ZWxsIGFzXG4gKiB7QGxpbmsgT08udWkuVGFiU2VsZWN0V2lkZ2V0IHRhYnN9IHRoYXQgYWxsb3cgdXNlcnMgdG8gZWFzaWx5IG5hdmlnYXRlIHRocm91Z2ggdGhlIHRhYiBwYW5lbHMgYW5kXG4gKiBzZWxlY3Qgd2hpY2ggb25lIHRvIGRpc3BsYXkuIEJ5IGRlZmF1bHQsIG9ubHkgb25lIHRhYiBwYW5lbCBpcyBkaXNwbGF5ZWQgYXQgYSB0aW1lLiBXaGVuIGEgdXNlclxuICogbmF2aWdhdGVzIHRvIGEgbmV3IHRhYiBwYW5lbCwgdGhlIGluZGV4IGxheW91dCBhdXRvbWF0aWNhbGx5IGZvY3VzZXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LFxuICogdW5sZXNzIHRoZSBkZWZhdWx0IHNldHRpbmcgaXMgY2hhbmdlZC5cbiAqXG4gKiBUT0RPOiBUaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gQm9va2xldExheW91dCwgd2UgbWF5IHdhbnQgdG8gcmVmYWN0b3IgdG8gcmVkdWNlIGR1cGxpY2F0aW9uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZSBvZiBhIEluZGV4TGF5b3V0IHRoYXQgY29udGFpbnMgdHdvIFRhYlBhbmVsTGF5b3V0cy5cbiAqXG4gKiAgICAgZnVuY3Rpb24gVGFiUGFuZWxPbmVMYXlvdXQoIG5hbWUsIGNvbmZpZyApIHtcbiAqICAgICAgICAgVGFiUGFuZWxPbmVMYXlvdXQucGFyZW50LmNhbGwoIHRoaXMsIG5hbWUsIGNvbmZpZyApO1xuICogICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCggJzxwPkZpcnN0IHRhYiBwYW5lbDwvcD4nICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggVGFiUGFuZWxPbmVMYXlvdXQsIE9PLnVpLlRhYlBhbmVsTGF5b3V0ICk7XG4gKiAgICAgVGFiUGFuZWxPbmVMYXlvdXQucHJvdG90eXBlLnNldHVwVGFiSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdGhpcy50YWJJdGVtLnNldExhYmVsKCAnVGFiIHBhbmVsIG9uZScgKTtcbiAqICAgICB9O1xuICpcbiAqICAgICB2YXIgdGFiUGFuZWwxID0gbmV3IFRhYlBhbmVsT25lTGF5b3V0KCAnb25lJyApLFxuICogICAgICAgICB0YWJQYW5lbDIgPSBuZXcgT08udWkuVGFiUGFuZWxMYXlvdXQoICd0d28nLCB7IGxhYmVsOiAnVGFiIHBhbmVsIHR3bycgfSApO1xuICpcbiAqICAgICB0YWJQYW5lbDIuJGVsZW1lbnQuYXBwZW5kKCAnPHA+U2Vjb25kIHRhYiBwYW5lbDwvcD4nICk7XG4gKlxuICogICAgIHZhciBpbmRleCA9IG5ldyBPTy51aS5JbmRleExheW91dCgpO1xuICpcbiAqICAgICBpbmRleC5hZGRUYWJQYW5lbHMoIFsgdGFiUGFuZWwxLCB0YWJQYW5lbDIgXSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGluZGV4LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5NZW51TGF5b3V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbY29udGludW91cz1mYWxzZV0gU2hvdyBhbGwgdGFiIHBhbmVscywgb25lIGFmdGVyIGFub3RoZXJcbiAqIEBjZmcge2Jvb2xlYW59IFthdXRvRm9jdXM9dHJ1ZV0gRm9jdXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdoZW4gYSBuZXcgdGFiIHBhbmVsIGlzIGRpc3BsYXllZC4gRGlzYWJsZWQgb24gbW9iaWxlLlxuICovXG5PTy51aS5JbmRleExheW91dCA9IGZ1bmN0aW9uIE9vVWlJbmRleExheW91dCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7IG1lbnVQb3NpdGlvbjogJ3RvcCcgfSApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5JbmRleExheW91dC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmN1cnJlbnRUYWJQYW5lbE5hbWUgPSBudWxsO1xuXHR0aGlzLnRhYlBhbmVscyA9IHt9O1xuXG5cdHRoaXMuaWdub3JlRm9jdXMgPSBmYWxzZTtcblx0dGhpcy5zdGFja0xheW91dCA9IG5ldyBPTy51aS5TdGFja0xheW91dCgge1xuXHRcdGNvbnRpbnVvdXM6ICEhY29uZmlnLmNvbnRpbnVvdXMsXG5cdFx0ZXhwYW5kZWQ6IHRoaXMuZXhwYW5kZWRcblx0fSApO1xuXHR0aGlzLnNldENvbnRlbnRQYW5lbCggdGhpcy5zdGFja0xheW91dCApO1xuXHR0aGlzLmF1dG9Gb2N1cyA9IGNvbmZpZy5hdXRvRm9jdXMgPT09IHVuZGVmaW5lZCB8fCAhIWNvbmZpZy5hdXRvRm9jdXM7XG5cblx0dGhpcy50YWJTZWxlY3RXaWRnZXQgPSBuZXcgT08udWkuVGFiU2VsZWN0V2lkZ2V0KCk7XG5cdHRoaXMudGFiUGFuZWwgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcblx0XHRleHBhbmRlZDogdGhpcy5leHBhbmRlZFxuXHR9ICk7XG5cdHRoaXMuc2V0TWVudVBhbmVsKCB0aGlzLnRhYlBhbmVsICk7XG5cblx0dGhpcy50b2dnbGVNZW51KCB0cnVlICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuc3RhY2tMYXlvdXQuY29ubmVjdCggdGhpcywgeyBzZXQ6ICdvblN0YWNrTGF5b3V0U2V0JyB9ICk7XG5cdHRoaXMudGFiU2VsZWN0V2lkZ2V0LmNvbm5lY3QoIHRoaXMsIHsgc2VsZWN0OiAnb25UYWJTZWxlY3RXaWRnZXRTZWxlY3QnIH0gKTtcblx0aWYgKCB0aGlzLmF1dG9Gb2N1cyApIHtcblx0XHQvLyBFdmVudCAnZm9jdXMnIGRvZXMgbm90IGJ1YmJsZSwgYnV0ICdmb2N1c2luJyBkb2VzXG5cdFx0dGhpcy5zdGFja0xheW91dC4kZWxlbWVudC5vbiggJ2ZvY3VzaW4nLCB0aGlzLm9uU3RhY2tMYXlvdXRGb2N1cy5iaW5kKCB0aGlzICkgKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1pbmRleExheW91dCcgKTtcblx0dGhpcy5zdGFja0xheW91dC4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWluZGV4TGF5b3V0LXN0YWNrTGF5b3V0JyApO1xuXHR0aGlzLnRhYlBhbmVsLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktaW5kZXhMYXlvdXQtdGFiUGFuZWwnIClcblx0XHQuYXBwZW5kKCB0aGlzLnRhYlNlbGVjdFdpZGdldC4kZWxlbWVudCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5JbmRleExheW91dCwgT08udWkuTWVudUxheW91dCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBBICdzZXQnIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiBhIHRhYiBwYW5lbCBpcyB7QGxpbmsgI3NldFRhYlBhbmVsIHNldH0gdG8gYmUgZGlzcGxheWVkIGJ5IHRoZSBpbmRleCBsYXlvdXQuXG4gKiBAZXZlbnQgc2V0XG4gKiBAcGFyYW0ge09PLnVpLlRhYlBhbmVsTGF5b3V0fSB0YWJQYW5lbCBDdXJyZW50IHRhYiBwYW5lbFxuICovXG5cbi8qKlxuICogQW4gJ2FkZCcgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRhYiBwYW5lbHMgYXJlIHtAbGluayAjYWRkVGFiUGFuZWxzIGFkZGVkfSB0byB0aGUgaW5kZXggbGF5b3V0LlxuICpcbiAqIEBldmVudCBhZGRcbiAqIEBwYXJhbSB7T08udWkuVGFiUGFuZWxMYXlvdXRbXX0gdGFiUGFuZWwgQWRkZWQgdGFiIHBhbmVsc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRhYiBwYW5lbHMgd2VyZSBhZGRlZCBhdFxuICovXG5cbi8qKlxuICogQSAncmVtb3ZlJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGFiIHBhbmVscyBhcmUge0BsaW5rICNjbGVhclRhYlBhbmVscyBjbGVhcmVkfSBvclxuICoge0BsaW5rICNyZW1vdmVUYWJQYW5lbHMgcmVtb3ZlZH0gZnJvbSB0aGUgaW5kZXguXG4gKlxuICogQGV2ZW50IHJlbW92ZVxuICogQHBhcmFtIHtPTy51aS5UYWJQYW5lbExheW91dFtdfSB0YWJQYW5lbCBSZW1vdmVkIHRhYiBwYW5lbHNcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIHN0YWNrIGxheW91dCBmb2N1cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgRm9jdXNpbmcgZXZlbnRcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLm9uU3RhY2tMYXlvdXRGb2N1cyA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIG5hbWUsICR0YXJnZXQ7XG5cblx0Ly8gRmluZCB0aGUgdGFiIHBhbmVsIHRoYXQgYW4gZWxlbWVudCB3YXMgZm9jdXNlZCB3aXRoaW5cblx0JHRhcmdldCA9ICQoIGUudGFyZ2V0ICkuY2xvc2VzdCggJy5vby11aS10YWJQYW5lbExheW91dCcgKTtcblx0Zm9yICggbmFtZSBpbiB0aGlzLnRhYlBhbmVscyApIHtcblx0XHQvLyBDaGVjayBmb3IgdGFiIHBhbmVsIG1hdGNoLCBleGNsdWRlIGN1cnJlbnQgdGFiIHBhbmVsIHRvIGZpbmQgb25seSB0YWIgcGFuZWwgY2hhbmdlc1xuXHRcdGlmICggdGhpcy50YWJQYW5lbHNbIG5hbWUgXS4kZWxlbWVudFsgMCBdID09PSAkdGFyZ2V0WyAwIF0gJiYgbmFtZSAhPT0gdGhpcy5jdXJyZW50VGFiUGFuZWxOYW1lICkge1xuXHRcdFx0dGhpcy5zZXRUYWJQYW5lbCggbmFtZSApO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBzdGFjayBsYXlvdXQgc2V0IGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5QYW5lbExheW91dHxudWxsfSB0YWJQYW5lbCBUaGUgdGFiIHBhbmVsIHRoYXQgaXMgbm93IHRoZSBjdXJyZW50IHBhbmVsXG4gKi9cbk9PLnVpLkluZGV4TGF5b3V0LnByb3RvdHlwZS5vblN0YWNrTGF5b3V0U2V0ID0gZnVuY3Rpb24gKCB0YWJQYW5lbCApIHtcblx0Ly8gSWYgZXZlcnl0aGluZyBpcyB1bnNlbGVjdGVkLCBkbyBub3RoaW5nXG5cdGlmICggIXRhYlBhbmVsICkge1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBGb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBvbiB0aGUgbmV3bHkgc2VsZWN0ZWQgcGFuZWxcblx0aWYgKCB0aGlzLmF1dG9Gb2N1cyAmJiAhT08udWkuaXNNb2JpbGUoKSApIHtcblx0XHR0aGlzLmZvY3VzKCk7XG5cdH1cbn07XG5cbi8qKlxuICogRm9jdXMgdGhlIGZpcnN0IGlucHV0IGluIHRoZSBjdXJyZW50IHRhYiBwYW5lbC5cbiAqXG4gKiBJZiBubyB0YWIgcGFuZWwgaXMgc2VsZWN0ZWQsIHRoZSBmaXJzdCBzZWxlY3RhYmxlIHRhYiBwYW5lbCB3aWxsIGJlIHNlbGVjdGVkLlxuICogSWYgdGhlIGZvY3VzIGlzIGFscmVhZHkgaW4gYW4gZWxlbWVudCBvbiB0aGUgY3VycmVudCB0YWIgcGFuZWwsIG5vdGhpbmcgd2lsbCBoYXBwZW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtpdGVtSW5kZXhdIEEgc3BlY2lmaWMgaXRlbSB0byBmb2N1cyBvblxuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoIGl0ZW1JbmRleCApIHtcblx0dmFyIHRhYlBhbmVsLFxuXHRcdGl0ZW1zID0gdGhpcy5zdGFja0xheW91dC5nZXRJdGVtcygpO1xuXG5cdGlmICggaXRlbUluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXRlbXNbIGl0ZW1JbmRleCBdICkge1xuXHRcdHRhYlBhbmVsID0gaXRlbXNbIGl0ZW1JbmRleCBdO1xuXHR9IGVsc2Uge1xuXHRcdHRhYlBhbmVsID0gdGhpcy5zdGFja0xheW91dC5nZXRDdXJyZW50SXRlbSgpO1xuXHR9XG5cblx0aWYgKCAhdGFiUGFuZWwgKSB7XG5cdFx0dGhpcy5zZWxlY3RGaXJzdFNlbGVjdGFibGVUYWJQYW5lbCgpO1xuXHRcdHRhYlBhbmVsID0gdGhpcy5zdGFja0xheW91dC5nZXRDdXJyZW50SXRlbSgpO1xuXHR9XG5cdGlmICggIXRhYlBhbmVsICkge1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBPbmx5IGNoYW5nZSB0aGUgZm9jdXMgaWYgaXMgbm90IGFscmVhZHkgaW4gdGhlIGN1cnJlbnQgcGFnZVxuXHRpZiAoICFPTy51aS5jb250YWlucyggdGFiUGFuZWwuJGVsZW1lbnRbIDAgXSwgdGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hY3RpdmVFbGVtZW50LCB0cnVlICkgKSB7XG5cdFx0dGFiUGFuZWwuZm9jdXMoKTtcblx0fVxufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBmaXJzdCBmb2N1c2FibGUgaW5wdXQgaW4gdGhlIGluZGV4IGxheW91dCBhbmQgZm9jdXNcbiAqIG9uIGl0LlxuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUuZm9jdXNGaXJzdEZvY3VzYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkuZmluZEZvY3VzYWJsZSggdGhpcy5zdGFja0xheW91dC4kZWxlbWVudCApLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0YWIgd2lkZ2V0IHNlbGVjdCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T08udWkuT3B0aW9uV2lkZ2V0fG51bGx9IGl0ZW0gU2VsZWN0ZWQgaXRlbVxuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUub25UYWJTZWxlY3RXaWRnZXRTZWxlY3QgPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdGlmICggaXRlbSApIHtcblx0XHR0aGlzLnNldFRhYlBhbmVsKCBpdGVtLmdldERhdGEoKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGFiIHBhbmVsIGNsb3Nlc3QgdG8gdGhlIHNwZWNpZmllZCB0YWIgcGFuZWwuXG4gKlxuICogQHBhcmFtIHtPTy51aS5UYWJQYW5lbExheW91dH0gdGFiUGFuZWwgVGFiIHBhbmVsIHRvIHVzZSBhcyBhIHJlZmVyZW5jZSBwb2ludFxuICogQHJldHVybiB7T08udWkuVGFiUGFuZWxMYXlvdXR8bnVsbH0gVGFiIHBhbmVsIGNsb3Nlc3QgdG8gdGhlIHNwZWNpZmllZFxuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUuZ2V0Q2xvc2VzdFRhYlBhbmVsID0gZnVuY3Rpb24gKCB0YWJQYW5lbCApIHtcblx0dmFyIG5leHQsIHByZXYsIGxldmVsLFxuXHRcdHRhYlBhbmVscyA9IHRoaXMuc3RhY2tMYXlvdXQuZ2V0SXRlbXMoKSxcblx0XHRpbmRleCA9IHRhYlBhbmVscy5pbmRleE9mKCB0YWJQYW5lbCApO1xuXG5cdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdG5leHQgPSB0YWJQYW5lbHNbIGluZGV4ICsgMSBdO1xuXHRcdHByZXYgPSB0YWJQYW5lbHNbIGluZGV4IC0gMSBdO1xuXHRcdC8vIFByZWZlciBhZGphY2VudCB0YWIgcGFuZWxzIGF0IHRoZSBzYW1lIGxldmVsXG5cdFx0bGV2ZWwgPSB0aGlzLnRhYlNlbGVjdFdpZGdldC5maW5kSXRlbUZyb21EYXRhKCB0YWJQYW5lbC5nZXROYW1lKCkgKS5nZXRMZXZlbCgpO1xuXHRcdGlmIChcblx0XHRcdHByZXYgJiZcblx0XHRcdGxldmVsID09PSB0aGlzLnRhYlNlbGVjdFdpZGdldC5maW5kSXRlbUZyb21EYXRhKCBwcmV2LmdldE5hbWUoKSApLmdldExldmVsKClcblx0XHQpIHtcblx0XHRcdHJldHVybiBwcmV2O1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHRuZXh0ICYmXG5cdFx0XHRsZXZlbCA9PT0gdGhpcy50YWJTZWxlY3RXaWRnZXQuZmluZEl0ZW1Gcm9tRGF0YSggbmV4dC5nZXROYW1lKCkgKS5nZXRMZXZlbCgpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gbmV4dDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHByZXYgfHwgbmV4dCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRhYnMgd2lkZ2V0LlxuICpcbiAqIEByZXR1cm4ge09PLnVpLlRhYlNlbGVjdFdpZGdldH0gVGFicyB3aWRnZXRcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLmdldFRhYnMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnRhYlNlbGVjdFdpZGdldDtcbn07XG5cbi8qKlxuICogR2V0IGEgdGFiIHBhbmVsIGJ5IGl0cyBzeW1ib2xpYyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN5bWJvbGljIG5hbWUgb2YgdGFiIHBhbmVsXG4gKiBAcmV0dXJuIHtPTy51aS5UYWJQYW5lbExheW91dHx1bmRlZmluZWR9IFRhYiBwYW5lbCwgaWYgZm91bmRcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLmdldFRhYlBhbmVsID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXHRyZXR1cm4gdGhpcy50YWJQYW5lbHNbIG5hbWUgXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHRhYiBwYW5lbC5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5UYWJQYW5lbExheW91dHx1bmRlZmluZWR9IEN1cnJlbnQgdGFiIHBhbmVsLCBpZiBmb3VuZFxuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUuZ2V0Q3VycmVudFRhYlBhbmVsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbmFtZSA9IHRoaXMuZ2V0Q3VycmVudFRhYlBhbmVsTmFtZSgpO1xuXHRyZXR1cm4gbmFtZSA/IHRoaXMuZ2V0VGFiUGFuZWwoIG5hbWUgKSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpYyBuYW1lIG9mIHRoZSBjdXJyZW50IHRhYiBwYW5lbC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gU3ltYm9saWMgbmFtZSBvZiB0aGUgY3VycmVudCB0YWIgcGFuZWxcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLmdldEN1cnJlbnRUYWJQYW5lbE5hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmN1cnJlbnRUYWJQYW5lbE5hbWU7XG59O1xuXG4vKipcbiAqIEFkZCB0YWIgcGFuZWxzIHRvIHRoZSBpbmRleCBsYXlvdXRcbiAqXG4gKiBXaGVuIHRhYiBwYW5lbHMgYXJlIGFkZGVkIHdpdGggdGhlIHNhbWUgbmFtZXMgYXMgZXhpc3RpbmcgdGFiIHBhbmVscywgdGhlIGV4aXN0aW5nIHRhYiBwYW5lbHNcbiAqIHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGJlZm9yZSB0aGUgbmV3IHRhYiBwYW5lbHMgYXJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T08udWkuVGFiUGFuZWxMYXlvdXRbXX0gdGFiUGFuZWxzIFRhYiBwYW5lbHMgdG8gYWRkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGluc2VydGlvbiBwb2ludFxuICogQGZpcmVzIGFkZFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQm9va2xldExheW91dH0gVGhlIGxheW91dCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkluZGV4TGF5b3V0LnByb3RvdHlwZS5hZGRUYWJQYW5lbHMgPSBmdW5jdGlvbiAoIHRhYlBhbmVscywgaW5kZXggKSB7XG5cdHZhciBpLCBsZW4sIG5hbWUsIHRhYlBhbmVsLCBpdGVtLCBjdXJyZW50SW5kZXgsXG5cdFx0c3RhY2tMYXlvdXRUYWJQYW5lbHMgPSB0aGlzLnN0YWNrTGF5b3V0LmdldEl0ZW1zKCksXG5cdFx0cmVtb3ZlID0gW10sXG5cdFx0aXRlbXMgPSBbXTtcblxuXHQvLyBSZW1vdmUgdGFiIHBhbmVscyB3aXRoIHNhbWUgbmFtZXNcblx0Zm9yICggaSA9IDAsIGxlbiA9IHRhYlBhbmVscy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR0YWJQYW5lbCA9IHRhYlBhbmVsc1sgaSBdO1xuXHRcdG5hbWUgPSB0YWJQYW5lbC5nZXROYW1lKCk7XG5cblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdGhpcy50YWJQYW5lbHMsIG5hbWUgKSApIHtcblx0XHRcdC8vIENvcnJlY3QgdGhlIGluc2VydGlvbiBpbmRleFxuXHRcdFx0Y3VycmVudEluZGV4ID0gc3RhY2tMYXlvdXRUYWJQYW5lbHMuaW5kZXhPZiggdGhpcy50YWJQYW5lbHNbIG5hbWUgXSApO1xuXHRcdFx0aWYgKCBjdXJyZW50SW5kZXggIT09IC0xICYmIGN1cnJlbnRJbmRleCArIDEgPCBpbmRleCApIHtcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdH1cblx0XHRcdHJlbW92ZS5wdXNoKCB0aGlzLnRhYlBhbmVsc1sgbmFtZSBdICk7XG5cdFx0fVxuXHR9XG5cdGlmICggcmVtb3ZlLmxlbmd0aCApIHtcblx0XHR0aGlzLnJlbW92ZVRhYlBhbmVscyggcmVtb3ZlICk7XG5cdH1cblxuXHQvLyBBZGQgbmV3IHRhYiBwYW5lbHNcblx0Zm9yICggaSA9IDAsIGxlbiA9IHRhYlBhbmVscy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR0YWJQYW5lbCA9IHRhYlBhbmVsc1sgaSBdO1xuXHRcdG5hbWUgPSB0YWJQYW5lbC5nZXROYW1lKCk7XG5cdFx0dGhpcy50YWJQYW5lbHNbIHRhYlBhbmVsLmdldE5hbWUoKSBdID0gdGFiUGFuZWw7XG5cdFx0aXRlbSA9IG5ldyBPTy51aS5UYWJPcHRpb25XaWRnZXQoIHsgZGF0YTogbmFtZSB9ICk7XG5cdFx0dGFiUGFuZWwuc2V0VGFiSXRlbSggaXRlbSApO1xuXHRcdGl0ZW1zLnB1c2goIGl0ZW0gKTtcblx0fVxuXG5cdGlmICggaXRlbXMubGVuZ3RoICkge1xuXHRcdHRoaXMudGFiU2VsZWN0V2lkZ2V0LmFkZEl0ZW1zKCBpdGVtcywgaW5kZXggKTtcblx0XHR0aGlzLnNlbGVjdEZpcnN0U2VsZWN0YWJsZVRhYlBhbmVsKCk7XG5cdH1cblx0dGhpcy5zdGFja0xheW91dC5hZGRJdGVtcyggdGFiUGFuZWxzLCBpbmRleCApO1xuXHR0aGlzLmVtaXQoICdhZGQnLCB0YWJQYW5lbHMsIGluZGV4ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIHRhYiBwYW5lbHMgZnJvbSB0aGUgaW5kZXggbGF5b3V0LlxuICpcbiAqIFRvIHJlbW92ZSBhbGwgdGFiIHBhbmVscyBmcm9tIHRoZSBpbmRleCwgeW91IG1heSB3aXNoIHRvIHVzZSB0aGUgI2NsZWFyVGFiUGFuZWxzIG1ldGhvZCBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7T08udWkuVGFiUGFuZWxMYXlvdXRbXX0gdGFiUGFuZWxzIEFuIGFycmF5IG9mIHRhYiBwYW5lbHMgdG8gcmVtb3ZlXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5Cb29rbGV0TGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLnJlbW92ZVRhYlBhbmVscyA9IGZ1bmN0aW9uICggdGFiUGFuZWxzICkge1xuXHR2YXIgaSwgbGVuLCBuYW1lLCB0YWJQYW5lbCxcblx0XHRpdGVtcyA9IFtdO1xuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSB0YWJQYW5lbHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGFiUGFuZWwgPSB0YWJQYW5lbHNbIGkgXTtcblx0XHRuYW1lID0gdGFiUGFuZWwuZ2V0TmFtZSgpO1xuXHRcdGRlbGV0ZSB0aGlzLnRhYlBhbmVsc1sgbmFtZSBdO1xuXHRcdGl0ZW1zLnB1c2goIHRoaXMudGFiU2VsZWN0V2lkZ2V0LmZpbmRJdGVtRnJvbURhdGEoIG5hbWUgKSApO1xuXHRcdHRhYlBhbmVsLnNldFRhYkl0ZW0oIG51bGwgKTtcblx0fVxuXHRpZiAoIGl0ZW1zLmxlbmd0aCApIHtcblx0XHR0aGlzLnRhYlNlbGVjdFdpZGdldC5yZW1vdmVJdGVtcyggaXRlbXMgKTtcblx0XHR0aGlzLnNlbGVjdEZpcnN0U2VsZWN0YWJsZVRhYlBhbmVsKCk7XG5cdH1cblx0dGhpcy5zdGFja0xheW91dC5yZW1vdmVJdGVtcyggdGFiUGFuZWxzICk7XG5cdHRoaXMuZW1pdCggJ3JlbW92ZScsIHRhYlBhbmVscyApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhciBhbGwgdGFiIHBhbmVscyBmcm9tIHRoZSBpbmRleCBsYXlvdXQuXG4gKlxuICogVG8gcmVtb3ZlIG9ubHkgYSBzdWJzZXQgb2YgdGFiIHBhbmVscyBmcm9tIHRoZSBpbmRleCwgdXNlIHRoZSAjcmVtb3ZlVGFiUGFuZWxzIG1ldGhvZC5cbiAqXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5Cb29rbGV0TGF5b3V0fSBUaGUgbGF5b3V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLmNsZWFyVGFiUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuLFxuXHRcdHRhYlBhbmVscyA9IHRoaXMuc3RhY2tMYXlvdXQuZ2V0SXRlbXMoKTtcblxuXHR0aGlzLnRhYlBhbmVscyA9IHt9O1xuXHR0aGlzLmN1cnJlbnRUYWJQYW5lbE5hbWUgPSBudWxsO1xuXHR0aGlzLnRhYlNlbGVjdFdpZGdldC5jbGVhckl0ZW1zKCk7XG5cdGZvciAoIGkgPSAwLCBsZW4gPSB0YWJQYW5lbHMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGFiUGFuZWxzWyBpIF0uc2V0VGFiSXRlbSggbnVsbCApO1xuXHR9XG5cdHRoaXMuc3RhY2tMYXlvdXQuY2xlYXJJdGVtcygpO1xuXG5cdHRoaXMuZW1pdCggJ3JlbW92ZScsIHRhYlBhbmVscyApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFiIHBhbmVsIGJ5IHN5bWJvbGljIG5hbWUuXG4gKlxuICogQGZpcmVzIHNldFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3ltYm9saWMgbmFtZSBvZiB0YWIgcGFuZWxcbiAqL1xuT08udWkuSW5kZXhMYXlvdXQucHJvdG90eXBlLnNldFRhYlBhbmVsID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXHR2YXIgc2VsZWN0ZWRJdGVtLFxuXHRcdCRmb2N1c2VkLFxuXHRcdHByZXZpb3VzVGFiUGFuZWwsXG5cdFx0dGFiUGFuZWwgPSB0aGlzLnRhYlBhbmVsc1sgbmFtZSBdO1xuXG5cdGlmICggbmFtZSAhPT0gdGhpcy5jdXJyZW50VGFiUGFuZWxOYW1lICkge1xuXHRcdHByZXZpb3VzVGFiUGFuZWwgPSB0aGlzLmdldEN1cnJlbnRUYWJQYW5lbCgpO1xuXHRcdHNlbGVjdGVkSXRlbSA9IHRoaXMudGFiU2VsZWN0V2lkZ2V0LmZpbmRTZWxlY3RlZEl0ZW0oKTtcblx0XHRpZiAoIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uZ2V0RGF0YSgpICE9PSBuYW1lICkge1xuXHRcdFx0dGhpcy50YWJTZWxlY3RXaWRnZXQuc2VsZWN0SXRlbUJ5RGF0YSggbmFtZSApO1xuXHRcdH1cblx0XHRpZiAoIHRhYlBhbmVsICkge1xuXHRcdFx0aWYgKCBwcmV2aW91c1RhYlBhbmVsICkge1xuXHRcdFx0XHRwcmV2aW91c1RhYlBhbmVsLnNldEFjdGl2ZSggZmFsc2UgKTtcblx0XHRcdFx0Ly8gQmx1ciBhbnl0aGluZyBmb2N1c2VkIGlmIHRoZSBuZXh0IHRhYiBwYW5lbCBkb2Vzbid0IGhhdmUgYW55dGhpbmcgZm9jdXNhYmxlLlxuXHRcdFx0XHQvLyBUaGlzIGlzIG5vdCBuZWVkZWQgaWYgdGhlIG5leHQgdGFiIHBhbmVsIGhhcyBzb21ldGhpbmcgZm9jdXNhYmxlIChiZWNhdXNlIG9uY2UgaXQgaXMgZm9jdXNlZFxuXHRcdFx0XHQvLyB0aGlzIGJsdXIgaGFwcGVucyBhdXRvbWF0aWNhbGx5KS4gSWYgdGhlIGxheW91dCBpcyBub24tY29udGludW91cywgdGhpcyBjaGVjayBpc1xuXHRcdFx0XHQvLyBtZWFuaW5nbGVzcyBiZWNhdXNlIHRoZSBuZXh0IHRhYiBwYW5lbCBpcyBub3QgdmlzaWJsZSB5ZXQgYW5kIHRodXMgY2FuJ3QgaG9sZCBmb2N1cy5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuYXV0b0ZvY3VzICYmXG5cdFx0XHRcdFx0IU9PLnVpLmlzTW9iaWxlKCkgJiZcblx0XHRcdFx0XHR0aGlzLnN0YWNrTGF5b3V0LmNvbnRpbnVvdXMgJiZcblx0XHRcdFx0XHRPTy51aS5maW5kRm9jdXNhYmxlKCB0YWJQYW5lbC4kZWxlbWVudCApLmxlbmd0aCAhPT0gMFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQkZm9jdXNlZCA9IHByZXZpb3VzVGFiUGFuZWwuJGVsZW1lbnQuZmluZCggJzpmb2N1cycgKTtcblx0XHRcdFx0XHRpZiAoICRmb2N1c2VkLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqcXVlcnkvbm8tZXZlbnQtc2hvcnRoYW5kXG5cdFx0XHRcdFx0XHQkZm9jdXNlZFsgMCBdLmJsdXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuY3VycmVudFRhYlBhbmVsTmFtZSA9IG5hbWU7XG5cdFx0XHR0YWJQYW5lbC5zZXRBY3RpdmUoIHRydWUgKTtcblx0XHRcdHRoaXMuc3RhY2tMYXlvdXQuc2V0SXRlbSggdGFiUGFuZWwgKTtcblx0XHRcdGlmICggIXRoaXMuc3RhY2tMYXlvdXQuY29udGludW91cyAmJiBwcmV2aW91c1RhYlBhbmVsICkge1xuXHRcdFx0XHQvLyBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5LCBzaW5jZSBhbnkgaW5wdXRzIG9uIHRoZSBwcmV2aW91cyB0YWIgcGFuZWwgc2hvdWxkIGhhdmUgYmVlblxuXHRcdFx0XHQvLyBibHVycmVkIHdoZW4gaXQgd2FzIGhpZGRlbiwgYnV0IGJyb3dzZXJzIGFyZSBub3QgdmVyeSBjb25zaXN0ZW50IGFib3V0IHRoaXMuXG5cdFx0XHRcdCRmb2N1c2VkID0gcHJldmlvdXNUYWJQYW5lbC4kZWxlbWVudC5maW5kKCAnOmZvY3VzJyApO1xuXHRcdFx0XHRpZiAoICRmb2N1c2VkLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganF1ZXJ5L25vLWV2ZW50LXNob3J0aGFuZFxuXHRcdFx0XHRcdCRmb2N1c2VkWyAwIF0uYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoICdzZXQnLCB0YWJQYW5lbCApO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBTZWxlY3QgdGhlIGZpcnN0IHNlbGVjdGFibGUgdGFiIHBhbmVsLlxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkJvb2tsZXRMYXlvdXR9IFRoZSBsYXlvdXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5JbmRleExheW91dC5wcm90b3R5cGUuc2VsZWN0Rmlyc3RTZWxlY3RhYmxlVGFiUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMudGFiU2VsZWN0V2lkZ2V0LmZpbmRTZWxlY3RlZEl0ZW0oKSApIHtcblx0XHR0aGlzLnRhYlNlbGVjdFdpZGdldC5zZWxlY3RJdGVtKCB0aGlzLnRhYlNlbGVjdFdpZGdldC5maW5kRmlyc3RTZWxlY3RhYmxlSXRlbSgpICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlV2lkZ2V0IGltcGxlbWVudHMgYmFzaWMgYmVoYXZpb3Igb2Ygd2lkZ2V0cyB3aXRoIGFuIG9uL29mZiBzdGF0ZS5cbiAqIFBsZWFzZSBzZWUgT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0IGFuZCBPTy51aS5Ub2dnbGVTd2l0Y2hXaWRnZXQgZm9yIGV4YW1wbGVzLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7Ym9vbGVhbn0gW3ZhbHVlPWZhbHNlXSBUaGUgdG9nZ2xl4oCZcyBpbml0aWFsIG9uL29mZiBzdGF0ZS5cbiAqICBCeSBkZWZhdWx0LCB0aGUgdG9nZ2xlIGlzIGluIHRoZSAnb2ZmJyBzdGF0ZS5cbiAqL1xuT08udWkuVG9nZ2xlV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRvZ2dsZVdpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVG9nZ2xlV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvclxuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy52YWx1ZSA9IG51bGw7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXRvZ2dsZVdpZGdldCcgKTtcblx0dGhpcy5zZXRWYWx1ZSggISFjb25maWcudmFsdWUgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9nZ2xlV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRvZ2dsZVdpZGdldCwgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCApO1xuXG4vKiBFdmVudHMgKi9cblxuLyoqXG4gKiBAZXZlbnQgY2hhbmdlXG4gKlxuICogQSBjaGFuZ2UgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBvbi9vZmYgc3RhdGUgb2YgdGhlIHRvZ2dsZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBuZXcgc3RhdGUgb2YgdGhlIHRvZ2dsZVxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdG9nZ2xl4oCZcyBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb24vb2ZmIHN0YXRlIG9mIHRoZSB0b2dnbGVcbiAqL1xuT08udWkuVG9nZ2xlV2lkZ2V0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHRvZ2dsZTogYHRydWVgIGZvciAnb24nLCBgZmFsc2VgIGZvciAnb2ZmJy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFRoZSBzdGF0ZSBvZiB0aGUgdG9nZ2xlXG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5Ub2dnbGVXaWRnZXQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0dmFsdWUgPSAhIXZhbHVlO1xuXHRpZiAoIHRoaXMudmFsdWUgIT09IHZhbHVlICkge1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLmVtaXQoICdjaGFuZ2UnLCB2YWx1ZSApO1xuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS10b2dnbGVXaWRnZXQtb24nLCB2YWx1ZSApO1xuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS10b2dnbGVXaWRnZXQtb2ZmJywgIXZhbHVlICk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZUJ1dHRvbnMgYXJlIGJ1dHRvbnMgdGhhdCBoYXZlIGEgc3RhdGUgKOKAmG9u4oCZIG9yIOKAmG9mZuKAmSkgdGhhdCBpcyByZXByZXNlbnRlZCBieSBhXG4gKiBCb29sZWFuIHZhbHVlLiBMaWtlIG90aGVyIHtAbGluayBPTy51aS5CdXR0b25XaWRnZXQgYnV0dG9uc30sIHRvZ2dsZSBidXR0b25zIGNhbiBiZVxuICogY29uZmlndXJlZCB3aXRoIHtAbGluayBPTy51aS5taXhpbi5JY29uRWxlbWVudCBpY29uc30sIHtAbGluayBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50IGluZGljYXRvcnN9LFxuICoge0BsaW5rIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgdGl0bGVzfSwge0BsaW5rIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50IHN0eWxpbmcgZmxhZ3N9LFxuICogYW5kIHtAbGluayBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgbGFiZWxzfS4gUGxlYXNlIHNlZVxuICogdGhlIFtPT1VJIGRvY3VtZW50YXRpb25dWzFdIG9uIE1lZGlhV2lraSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBUb2dnbGUgYnV0dG9ucyBpbiB0aGUgJ29mZicgYW5kICdvbicgc3RhdGUuXG4gKiAgICAgdmFyIHRvZ2dsZUJ1dHRvbjEgPSBuZXcgT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1RvZ2dsZSBCdXR0b24gb2ZmJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIHRvZ2dsZUJ1dHRvbjIgPSBuZXcgT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBsYWJlbDogJ1RvZ2dsZSBCdXR0b24gb24nLFxuICogICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAqICAgICAgICAgfSApO1xuICogICAgIC8vIEFwcGVuZCB0aGUgYnV0dG9ucyB0byB0aGUgRE9NLlxuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHRvZ2dsZUJ1dHRvbjEuJGVsZW1lbnQsIHRvZ2dsZUJ1dHRvbjIuJGVsZW1lbnQgKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvQnV0dG9uc19hbmRfU3dpdGNoZXMjVG9nZ2xlX2J1dHRvbnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLlRvZ2dsZVdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5CdXR0b25FbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkljb25FbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uTGFiZWxFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtib29sZWFufSBbdmFsdWU9ZmFsc2VdIFRoZSB0b2dnbGUgYnV0dG9u4oCZcyBpbml0aWFsIG9uL29mZlxuICogIHN0YXRlLiBCeSBkZWZhdWx0LCB0aGUgYnV0dG9uIGlzIGluIHRoZSAnb2ZmJyBzdGF0ZS5cbiAqL1xuT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRvZ2dsZUJ1dHRvbldpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uQnV0dG9uRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyBhY3RpdmU6IHRoaXMuYWN0aXZlIH0gKSApO1xuXHRPTy51aS5taXhpbi5JY29uRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uTGFiZWxFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRhYkluZGV4ZWQ6IHRoaXMuJGJ1dHRvbiB9ICkgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5jb25uZWN0KCB0aGlzLCB7IGNsaWNrOiAnb25BY3Rpb24nIH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRidXR0b24uYXBwZW5kKCB0aGlzLiRpY29uLCB0aGlzLiRsYWJlbCwgdGhpcy4kaW5kaWNhdG9yICk7XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS10b2dnbGVCdXR0b25XaWRnZXQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRidXR0b24gKTtcblx0dGhpcy5zZXRUaXRsZWRFbGVtZW50KCB0aGlzLiRidXR0b24gKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LCBPTy51aS5Ub2dnbGVXaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRvZ2dsZUJ1dHRvbldpZGdldCwgT08udWkubWl4aW4uQnV0dG9uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Ub2dnbGVCdXR0b25XaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlRvZ2dsZUJ1dHRvbldpZGdldC5zdGF0aWMudGFnTmFtZSA9ICdzcGFuJztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgYnV0dG9uIGFjdGlvbiBiZWluZyB0cmlnZ2VyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZXRWYWx1ZSggIXRoaXMudmFsdWUgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdHZhbHVlID0gISF2YWx1ZTtcblx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHQvLyBNaWdodCBiZSBjYWxsZWQgZnJvbSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIEJ1dHRvbkVsZW1lbnQgY29uc3RydWN0b3Jcblx0XHRpZiAoIHRoaXMuJGJ1dHRvbiApIHtcblx0XHRcdHRoaXMuJGJ1dHRvbi5hdHRyKCAnYXJpYS1wcmVzc2VkJywgdmFsdWUudG9TdHJpbmcoKSApO1xuXHRcdH1cblx0XHR0aGlzLnNldEFjdGl2ZSggdmFsdWUgKTtcblx0fVxuXG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCggdGhpcywgdmFsdWUgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVG9nZ2xlQnV0dG9uV2lkZ2V0LnByb3RvdHlwZS5zZXRCdXR0b25FbGVtZW50ID0gZnVuY3Rpb24gKCAkYnV0dG9uICkge1xuXHRpZiAoIHRoaXMuJGJ1dHRvbiApIHtcblx0XHR0aGlzLiRidXR0b24ucmVtb3ZlQXR0ciggJ2FyaWEtcHJlc3NlZCcgKTtcblx0fVxuXHRPTy51aS5taXhpbi5CdXR0b25FbGVtZW50LnByb3RvdHlwZS5zZXRCdXR0b25FbGVtZW50LmNhbGwoIHRoaXMsICRidXR0b24gKTtcblx0dGhpcy4kYnV0dG9uLmF0dHIoICdhcmlhLXByZXNzZWQnLCB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlU3dpdGNoZXMgYXJlIHN3aXRjaGVzIHRoYXQgc2xpZGUgb24gYW5kIG9mZi4gVGhlaXIgc3RhdGUgaXMgcmVwcmVzZW50ZWQgYnkgYSBCb29sZWFuXG4gKiB2YWx1ZSAoYHRydWVgIGZvciDigJhvbuKAmSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCkuIFRoZSDigJhvZmbigJkgc3RhdGUgaXMgcmVwcmVzZW50ZWRcbiAqIHZpc3VhbGx5IGJ5IGEgc2xpZGVyIGluIHRoZSBsZWZ0bW9zdCBwb3NpdGlvbi5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBUb2dnbGUgc3dpdGNoZXMgaW4gdGhlICdvZmYnIGFuZCAnb24nIHBvc2l0aW9uLlxuICogICAgIHZhciB0b2dnbGVTd2l0Y2gxID0gbmV3IE9PLnVpLlRvZ2dsZVN3aXRjaFdpZGdldCgpLFxuICogICAgICAgICB0b2dnbGVTd2l0Y2gyID0gbmV3IE9PLnVpLlRvZ2dsZVN3aXRjaFdpZGdldCgge1xuICogICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAqICAgICAgICAgfSApO1xuICogICAgICAgICAvLyBDcmVhdGUgYSBGaWVsZHNldExheW91dCB0byBsYXlvdXQgYW5kIGxhYmVsIHN3aXRjaGVzLlxuICogICAgICAgICBmaWVsZHNldCA9IG5ldyBPTy51aS5GaWVsZHNldExheW91dCgge1xuICogICAgICAgICAgICAgbGFiZWw6ICdUb2dnbGUgc3dpdGNoZXMnXG4gKiAgICAgICAgIH0gKTtcbiAqICAgICBmaWVsZHNldC5hZGRJdGVtcyggW1xuICogICAgICAgICBuZXcgT08udWkuRmllbGRMYXlvdXQoIHRvZ2dsZVN3aXRjaDEsIHtcbiAqICAgICAgICAgICAgIGxhYmVsOiAnT2ZmJyxcbiAqICAgICAgICAgICAgIGFsaWduOiAndG9wJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIG5ldyBPTy51aS5GaWVsZExheW91dCggdG9nZ2xlU3dpdGNoMiwge1xuICogICAgICAgICAgICAgbGFiZWw6ICdPbicsXG4gKiAgICAgICAgICAgICBhbGlnbjogJ3RvcCdcbiAqICAgICAgICAgfSApXG4gKiAgICAgXSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGZpZWxkc2V0LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5Ub2dnbGVXaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge2Jvb2xlYW59IFt2YWx1ZT1mYWxzZV0gVGhlIHRvZ2dsZSBzd2l0Y2jigJlzIGluaXRpYWwgb24vb2ZmIHN0YXRlLlxuICogIEJ5IGRlZmF1bHQsIHRoZSB0b2dnbGUgc3dpdGNoIGlzIGluIHRoZSAnb2ZmJyBwb3NpdGlvbi5cbiAqL1xuT08udWkuVG9nZ2xlU3dpdGNoV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRvZ2dsZVN3aXRjaFdpZGdldCggY29uZmlnICkge1xuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVG9nZ2xlU3dpdGNoV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdHRoaXMuZHJhZ1N0YXJ0ID0gbnVsbDtcblx0dGhpcy5zbGlkaW5nID0gZmFsc2U7XG5cdHRoaXMuJGdsb3cgPSAkKCAnPHNwYW4+JyApO1xuXHR0aGlzLiRncmlwID0gJCggJzxzcGFuPicgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kZWxlbWVudC5vbigge1xuXHRcdGNsaWNrOiB0aGlzLm9uQ2xpY2suYmluZCggdGhpcyApLFxuXHRcdGtleXByZXNzOiB0aGlzLm9uS2V5UHJlc3MuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRnbG93LmFkZENsYXNzKCAnb28tdWktdG9nZ2xlU3dpdGNoV2lkZ2V0LWdsb3cnICk7XG5cdHRoaXMuJGdyaXAuYWRkQ2xhc3MoICdvby11aS10b2dnbGVTd2l0Y2hXaWRnZXQtZ3JpcCcgKTtcblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRvZ2dsZVN3aXRjaFdpZGdldCcgKVxuXHRcdC5hdHRyKCAncm9sZScsICdjaGVja2JveCcgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGdsb3csIHRoaXMuJGdyaXAgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9nZ2xlU3dpdGNoV2lkZ2V0LCBPTy51aS5Ub2dnbGVXaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRvZ2dsZVN3aXRjaFdpZGdldCwgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSBjbGljayBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGNsaWNrIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuVG9nZ2xlU3dpdGNoV2lkZ2V0LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSAmJiBlLndoaWNoID09PSBPTy51aS5Nb3VzZUJ1dHRvbnMuTEVGVCApIHtcblx0XHR0aGlzLnNldFZhbHVlKCAhdGhpcy52YWx1ZSApO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGtleSBwcmVzcyBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBwcmVzcyBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLlRvZ2dsZVN3aXRjaFdpZGdldC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgKCBlLndoaWNoID09PSBPTy51aS5LZXlzLlNQQUNFIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuRU5URVIgKSApIHtcblx0XHR0aGlzLnNldFZhbHVlKCAhdGhpcy52YWx1ZSApO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Ub2dnbGVTd2l0Y2hXaWRnZXQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0T08udWkuVG9nZ2xlU3dpdGNoV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCggdGhpcywgdmFsdWUgKTtcblx0dGhpcy4kZWxlbWVudC5hdHRyKCAnYXJpYS1jaGVja2VkJywgdGhpcy52YWx1ZS50b1N0cmluZygpICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Ub2dnbGVTd2l0Y2hXaWRnZXQucHJvdG90eXBlLnNpbXVsYXRlTGFiZWxDbGljayA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0dGhpcy5zZXRWYWx1ZSggIXRoaXMudmFsdWUgKTtcblx0fVxuXHR0aGlzLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIE91dGxpbmVDb250cm9sc1dpZGdldCBpcyBhIHNldCBvZiBjb250cm9scyBmb3IgYW4ge0BsaW5rIE9PLnVpLk91dGxpbmVTZWxlY3RXaWRnZXQgb3V0bGluZSBzZWxlY3Qgd2lkZ2V0fS5cbiAqIENvbnRyb2xzIGluY2x1ZGUgbW92aW5nIGl0ZW1zIHVwIGFuZCBkb3duLCByZW1vdmluZyBpdGVtcywgYW5kIGFkZGluZyBkaWZmZXJlbnQga2luZHMgb2YgaXRlbXMuXG4gKlxuICogKipDdXJyZW50bHksIHRoaXMgY2xhc3MgaXMgb25seSB1c2VkIGJ5IHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IGJvb2tsZXQgbGF5b3V0c30uKipcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T08udWkuT3V0bGluZVNlbGVjdFdpZGdldH0gb3V0bGluZSBPdXRsaW5lIHRvIGNvbnRyb2xcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge09iamVjdH0gW2FiaWxpdGllc10gTGlzdCBvZiBhYmlsdGllc1xuICogQGNmZyB7Ym9vbGVhbn0gW2FiaWxpdGllcy5tb3ZlPXRydWVdIEFsbG93IG1vdmluZyBtb3ZhYmxlIGl0ZW1zXG4gKiBAY2ZnIHtib29sZWFufSBbYWJpbGl0aWVzLnJlbW92ZT10cnVlXSBBbGxvdyByZW1vdmluZyByZW1vdmFibGUgaXRlbXNcbiAqL1xuT08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0ID0gZnVuY3Rpb24gT29VaU91dGxpbmVDb250cm9sc1dpZGdldCggb3V0bGluZSwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCBvdXRsaW5lICkgJiYgY29uZmlnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Y29uZmlnID0gb3V0bGluZTtcblx0XHRvdXRsaW5lID0gY29uZmlnLm91dGxpbmU7XG5cdH1cblxuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uR3JvdXBFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5vdXRsaW5lID0gb3V0bGluZTtcblx0dGhpcy4kbW92ZXJzID0gJCggJzxkaXY+JyApO1xuXHR0aGlzLnVwQnV0dG9uID0gbmV3IE9PLnVpLkJ1dHRvbldpZGdldCgge1xuXHRcdGZyYW1lZDogZmFsc2UsXG5cdFx0aWNvbjogJ2NvbGxhcHNlJyxcblx0XHR0aXRsZTogT08udWkubXNnKCAnb291aS1vdXRsaW5lLWNvbnRyb2wtbW92ZS11cCcgKVxuXHR9ICk7XG5cdHRoaXMuZG93bkJ1dHRvbiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcblx0XHRmcmFtZWQ6IGZhbHNlLFxuXHRcdGljb246ICdleHBhbmQnLFxuXHRcdHRpdGxlOiBPTy51aS5tc2coICdvb3VpLW91dGxpbmUtY29udHJvbC1tb3ZlLWRvd24nIClcblx0fSApO1xuXHR0aGlzLnJlbW92ZUJ1dHRvbiA9IG5ldyBPTy51aS5CdXR0b25XaWRnZXQoIHtcblx0XHRmcmFtZWQ6IGZhbHNlLFxuXHRcdGljb246ICd0cmFzaCcsXG5cdFx0dGl0bGU6IE9PLnVpLm1zZyggJ29vdWktb3V0bGluZS1jb250cm9sLXJlbW92ZScgKVxuXHR9ICk7XG5cdHRoaXMuYWJpbGl0aWVzID0geyBtb3ZlOiB0cnVlLCByZW1vdmU6IHRydWUgfTtcblxuXHQvLyBFdmVudHNcblx0b3V0bGluZS5jb25uZWN0KCB0aGlzLCB7XG5cdFx0c2VsZWN0OiAnb25PdXRsaW5lQ2hhbmdlJyxcblx0XHRhZGQ6ICdvbk91dGxpbmVDaGFuZ2UnLFxuXHRcdHJlbW92ZTogJ29uT3V0bGluZUNoYW5nZSdcblx0fSApO1xuXHR0aGlzLnVwQnV0dG9uLmNvbm5lY3QoIHRoaXMsIHsgY2xpY2s6IFsgJ2VtaXQnLCAnbW92ZScsIC0xIF0gfSApO1xuXHR0aGlzLmRvd25CdXR0b24uY29ubmVjdCggdGhpcywgeyBjbGljazogWyAnZW1pdCcsICdtb3ZlJywgMSBdIH0gKTtcblx0dGhpcy5yZW1vdmVCdXR0b24uY29ubmVjdCggdGhpcywgeyBjbGljazogWyAnZW1pdCcsICdyZW1vdmUnIF0gfSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1vdXRsaW5lQ29udHJvbHNXaWRnZXQnICk7XG5cdHRoaXMuJGdyb3VwLmFkZENsYXNzKCAnb28tdWktb3V0bGluZUNvbnRyb2xzV2lkZ2V0LWl0ZW1zJyApO1xuXHR0aGlzLiRtb3ZlcnNcblx0XHQuYWRkQ2xhc3MoICdvby11aS1vdXRsaW5lQ29udHJvbHNXaWRnZXQtbW92ZXJzJyApXG5cdFx0LmFwcGVuZCggdGhpcy5yZW1vdmVCdXR0b24uJGVsZW1lbnQsIHRoaXMudXBCdXR0b24uJGVsZW1lbnQsIHRoaXMuZG93bkJ1dHRvbi4kZWxlbWVudCApO1xuXHR0aGlzLiRlbGVtZW50LmFwcGVuZCggdGhpcy4kaWNvbiwgdGhpcy4kZ3JvdXAsIHRoaXMuJG1vdmVycyApO1xuXHR0aGlzLnNldEFiaWxpdGllcyggY29uZmlnLmFiaWxpdGllcyB8fCB7fSApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5PdXRsaW5lQ29udHJvbHNXaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0LCBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IG1vdmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwbGFjZXMgTnVtYmVyIG9mIHBsYWNlcyB0byBtb3ZlXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgcmVtb3ZlXG4gKi9cblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFNldCBhYmlsaXRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFiaWxpdGllcyBMaXN0IG9mIGFiaWx0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthYmlsaXRpZXMubW92ZV0gQWxsb3cgbW92aW5nIG1vdmFibGUgaXRlbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FiaWxpdGllcy5yZW1vdmVdIEFsbG93IHJlbW92aW5nIHJlbW92YWJsZSBpdGVtc1xuICovXG5PTy51aS5PdXRsaW5lQ29udHJvbHNXaWRnZXQucHJvdG90eXBlLnNldEFiaWxpdGllcyA9IGZ1bmN0aW9uICggYWJpbGl0aWVzICkge1xuXHR2YXIgYWJpbGl0eTtcblxuXHRmb3IgKCBhYmlsaXR5IGluIHRoaXMuYWJpbGl0aWVzICkge1xuXHRcdGlmICggYWJpbGl0aWVzWyBhYmlsaXR5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuYWJpbGl0aWVzWyBhYmlsaXR5IF0gPSAhIWFiaWxpdGllc1sgYWJpbGl0eSBdO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMub25PdXRsaW5lQ2hhbmdlKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBvdXRsaW5lIGNoYW5nZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0LnByb3RvdHlwZS5vbk91dGxpbmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpLCBsZW4sIGZpcnN0TW92YWJsZSwgbGFzdE1vdmFibGUsXG5cdFx0aXRlbXMgPSB0aGlzLm91dGxpbmUuZ2V0SXRlbXMoKSxcblx0XHRzZWxlY3RlZEl0ZW0gPSB0aGlzLm91dGxpbmUuZmluZFNlbGVjdGVkSXRlbSgpLFxuXHRcdG1vdmFibGUgPSB0aGlzLmFiaWxpdGllcy5tb3ZlICYmIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uaXNNb3ZhYmxlKCksXG5cdFx0cmVtb3ZhYmxlID0gdGhpcy5hYmlsaXRpZXMucmVtb3ZlICYmIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uaXNSZW1vdmFibGUoKTtcblxuXHRpZiAoIG1vdmFibGUgKSB7XG5cdFx0aSA9IC0xO1xuXHRcdGxlbiA9IGl0ZW1zLmxlbmd0aDtcblx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcblx0XHRcdGlmICggaXRlbXNbIGkgXS5pc01vdmFibGUoKSApIHtcblx0XHRcdFx0Zmlyc3RNb3ZhYmxlID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGkgPSBsZW47XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRpZiAoIGl0ZW1zWyBpIF0uaXNNb3ZhYmxlKCkgKSB7XG5cdFx0XHRcdGxhc3RNb3ZhYmxlID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRoaXMudXBCdXR0b24uc2V0RGlzYWJsZWQoICFtb3ZhYmxlIHx8IHNlbGVjdGVkSXRlbSA9PT0gZmlyc3RNb3ZhYmxlICk7XG5cdHRoaXMuZG93bkJ1dHRvbi5zZXREaXNhYmxlZCggIW1vdmFibGUgfHwgc2VsZWN0ZWRJdGVtID09PSBsYXN0TW92YWJsZSApO1xuXHR0aGlzLnJlbW92ZUJ1dHRvbi5zZXREaXNhYmxlZCggIXJlbW92YWJsZSApO1xufTtcblxuLyoqXG4gKiBPdXRsaW5lT3B0aW9uV2lkZ2V0IGlzIGFuIGl0ZW0gaW4gYW4ge0BsaW5rIE9PLnVpLk91dGxpbmVTZWxlY3RXaWRnZXQgT3V0bGluZVNlbGVjdFdpZGdldH0uXG4gKlxuICogQ3VycmVudGx5LCB0aGlzIGNsYXNzIGlzIG9ubHkgdXNlZCBieSB7QGxpbmsgT08udWkuQm9va2xldExheW91dCBib29rbGV0IGxheW91dHN9LCB3aGljaCBjb250YWluXG4gKiB7QGxpbmsgT08udWkuUGFnZUxheW91dCBwYWdlIGxheW91dHN9LiBTZWUge0BsaW5rIE9PLnVpLkJvb2tsZXRMYXlvdXQgQm9va2xldExheW91dH1cbiAqIGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuRGVjb3JhdGVkT3B0aW9uV2lkZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtudW1iZXJ9IFtsZXZlbF0gSW5kZW50YXRpb24gbGV2ZWxcbiAqIEBjZmcge2Jvb2xlYW59IFttb3ZhYmxlXSBBbGxvdyBtb2RpZmljYXRpb24gZnJvbSB7QGxpbmsgT08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0IG91dGxpbmUgY29udHJvbHN9LlxuICovXG5PTy51aS5PdXRsaW5lT3B0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gT29VaU91dGxpbmVPcHRpb25XaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5sZXZlbCA9IDA7XG5cdHRoaXMubW92YWJsZSA9ICEhY29uZmlnLm1vdmFibGU7XG5cdHRoaXMucmVtb3ZhYmxlID0gISFjb25maWcucmVtb3ZhYmxlO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1vdXRsaW5lT3B0aW9uV2lkZ2V0JyApO1xuXHR0aGlzLnNldExldmVsKCBjb25maWcubGV2ZWwgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuT3V0bGluZU9wdGlvbldpZGdldCwgT08udWkuRGVjb3JhdGVkT3B0aW9uV2lkZ2V0ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5zdGF0aWMuaGlnaGxpZ2h0YWJsZSA9IHRydWU7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5zdGF0aWMuc2Nyb2xsSW50b1ZpZXdPblNlbGVjdCA9IHRydWU7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ31cbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5zdGF0aWMubGV2ZWxDbGFzcyA9ICdvby11aS1vdXRsaW5lT3B0aW9uV2lkZ2V0LWxldmVsLSc7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5zdGF0aWMubGV2ZWxzID0gMztcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGl0ZW0gaXMgbW92YWJsZS5cbiAqXG4gKiBNb3ZhYmlsaXR5IGlzIHVzZWQgYnkge0BsaW5rIE9PLnVpLk91dGxpbmVDb250cm9sc1dpZGdldCBvdXRsaW5lIGNvbnRyb2xzfS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBJdGVtIGlzIG1vdmFibGVcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5wcm90b3R5cGUuaXNNb3ZhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5tb3ZhYmxlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdGVtIGlzIHJlbW92YWJsZS5cbiAqXG4gKiBSZW1vdmFiaWxpdHkgaXMgdXNlZCBieSB7QGxpbmsgT08udWkuT3V0bGluZUNvbnRyb2xzV2lkZ2V0IG91dGxpbmUgY29udHJvbHN9LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEl0ZW0gaXMgcmVtb3ZhYmxlXG4gKi9cbk9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQucHJvdG90eXBlLmlzUmVtb3ZhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5yZW1vdmFibGU7XG59O1xuXG4vKipcbiAqIEdldCBpbmRlbnRhdGlvbiBsZXZlbC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEluZGVudGF0aW9uIGxldmVsXG4gKi9cbk9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQucHJvdG90eXBlLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5sZXZlbDtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0UHJlc3NlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXRQcmVzc2VkLmNhbGwoIHRoaXMsIHN0YXRlICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbW92YWJpbGl0eS5cbiAqXG4gKiBNb3ZhYmlsaXR5IGlzIHVzZWQgYnkge0BsaW5rIE9PLnVpLk91dGxpbmVDb250cm9sc1dpZGdldCBvdXRsaW5lIGNvbnRyb2xzfS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1vdmFibGUgSXRlbSBpcyBtb3ZhYmxlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5PdXRsaW5lT3B0aW9uV2lkZ2V0LnByb3RvdHlwZS5zZXRNb3ZhYmxlID0gZnVuY3Rpb24gKCBtb3ZhYmxlICkge1xuXHR0aGlzLm1vdmFibGUgPSAhIW1vdmFibGU7XG5cdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgcmVtb3ZhYmlsaXR5LlxuICpcbiAqIFJlbW92YWJpbGl0eSBpcyB1c2VkIGJ5IHtAbGluayBPTy51aS5PdXRsaW5lQ29udHJvbHNXaWRnZXQgb3V0bGluZSBjb250cm9sc30uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmFibGUgSXRlbSBpcyByZW1vdmFibGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpZGdldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQucHJvdG90eXBlLnNldFJlbW92YWJsZSA9IGZ1bmN0aW9uICggcmVtb3ZhYmxlICkge1xuXHR0aGlzLnJlbW92YWJsZSA9ICEhcmVtb3ZhYmxlO1xuXHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRPTy51aS5PdXRsaW5lT3B0aW9uV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBpbmRlbnRhdGlvbiBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdIEluZGVudGF0aW9uIGxldmVsLCBpbiB0aGUgcmFuZ2Ugb2YgWzAsI21heExldmVsXVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuT3V0bGluZU9wdGlvbldpZGdldC5wcm90b3R5cGUuc2V0TGV2ZWwgPSBmdW5jdGlvbiAoIGxldmVsICkge1xuXHR2YXIgbGV2ZWxzID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMubGV2ZWxzLFxuXHRcdGxldmVsQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5sZXZlbENsYXNzLFxuXHRcdGkgPSBsZXZlbHM7XG5cblx0dGhpcy5sZXZlbCA9IGxldmVsID8gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBsZXZlbHMgLSAxLCBsZXZlbCApICkgOiAwO1xuXHR3aGlsZSAoIGktLSApIHtcblx0XHRpZiAoIHRoaXMubGV2ZWwgPT09IGkgKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCBsZXZlbENsYXNzICsgaSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCBsZXZlbENsYXNzICsgaSApO1xuXHRcdH1cblx0fVxuXHR0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NlcygpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdXRsaW5lU2VsZWN0V2lkZ2V0IGlzIGEgc3RydWN0dXJlZCBsaXN0IHRoYXQgY29udGFpbnMge0BsaW5rIE9PLnVpLk91dGxpbmVPcHRpb25XaWRnZXQgb3V0bGluZSBvcHRpb25zfVxuICogQSBzZXQgb2YgY29udHJvbHMgY2FuIGJlIHByb3ZpZGVkIHdpdGggYW4ge0BsaW5rIE9PLnVpLk91dGxpbmVDb250cm9sc1dpZGdldCBvdXRsaW5lIGNvbnRyb2xzfSB3aWRnZXQuXG4gKlxuICogKipDdXJyZW50bHksIHRoaXMgY2xhc3MgaXMgb25seSB1c2VkIGJ5IHtAbGluayBPTy51aS5Cb29rbGV0TGF5b3V0IGJvb2tsZXQgbGF5b3V0c30uKipcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLlNlbGVjdFdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5PdXRsaW5lU2VsZWN0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaU91dGxpbmVTZWxlY3RXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLk91dGxpbmVTZWxlY3RXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kZWxlbWVudC5vbigge1xuXHRcdGZvY3VzOiB0aGlzLmJpbmREb2N1bWVudEtleURvd25MaXN0ZW5lci5iaW5kKCB0aGlzICksXG5cdFx0Ymx1cjogdGhpcy51bmJpbmREb2N1bWVudEtleURvd25MaXN0ZW5lci5iaW5kKCB0aGlzIClcblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1vdXRsaW5lU2VsZWN0V2lkZ2V0JyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5PdXRsaW5lU2VsZWN0V2lkZ2V0LCBPTy51aS5TZWxlY3RXaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLk91dGxpbmVTZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5cbi8qKlxuICogQnV0dG9uT3B0aW9uV2lkZ2V0IGlzIGEgc3BlY2lhbCB0eXBlIG9mIHtAbGluayBPTy51aS5taXhpbi5CdXR0b25FbGVtZW50IGJ1dHRvbiBlbGVtZW50fSB0aGF0XG4gKiBjYW4gYmUgc2VsZWN0ZWQgYW5kIGNvbmZpZ3VyZWQgd2l0aCBkYXRhLiBUaGUgY2xhc3MgaXNcbiAqIHVzZWQgd2l0aCBPTy51aS5CdXR0b25TZWxlY3RXaWRnZXQgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIG9mIGJ1dHRvbiBvcHRpb25zLiBQbGVhc2Ugc2VlIHRoZVxuICogW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpZGdldHMvU2VsZWN0c19hbmRfT3B0aW9ucyNCdXR0b25fc2VsZWN0c19hbmRfb3B0aW9uc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuT3B0aW9uV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkJ1dHRvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSWNvbkVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5CdXR0b25PcHRpb25XaWRnZXQgPSBmdW5jdGlvbiBPb1VpQnV0dG9uT3B0aW9uV2lkZ2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5CdXR0b25PcHRpb25XaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5CdXR0b25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5JY29uRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYnV0dG9uT3B0aW9uV2lkZ2V0JyApO1xuXHR0aGlzLiRidXR0b24uYXBwZW5kKCB0aGlzLiRpY29uLCB0aGlzLiRsYWJlbCwgdGhpcy4kaW5kaWNhdG9yICk7XG5cdHRoaXMuJGVsZW1lbnQuYXBwZW5kKCB0aGlzLiRidXR0b24gKTtcblx0dGhpcy5zZXRUaXRsZWRFbGVtZW50KCB0aGlzLiRidXR0b24gKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0LCBPTy51aS5PcHRpb25XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLkJ1dHRvbk9wdGlvbldpZGdldCwgT08udWkubWl4aW4uQnV0dG9uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0LCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0LCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQWxsb3cgYnV0dG9uIG1vdXNlIGRvd24gZXZlbnRzIHRvIHBhc3MgdGhyb3VnaCBzbyB0aGV5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBwYXJlbnQgc2VsZWN0IHdpZGdldFxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkJ1dHRvbk9wdGlvbldpZGdldC5zdGF0aWMuY2FuY2VsQnV0dG9uTW91c2VEb3duRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0LnN0YXRpYy5oaWdobGlnaHRhYmxlID0gZmFsc2U7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CdXR0b25PcHRpb25XaWRnZXQucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKCBzdGF0ZSApIHtcblx0T08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQuY2FsbCggdGhpcywgc3RhdGUgKTtcblxuXHRpZiAoIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLnNlbGVjdGFibGUgKSB7XG5cdFx0dGhpcy5zZXRBY3RpdmUoIHN0YXRlICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQnV0dG9uU2VsZWN0V2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLlNlbGVjdFdpZGdldCBzZWxlY3Qgd2lkZ2V0fSB0aGF0IGNvbnRhaW5zXG4gKiBidXR0b24gb3B0aW9ucyBhbmQgaXMgdXNlZCB0b2dldGhlciB3aXRoXG4gKiBPTy51aS5CdXR0b25PcHRpb25XaWRnZXQuIFRoZSBCdXR0b25TZWxlY3RXaWRnZXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvclxuICogaGlnaGxpZ2h0aW5nLCBjaG9vc2luZywgYW5kIHNlbGVjdGluZyBtdXR1YWxseSBleGNsdXNpdmUgb3B0aW9ucy4gUGxlYXNlIHNlZVxuICogdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBCdXR0b25TZWxlY3RXaWRnZXQgdGhhdCBjb250YWlucyB0aHJlZSBCdXR0b25PcHRpb25XaWRnZXRzLlxuICogICAgIHZhciBvcHRpb24xID0gbmV3IE9PLnVpLkJ1dHRvbk9wdGlvbldpZGdldCgge1xuICogICAgICAgICAgICAgZGF0YTogMSxcbiAqICAgICAgICAgICAgIGxhYmVsOiAnT3B0aW9uIDEnLFxuICogICAgICAgICAgICAgdGl0bGU6ICdCdXR0b24gb3B0aW9uIDEnXG4gKiAgICAgICAgIH0gKSxcbiAqICAgICAgICAgb3B0aW9uMiA9IG5ldyBPTy51aS5CdXR0b25PcHRpb25XaWRnZXQoIHtcbiAqICAgICAgICAgICAgIGRhdGE6IDIsXG4gKiAgICAgICAgICAgICBsYWJlbDogJ09wdGlvbiAyJyxcbiAqICAgICAgICAgICAgIHRpdGxlOiAnQnV0dG9uIG9wdGlvbiAyJ1xuICogICAgICAgICB9ICksXG4gKiAgICAgICAgIG9wdGlvbjMgPSBuZXcgT08udWkuQnV0dG9uT3B0aW9uV2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBkYXRhOiAzLFxuICogICAgICAgICAgICAgbGFiZWw6ICdPcHRpb24gMycsXG4gKiAgICAgICAgICAgICB0aXRsZTogJ0J1dHRvbiBvcHRpb24gMydcbiAqICAgICAgICAgfSApLFxuICogICAgICAgICBidXR0b25TZWxlY3QgPSBuZXcgT08udWkuQnV0dG9uU2VsZWN0V2lkZ2V0KCB7XG4gKiAgICAgICAgICAgICBpdGVtczogWyBvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zIF1cbiAqICAgICAgICAgfSApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGJ1dHRvblNlbGVjdC4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0cy9TZWxlY3RzX2FuZF9PcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5TZWxlY3RXaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuQnV0dG9uU2VsZWN0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaUJ1dHRvblNlbGVjdFdpZGdldCggY29uZmlnICkge1xuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuQnV0dG9uU2VsZWN0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGVsZW1lbnQub24oIHtcblx0XHRmb2N1czogdGhpcy5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApLFxuXHRcdGJsdXI6IHRoaXMudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYnV0dG9uU2VsZWN0V2lkZ2V0JyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5CdXR0b25TZWxlY3RXaWRnZXQsIE9PLnVpLlNlbGVjdFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuQnV0dG9uU2VsZWN0V2lkZ2V0LCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuXG4vKipcbiAqIFRhYk9wdGlvbldpZGdldCBpcyBhbiBpdGVtIGluIGEge0BsaW5rIE9PLnVpLlRhYlNlbGVjdFdpZGdldCBUYWJTZWxlY3RXaWRnZXR9LlxuICpcbiAqIEN1cnJlbnRseSwgdGhpcyBjbGFzcyBpcyBvbmx5IHVzZWQgYnkge0BsaW5rIE9PLnVpLkluZGV4TGF5b3V0IGluZGV4IGxheW91dHN9LCB3aGljaCBjb250YWluXG4gKiB7QGxpbmsgT08udWkuVGFiUGFuZWxMYXlvdXQgdGFiIHBhbmVsIGxheW91dHN9LiBTZWUge0BsaW5rIE9PLnVpLkluZGV4TGF5b3V0IEluZGV4TGF5b3V0fVxuICogZm9yIGFuIGV4YW1wbGUuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5PcHRpb25XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuVGFiT3B0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRhYk9wdGlvbldpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVGFiT3B0aW9uV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktdGFiT3B0aW9uV2lkZ2V0JyApXG5cdFx0LmF0dHIoICdyb2xlJywgJ3RhYicgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVGFiT3B0aW9uV2lkZ2V0LCBPTy51aS5PcHRpb25XaWRnZXQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5UYWJPcHRpb25XaWRnZXQuc3RhdGljLmhpZ2hsaWdodGFibGUgPSBmYWxzZTtcblxuLyoqXG4gKiBUYWJTZWxlY3RXaWRnZXQgaXMgYSBsaXN0IHRoYXQgY29udGFpbnMge0BsaW5rIE9PLnVpLlRhYk9wdGlvbldpZGdldCB0YWIgb3B0aW9uc31cbiAqXG4gKiAqKkN1cnJlbnRseSwgdGhpcyBjbGFzcyBpcyBvbmx5IHVzZWQgYnkge0BsaW5rIE9PLnVpLkluZGV4TGF5b3V0IGluZGV4IGxheW91dHN9LioqXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5TZWxlY3RXaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuVGFiU2VsZWN0V2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRhYlNlbGVjdFdpZGdldCggY29uZmlnICkge1xuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVGFiU2VsZWN0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGVsZW1lbnQub24oIHtcblx0XHRmb2N1czogdGhpcy5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApLFxuXHRcdGJsdXI6IHRoaXMudW5iaW5kRG9jdW1lbnRLZXlEb3duTGlzdGVuZXIuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktdGFiU2VsZWN0V2lkZ2V0JyApXG5cdFx0LmF0dHIoICdyb2xlJywgJ3RhYmxpc3QnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlRhYlNlbGVjdFdpZGdldCwgT08udWkuU2VsZWN0V2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5UYWJTZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5cbi8qKlxuICogVGFnSXRlbVdpZGdldHMgYXJlIHVzZWQgd2l0aGluIGEge0BsaW5rIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0XG4gKiBUYWdNdWx0aXNlbGVjdFdpZGdldH0gdG8gZGlzcGxheSB0aGUgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSXRlbVdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uRHJhZ2dhYmxlRWxlbWVudFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAY2ZnIHtib29sZWFufSBbdmFsaWQ9dHJ1ZV0gSXRlbSBpcyB2YWxpZFxuICogQGNmZyB7Ym9vbGVhbn0gW2ZpeGVkXSBJdGVtIGlzIGZpeGVkLiBUaGlzIG1lYW5zIHRoZSBpdGVtIGlzXG4gKiAgYWx3YXlzIGluY2x1ZGVkIGluIHRoZSB2YWx1ZXMgYW5kIGNhbm5vdCBiZSByZW1vdmVkLlxuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0ID0gZnVuY3Rpb24gT29VaVRhZ0l0ZW1XaWRnZXQoIGNvbmZpZyApIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5UYWdJdGVtV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uSXRlbVdpZGdldC5jYWxsKCB0aGlzICk7XG5cdE9PLnVpLm1peGluLkxhYmVsRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdHRoaXMudmFsaWQgPSBjb25maWcudmFsaWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWNvbmZpZy52YWxpZDtcblx0dGhpcy5maXhlZCA9ICEhY29uZmlnLmZpeGVkO1xuXG5cdHRoaXMuY2xvc2VCdXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG5cdFx0ZnJhbWVkOiBmYWxzZSxcblx0XHRpY29uOiAnY2xvc2UnLFxuXHRcdHRhYkluZGV4OiAtMSxcblx0XHR0aXRsZTogT08udWkubXNnKCAnb291aS1pdGVtLXJlbW92ZScgKVxuXHR9ICk7XG5cdHRoaXMuY2xvc2VCdXR0b24uc2V0RGlzYWJsZWQoIHRoaXMuaXNEaXNhYmxlZCgpICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuY2xvc2VCdXR0b25cblx0XHQuY29ubmVjdCggdGhpcywgeyBjbGljazogJ3JlbW92ZScgfSApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0Lm9uKCAnY2xpY2snLCB0aGlzLnNlbGVjdC5iaW5kKCB0aGlzICkgKVxuXHRcdC5vbiggJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKCB0aGlzICkgKVxuXHRcdC8vIFByZXZlbnQgcHJvcGFnYXRpb24gb2YgbW91c2Vkb3duOyB0aGUgdGFnIGl0ZW0gXCJsaXZlc1wiIGluIHRoZVxuXHRcdC8vIGNsaWNrYWJsZSBhcmVhIG9mIHRoZSBUYWdNdWx0aXNlbGVjdFdpZGdldCwgd2hpY2ggbGlzdGVucyB0b1xuXHRcdC8vIG1vdXNlZG93biB0byBvcGVuIHRoZSBtZW51IG9yIHBvcHVwLiBXZSB3YW50IHRvIHByZXZlbnQgdGhhdFxuXHRcdC8vIGZvciBjbGlja3Mgc3BlY2lmaWNhbGx5IG9uIHRoZSB0YWcgaXRzZWxmLCBzbyB0aGUgYWN0aW9ucyB0YWtlblxuXHRcdC8vIGFyZSBtb3JlIGRlbGliZXJhdGUuIFdoZW4gdGhlIHRhZyBpcyBjbGlja2VkLCBpdCB3aWxsIGVtaXQgdGhlXG5cdFx0Ly8gc2VsZWN0aW9uIGV2ZW50IChzaW1pbGFyIHRvIGhvdyAjT08udWkuTXVsdGlvcHRpb25XaWRnZXQgZW1pdHMgJ2NoYW5nZScpXG5cdFx0Ly8gYW5kIGNhbiBiZSBoYW5kbGVkIHNlcGFyYXRlbHkuXG5cdFx0Lm9uKCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCBlICkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRhZ0l0ZW1XaWRnZXQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRsYWJlbCwgdGhpcy5jbG9zZUJ1dHRvbi4kZWxlbWVudCApO1xufTtcblxuLyogSW5pdGlhbGl6YXRpb24gKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5UYWdJdGVtV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ0l0ZW1XaWRnZXQsIE9PLnVpLm1peGluLkl0ZW1XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ0l0ZW1XaWRnZXQsIE9PLnVpLm1peGluLkxhYmVsRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGFnSXRlbVdpZGdldCwgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ0l0ZW1XaWRnZXQsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5UYWdJdGVtV2lkZ2V0LCBPTy51aS5taXhpbi5EcmFnZ2FibGVFbGVtZW50ICk7XG5cbi8qIEV2ZW50cyAqL1xuXG4vKipcbiAqIEBldmVudCByZW1vdmVcbiAqXG4gKiBBIHJlbW92ZSBhY3Rpb24gd2FzIHBlcmZvcm1lZCBvbiB0aGUgaXRlbVxuICovXG5cbi8qKlxuICogQGV2ZW50IG5hdmlnYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiB0aGUgbW92ZW1lbnQsIGZvcndhcmQgb3IgYmFja3dhcmRzXG4gKlxuICogQSBuYXZpZ2F0ZSBhY3Rpb24gd2FzIHBlcmZvcm1lZCBvbiB0aGUgaXRlbVxuICovXG5cbi8qKlxuICogQGV2ZW50IHNlbGVjdFxuICpcbiAqIFRoZSB0YWcgd2lkZ2V0IHdhcyBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjdXIgd2hlbiB0aGUgd2lkZ2V0XG4gKiBpcyBlaXRoZXIgY2xpY2tlZCBvciBlbnRlciB3YXMgcHJlc3NlZCBvbiBpdC5cbiAqL1xuXG4vKipcbiAqIEBldmVudCB2YWxpZFxuICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkIEl0ZW0gaXMgdmFsaWRcbiAqXG4gKiBJdGVtIHZhbGlkaXR5IGhhcyBjaGFuZ2VkXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgZml4ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGaXhlZCBJdGVtIGlzIGZpeGVkXG4gKlxuICogSXRlbSBmaXhlZCBzdGF0ZSBoYXMgY2hhbmdlZFxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBTZXQgdGhpcyBpdGVtIGFzIGZpeGVkLCBtZWFuaW5nIGl0IGNhbm5vdCBiZSByZW1vdmVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV0gSXRlbSBpcyBmaXhlZFxuICogQGZpcmVzIGZpeGVkXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0LnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG5cdHN0YXRlID0gc3RhdGUgPT09IHVuZGVmaW5lZCA/ICF0aGlzLmZpeGVkIDogISFzdGF0ZTtcblxuXHRpZiAoIHRoaXMuZml4ZWQgIT09IHN0YXRlICkge1xuXHRcdHRoaXMuZml4ZWQgPSBzdGF0ZTtcblx0XHRpZiAoIHRoaXMuY2xvc2VCdXR0b24gKSB7XG5cdFx0XHR0aGlzLmNsb3NlQnV0dG9uLnRvZ2dsZSggIXRoaXMuZml4ZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmZpeGVkICYmIHRoaXMuZWxlbWVudEdyb3VwICYmICF0aGlzLmVsZW1lbnRHcm91cC5pc0RyYWdnYWJsZSgpICkge1xuXHRcdFx0Ly8gT25seSBlbmFibGUgdGhlIHN0YXRlIG9mIHRoZSBpdGVtIGlmIHRoZVxuXHRcdFx0Ly8gZW50aXJlIGdyb3VwIGlzIGRyYWdnYWJsZVxuXHRcdFx0dGhpcy50b2dnbGVEcmFnZ2FibGUoICF0aGlzLmZpeGVkICk7XG5cdFx0fVxuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS10YWdJdGVtV2lkZ2V0LWZpeGVkJywgdGhpcy5maXhlZCApO1xuXG5cdFx0dGhpcy5lbWl0KCAnZml4ZWQnLCB0aGlzLmlzRml4ZWQoKSApO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBpdGVtIGlzIGZpeGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0LnByb3RvdHlwZS5pc0ZpeGVkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5maXhlZDtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVGFnSXRlbVdpZGdldC5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHRpZiAoIHN0YXRlICYmIHRoaXMuZWxlbWVudEdyb3VwICYmICF0aGlzLmVsZW1lbnRHcm91cC5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnVGFnSXRlbVdpZGdldCNzZXREaXNhYmxlZDogRGlzYWJsaW5nIGluZGl2aWR1YWwgaXRlbXMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCByZXN1bHQgaW4gaW5jb25zaXN0ZW50IGJlaGF2aW9yLiBVc2UgI3NldEZpeGVkIGluc3RlYWQuIFNlZSBUMTkzNTcxLicgKTtcblx0fVxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlRhZ0l0ZW1XaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXREaXNhYmxlZC5jYWxsKCB0aGlzLCBzdGF0ZSApO1xuXHRpZiAoXG5cdFx0IXN0YXRlICYmXG5cdFx0Ly8gVmVyaWZ5IHdlIGhhdmUgYSBncm91cCwgYW5kIHRoYXQgdGhlIHdpZGdldCBpcyByZWFkeVxuXHRcdHRoaXMudG9nZ2xlRHJhZ2dhYmxlICYmIHRoaXMuZWxlbWVudEdyb3VwICYmXG5cdFx0IXRoaXMuaXNGaXhlZCgpICYmXG5cdFx0IXRoaXMuZWxlbWVudEdyb3VwLmlzRHJhZ2dhYmxlKClcblx0KSB7XG5cdFx0Ly8gT25seSBlbmFibGUgdGhlIGRyYWdnYWJsZSBzdGF0ZSBvZiB0aGUgaXRlbSBpZiB0aGVcblx0XHQvLyBlbnRpcmUgZ3JvdXAgaXMgZHJhZ2dhYmxlIHRvIGJlZ2luIHdpdGgsIGFuZCBpZiB0aGVcblx0XHQvLyBpdGVtIGlzIG5vdCBmaXhlZFxuXHRcdHRoaXMudG9nZ2xlRHJhZ2dhYmxlKCAhc3RhdGUgKTtcblx0fVxuXG5cdGlmICggdGhpcy5jbG9zZUJ1dHRvbiApIHtcblx0XHR0aGlzLmNsb3NlQnV0dG9uLnNldERpc2FibGVkKCBzdGF0ZSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZW1vdmFsIG9mIHRoZSBpdGVtXG4gKlxuICogVGhpcyBpcyBtYWlubHkgZm9yIGV4dGVuc2liaWxpdHkgY29uY2VybnMsIHNvIG90aGVyIGNoaWxkcmVuXG4gKiBvZiB0aGlzIGNsYXNzIGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yIGlmIHRoZXkgbmVlZCB0by4gVGhpc1xuICogaXMgY2FsbGVkIGJ5IGJvdGggY2xpY2tpbmcgdGhlICdyZW1vdmUnIGJ1dHRvbiBidXQgYWxzb1xuICogb24ga2V5cHJlc3MsIHdoaWNoIGlzIGhhcmRlciB0byBvdmVycmlkZSBpZiBuZWVkZWQuXG4gKlxuICogQGZpcmVzIHJlbW92ZVxuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICYmICF0aGlzLmlzRml4ZWQoKSApIHtcblx0XHR0aGlzLmVtaXQoICdyZW1vdmUnICk7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGEga2V5ZG93biBldmVudCBvbiB0aGUgd2lkZ2V0XG4gKlxuICogQGZpcmVzIG5hdmlnYXRlXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBLZXkgZG93biBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IGZhbHNlIHRvIHN0b3AgdGhlIG9wZXJhdGlvblxuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0LnByb3RvdHlwZS5vbktleURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBtb3ZlbWVudDtcblxuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSAmJiAhdGhpcy5pc0ZpeGVkKCkgJiYgKCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuQkFDS1NQQUNFIHx8IGUua2V5Q29kZSA9PT0gT08udWkuS2V5cy5ERUxFVEUgKSApIHtcblx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIGlmICggZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLkVOVEVSICkge1xuXHRcdHRoaXMuc2VsZWN0KCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2UgaWYgKFxuXHRcdGUua2V5Q29kZSA9PT0gT08udWkuS2V5cy5MRUZUIHx8XG5cdFx0ZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLlJJR0hUXG5cdCkge1xuXHRcdGlmICggT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RGlyKCB0aGlzLiRlbGVtZW50ICkgPT09ICdydGwnICkge1xuXHRcdFx0bW92ZW1lbnQgPSB7XG5cdFx0XHRcdGxlZnQ6ICdmb3J3YXJkcycsXG5cdFx0XHRcdHJpZ2h0OiAnYmFja3dhcmRzJ1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bW92ZW1lbnQgPSB7XG5cdFx0XHRcdGxlZnQ6ICdiYWNrd2FyZHMnLFxuXHRcdFx0XHRyaWdodDogJ2ZvcndhcmRzJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoXG5cdFx0XHQnbmF2aWdhdGUnLFxuXHRcdFx0ZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLkxFRlQgP1xuXHRcdFx0XHRtb3ZlbWVudC5sZWZ0IDogbW92ZW1lbnQucmlnaHRcblx0XHQpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBTZWxlY3QgdGhpcyBpdGVtXG4gKlxuICogQGZpcmVzIHNlbGVjdFxuICovXG5PTy51aS5UYWdJdGVtV2lkZ2V0LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdHRoaXMuZW1pdCggJ3NlbGVjdCcgKTtcblx0fVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZhbGlkIHN0YXRlIG9mIHRoaXMgaXRlbVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkXSBJdGVtIGlzIHZhbGlkXG4gKiBAZmlyZXMgdmFsaWRcbiAqL1xuT08udWkuVGFnSXRlbVdpZGdldC5wcm90b3R5cGUudG9nZ2xlVmFsaWQgPSBmdW5jdGlvbiAoIHZhbGlkICkge1xuXHR2YWxpZCA9IHZhbGlkID09PSB1bmRlZmluZWQgPyAhdGhpcy52YWxpZCA6ICEhdmFsaWQ7XG5cblx0aWYgKCB0aGlzLnZhbGlkICE9PSB2YWxpZCApIHtcblx0XHR0aGlzLnZhbGlkID0gdmFsaWQ7XG5cblx0XHR0aGlzLnNldEZsYWdzKCB7IGludmFsaWQ6ICF0aGlzLnZhbGlkIH0gKTtcblxuXHRcdHRoaXMuZW1pdCggJ3ZhbGlkJywgdGhpcy52YWxpZCApO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGl0ZW0gaXMgdmFsaWRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBJdGVtIGlzIHZhbGlkXG4gKi9cbk9PLnVpLlRhZ0l0ZW1XaWRnZXQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkO1xufTtcblxuLyoqXG4gKiBBIGJhc2ljIHRhZyBtdWx0aXNlbGVjdCB3aWRnZXQsIHNpbWlsYXIgaW4gY29uY2VwdCB0byB7QGxpbmsgT08udWkuQ29tYm9Cb3hJbnB1dFdpZGdldCBjb21ibyBib3ggd2lkZ2V0fVxuICogdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gYWRkIG11bHRpcGxlIHZhbHVlcyB0aGF0IGFyZSBkaXNwbGF5ZWQgaW4gYSB0YWcgYXJlYS5cbiAqXG4gKiBUaGlzIHdpZGdldCBpcyBhIGJhc2Ugd2lkZ2V0OyBzZWUge0BsaW5rIE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCBNZW51VGFnTXVsdGlzZWxlY3RXaWRnZXR9IGFuZFxuICoge0BsaW5rIE9PLnVpLlBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQgUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldH0gZm9yIHRoZSBpbXBsZW1lbnRhdGlvbnMgdGhhdCB1c2VcbiAqIGEgbWVudSBhbmQgYSBwb3B1cCByZXNwZWN0aXZlbHkuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQSBUYWdNdWx0aXNlbGVjdFdpZGdldC5cbiAqICAgICB2YXIgd2lkZ2V0ID0gbmV3IE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0KCB7XG4gKiAgICAgICAgIGlucHV0UG9zaXRpb246ICdvdXRsaW5lJyxcbiAqICAgICAgICAgYWxsb3dlZFZhbHVlczogWyAnT3B0aW9uIDEnLCAnT3B0aW9uIDInLCAnT3B0aW9uIDMnIF0sXG4gKiAgICAgICAgIHNlbGVjdGVkOiBbICdPcHRpb24gMScgXVxuICogICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCB3aWRnZXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLldpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cFdpZGdldFxuICogQG1peGlucyBPTy51aS5taXhpbi5EcmFnZ2FibGVHcm91cEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5JY29uRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAY2ZnIHtPYmplY3R9IFtpbnB1dF0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgaW5wdXQgd2lkZ2V0XG4gKiBAY2ZnIHtPTy51aS5JbnB1dFdpZGdldH0gW2lucHV0V2lkZ2V0XSBBbiBvcHRpb25hbCBpbnB1dCB3aWRnZXQuIElmIGdpdmVuLCBpdCB3aWxsXG4gKiAgcmVwbGFjZSB0aGUgaW5wdXQgd2lkZ2V0IHVzZWQgaW4gdGhlIFRhZ011bHRpc2VsZWN0V2lkZ2V0LiBJZiBub3QgZ2l2ZW4sXG4gKiAgVGFnTXVsdGlzZWxlY3RXaWRnZXQgY3JlYXRlcyBpdHMgb3duLlxuICogQGNmZyB7Ym9vbGVhbn0gW2lucHV0UG9zaXRpb249J2lubGluZSddIFBvc2l0aW9uIG9mIHRoZSBpbnB1dC4gT3B0aW9ucyBhcmU6XG4gKiAgLSBpbmxpbmU6IFRoZSBpbnB1dCBpcyBpbnZpc2libGUsIGJ1dCBleGlzdHMgaW5zaWRlIHRoZSB0YWcgbGlzdCwgc29cbiAqICAgIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlIHRhZyBncm91cHMgdG8gYWRkIHRhZ3MuXG4gKiAgLSBvdXRsaW5lOiBUaGUgaW5wdXQgaXMgdW5kZXJuZWF0aCB0aGUgdGFnIGFyZWEuXG4gKiAgLSBub25lOiBObyBpbnB1dCBzdXBwbGllZFxuICogQGNmZyB7Ym9vbGVhbn0gW2FsbG93RWRpdFRhZ3M9dHJ1ZV0gQWxsb3cgZWRpdGluZyBvZiB0aGUgdGFncyBieSBjbGlja2luZyB0aGVtXG4gKiBAY2ZnIHtib29sZWFufSBbYWxsb3dBcmJpdHJhcnk9ZmFsc2VdIEFsbG93IGRhdGEgaXRlbXMgdG8gYmUgYWRkZWQgZXZlbiBpZlxuICogIG5vdCBwcmVzZW50IGluIHRoZSBtZW51LlxuICogQGNmZyB7T2JqZWN0W119IFthbGxvd2VkVmFsdWVzXSBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIGFsbG93ZWQgaXRlbXNcbiAqICBieSB0aGVpciBkYXRhcy5cbiAqIEBjZmcge2Jvb2xlYW59IFthbGxvd0R1cGxpY2F0ZXM9ZmFsc2VdIEFsbG93IGR1cGxpY2F0ZSBpdGVtcyB0byBiZSBhZGRlZFxuICogQGNmZyB7Ym9vbGVhbn0gW2FsbG93RGlzcGxheUludmFsaWRUYWdzPWZhbHNlXSBBbGxvdyB0aGUgZGlzcGxheSBvZlxuICogIGludmFsaWQgdGFncy4gVGhlc2UgdGFncyB3aWxsIGRpc3BsYXkgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLCBhbmRcbiAqICB0aGUgd2lkZ2V0IGFzIGEgd2hvbGUgd2lsbCBoYXZlIGFuIGludmFsaWQgc3RhdGUgaWYgYW55IGludmFsaWQgdGFnc1xuICogIGFyZSBwcmVzZW50LlxuICogQGNmZyB7bnVtYmVyfSBbdGFnTGltaXRdIEFuIG9wdGlvbmFsIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgb3B0aW9ucy5cbiAqICBJZiAndGFnTGltaXQnIGlzIHNldCBhbmQgaXMgcmVhY2hlZCwgdGhlIGlucHV0IGlzIGRpc2FibGVkLCBub3QgYWxsb3dpbmcgYW55XG4gKiAgYWRkaXRpb25zLiBJZiAndGFnTGltaXQnIGlzIHVuc2V0IG9yIGlzIDAsIGFuIHVubGltaXRlZCBudW1iZXIgb2YgaXRlbXMgY2FuIGJlXG4gKiAgYWRkZWQuXG4gKiBAY2ZnIHtib29sZWFufSBbYWxsb3dSZW9yZGVyaW5nPXRydWVdIEFsbG93IHJlb3JkZXJpbmcgb2YgdGhlIGl0ZW1zXG4gKiBAY2ZnIHtPYmplY3RbXXxTdHJpbmdbXX0gW3NlbGVjdGVkXSBBIHNldCBvZiBzZWxlY3RlZCB0YWdzLiBJZiBnaXZlbixcbiAqICB0aGVzZSB3aWxsIGFwcGVhciBpbiB0aGUgdGFnIGxpc3Qgb24gaW5pdGlhbGl6YXRpb24sIGFzIGxvbmcgYXMgdGhleVxuICogIHBhc3MgdGhlIHZhbGlkaXR5IHRlc3RzLlxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlUYWdNdWx0aXNlbGVjdFdpZGdldCggY29uZmlnICkge1xuXHR2YXIgaW5wdXRFdmVudHMsXG5cdFx0ckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0LFxuXHRcdHdpZGdldCA9IHRoaXMsXG5cdFx0JHRhYkZvY3VzID0gJCggJzxzcGFuPicgKVxuXHRcdFx0LmFkZENsYXNzKCAnb28tdWktdGFnTXVsdGlzZWxlY3RXaWRnZXQtZm9jdXNUcmFwJyApO1xuXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5Hcm91cFdpZGdldC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSWNvbkVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uRHJhZ2dhYmxlR3JvdXBFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdHRoaXMudG9nZ2xlRHJhZ2dhYmxlKFxuXHRcdGNvbmZpZy5hbGxvd1Jlb3JkZXJpbmcgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0cnVlIDogISFjb25maWcuYWxsb3dSZW9yZGVyaW5nXG5cdCk7XG5cblx0dGhpcy5pbnB1dFBvc2l0aW9uID1cblx0XHR0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5hbGxvd2VkSW5wdXRQb3NpdGlvbnMuaW5kZXhPZiggY29uZmlnLmlucHV0UG9zaXRpb24gKSA+IC0xID9cblx0XHRcdGNvbmZpZy5pbnB1dFBvc2l0aW9uIDogJ2lubGluZSc7XG5cdHRoaXMuYWxsb3dFZGl0VGFncyA9IGNvbmZpZy5hbGxvd0VkaXRUYWdzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFjb25maWcuYWxsb3dFZGl0VGFncztcblx0dGhpcy5hbGxvd0FyYml0cmFyeSA9ICEhY29uZmlnLmFsbG93QXJiaXRyYXJ5O1xuXHR0aGlzLmFsbG93RHVwbGljYXRlcyA9ICEhY29uZmlnLmFsbG93RHVwbGljYXRlcztcblx0dGhpcy5hbGxvd2VkVmFsdWVzID0gY29uZmlnLmFsbG93ZWRWYWx1ZXMgfHwgW107XG5cdHRoaXMuYWxsb3dEaXNwbGF5SW52YWxpZFRhZ3MgPSBjb25maWcuYWxsb3dEaXNwbGF5SW52YWxpZFRhZ3M7XG5cdHRoaXMuaGFzSW5wdXQgPSB0aGlzLmlucHV0UG9zaXRpb24gIT09ICdub25lJztcblx0dGhpcy50YWdMaW1pdCA9IGNvbmZpZy50YWdMaW1pdDtcblx0dGhpcy5oZWlnaHQgPSBudWxsO1xuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHR0aGlzLiRjb250ZW50ID0gJCggJzxkaXY+JyApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktdGFnTXVsdGlzZWxlY3RXaWRnZXQtY29udGVudCcgKTtcblx0dGhpcy4kaGFuZGxlID0gJCggJzxkaXY+JyApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktdGFnTXVsdGlzZWxlY3RXaWRnZXQtaGFuZGxlJyApXG5cdFx0LmFwcGVuZChcblx0XHRcdHRoaXMuJGluZGljYXRvcixcblx0XHRcdHRoaXMuJGljb24sXG5cdFx0XHR0aGlzLiRjb250ZW50XG5cdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0dGhpcy4kZ3JvdXBcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLXRhZ011bHRpc2VsZWN0V2lkZ2V0LWdyb3VwJyApXG5cdFx0XHRcdClcblx0XHQpO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmFnZ3JlZ2F0ZSgge1xuXHRcdHJlbW92ZTogJ2l0ZW1SZW1vdmUnLFxuXHRcdG5hdmlnYXRlOiAnaXRlbU5hdmlnYXRlJyxcblx0XHRzZWxlY3Q6ICdpdGVtU2VsZWN0Jyxcblx0XHRmaXhlZDogJ2l0ZW1GaXhlZCdcblx0fSApO1xuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHtcblx0XHRpdGVtUmVtb3ZlOiAnb25UYWdSZW1vdmUnLFxuXHRcdGl0ZW1TZWxlY3Q6ICdvblRhZ1NlbGVjdCcsXG5cdFx0aXRlbUZpeGVkOiAnb25UYWdGaXhlZCcsXG5cdFx0aXRlbU5hdmlnYXRlOiAnb25UYWdOYXZpZ2F0ZScsXG5cdFx0Y2hhbmdlOiAnb25DaGFuZ2VUYWdzJ1xuXHR9ICk7XG5cdHRoaXMuJGhhbmRsZS5vbigge1xuXHRcdG1vdXNlZG93bjogdGhpcy5vbk1vdXNlRG93bi5iaW5kKCB0aGlzIClcblx0fSApO1xuXG5cdC8vIEluaXRpYWxpemVcblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRhZ011bHRpc2VsZWN0V2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kaGFuZGxlICk7XG5cblx0aWYgKCB0aGlzLmhhc0lucHV0ICkge1xuXHRcdGlmICggY29uZmlnLmlucHV0V2lkZ2V0ICkge1xuXHRcdFx0dGhpcy5pbnB1dCA9IGNvbmZpZy5pbnB1dFdpZGdldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbnB1dCA9IG5ldyBPTy51aS5UZXh0SW5wdXRXaWRnZXQoICQuZXh0ZW5kKCB7XG5cdFx0XHRcdHBsYWNlaG9sZGVyOiBjb25maWcucGxhY2Vob2xkZXIsXG5cdFx0XHRcdGNsYXNzZXM6IFsgJ29vLXVpLXRhZ011bHRpc2VsZWN0V2lkZ2V0LWlucHV0JyBdXG5cdFx0XHR9LCBjb25maWcuaW5wdXQgKSApO1xuXHRcdH1cblx0XHR0aGlzLmlucHV0LnNldERpc2FibGVkKCB0aGlzLmlzRGlzYWJsZWQoKSApO1xuXG5cdFx0aW5wdXRFdmVudHMgPSB7XG5cdFx0XHRmb2N1czogdGhpcy5vbklucHV0Rm9jdXMuYmluZCggdGhpcyApLFxuXHRcdFx0Ymx1cjogdGhpcy5vbklucHV0Qmx1ci5iaW5kKCB0aGlzICksXG5cdFx0XHQncHJvcGVydHljaGFuZ2UgY2hhbmdlIGNsaWNrIG1vdXNldXAga2V5ZG93biBrZXl1cCBpbnB1dCBjdXQgcGFzdGUgc2VsZWN0IGZvY3VzJzpcblx0XHRcdFx0T08udWkuZGVib3VuY2UoIHRoaXMudXBkYXRlSW5wdXRTaXplLmJpbmQoIHRoaXMgKSApLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5vbklucHV0S2V5RG93bi5iaW5kKCB0aGlzICksXG5cdFx0XHRrZXlwcmVzczogdGhpcy5vbklucHV0S2V5UHJlc3MuYmluZCggdGhpcyApXG5cdFx0fTtcblxuXHRcdHRoaXMuaW5wdXQuJGlucHV0Lm9uKCBpbnB1dEV2ZW50cyApO1xuXHRcdHRoaXMuaW5wdXRQbGFjZWhvbGRlciA9IHRoaXMuaW5wdXQuJGlucHV0LmF0dHIoICdwbGFjZWhvbGRlcicgKTtcblxuXHRcdGlmICggdGhpcy5pbnB1dFBvc2l0aW9uID09PSAnb3V0bGluZScgKSB7XG5cdFx0XHQvLyBPdmVycmlkZSBtYXgtaGVpZ2h0IGZvciB0aGUgaW5wdXQgd2lkZ2V0XG5cdFx0XHQvLyBpbiB0aGUgY2FzZSB0aGUgd2lkZ2V0IGlzIG91dGxpbmUgc28gaXQgY2FuXG5cdFx0XHQvLyBzdHJldGNoIGFsbCB0aGUgd2F5IGlmIHRoZSB3aWRnZXQgaXMgd2lkZVxuXHRcdFx0dGhpcy5pbnB1dC4kZWxlbWVudC5jc3MoICdtYXgtd2lkdGgnLCAnaW5oZXJpdCcgKTtcblx0XHRcdHRoaXMuJGVsZW1lbnRcblx0XHRcdFx0LmFkZENsYXNzKCAnb28tdWktdGFnTXVsdGlzZWxlY3RXaWRnZXQtb3V0bGluZWQnIClcblx0XHRcdFx0LmFwcGVuZCggdGhpcy5pbnB1dC4kZWxlbWVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktdGFnTXVsdGlzZWxlY3RXaWRnZXQtaW5saW5lZCcgKTtcblx0XHRcdC8vIEhBQ0s6IFdoZW4gdGhlIHdpZGdldCBpcyB1c2luZyAnaW5saW5lJyBpbnB1dCwgdGhlXG5cdFx0XHQvLyBiZWhhdmlvciBuZWVkcyB0byBvbmx5IHVzZSB0aGUgJGlucHV0IGl0c2VsZlxuXHRcdFx0Ly8gc28gd2Ugc3R5bGUgYW5kIHNpemUgaXQgYWNjb3JkaW5nbHkgKG90aGVyd2lzZVxuXHRcdFx0Ly8gdGhlIHN0eWxpbmcgYW5kIHNpemluZyBjYW4gZ2V0IHZlcnkgY29udm9sdXRlZFxuXHRcdFx0Ly8gd2hlbiB0aGUgd3JhcHBpbmcgZGl2cyBhbmQgb3RoZXIgZWxlbWVudHMpXG5cdFx0XHQvLyBXZSBhcmUgdGFraW5nIGFkdmFudGFnZSBvZiBzdGlsbCBiZWluZyBhYmxlIHRvXG5cdFx0XHQvLyBjYWxsIHRoZSB3aWRnZXQgaXRzZWxmIGZvciBvcGVyYXRpb25zIGxpa2Vcblx0XHRcdC8vIC5nZXRWYWx1ZSgpIGFuZCBzZXREaXNhYmxlZCgpIGFuZCAuZm9jdXMoKSBidXRcblx0XHRcdC8vIGhhdmluZyBvbmx5IHRoZSAkaW5wdXQgYXR0YWNoZWQgdG8gdGhlIERPTVxuXHRcdFx0dGhpcy4kY29udGVudC5hcHBlbmQoIHRoaXMuaW5wdXQuJGlucHV0ICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMuJGNvbnRlbnQuYXBwZW5kKCAkdGFiRm9jdXMgKTtcblx0fVxuXG5cdHRoaXMuc2V0VGFiSW5kZXhlZEVsZW1lbnQoXG5cdFx0dGhpcy5oYXNJbnB1dCA/XG5cdFx0XHR0aGlzLmlucHV0LiRpbnB1dCA6XG5cdFx0XHQkdGFiRm9jdXNcblx0KTtcblxuXHRpZiAoIGNvbmZpZy5zZWxlY3RlZCApIHtcblx0XHR0aGlzLnNldFZhbHVlKCBjb25maWcuc2VsZWN0ZWQgKTtcblx0fVxuXG5cdC8vIEhBQ0s6IElucHV0IHNpemUgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCBhZnRlciBldmVyeXRoaW5nXG5cdC8vIGVsc2UgaXMgcmVuZGVyZWRcblx0ckFGKCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCB3aWRnZXQuaGFzSW5wdXQgKSB7XG5cdFx0XHR3aWRnZXQudXBkYXRlSW5wdXRTaXplKCk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG4vKiBJbml0aWFsaXphdGlvbiAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5taXhpbi5Hcm91cFdpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLkRyYWdnYWJsZUdyb3VwRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldCwgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LCBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBwcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQWxsb3dlZCBpbnB1dCBwb3NpdGlvbnMuXG4gKiAtIGlubGluZTogVGhlIGlucHV0IGlzIGluc2lkZSB0aGUgdGFnIGxpc3RcbiAqIC0gb3V0bGluZTogVGhlIGlucHV0IGlzIHVuZGVyIHRoZSB0YWcgbGlzdFxuICogLSBub25lOiBUaGVyZSBpcyBubyBpbnB1dFxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnN0YXRpYy5hbGxvd2VkSW5wdXRQb3NpdGlvbnMgPSBbICdpbmxpbmUnLCAnb3V0bGluZScsICdub25lJyBdO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBNb3VzZSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHRzXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKFxuXHRcdCF0aGlzLmlzRGlzYWJsZWQoKSAmJlxuXHRcdCggIXRoaXMuaGFzSW5wdXQgfHwgZS50YXJnZXQgIT09IHRoaXMuaW5wdXQuJGlucHV0WyAwIF0gKSAmJlxuXHRcdGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUXG5cdCkge1xuXHRcdHRoaXMuZm9jdXMoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGtleSBwcmVzcyBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBwcmVzcyBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBwcmV2ZW50IGRlZmF1bHRzXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbklucHV0S2V5UHJlc3MgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBzdG9wT3JDb250aW51ZSxcblx0XHR3aXRoTWV0YUtleSA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7XG5cblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0aWYgKCBlLndoaWNoID09PSBPTy51aS5LZXlzLkVOVEVSICkge1xuXHRcdFx0c3RvcE9yQ29udGludWUgPSB0aGlzLmRvSW5wdXRFbnRlciggZSwgd2l0aE1ldGFLZXkgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGdldHMgcmVzaXplZC5cblx0XHRzZXRUaW1lb3V0KCB0aGlzLnVwZGF0ZUlucHV0U2l6ZS5iaW5kKCB0aGlzICksIDAgKTtcblx0XHRyZXR1cm4gc3RvcE9yQ29udGludWU7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGtleSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgS2V5IGRvd24gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbklucHV0S2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIG1vdmVtZW50LCBkaXJlY3Rpb24sXG5cdFx0d2lkZ2V0ID0gdGhpcyxcblx0XHR3aXRoTWV0YUtleSA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXksXG5cdFx0aXNNb3ZlbWVudEluc2lkZUlucHV0ID0gZnVuY3Rpb24gKCBkaXJlY3Rpb24gKSB7XG5cdFx0XHR2YXIgaW5wdXRSYW5nZSA9IHdpZGdldC5pbnB1dC5nZXRSYW5nZSgpLFxuXHRcdFx0XHRpbnB1dFZhbHVlID0gd2lkZ2V0Lmhhc0lucHV0ICYmIHdpZGdldC5pbnB1dC5nZXRWYWx1ZSgpO1xuXG5cdFx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmRzJyAmJiBpbnB1dFJhbmdlLnRvID4gaW5wdXRWYWx1ZS5sZW5ndGggLSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGlyZWN0aW9uID09PSAnYmFja3dhcmRzJyAmJiBpbnB1dFJhbmdlLmZyb20gPD0gMCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdGlmICggIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdC8vICdrZXlwcmVzcycgZXZlbnQgaXMgbm90IHRyaWdnZXJlZCBmb3IgQmFja3NwYWNlXG5cdFx0aWYgKCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuQkFDS1NQQUNFICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9JbnB1dEJhY2tzcGFjZSggZSwgd2l0aE1ldGFLZXkgKTtcblx0XHR9IGVsc2UgaWYgKCBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuRVNDQVBFICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9JbnB1dEVzY2FwZSggZSApO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRlLmtleUNvZGUgPT09IE9PLnVpLktleXMuTEVGVCB8fFxuXHRcdFx0ZS5rZXlDb2RlID09PSBPTy51aS5LZXlzLlJJR0hUXG5cdFx0KSB7XG5cdFx0XHRpZiAoIE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldERpciggdGhpcy4kZWxlbWVudCApID09PSAncnRsJyApIHtcblx0XHRcdFx0bW92ZW1lbnQgPSB7XG5cdFx0XHRcdFx0bGVmdDogJ2ZvcndhcmRzJyxcblx0XHRcdFx0XHRyaWdodDogJ2JhY2t3YXJkcydcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vdmVtZW50ID0ge1xuXHRcdFx0XHRcdGxlZnQ6ICdiYWNrd2FyZHMnLFxuXHRcdFx0XHRcdHJpZ2h0OiAnZm9yd2FyZHMnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRkaXJlY3Rpb24gPSBlLmtleUNvZGUgPT09IE9PLnVpLktleXMuTEVGVCA/XG5cdFx0XHRcdG1vdmVtZW50LmxlZnQgOiBtb3ZlbWVudC5yaWdodDtcblxuXHRcdFx0aWYgKCAhdGhpcy5oYXNJbnB1dCB8fCAhaXNNb3ZlbWVudEluc2lkZUlucHV0KCBkaXJlY3Rpb24gKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9JbnB1dEFycm93KCBlLCBkaXJlY3Rpb24sIHdpdGhNZXRhS2V5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIFJlc3BvbmQgdG8gaW5wdXQgZm9jdXMgZXZlbnRcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXRhZ011bHRpc2VsZWN0V2lkZ2V0LWZvY3VzJyApO1xuXHQvLyBSZXNldCB2YWxpZGl0eVxuXHR0aGlzLnRvZ2dsZVZhbGlkKCB0cnVlICk7XG59O1xuXG4vKipcbiAqIFJlc3BvbmQgdG8gaW5wdXQgYmx1ciBldmVudFxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS10YWdNdWx0aXNlbGVjdFdpZGdldC1mb2N1cycgKTtcblxuXHQvLyBTZXQgdGhlIHdpZGdldCBhcyBpbnZhbGlkIGlmIHRoZXJlJ3MgdGV4dCBpbiB0aGUgaW5wdXRcblx0dGhpcy5hZGRUYWdGcm9tSW5wdXQoKTtcblx0dGhpcy50b2dnbGVWYWxpZCggdGhpcy5jaGVja1ZhbGlkaXR5KCkgJiYgKCAhdGhpcy5oYXNJbnB1dCB8fCAhdGhpcy5pbnB1dC5nZXRWYWx1ZSgpICkgKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhbiBhY3Rpb24gYWZ0ZXIgdGhlIGVudGVyIGtleSBvbiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBFdmVudCBkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoTWV0YUtleV0gV2hldGhlciB0aGlzIGtleSB3YXMgcHJlc3NlZCB3aXRoXG4gKiBhIG1ldGEga2V5IGxpa2UgJ2N0cmwnXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRvIHByZXZlbnQgZGVmYXVsdHNcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmRvSW5wdXRFbnRlciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5hZGRUYWdGcm9tSW5wdXQoKTtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGFuIGFjdGlvbiByZXNwb25kaW5nIHRvIHRoZSBlbnRlciBrZXkgb24gdGhlIGlucHV0XG4gKlxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgRXZlbnQgZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBbd2l0aE1ldGFLZXldIFdoZXRoZXIgdGhpcyBrZXkgd2FzIHByZXNzZWQgd2l0aFxuICogYSBtZXRhIGtleSBsaWtlICdjdHJsJ1xuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBwcmV2ZW50IGRlZmF1bHRzXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5kb0lucHV0QmFja3NwYWNlID0gZnVuY3Rpb24gKCBlLCB3aXRoTWV0YUtleSApIHtcblx0dmFyIGl0ZW1zLCBpdGVtO1xuXG5cdGlmIChcblx0XHR0aGlzLmlucHV0UG9zaXRpb24gPT09ICdpbmxpbmUnICYmXG5cdFx0dGhpcy5pbnB1dC5nZXRWYWx1ZSgpID09PSAnJyAmJlxuXHRcdCF0aGlzLmlzRW1wdHkoKVxuXHQpIHtcblx0XHQvLyBEZWxldGUgdGhlIGxhc3QgaXRlbVxuXHRcdGl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuXHRcdGl0ZW0gPSBpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0aWYgKCAhaXRlbS5pc0Rpc2FibGVkKCkgJiYgIWl0ZW0uaXNGaXhlZCgpICkge1xuXHRcdFx0dGhpcy5yZW1vdmVJdGVtcyggWyBpdGVtIF0gKTtcblx0XHRcdC8vIElmIEN0cmwvQ21kIHdhcyBwcmVzc2VkLCBkZWxldGUgaXRlbSBlbnRpcmVseS5cblx0XHRcdC8vIE90aGVyd2lzZSBwdXQgaXQgaW50byB0aGUgdGV4dCBmaWVsZCBmb3IgZWRpdGluZy5cblx0XHRcdGlmICggIXdpdGhNZXRhS2V5ICkge1xuXHRcdFx0XHR0aGlzLmlucHV0LnNldFZhbHVlKCBpdGVtLmdldERhdGEoKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGFuIGFjdGlvbiBhZnRlciB0aGUgZXNjYXBlIGtleSBvbiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBFdmVudCBkYXRhXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5kb0lucHV0RXNjYXBlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmNsZWFySW5wdXQoKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhbiBhY3Rpb24gYWZ0ZXIgdGhlIGFycm93IGtleSBvbiB0aGUgaW5wdXQsIHNlbGVjdCB0aGUgcHJldmlvdXNcbiAqIGl0ZW0gZnJvbSB0aGUgaW5wdXQuXG4gKiBTZWUgI2dldFByZXZpb3VzSXRlbVxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEV2ZW50IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudDsgZm9yd2FyZHMgb3IgYmFja3dhcmRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoTWV0YUtleV0gV2hldGhlciB0aGlzIGtleSB3YXMgcHJlc3NlZCB3aXRoXG4gKiAgYSBtZXRhIGtleSBsaWtlICdjdHJsJ1xuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZG9JbnB1dEFycm93ID0gZnVuY3Rpb24gKCBlLCBkaXJlY3Rpb24gKSB7XG5cdGlmIChcblx0XHR0aGlzLmlucHV0UG9zaXRpb24gPT09ICdpbmxpbmUnICYmXG5cdFx0IXRoaXMuaXNFbXB0eSgpICYmXG5cdFx0ZGlyZWN0aW9uID09PSAnYmFja3dhcmRzJ1xuXHQpIHtcblx0XHQvLyBHZXQgcHJldmlvdXMgaXRlbVxuXHRcdHRoaXMuZ2V0UHJldmlvdXNJdGVtKCkuZm9jdXMoKTtcblx0fVxufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGl0ZW0gc2VsZWN0IGV2ZW50XG4gKlxuICogQHBhcmFtIHtPTy51aS5UYWdJdGVtV2lkZ2V0fSBpdGVtIFNlbGVjdGVkIGl0ZW1cbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uVGFnU2VsZWN0ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoIHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5hbGxvd0VkaXRUYWdzICYmICFpdGVtLmlzRml4ZWQoKSApIHtcblx0XHRpZiAoIHRoaXMuaW5wdXQuZ2V0VmFsdWUoKSApIHtcblx0XHRcdHRoaXMuYWRkVGFnRnJvbUlucHV0KCk7XG5cdFx0fVxuXHRcdC8vIDEuIEdldCB0aGUgbGFiZWwgb2YgdGhlIHRhZyBpbnRvIHRoZSBpbnB1dFxuXHRcdHRoaXMuaW5wdXQuc2V0VmFsdWUoIGl0ZW0uZ2V0RGF0YSgpICk7XG5cdFx0Ly8gMi4gUmVtb3ZlIHRoZSB0YWdcblx0XHR0aGlzLnJlbW92ZUl0ZW1zKCBbIGl0ZW0gXSApO1xuXHRcdC8vIDMuIEZvY3VzIHRoZSBpbnB1dFxuXHRcdHRoaXMuZm9jdXMoKTtcblx0fVxufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGl0ZW0gZml4ZWQgc3RhdGUgY2hhbmdlXG4gKlxuICogQHBhcmFtIHtPTy51aS5UYWdJdGVtV2lkZ2V0fSBpdGVtIFNlbGVjdGVkIGl0ZW1cbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uVGFnRml4ZWQgPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdHZhciBpLFxuXHRcdGl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuXG5cdC8vIE1vdmUgaXRlbSB0byB0aGUgZW5kIG9mIHRoZSBzdGF0aWMgaXRlbXNcblx0Zm9yICggaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApIHtcblx0XHRpZiAoIGl0ZW1zWyBpIF0gIT09IGl0ZW0gJiYgIWl0ZW1zWyBpIF0uaXNGaXhlZCgpICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdHRoaXMuYWRkSXRlbXMoIGl0ZW0sIGkgKTtcbn07XG4vKipcbiAqIFJlc3BvbmQgdG8gY2hhbmdlIGV2ZW50LCB3aGVyZSBpdGVtcyB3ZXJlIGFkZGVkLCByZW1vdmVkLCBvciBjbGVhcmVkLlxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25DaGFuZ2VUYWdzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaXNVbmRlckxpbWl0ID0gdGhpcy5pc1VuZGVyTGltaXQoKTtcblxuXHQvLyBSZXNldCB2YWxpZGl0eVxuXHR0aGlzLnRvZ2dsZVZhbGlkKFxuXHRcdHRoaXMuY2hlY2tWYWxpZGl0eSgpICYmXG5cdFx0ISggdGhpcy5oYXNJbnB1dCAmJiB0aGlzLmlucHV0LmdldFZhbHVlKCkgKVxuXHQpO1xuXG5cdGlmICggdGhpcy5oYXNJbnB1dCApIHtcblx0XHR0aGlzLnVwZGF0ZUlucHV0U2l6ZSgpO1xuXHRcdGlmICggIWlzVW5kZXJMaW1pdCApIHtcblx0XHRcdC8vIENsZWFyIHRoZSBpbnB1dFxuXHRcdFx0dGhpcy5pbnB1dC5zZXRWYWx1ZSggJycgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmlucHV0UG9zaXRpb24gPT09ICdvdXRsaW5lJyApIHtcblx0XHRcdC8vIFNob3cvY2xlYXIgdGhlIHBsYWNlaG9sZGVyIGFuZCBlbmFibGUvZGlzYWJsZSB0aGUgaW5wdXRcblx0XHRcdC8vIGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlL2FyZW4ndCB1bmRlciB0aGUgc3BlY2lmaWVkIGxpbWl0XG5cdFx0XHR0aGlzLmlucHV0LiRpbnB1dC5hdHRyKCAncGxhY2Vob2xkZXInLCBpc1VuZGVyTGltaXQgPyB0aGlzLmlucHV0UGxhY2Vob2xkZXIgOiAnJyApO1xuXHRcdFx0dGhpcy5pbnB1dC5zZXREaXNhYmxlZCggIWlzVW5kZXJMaW1pdCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTaG93L2hpZGUgdGhlIGlucHV0XG5cdFx0XHR0aGlzLmlucHV0LiRpbnB1dC50b2dnbGVDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJywgIWlzVW5kZXJMaW1pdCApO1xuXHRcdH1cblx0fVxuXHR0aGlzLnVwZGF0ZUlmSGVpZ2h0Q2hhbmdlZCgpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbiAoIGlzRGlzYWJsZWQgKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXREaXNhYmxlZC5jYWxsKCB0aGlzLCBpc0Rpc2FibGVkICk7XG5cblx0aWYgKCB0aGlzLmhhc0lucHV0ICYmIHRoaXMuaW5wdXQgKSB7XG5cdFx0aWYgKCAhaXNEaXNhYmxlZCApIHtcblx0XHRcdHRoaXMudXBkYXRlSW5wdXRTaXplKCk7XG5cdFx0fVxuXHRcdHRoaXMuaW5wdXQuc2V0RGlzYWJsZWQoICEhaXNEaXNhYmxlZCAmJiAhdGhpcy5pc1VuZGVyTGltaXQoKSApO1xuXHR9XG5cblx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdHRoaXMuZ2V0SXRlbXMoKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdFx0XHRpdGVtLnNldERpc2FibGVkKCAhIWlzRGlzYWJsZWQgKTtcblx0XHR9ICk7XG5cdH1cbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byB0YWcgcmVtb3ZlIGV2ZW50XG4gKiBAcGFyYW0ge09PLnVpLlRhZ0l0ZW1XaWRnZXR9IGl0ZW0gUmVtb3ZlZCB0YWdcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uVGFnUmVtb3ZlID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR0aGlzLnJlbW92ZVRhZ0J5RGF0YSggaXRlbS5nZXREYXRhKCkgKTtcbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byBuYXZpZ2F0ZSBldmVudCBvbiB0aGUgdGFnXG4gKlxuICogQHBhcmFtIHtPTy51aS5UYWdJdGVtV2lkZ2V0fSBpdGVtIFJlbW92ZWQgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiBtb3ZlbWVudDsgJ2ZvcndhcmRzJyBvciAnYmFja3dhcmRzJ1xuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25UYWdOYXZpZ2F0ZSA9IGZ1bmN0aW9uICggaXRlbSwgZGlyZWN0aW9uICkge1xuXHR2YXIgZmlyc3RJdGVtID0gdGhpcy5nZXRJdGVtcygpWyAwIF07XG5cblx0aWYgKCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkcycgKSB7XG5cdFx0dGhpcy5nZXROZXh0SXRlbSggaXRlbSApLmZvY3VzKCk7XG5cdH0gZWxzZSBpZiAoICF0aGlzLmlucHV0UG9zaXRpb24gPT09ICdpbmxpbmUnIHx8IGl0ZW0gIT09IGZpcnN0SXRlbSApIHtcblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGhhcyBhbiBpbmxpbmUgaW5wdXQsIHdlIHdhbnQgdG8gc3RvcCBhdCB0aGUgc3RhcnRpbmcgZWRnZVxuXHRcdC8vIG9mIHRoZSB0YWdzXG5cdFx0dGhpcy5nZXRQcmV2aW91c0l0ZW0oIGl0ZW0gKS5mb2N1cygpO1xuXHR9XG59O1xuXG4vKipcbiAqIEFkZCB0YWcgZnJvbSBpbnB1dCB2YWx1ZVxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuYWRkVGFnRnJvbUlucHV0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdmFsID0gdGhpcy5pbnB1dC5nZXRWYWx1ZSgpLFxuXHRcdGlzVmFsaWQgPSB0aGlzLmlzQWxsb3dlZERhdGEoIHZhbCApO1xuXG5cdGlmICggIXZhbCApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIGlzVmFsaWQgfHwgdGhpcy5hbGxvd0Rpc3BsYXlJbnZhbGlkVGFncyApIHtcblx0XHR0aGlzLmNsZWFySW5wdXQoKTtcblx0XHR0aGlzLmFkZFRhZyggdmFsICk7XG5cdH1cbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGlucHV0XG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5jbGVhcklucHV0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmlucHV0LnNldFZhbHVlKCAnJyApO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGR1cGxpY2F0ZSBvZiBhbiBleGlzdGluZ1xuICogdGFnIGFscmVhZHkgaW4gdGhlIGxpc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBkYXRhIFJlcXVlc3RlZCB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVmFsdWUgaXMgZHVwbGljYXRlXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5pc0R1cGxpY2F0ZURhdGEgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdHJldHVybiAhIXRoaXMuZmluZEl0ZW1Gcm9tRGF0YSggZGF0YSApO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYWxsb3dlZCB0byBiZSBhZGRlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZGF0YSBSZXF1ZXN0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFZhbHVlIGlzIGFsbG93ZWRcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmlzQWxsb3dlZERhdGEgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdGlmIChcblx0XHQhdGhpcy5hbGxvd0R1cGxpY2F0ZXMgJiZcblx0XHR0aGlzLmlzRHVwbGljYXRlRGF0YSggZGF0YSApXG5cdCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggdGhpcy5hbGxvd0FyYml0cmFyeSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIENoZWNrIHdpdGggYWxsb3dlZCB2YWx1ZXNcblx0aWYgKFxuXHRcdHRoaXMuZ2V0QWxsb3dlZFZhbHVlcygpLnNvbWUoIGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YSA9PT0gdmFsdWU7XG5cdFx0fSApXG5cdCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFsbG93ZWQgdmFsdWVzIGxpc3RcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQWxsb3dlZCBkYXRhIHZhbHVlc1xuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZ2V0QWxsb3dlZFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuYWxsb3dlZFZhbHVlcztcbn07XG5cbi8qKlxuICogQWRkIGEgdmFsdWUgdG8gdGhlIGFsbG93ZWQgdmFsdWVzIGxpc3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQWxsb3dlZCBkYXRhIHZhbHVlXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5hZGRBbGxvd2VkVmFsdWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRpZiAoIHRoaXMuYWxsb3dlZFZhbHVlcy5pbmRleE9mKCB2YWx1ZSApID09PSAtMSApIHtcblx0XHR0aGlzLmFsbG93ZWRWYWx1ZXMucHVzaCggdmFsdWUgKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRhdGFzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXXxPYmplY3RbXX0gRGF0YXMgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZ2V0SXRlbXMoKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uICggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLmlzVmFsaWQoKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS5nZXREYXRhKCk7XG5cdFx0fSApO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoaXMgd2lkZ2V0IGJ5IGRhdGFzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfE9iamVjdHxPYmplY3RbXX0gdmFsdWVPYmplY3QgQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGF0YVxuICogIGFuZCBsYWJlbCBvZiB0aGUgdmFsdWUuIElmIHRoZSB3aWRnZXQgYWxsb3dzIGFyYml0cmFyeSB2YWx1ZXMsXG4gKiAgdGhlIGl0ZW1zIHdpbGwgYmUgYWRkZWQgYXMtaXMuIE90aGVyd2lzZSwgdGhlIGRhdGEgdmFsdWUgd2lsbFxuICogIGJlIGNoZWNrZWQgYWdhaW5zdCBhbGxvd2VkVmFsdWVzLlxuICogIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBhdCBsZWFzdCBhIGRhdGEga2V5LiBFeGFtcGxlOlxuICogIHsgZGF0YTogJ2ZvbycsIGxhYmVsOiAnRm9vIGl0ZW0nIH1cbiAqICBGb3IgbXVsdGlwbGUgaXRlbXMsIHVzZSBhbiBhcnJheSBvZiBvYmplY3RzLiBGb3IgZXhhbXBsZTpcbiAqICBbXG4gKiAgICAgeyBkYXRhOiAnZm9vJywgbGFiZWw6ICdGb28gaXRlbScgfSxcbiAqICAgICB7IGRhdGE6ICdiYXInLCBsYWJlbDogJ0JhciBpdGVtJyB9XG4gKiAgXVxuICogIFZhbHVlIGNhbiBhbHNvIGJlIGFkZGVkIHdpdGggcGxhaW50ZXh0IGFycmF5LCBmb3IgZXhhbXBsZTpcbiAqICBbICdmb28nLCAnYmFyJywgJ2JsYScgXSBvciBhIHNpbmdsZSBzdHJpbmcsIGxpa2UgJ2ZvbydcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCB2YWx1ZU9iamVjdCApIHtcblx0dmFsdWVPYmplY3QgPSBBcnJheS5pc0FycmF5KCB2YWx1ZU9iamVjdCApID8gdmFsdWVPYmplY3QgOiBbIHZhbHVlT2JqZWN0IF07XG5cblx0dGhpcy5jbGVhckl0ZW1zKCk7XG5cdHZhbHVlT2JqZWN0LmZvckVhY2goIGZ1bmN0aW9uICggb2JqICkge1xuXHRcdGlmICggdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aGlzLmFkZFRhZyggb2JqICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYWRkVGFnKCBvYmouZGF0YSwgb2JqLmxhYmVsICk7XG5cdFx0fVxuXHR9LmJpbmQoIHRoaXMgKSApO1xufTtcblxuLyoqXG4gKiBBZGQgdGFnIHRvIHRoZSBkaXNwbGF5IGFyZWFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgVGFnIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIFRhZyBsYWJlbC4gSWYgbm8gbGFiZWwgaXMgcHJvdmlkZWQsIHRoZVxuICogIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIGRhdGEgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJdGVtIHdhcyBhZGRlZCBzdWNjZXNzZnVsbHlcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uICggZGF0YSwgbGFiZWwgKSB7XG5cdHZhciBuZXdJdGVtV2lkZ2V0LFxuXHRcdGlzVmFsaWQgPSB0aGlzLmlzQWxsb3dlZERhdGEoIGRhdGEgKTtcblxuXHRpZiAoIHRoaXMuaXNVbmRlckxpbWl0KCkgJiYgKCBpc1ZhbGlkIHx8IHRoaXMuYWxsb3dEaXNwbGF5SW52YWxpZFRhZ3MgKSApIHtcblx0XHRuZXdJdGVtV2lkZ2V0ID0gdGhpcy5jcmVhdGVUYWdJdGVtV2lkZ2V0KCBkYXRhLCBsYWJlbCApO1xuXHRcdG5ld0l0ZW1XaWRnZXQudG9nZ2xlVmFsaWQoIGlzVmFsaWQgKTtcblx0XHR0aGlzLmFkZEl0ZW1zKCBbIG5ld0l0ZW1XaWRnZXQgXSApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBudW1iZXIgb2YgY3VycmVudCB0YWdzIGlzIHdpdGhpbiB0aGUgbGltaXQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjdXJyZW50IHRhZyBjb3VudCBpcyB3aXRoaW4gdGhlIGxpbWl0IG9yXG4gKiAgaWYgJ3RhZ0xpbWl0JyBpcyBub3Qgc2V0XG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5pc1VuZGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAhdGhpcy50YWdMaW1pdCB8fFxuXHRcdHRoaXMuZ2V0SXRlbUNvdW50KCkgPCB0aGlzLnRhZ0xpbWl0O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGFnIGJ5IGl0cyBkYXRhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZGF0YSBUYWcgZGF0YVxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUucmVtb3ZlVGFnQnlEYXRhID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXHR2YXIgaXRlbSA9IHRoaXMuZmluZEl0ZW1Gcm9tRGF0YSggZGF0YSApO1xuXG5cdHRoaXMucmVtb3ZlSXRlbXMoIFsgaXRlbSBdICk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIE9PLnVpLlRhZ0l0ZW1XaWRnZXQgKG9yIGEgc3ViY2xhc3MgdGhlcmVvZikgZnJvbSBnaXZlbiBsYWJlbCBhbmQgZGF0YS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBJdGVtIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgdGV4dC5cbiAqIEByZXR1cm4ge09PLnVpLlRhZ0l0ZW1XaWRnZXR9XG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVUYWdJdGVtV2lkZ2V0ID0gZnVuY3Rpb24gKCBkYXRhLCBsYWJlbCApIHtcblx0bGFiZWwgPSBsYWJlbCB8fCBkYXRhO1xuXG5cdHJldHVybiBuZXcgT08udWkuVGFnSXRlbVdpZGdldCggeyBkYXRhOiBkYXRhLCBsYWJlbDogbGFiZWwgfSApO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpdGVtLCByZXR1cm5zIHRoZSBpdGVtIGFmdGVyIGl0LiBJZiB0aGUgaXRlbSBpcyBhbHJlYWR5IHRoZVxuICogbGFzdCBpdGVtLCByZXR1cm4gYHRoaXMuaW5wdXRgLiBJZiBubyBpdGVtIGlzIHBhc3NlZCwgcmV0dXJucyB0aGVcbiAqIHZlcnkgZmlyc3QgaXRlbS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge09PLnVpLlRhZ0l0ZW1XaWRnZXR9IFtpdGVtXSBUYWcgaXRlbVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgbmV4dCB3aWRnZXQgYXZhaWxhYmxlLlxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZ2V0TmV4dEl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdHZhciBpdGVtSW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKTtcblxuXHRpZiAoIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtSW5kZXggPT09IC0xICkge1xuXHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF07XG5cdH1cblxuXHRpZiAoIGl0ZW1JbmRleCA9PT0gdGhpcy5pdGVtcy5sZW5ndGggLSAxICkgeyAvLyBMYXN0IGl0ZW1cblx0XHRpZiAoIHRoaXMuaGFzSW5wdXQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnB1dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmV0dXJuIGZpcnN0IGl0ZW1cblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLml0ZW1zWyBpdGVtSW5kZXggKyAxIF07XG5cdH1cbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gaXRlbSwgcmV0dXJucyB0aGUgaXRlbSBiZWZvcmUgaXQuIElmIHRoZSBpdGVtIGlzIGFscmVhZHkgdGhlXG4gKiBmaXJzdCBpdGVtLCByZXR1cm4gYHRoaXMuaW5wdXRgLiBJZiBubyBpdGVtIGlzIHBhc3NlZCwgcmV0dXJucyB0aGVcbiAqIHZlcnkgbGFzdCBpdGVtLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7T08udWkuVGFnSXRlbVdpZGdldH0gW2l0ZW1dIFRhZyBpdGVtXG4gKiBAcmV0dXJuIHtPTy51aS5XaWRnZXR9IFRoZSBwcmV2aW91cyB3aWRnZXQgYXZhaWxhYmxlLlxuICovXG5PTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZ2V0UHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR2YXIgaXRlbUluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKCBpdGVtICk7XG5cblx0aWYgKCBpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbUluZGV4ID09PSAtMSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgdGhpcy5pdGVtcy5sZW5ndGggLSAxIF07XG5cdH1cblxuXHRpZiAoIGl0ZW1JbmRleCA9PT0gMCApIHtcblx0XHRpZiAoIHRoaXMuaGFzSW5wdXQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnB1dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmV0dXJuIHRoZSBsYXN0IGl0ZW1cblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyB0aGlzLml0ZW1zLmxlbmd0aCAtIDEgXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlbXNbIGl0ZW1JbmRleCAtIDEgXTtcblx0fVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRleHQgaW5wdXQgZmllbGQgdG8gZW5jb21wYXNzIGFsbCBhdmFpbGFibGUgYXJlYS5cbiAqIFRoaXMgaXMgZXNwZWNpYWxseSByZWxldmFudCBmb3Igd2hlbiB0aGUgaW5wdXQgaXMgYXQgdGhlIGVkZ2Ugb2YgYSBsaW5lXG4gKiBhbmQgc2hvdWxkIGdldCBzbWFsbGVyLiBUaGUgdXN1YWwgb3BlcmF0aW9uIChhcyBhbiBpbmxpbmUtYmxvY2sgd2l0aCBtaW4td2lkdGgpXG4gKiBkb2VzIG5vdCB3b3JrIGluIHRoYXQgY2FzZSwgcHVzaGluZyB0aGUgaW5wdXQgZG93bndhcmRzIHRvIHRoZSBuZXh0IGxpbmUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLnVwZGF0ZUlucHV0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyICRsYXN0SXRlbSwgZGlyZWN0aW9uLCBjb250ZW50V2lkdGgsIGN1cnJlbnRXaWR0aCwgYmVzdFdpZHRoO1xuXHRpZiAoIHRoaXMuaW5wdXRQb3NpdGlvbiA9PT0gJ2lubGluZScgJiYgIXRoaXMuaXNEaXNhYmxlZCgpICkge1xuXHRcdGlmICggdGhpcy5pbnB1dC4kaW5wdXRbIDAgXS5zY3JvbGxXaWR0aCA9PT0gMCApIHtcblx0XHRcdC8vIElucHV0IGFwcGVhcnMgdG8gYmUgYXR0YWNoZWQgYnV0IG5vdCB2aXNpYmxlLlxuXHRcdFx0Ly8gRG9uJ3QgYXR0ZW1wdCB0byBhZGp1c3QgaXRzIHNpemUsIGJlY2F1c2Ugb3VyIG1lYXN1cmVtZW50c1xuXHRcdFx0Ly8gYXJlIGdvaW5nIHRvIGZhaWwgYW55d2F5LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmlucHV0LiRpbnB1dC5jc3MoICd3aWR0aCcsICcxZW0nICk7XG5cdFx0JGxhc3RJdGVtID0gdGhpcy4kZ3JvdXAuY2hpbGRyZW4oKS5sYXN0KCk7XG5cdFx0ZGlyZWN0aW9uID0gT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RGlyKCB0aGlzLiRoYW5kbGUgKTtcblxuXHRcdC8vIEdldCB0aGUgd2lkdGggb2YgdGhlIGlucHV0IHdpdGggdGhlIHBsYWNlaG9sZGVyIHRleHQgYXNcblx0XHQvLyB0aGUgdmFsdWUgYW5kIHNhdmUgaXQgc28gdGhhdCB3ZSBkb24ndCBrZWVwIHJlY2FsY3VsYXRpbmdcblx0XHRpZiAoXG5cdFx0XHR0aGlzLmNvbnRlbnRXaWR0aFdpdGhQbGFjZWhvbGRlciA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHR0aGlzLmlucHV0LmdldFZhbHVlKCkgPT09ICcnICYmXG5cdFx0XHR0aGlzLmlucHV0LiRpbnB1dC5hdHRyKCAncGxhY2Vob2xkZXInICkgIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0dGhpcy5pbnB1dC5zZXRWYWx1ZSggdGhpcy5pbnB1dC4kaW5wdXQuYXR0ciggJ3BsYWNlaG9sZGVyJyApICk7XG5cdFx0XHR0aGlzLmNvbnRlbnRXaWR0aFdpdGhQbGFjZWhvbGRlciA9IHRoaXMuaW5wdXQuJGlucHV0WyAwIF0uc2Nyb2xsV2lkdGg7XG5cdFx0XHR0aGlzLmlucHV0LnNldFZhbHVlKCAnJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIGtlZXAgdGhlIGlucHV0IHdpZGUgZW5vdWdoIGZvciB0aGUgcGxhY2Vob2xkZXIgdGV4dFxuXHRcdGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KFxuXHRcdFx0dGhpcy5pbnB1dC4kaW5wdXRbIDAgXS5zY3JvbGxXaWR0aCxcblx0XHRcdC8vIHVuZGVmaW5lZCBhcmd1bWVudHMgaW4gTWF0aC5tYXggbGVhZCB0byBOYU5cblx0XHRcdCggdGhpcy5jb250ZW50V2lkdGhXaXRoUGxhY2Vob2xkZXIgPT09IHVuZGVmaW5lZCApID9cblx0XHRcdFx0MCA6IHRoaXMuY29udGVudFdpZHRoV2l0aFBsYWNlaG9sZGVyXG5cdFx0KTtcblx0XHRjdXJyZW50V2lkdGggPSB0aGlzLmlucHV0LiRpbnB1dC53aWR0aCgpO1xuXG5cdFx0aWYgKCBjb250ZW50V2lkdGggPCBjdXJyZW50V2lkdGggKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUlmSGVpZ2h0Q2hhbmdlZCgpO1xuXHRcdFx0Ly8gQWxsIGlzIGZpbmUsIGRvbid0IHBlcmZvcm0gZXhwZW5zaXZlIGNhbGN1bGF0aW9uc1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggJGxhc3RJdGVtLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdGJlc3RXaWR0aCA9IHRoaXMuJGNvbnRlbnQuaW5uZXJXaWR0aCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiZXN0V2lkdGggPSBkaXJlY3Rpb24gPT09ICdsdHInID9cblx0XHRcdFx0dGhpcy4kY29udGVudC5pbm5lcldpZHRoKCkgLSAkbGFzdEl0ZW0ucG9zaXRpb24oKS5sZWZ0IC0gJGxhc3RJdGVtLm91dGVyV2lkdGgoKSA6XG5cdFx0XHRcdCRsYXN0SXRlbS5wb3NpdGlvbigpLmxlZnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBzYWZldHkgbWFyZ2luIGZvciBzYW5pdHksIGJlY2F1c2UgSSAqcmVhbGx5KiBkb24ndCBmZWVsIGxpa2UgZmluZGluZyBvdXQgd2hlcmUgdGhlIGZld1xuXHRcdC8vIHBpeGVscyB0aGlzIGlzIG9mZiBieSBhcmUgY29taW5nIGZyb20uXG5cdFx0YmVzdFdpZHRoIC09IDEzO1xuXHRcdGlmICggY29udGVudFdpZHRoID4gYmVzdFdpZHRoICkge1xuXHRcdFx0Ly8gVGhpcyB3aWxsIHJlc3VsdCBpbiB0aGUgaW5wdXQgZ2V0dGluZyBzaGlmdGVkIHRvIHRoZSBuZXh0IGxpbmVcblx0XHRcdGJlc3RXaWR0aCA9IHRoaXMuJGNvbnRlbnQuaW5uZXJXaWR0aCgpIC0gMTM7XG5cdFx0fVxuXHRcdHRoaXMuaW5wdXQuJGlucHV0LndpZHRoKCBNYXRoLmZsb29yKCBiZXN0V2lkdGggKSApO1xuXHRcdHRoaXMudXBkYXRlSWZIZWlnaHRDaGFuZ2VkKCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy51cGRhdGVJZkhlaWdodENoYW5nZWQoKTtcblx0fVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2lkZ2V0IGhlaWdodCBjaGFuZ2VkLCBhbmQgaWYgc28sXG4gKiBlbWl0IHRoZSByZXNpemUgZXZlbnQuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHRoZXJlIGFyZSBlaXRoZXJcbiAqIG1lbnVzIG9yIHBvcHVwcyBhdHRhY2hlZCB0byB0aGUgYm90dG9tIG9mIHRoZSB3aWRnZXQsIHRvIGFsbG93XG4gKiB0aGVtIHRvIGNoYW5nZSB0aGVpciBwb3NpdGlvbmluZyBpbiBjYXNlIHRoZSB3aWRnZXQgbW92ZWQgZG93blxuICogb3IgdXAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLnVwZGF0ZUlmSGVpZ2h0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGhlaWdodCA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KCk7XG5cdGlmICggaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCApIHtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLmVtaXQoICdyZXNpemUnICk7XG5cdH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbGwgaXRlbXMgaW4gdGhlIHdpZGdldCBhcmUgdmFsaWRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaWRnZXQgaXMgdmFsaWRcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmNoZWNrVmFsaWRpdHkgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmdldEl0ZW1zKCkuZXZlcnkoIGZ1bmN0aW9uICggaXRlbSApIHtcblx0XHRyZXR1cm4gaXRlbS5pc1ZhbGlkKCk7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2YWxpZCBzdGF0ZSBvZiB0aGlzIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZF0gSXRlbSBpcyB2YWxpZFxuICogQGZpcmVzIHZhbGlkXG4gKi9cbk9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS50b2dnbGVWYWxpZCA9IGZ1bmN0aW9uICggdmFsaWQgKSB7XG5cdHZhbGlkID0gdmFsaWQgPT09IHVuZGVmaW5lZCA/ICF0aGlzLnZhbGlkIDogISF2YWxpZDtcblxuXHRpZiAoIHRoaXMudmFsaWQgIT09IHZhbGlkICkge1xuXHRcdHRoaXMudmFsaWQgPSB2YWxpZDtcblxuXHRcdHRoaXMuc2V0RmxhZ3MoIHsgaW52YWxpZDogIXRoaXMudmFsaWQgfSApO1xuXG5cdFx0dGhpcy5lbWl0KCAndmFsaWQnLCB0aGlzLnZhbGlkICk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbGlkIHN0YXRlIG9mIHRoZSB3aWRnZXRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaWRnZXQgaXMgdmFsaWRcbiAqL1xuT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkO1xufTtcblxuLyoqXG4gKiBQb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0IE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0fSBpbnRlbmRlZFxuICogdG8gdXNlIGEgcG9wdXAuIFRoZSBwb3B1cCBjYW4gYmUgY29uZmlndXJlZCB0byBoYXZlIGEgZGVmYXVsdCBpbnB1dCB0byBpbnNlcnQgdmFsdWVzIGludG8gdGhlIHdpZGdldC5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIFBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQuXG4gKiAgICAgdmFyIHdpZGdldCA9IG5ldyBPTy51aS5Qb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0KCk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggd2lkZ2V0LiRlbGVtZW50ICk7XG4gKlxuICogICAgIC8vIEV4YW1wbGU6IEEgUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldCB3aXRoIGFuIGV4dGVybmFsIHBvcHVwLlxuICogICAgIHZhciBwb3B1cElucHV0ID0gbmV3IE9PLnVpLlRleHRJbnB1dFdpZGdldCgpLFxuICogICAgICAgICB3aWRnZXQgPSBuZXcgT08udWkuUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldCgge1xuICogICAgICAgICAgICBwb3B1cElucHV0OiBwb3B1cElucHV0LFxuICogICAgICAgICAgICBwb3B1cDoge1xuICogICAgICAgICAgICAgICAkY29udGVudDogcG9wdXBJbnB1dC4kZWxlbWVudFxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgIH0gKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCB3aWRnZXQuJGVsZW1lbnQgKTtcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLlRhZ011bHRpc2VsZWN0V2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlBvcHVwRWxlbWVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3RcbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBBbiBvdmVybGF5IGZvciB0aGUgcG9wdXAuXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKiBAY2ZnIHtPYmplY3R9IFtwb3B1cF0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcG9wdXBcbiAqIEBjZmcge09PLnVpLklucHV0V2lkZ2V0fSBbcG9wdXBJbnB1dF0gQW4gaW5wdXQgd2lkZ2V0IGluc2lkZSB0aGUgcG9wdXAgdGhhdCB3aWxsIGJlXG4gKiAgZm9jdXNlZCB3aGVuIHRoZSBwb3B1cCBpcyBvcGVuZWQgYW5kIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBmb3IgdGhlXG4gKiAgZ2VuZXJhbCBpbnB1dCBpbiB0aGUgd2lkZ2V0LlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuT08udWkuUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlQb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0KCBjb25maWcgKSB7XG5cdHZhciBkZWZhdWx0SW5wdXQsXG5cdFx0ZGVmYXVsdENvbmZpZyA9IHsgcG9wdXA6IHt9IH07XG5cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Qb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCggeyBpbnB1dFBvc2l0aW9uOiAnbm9uZScgfSwgY29uZmlnICkgKTtcblxuXHR0aGlzLiRvdmVybGF5ID0gKCBjb25maWcuJG92ZXJsYXkgPT09IHRydWUgPyBPTy51aS5nZXREZWZhdWx0T3ZlcmxheSgpIDogY29uZmlnLiRvdmVybGF5ICkgfHwgdGhpcy4kZWxlbWVudDtcblxuXHRpZiAoICFjb25maWcucG9wdXAgKSB7XG5cdFx0Ly8gRm9yIHRoZSBkZWZhdWx0IGJhc2UgaW1wbGVtZW50YXRpb24sIHdlIGdpdmUgYSBwb3B1cFxuXHRcdC8vIHdpdGggYW4gaW5wdXQgd2lkZ2V0IGluc2lkZSBpdC4gRm9yIGFueSBvdGhlciB1c2UgY2FzZXNcblx0XHQvLyB0aGUgcG9wdXAgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGV4dGVybmFsbHkgYW5kIHRoZVxuXHRcdC8vIGV2ZW50IGhhbmRsZWQgdG8gYWRkIHRhZ3Mgc2VwYXJhdGVseSBhbmQgbWFudWFsbHlcblx0XHRkZWZhdWx0SW5wdXQgPSBuZXcgT08udWkuVGV4dElucHV0V2lkZ2V0KCk7XG5cblx0XHRkZWZhdWx0Q29uZmlnLnBvcHVwSW5wdXQgPSBkZWZhdWx0SW5wdXQ7XG5cdFx0ZGVmYXVsdENvbmZpZy5wb3B1cC4kY29udGVudCA9IGRlZmF1bHRJbnB1dC4kZWxlbWVudDtcblx0XHRkZWZhdWx0Q29uZmlnLnBvcHVwLnBhZGRlZCA9IHRydWU7XG5cblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldC1kZWZhdWx0UG9wdXAnICk7XG5cdH1cblxuXHQvLyBBZGQgb3ZlcmxheSwgYW5kIGFkZCB0aGF0IHRvIHRoZSBhdXRvQ2xvc2VJZ25vcmVcblx0ZGVmYXVsdENvbmZpZy5wb3B1cC4kb3ZlcmxheSA9IHRoaXMuJG92ZXJsYXk7XG5cdGRlZmF1bHRDb25maWcucG9wdXAuJGF1dG9DbG9zZUlnbm9yZSA9IHRoaXMuaGFzSW5wdXQgP1xuXHRcdHRoaXMuaW5wdXQuJGVsZW1lbnQuYWRkKCB0aGlzLiRvdmVybGF5ICkgOiB0aGlzLiRvdmVybGF5O1xuXG5cdC8vIEFsbG93IGV4dGVuZGluZyBhbnkgb2YgdGhlIGFib3ZlXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCBkZWZhdWx0Q29uZmlnLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uUG9wdXBFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdGlmICggdGhpcy5oYXNJbnB1dCApIHtcblx0XHR0aGlzLmlucHV0LiRpbnB1dC5vbiggJ2ZvY3VzJywgdGhpcy5wb3B1cC50b2dnbGUuYmluZCggdGhpcy5wb3B1cCwgdHJ1ZSApICk7XG5cdH1cblxuXHQvLyBDb25maWd1cmF0aW9uIG9wdGlvbnNcblx0dGhpcy5wb3B1cElucHV0ID0gY29uZmlnLnBvcHVwSW5wdXQ7XG5cdGlmICggdGhpcy5wb3B1cElucHV0ICkge1xuXHRcdHRoaXMucG9wdXBJbnB1dC5jb25uZWN0KCB0aGlzLCB7XG5cdFx0XHRlbnRlcjogJ29uUG9wdXBJbnB1dEVudGVyJ1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLm9uKCAncmVzaXplJywgdGhpcy5wb3B1cC51cGRhdGVEaW1lbnNpb25zLmJpbmQoIHRoaXMucG9wdXAgKSApO1xuXHR0aGlzLnBvcHVwLmNvbm5lY3QoIHRoaXMsIHsgdG9nZ2xlOiAnb25Qb3B1cFRvZ2dsZScgfSApO1xuXHR0aGlzLiR0YWJJbmRleGVkXG5cdFx0Lm9uKCAnZm9jdXMnLCB0aGlzLm9uRm9jdXMuYmluZCggdGhpcyApICk7XG5cblx0Ly8gSW5pdGlhbGl6ZVxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFwcGVuZCggdGhpcy5wb3B1cC4kZWxlbWVudCApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktcG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldCcgKTtcblxuXHQvLyBEZXByZWNhdGlvbiB3YXJuaW5nXG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ1BvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQ6IERlcHJlY2F0ZWQgd2lkZ2V0LiBVc2UgTWVudVRhZ011bHRpc2VsZWN0V2lkZ2V0IGluc3RlYWQuIFNlZSBUMjA4ODIxLicgKTtcbn07XG5cbi8qIEluaXRpYWxpemF0aW9uICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldCwgT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQsIE9PLnVpLm1peGluLlBvcHVwRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogRm9jdXMgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Qb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnBvcHVwLnRvZ2dsZSggdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIHBvcHVwIHRvZ2dsZSBldmVudFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWaXNpYmxlIFBvcHVwIGlzIHZpc2libGVcbiAqL1xuT08udWkuUG9wdXBUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25Qb3B1cFRvZ2dsZSA9IGZ1bmN0aW9uICggaXNWaXNpYmxlICkge1xuXHRpZiAoIGlzVmlzaWJsZSAmJiB0aGlzLnBvcHVwSW5wdXQgKSB7XG5cdFx0dGhpcy5wb3B1cElucHV0LmZvY3VzKCk7XG5cdH1cbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byBwb3B1cCBpbnB1dCBlbnRlciBldmVudFxuICovXG5PTy51aS5Qb3B1cFRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vblBvcHVwSW5wdXRFbnRlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLnBvcHVwSW5wdXQgKSB7XG5cdFx0dGhpcy5hZGRUYWdCeVBvcHVwVmFsdWUoIHRoaXMucG9wdXBJbnB1dC5nZXRWYWx1ZSgpICk7XG5cdFx0dGhpcy5wb3B1cElucHV0LnNldFZhbHVlKCAnJyApO1xuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uVGFnU2VsZWN0ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRpZiAoIHRoaXMucG9wdXBJbnB1dCAmJiB0aGlzLmFsbG93RWRpdFRhZ3MgKSB7XG5cdFx0dGhpcy5wb3B1cElucHV0LnNldFZhbHVlKCBpdGVtLmdldERhdGEoKSApO1xuXHRcdHRoaXMucmVtb3ZlSXRlbXMoIFsgaXRlbSBdICk7XG5cblx0XHR0aGlzLnBvcHVwLnRvZ2dsZSggdHJ1ZSApO1xuXHRcdHRoaXMucG9wdXBJbnB1dC5mb2N1cygpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFBhcmVudFxuXHRcdE9PLnVpLlBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5vblRhZ1NlbGVjdC5jYWxsKCB0aGlzLCBpdGVtICk7XG5cdH1cbn07XG5cbi8qKlxuICogQWRkIGEgdGFnIGJ5IHRoZSBwb3B1cCB2YWx1ZS5cbiAqIFdoYXRldmVyIGlzIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHRoZSB2YWx1ZSBpbiB0aGUgcG9wdXAgc2hvdWxkIGNhbGxcbiAqIHRoaXMgbWV0aG9kIHRvIGFkZCBhIHRhZywgb3IgdXNlIHRoZSByZWd1bGFyIG1ldGhvZHMgbGlrZSAjYWRkVGFnIG9yXG4gKiAjc2V0VmFsdWUgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIHZhbHVlIG9mIGl0ZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIFRoZSBsYWJlbCBvZiB0aGUgdGFnLiBJZiBub3QgZ2l2ZW4sIHRoZSBkYXRhIGlzIHVzZWQuXG4gKi9cbk9PLnVpLlBvcHVwVGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmFkZFRhZ0J5UG9wdXBWYWx1ZSA9IGZ1bmN0aW9uICggZGF0YSwgbGFiZWwgKSB7XG5cdHRoaXMuYWRkVGFnKCBkYXRhLCBsYWJlbCApO1xufTtcblxuLyoqXG4gKiBNZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQgaXMgYSB7QGxpbmsgT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQgT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXR9IGludGVuZGVkXG4gKiB0byB1c2UgYSBtZW51IG9mIHNlbGVjdGFibGUgb3B0aW9ucy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIGJhc2ljIE1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5cbiAqICAgICB2YXIgd2lkZ2V0ID0gbmV3IE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCgge1xuICogICAgICAgICBpbnB1dFBvc2l0aW9uOiAnb3V0bGluZScsXG4gKiAgICAgICAgIG9wdGlvbnM6IFtcbiAqICAgICAgICAgICAgeyBkYXRhOiAnb3B0aW9uMScsIGxhYmVsOiAnT3B0aW9uIDEnLCBpY29uOiAndGFnJyB9LFxuICogICAgICAgICAgICB7IGRhdGE6ICdvcHRpb24yJywgbGFiZWw6ICdPcHRpb24gMicgfSxcbiAqICAgICAgICAgICAgeyBkYXRhOiAnb3B0aW9uMycsIGxhYmVsOiAnT3B0aW9uIDMnIH0sXG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIHNlbGVjdGVkOiBbICdvcHRpb24xJywgJ29wdGlvbjInIF1cbiAqICAgICB9ICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggd2lkZ2V0LiRlbGVtZW50ICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5UYWdNdWx0aXNlbGVjdFdpZGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAY2ZnIHtib29sZWFufSBbY2xlYXJJbnB1dE9uQ2hvb3NlPXRydWVdIENsZWFyIHRoZSB0ZXh0IGlucHV0IHZhbHVlIHdoZW4gYSBtZW51IG9wdGlvbiBpcyBjaG9zZW5cbiAqIEBjZmcge09iamVjdH0gW21lbnVdIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgbWVudSB3aWRnZXRcbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBBbiBvdmVybGF5IGZvciB0aGUgbWVudS5cbiAqICBTZWUgPGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL0NvbmNlcHRzI092ZXJsYXlzPi5cbiAqIEBjZmcge09iamVjdFtdfSBbb3B0aW9ucz1bXV0gQXJyYXkgb2YgbWVudSBvcHRpb25zIGluIHRoZSBmb3JtYXQgYHsgZGF0YTog4oCmLCBsYWJlbDog4oCmIH1gXG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlNZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQoIGNvbmZpZyApIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdHRoaXMuJG92ZXJsYXkgPSAoIGNvbmZpZy4kb3ZlcmxheSA9PT0gdHJ1ZSA/IE9PLnVpLmdldERlZmF1bHRPdmVybGF5KCkgOiBjb25maWcuJG92ZXJsYXkgKSB8fCB0aGlzLiRlbGVtZW50O1xuXHR0aGlzLmNsZWFySW5wdXRPbkNob29zZSA9IGNvbmZpZy5jbGVhcklucHV0T25DaG9vc2UgPT09IHVuZGVmaW5lZCB8fCAhIWNvbmZpZy5jbGVhcklucHV0T25DaG9vc2U7XG5cdHRoaXMubWVudSA9IHRoaXMuY3JlYXRlTWVudVdpZGdldCggJC5leHRlbmQoIHtcblx0XHR3aWRnZXQ6IHRoaXMsXG5cdFx0aW5wdXQ6IHRoaXMuaGFzSW5wdXQgPyB0aGlzLmlucHV0IDogbnVsbCxcblx0XHQkaW5wdXQ6IHRoaXMuaGFzSW5wdXQgPyB0aGlzLmlucHV0LiRpbnB1dCA6IG51bGwsXG5cdFx0ZmlsdGVyRnJvbUlucHV0OiAhIXRoaXMuaGFzSW5wdXQsXG5cdFx0JGF1dG9DbG9zZUlnbm9yZTogdGhpcy5oYXNJbnB1dCA/XG5cdFx0XHR0aGlzLmlucHV0LiRlbGVtZW50IDogJCggW10gKSxcblx0XHQkZmxvYXRhYmxlQ29udGFpbmVyOiB0aGlzLmhhc0lucHV0ICYmIHRoaXMuaW5wdXRQb3NpdGlvbiA9PT0gJ291dGxpbmUnID9cblx0XHRcdHRoaXMuaW5wdXQuJGVsZW1lbnQgOiB0aGlzLiRlbGVtZW50LFxuXHRcdCRvdmVybGF5OiB0aGlzLiRvdmVybGF5LFxuXHRcdGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQoKVxuXHR9LCBjb25maWcubWVudSApICk7XG5cdHRoaXMuYWRkT3B0aW9ucyggY29uZmlnLm9wdGlvbnMgfHwgW10gKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy5tZW51LmNvbm5lY3QoIHRoaXMsIHtcblx0XHRjaG9vc2U6ICdvbk1lbnVDaG9vc2UnLFxuXHRcdHRvZ2dsZTogJ29uTWVudVRvZ2dsZSdcblx0fSApO1xuXHRpZiAoIHRoaXMuaGFzSW5wdXQgKSB7XG5cdFx0dGhpcy5pbnB1dC5jb25uZWN0KCB0aGlzLCB7IGNoYW5nZTogJ29uSW5wdXRDaGFuZ2UnIH0gKTtcblx0fVxuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHsgcmVzaXplOiAnb25SZXNpemUnIH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRvdmVybGF5XG5cdFx0LmFwcGVuZCggdGhpcy5tZW51LiRlbGVtZW50ICk7XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1tZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQnICk7XG5cdC8vIFJlbW92ZSBNZW51U2VsZWN0V2lkZ2V0J3MgZ2VuZXJpYyBmb2N1cyBvd25lciBBUklBIGF0dHJpYnV0ZVxuXHQvLyBUT0RPOiBTaG91bGQgdGhpcyB3aWRnZXQgaGF2ZSBhIGByb2xlYCB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGlzIGF0dHJpYnV0ZT9cblx0dGhpcy5tZW51LiRmb2N1c093bmVyLnJlbW92ZUF0dHIoICdhcmlhLWV4cGFuZGVkJyApO1xuXHQvLyBUYWdNdWx0aXNlbGVjdFdpZGdldCBhbHJlYWR5IGRvZXMgdGhpcywgYnV0IGl0IGRvZXNuJ3Qgd29yayByaWdodCBiZWNhdXNlIHRoaXMubWVudSBpcyBub3QgeWV0XG5cdC8vIHNldCB1cCB3aGlsZSB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHJ1bnMsIGFuZCAjZ2V0QWxsb3dlZFZhbHVlcyByZWplY3RzIGV2ZXJ5dGhpbmcuXG5cdGlmICggY29uZmlnLnNlbGVjdGVkICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIGNvbmZpZy5zZWxlY3RlZCApO1xuXHR9XG59O1xuXG4vKiBJbml0aWFsaXphdGlvbiAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldCwgT08udWkuVGFnTXVsdGlzZWxlY3RXaWRnZXQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFJlc3BvbmQgdG8gcmVzaXplIGV2ZW50XG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFJlcG9zaXRpb24gdGhlIG1lbnVcblx0dGhpcy5tZW51LnBvc2l0aW9uKCk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUub25JbnB1dEZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLm9uSW5wdXRGb2N1cy5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5tZW51LnRvZ2dsZSggdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uSW5wdXRCbHVyID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wYXJlbnQucHJvdG90eXBlLm9uSW5wdXRCbHVyLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLm1lbnUudG9nZ2xlKCBmYWxzZSApO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIGlucHV0IGNoYW5nZSBldmVudFxuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMubWVudS50b2dnbGUoIHRydWUgKTtcblx0dGhpcy5pbml0aWFsaXplTWVudVNlbGVjdGlvbigpO1xufTtcblxuLyoqXG4gKiBSZXNwb25kIHRvIG1lbnUgY2hvb3NlIGV2ZW50XG4gKlxuICogQHBhcmFtIHtPTy51aS5PcHRpb25XaWRnZXR9IG1lbnVJdGVtIENob3NlbiBtZW51IGl0ZW1cbiAqL1xuT08udWkuTWVudVRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5vbk1lbnVDaG9vc2UgPSBmdW5jdGlvbiAoIG1lbnVJdGVtICkge1xuXHRpZiAoIHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5jbGVhcklucHV0T25DaG9vc2UgKSB7XG5cdFx0dGhpcy5pbnB1dC5zZXRWYWx1ZSggJycgKTtcblx0fVxuXHQvLyBBZGQgdGFnXG5cdHRoaXMuYWRkVGFnKCBtZW51SXRlbS5nZXREYXRhKCksIG1lbnVJdGVtLmdldExhYmVsKCkgKTtcbn07XG5cbi8qKlxuICogUmVzcG9uZCB0byBtZW51IHRvZ2dsZSBldmVudC4gUmVzZXQgaXRlbSBoaWdobGlnaHRzIG9uIGhpZGUuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGUgVGhlIG1lbnUgaXMgdmlzaWJsZVxuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uTWVudVRvZ2dsZSA9IGZ1bmN0aW9uICggaXNWaXNpYmxlICkge1xuXHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0dGhpcy5tZW51LnNlbGVjdEl0ZW0oIG51bGwgKTtcblx0XHR0aGlzLm1lbnUuaGlnaGxpZ2h0SXRlbSggbnVsbCApO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuaW5pdGlhbGl6ZU1lbnVTZWxlY3Rpb24oKTtcblx0fVxuXHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gUmVtb3ZlIE1lbnVTZWxlY3RXaWRnZXQncyBnZW5lcmljIGZvY3VzIG93bmVyIEFSSUEgYXR0cmlidXRlXG5cdFx0Ly8gVE9ETzogU2hvdWxkIHRoaXMgd2lkZ2V0IGhhdmUgYSBgcm9sZWAgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggdGhpcyBhdHRyaWJ1dGU/XG5cdFx0dGhpcy5tZW51LiRmb2N1c093bmVyLnJlbW92ZUF0dHIoICdhcmlhLWV4cGFuZGVkJyApO1xuXHR9LmJpbmQoIHRoaXMgKSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLm9uVGFnU2VsZWN0ID0gZnVuY3Rpb24gKCB0YWdJdGVtICkge1xuXHR2YXIgbWVudUl0ZW0gPSB0aGlzLm1lbnUuZmluZEl0ZW1Gcm9tRGF0YSggdGFnSXRlbS5nZXREYXRhKCkgKTtcblx0aWYgKCAhdGhpcy5hbGxvd0FyYml0cmFyeSApIHtcblx0XHQvLyBPdmVycmlkZSB0aGUgYmFzZSBiZWhhdmlvciBmcm9tIFRhZ011bHRpc2VsZWN0V2lkZ2V0OyB0aGUgYmFzZSBiZWhhdmlvclxuXHRcdC8vIGluIFRhZ011bHRpc2VsZWN0V2lkZ2V0IGlzIHRvIHJlbW92ZSB0aGUgdGFnIHRvIGVkaXQgaXQgaW4gdGhlIGlucHV0LFxuXHRcdC8vIGJ1dCBpbiBvdXIgY2FzZSwgd2Ugd2FudCB0byB1dGlsaXplIHRoZSBtZW51IHNlbGVjdGlvbiBiZWhhdmlvciwgYW5kXG5cdFx0Ly8gZGVmaW5pdGVseSBub3QgcmVtb3ZlIHRoZSBpdGVtLlxuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYW4gaW5wdXQgdGhhdCBpcyB1c2VkIGZvciBmaWx0ZXJpbmcsIGVyYXNlIHRoZSB2YWx1ZSBzbyB3ZSBkb24ndCBmaWx0ZXJcblx0XHRpZiAoIHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5tZW51LmZpbHRlckZyb21JbnB1dCApIHtcblx0XHRcdHRoaXMuaW5wdXQuc2V0VmFsdWUoICcnICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0IHRoZSBtZW51IGl0ZW1cblx0XHR0aGlzLm1lbnUuc2VsZWN0SXRlbSggbWVudUl0ZW0gKTtcblxuXHRcdHRoaXMuZm9jdXMoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBVc2UgdGhlIGRlZmF1bHRcblx0XHRPTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5vblRhZ1NlbGVjdC5jYWxsKCB0aGlzLCB0YWdJdGVtICk7XG5cdH1cbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuTWVudVRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uICggaXNEaXNhYmxlZCApIHtcblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRPTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucGFyZW50LnByb3RvdHlwZS5zZXREaXNhYmxlZC5jYWxsKCB0aGlzLCBpc0Rpc2FibGVkICk7XG5cblx0aWYgKCB0aGlzLm1lbnUgKSB7XG5cdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IGNhbGxpbmcgc2V0RGlzYWJsZWQoKSBiZWZvcmUgdGhlIG1lbnUgd2FzIGluaXRpYWxpemVkXG5cdFx0dGhpcy5tZW51LnNldERpc2FibGVkKCBpc0Rpc2FibGVkICk7XG5cdH1cbn07XG5cbi8qKlxuICogSGlnaGxpZ2h0IHRoZSBmaXJzdCBzZWxlY3RhYmxlIGl0ZW0gaW4gdGhlIG1lbnUsIGlmIGNvbmZpZ3VyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjaGFpbmFibGVcbiAqL1xuT08udWkuTWVudVRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5pbml0aWFsaXplTWVudVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCAhdGhpcy5tZW51LmZpbmRTZWxlY3RlZEl0ZW0oKSApIHtcblx0XHR0aGlzLm1lbnUuaGlnaGxpZ2h0SXRlbShcblx0XHRcdHRoaXMuYWxsb3dBcmJpdHJhcnkgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0dGhpcy5tZW51LmZpbmRGaXJzdFNlbGVjdGFibGVJdGVtKClcblx0XHQpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuYWRkVGFnRnJvbUlucHV0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdmFsID0gdGhpcy5pbnB1dC5nZXRWYWx1ZSgpLFxuXHRcdC8vIExvb2sgZm9yIGEgaGlnaGxpZ2h0ZWQgaXRlbSBmaXJzdFxuXHRcdC8vIFRoZW4gbG9vayBmb3IgdGhlIGVsZW1lbnQgdGhhdCBmaXRzIHRoZSBkYXRhXG5cdFx0aXRlbSA9IHRoaXMubWVudS5maW5kSGlnaGxpZ2h0ZWRJdGVtKCkgfHwgdGhpcy5tZW51LmZpbmRJdGVtRnJvbURhdGEoIHZhbCApLFxuXHRcdGRhdGEgPSBpdGVtID8gaXRlbS5nZXREYXRhKCkgOiB2YWwsXG5cdFx0aXNWYWxpZCA9IHRoaXMuaXNBbGxvd2VkRGF0YSggZGF0YSApO1xuXG5cdC8vIE92ZXJyaWRlIHRoZSBwYXJlbnQgbWV0aG9kIHNvIHdlIGFkZCBmcm9tIHRoZSBtZW51XG5cdC8vIHJhdGhlciB0aGFuIGRpcmVjdGx5IGZyb20gdGhlIGlucHV0XG5cblx0aWYgKCAhdmFsICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggaXNWYWxpZCB8fCB0aGlzLmFsbG93RGlzcGxheUludmFsaWRUYWdzICkge1xuXHRcdHRoaXMuY2xlYXJJbnB1dCgpO1xuXHRcdGlmICggaXRlbSApIHtcblx0XHRcdHRoaXMuYWRkVGFnKCBkYXRhLCBpdGVtLmdldExhYmVsKCkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hZGRUYWcoIHZhbCApO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHZpc2libGUgaXRlbXMgaW4gdGhlIG1lbnUuIFRoaXMgaXMgbWFpbmx5IHVzZWQgZm9yIHdoZW5cbiAqIHRoZSBtZW51IGlzIGZpbHRlcmluZyByZXN1bHRzLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVPcHRpb25XaWRnZXRbXX0gVmlzaWJsZSByZXN1bHRzXG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuZ2V0TWVudVZpc2libGVJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubWVudS5nZXRJdGVtcygpLmZpbHRlciggZnVuY3Rpb24gKCBtZW51SXRlbSApIHtcblx0XHRyZXR1cm4gbWVudUl0ZW0uaXNWaXNpYmxlKCk7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtZW51IGZvciB0aGlzIHdpZGdldC4gVGhpcyBpcyBpbiBhIHNlcGFyYXRlIG1ldGhvZCBzbyB0aGF0XG4gKiBjaGlsZCBjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBjb25zdHJ1Y3RvciB3aXRoXG4gKiB1bm5lY2Vzc2FyeSBleHRyYSBvYmplY3RzIHRoYXQgd2lsbCBiZSBvdmVyaWRkZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lbnVDb25maWcgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtPTy51aS5NZW51U2VsZWN0V2lkZ2V0fSBNZW51IHdpZGdldFxuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmNyZWF0ZU1lbnVXaWRnZXQgPSBmdW5jdGlvbiAoIG1lbnVDb25maWcgKSB7XG5cdHJldHVybiBuZXcgT08udWkuTWVudVNlbGVjdFdpZGdldCggbWVudUNvbmZpZyApO1xufTtcblxuLyoqXG4gKiBBZGQgb3B0aW9ucyB0byB0aGUgbWVudVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IG1lbnVPcHRpb25zIE9iamVjdCBkZWZpbmluZyBvcHRpb25zXG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuYWRkT3B0aW9ucyA9IGZ1bmN0aW9uICggbWVudU9wdGlvbnMgKSB7XG5cdHZhciB3aWRnZXQgPSB0aGlzLFxuXHRcdGl0ZW1zID0gbWVudU9wdGlvbnMubWFwKCBmdW5jdGlvbiAoIG9iaiApIHtcblx0XHRcdHJldHVybiB3aWRnZXQuY3JlYXRlTWVudU9wdGlvbldpZGdldCggb2JqLmRhdGEsIG9iai5sYWJlbCwgb2JqLmljb24gKTtcblx0XHR9ICk7XG5cblx0dGhpcy5tZW51LmFkZEl0ZW1zKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtZW51IG9wdGlvbiB3aWRnZXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgSXRlbSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXSBJdGVtIGxhYmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ljb25dIFN5bWJvbGljIGljb24gbmFtZVxuICogQHJldHVybiB7T08udWkuT3B0aW9uV2lkZ2V0fSBPcHRpb24gd2lkZ2V0XG4gKi9cbk9PLnVpLk1lbnVUYWdNdWx0aXNlbGVjdFdpZGdldC5wcm90b3R5cGUuY3JlYXRlTWVudU9wdGlvbldpZGdldCA9IGZ1bmN0aW9uICggZGF0YSwgbGFiZWwsIGljb24gKSB7XG5cdHJldHVybiBuZXcgT08udWkuTWVudU9wdGlvbldpZGdldCgge1xuXHRcdGRhdGE6IGRhdGEsXG5cdFx0bGFiZWw6IGxhYmVsIHx8IGRhdGEsXG5cdFx0aWNvbjogaWNvblxuXHR9ICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWVudVxuICpcbiAqIEByZXR1cm4ge09PLnVpLk1lbnVTZWxlY3RXaWRnZXR9IE1lbnVcbiAqL1xuT08udWkuTWVudVRhZ011bHRpc2VsZWN0V2lkZ2V0LnByb3RvdHlwZS5nZXRNZW51ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5tZW51O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFsbG93ZWQgdmFsdWVzIGxpc3RcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQWxsb3dlZCBkYXRhIHZhbHVlc1xuICovXG5PTy51aS5NZW51VGFnTXVsdGlzZWxlY3RXaWRnZXQucHJvdG90eXBlLmdldEFsbG93ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtZW51RGF0YXMgPSBbXTtcblx0aWYgKCB0aGlzLm1lbnUgKSB7XG5cdFx0Ly8gSWYgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBpcyBjYWxsaW5nIHVzLCB3ZSdyZSBub3QgcmVhZHkgeWV0LCB0aGlzLm1lbnUgaXMgbm90IHNldCB1cC5cblx0XHRtZW51RGF0YXMgPSB0aGlzLm1lbnUuZ2V0SXRlbXMoKS5tYXAoIGZ1bmN0aW9uICggbWVudUl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gbWVudUl0ZW0uZ2V0RGF0YSgpO1xuXHRcdH0gKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5hbGxvd2VkVmFsdWVzLmNvbmNhdCggbWVudURhdGFzICk7XG59O1xuXG4vKipcbiAqIFNlbGVjdEZpbGVXaWRnZXRzIGFsbG93IGZvciBzZWxlY3RpbmcgZmlsZXMsIHVzaW5nIHRoZSBIVE1MNSBGaWxlIEFQSS4gVGhlc2VcbiAqIHdpZGdldHMgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCB7QGxpbmsgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgaWNvbnN9LCB7QGxpbmtcbiAqIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgaW5kaWNhdG9yc30gYW5kIHtAbGluayBPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50IHRpdGxlc30uXG4gKiBQbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcy5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBBIGZpbGUgc2VsZWN0IHdpZGdldC5cbiAqICAgICB2YXIgc2VsZWN0RmlsZSA9IG5ldyBPTy51aS5TZWxlY3RGaWxlV2lkZ2V0KCk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggc2VsZWN0RmlsZS4kZWxlbWVudCApO1xuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2lkZ2V0c1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkljb25FbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uUGVuZGluZ0VsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uTGFiZWxFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ1tdfG51bGx9IFthY2NlcHQ9bnVsbF0gTUlNRSB0eXBlcyB0byBhY2NlcHQuIG51bGwgYWNjZXB0cyBhbGwgdHlwZXMuXG4gKiBAY2ZnIHtzdHJpbmd9IFtwbGFjZWhvbGRlcl0gVGV4dCB0byBkaXNwbGF5IHdoZW4gbm8gZmlsZSBpcyBzZWxlY3RlZC5cbiAqIEBjZmcge3N0cmluZ30gW25vdHN1cHBvcnRlZF0gVGV4dCB0byBkaXNwbGF5IHdoZW4gZmlsZSBzdXBwb3J0IGlzIG1pc3NpbmcgaW4gdGhlIGJyb3dzZXIuXG4gKiBAY2ZnIHtib29sZWFufSBbZHJvcHBhYmxlPXRydWVdIFdoZXRoZXIgdG8gYWNjZXB0IGZpbGVzIGJ5IGRyYWcgYW5kIGRyb3AuXG4gKiBAY2ZnIHtib29sZWFufSBbc2hvd0Ryb3BUYXJnZXQ9ZmFsc2VdIFdoZXRoZXIgdG8gc2hvdyBhIGRyb3AgdGFyZ2V0LiBSZXF1aXJlcyBkcm9wcGFibGUgdG8gYmUgdHJ1ZS5cbiAqIEBjZmcge251bWJlcn0gW3RodW1ibmFpbFNpemVMaW1pdD0yMF0gRmlsZSBzaXplIGxpbWl0IGluIE1pQiBhYm92ZSB3aGljaCB0byBub3QgdHJ5IGFuZCBzaG93IGFcbiAqICBwcmV2aWV3IChmb3IgcGVyZm9ybWFuY2UpXG4gKi9cbk9PLnVpLlNlbGVjdEZpbGVXaWRnZXQgPSBmdW5jdGlvbiBPb1VpU2VsZWN0RmlsZVdpZGdldCggY29uZmlnICkge1xuXHR2YXIgZHJhZ0hhbmRsZXI7XG5cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSAkLmV4dGVuZCgge1xuXHRcdGFjY2VwdDogbnVsbCxcblx0XHRwbGFjZWhvbGRlcjogT08udWkubXNnKCAnb291aS1zZWxlY3RmaWxlLXBsYWNlaG9sZGVyJyApLFxuXHRcdG5vdHN1cHBvcnRlZDogT08udWkubXNnKCAnb291aS1zZWxlY3RmaWxlLW5vdC1zdXBwb3J0ZWQnICksXG5cdFx0ZHJvcHBhYmxlOiB0cnVlLFxuXHRcdHNob3dEcm9wVGFyZ2V0OiBmYWxzZSxcblx0XHR0aHVtYm5haWxTaXplTGltaXQ6IDIwXG5cdH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uSWNvbkVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50LmNhbGwoIHRoaXMsICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7ICRwZW5kaW5nOiB0aGlzLiRpbmZvIH0gKSApO1xuXHRPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cdE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLiRpbmZvID0gJCggJzxzcGFuPicgKTtcblx0dGhpcy5zaG93RHJvcFRhcmdldCA9IGNvbmZpZy5zaG93RHJvcFRhcmdldDtcblx0dGhpcy50aHVtYm5haWxTaXplTGltaXQgPSBjb25maWcudGh1bWJuYWlsU2l6ZUxpbWl0O1xuXHR0aGlzLmlzU3VwcG9ydGVkID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuaXNTdXBwb3J0ZWQoKTtcblx0dGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnLmFjY2VwdCApICkge1xuXHRcdHRoaXMuYWNjZXB0ID0gY29uZmlnLmFjY2VwdDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmFjY2VwdCA9IG51bGw7XG5cdH1cblx0dGhpcy5wbGFjZWhvbGRlciA9IGNvbmZpZy5wbGFjZWhvbGRlcjtcblx0dGhpcy5ub3RzdXBwb3J0ZWQgPSBjb25maWcubm90c3VwcG9ydGVkO1xuXHR0aGlzLm9uRmlsZVNlbGVjdGVkSGFuZGxlciA9IHRoaXMub25GaWxlU2VsZWN0ZWQuYmluZCggdGhpcyApO1xuXG5cdHRoaXMuc2VsZWN0QnV0dG9uID0gbmV3IE9PLnVpLkJ1dHRvbldpZGdldCgge1xuXHRcdCRlbGVtZW50OiAkKCAnPGxhYmVsPicgKSxcblx0XHRjbGFzc2VzOiBbICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LXNlbGVjdEJ1dHRvbicgXSxcblx0XHRsYWJlbDogT08udWkubXNnKCAnb291aS1zZWxlY3RmaWxlLWJ1dHRvbi1zZWxlY3QnICksXG5cdFx0ZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuaXNTdXBwb3J0ZWRcblx0fSApO1xuXG5cdHRoaXMuY2xlYXJCdXR0b24gPSBuZXcgT08udWkuQnV0dG9uV2lkZ2V0KCB7XG5cdFx0Y2xhc3NlczogWyAnb28tdWktc2VsZWN0RmlsZVdpZGdldC1jbGVhckJ1dHRvbicgXSxcblx0XHRmcmFtZWQ6IGZhbHNlLFxuXHRcdGljb246ICdjbGVhcicsXG5cdFx0ZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcblx0fSApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLnNlbGVjdEJ1dHRvbi4kYnV0dG9uLm9uKCB7XG5cdFx0a2V5cHJlc3M6IHRoaXMub25LZXlQcmVzcy5iaW5kKCB0aGlzIClcblx0fSApO1xuXHR0aGlzLmNsZWFyQnV0dG9uLmNvbm5lY3QoIHRoaXMsIHtcblx0XHRjbGljazogJ29uQ2xlYXJDbGljaydcblx0fSApO1xuXHRpZiAoIGNvbmZpZy5kcm9wcGFibGUgKSB7XG5cdFx0ZHJhZ0hhbmRsZXIgPSB0aGlzLm9uRHJhZ0VudGVyT3JPdmVyLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLiRlbGVtZW50Lm9uKCB7XG5cdFx0XHRkcmFnZW50ZXI6IGRyYWdIYW5kbGVyLFxuXHRcdFx0ZHJhZ292ZXI6IGRyYWdIYW5kbGVyLFxuXHRcdFx0ZHJhZ2xlYXZlOiB0aGlzLm9uRHJhZ0xlYXZlLmJpbmQoIHRoaXMgKSxcblx0XHRcdGRyb3A6IHRoaXMub25Ecm9wLmJpbmQoIHRoaXMgKVxuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuYWRkSW5wdXQoKTtcblx0dGhpcy4kbGFiZWwuYWRkQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWxhYmVsJyApO1xuXHR0aGlzLiRpbmZvXG5cdFx0LmFkZENsYXNzKCAnb28tdWktc2VsZWN0RmlsZVdpZGdldC1pbmZvJyApXG5cdFx0LmFwcGVuZCggdGhpcy4kaWNvbiwgdGhpcy4kbGFiZWwsIHRoaXMuY2xlYXJCdXR0b24uJGVsZW1lbnQsIHRoaXMuJGluZGljYXRvciApO1xuXG5cdGlmICggY29uZmlnLmRyb3BwYWJsZSAmJiBjb25maWcuc2hvd0Ryb3BUYXJnZXQgKSB7XG5cdFx0dGhpcy5zZWxlY3RCdXR0b24uc2V0SWNvbiggJ3VwbG9hZCcgKTtcblx0XHR0aGlzLiR0aHVtYm5haWwgPSAkKCAnPGRpdj4nICkuYWRkQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LXRodW1ibmFpbCcgKTtcblx0XHR0aGlzLnNldFBlbmRpbmdFbGVtZW50KCB0aGlzLiR0aHVtYm5haWwgKTtcblx0XHR0aGlzLiRlbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWRyb3BUYXJnZXQgb28tdWktc2VsZWN0RmlsZVdpZGdldCcgKVxuXHRcdFx0Lm9uKCB7XG5cdFx0XHRcdGNsaWNrOiB0aGlzLm9uRHJvcFRhcmdldENsaWNrLmJpbmQoIHRoaXMgKVxuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHR0aGlzLiR0aHVtYm5haWwsXG5cdFx0XHRcdHRoaXMuJGluZm8sXG5cdFx0XHRcdHRoaXMuc2VsZWN0QnV0dG9uLiRlbGVtZW50LFxuXHRcdFx0XHQkKCAnPHNwYW4+JyApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCAnb28tdWktc2VsZWN0RmlsZVdpZGdldC1kcm9wTGFiZWwnIClcblx0XHRcdFx0XHQudGV4dCggT08udWkubXNnKCAnb291aS1zZWxlY3RmaWxlLWRyYWdkcm9wLXBsYWNlaG9sZGVyJyApIClcblx0XHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCAnb28tdWktc2VsZWN0RmlsZVdpZGdldCcgKVxuXHRcdFx0LmFwcGVuZCggdGhpcy4kaW5mbywgdGhpcy5zZWxlY3RCdXR0b24uJGVsZW1lbnQgKTtcblx0fVxuXHR0aGlzLnVwZGF0ZVVJKCk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlNlbGVjdEZpbGVXaWRnZXQsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuU2VsZWN0RmlsZVdpZGdldCwgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlNlbGVjdEZpbGVXaWRnZXQsIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlNlbGVjdEZpbGVXaWRnZXQsIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5TZWxlY3RGaWxlV2lkZ2V0LCBPTy51aS5taXhpbi5MYWJlbEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlNlbGVjdEZpbGVXaWRnZXQsIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnQgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHdpZGdldCBpcyBzdXBwb3J0ZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnN0YXRpYy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyICRpbnB1dDtcblx0aWYgKCBPTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnN0YXRpYy5pc1N1cHBvcnRlZENhY2hlID09PSBudWxsICkge1xuXHRcdCRpbnB1dCA9ICQoICc8aW5wdXQ+JyApLmF0dHIoICd0eXBlJywgJ2ZpbGUnICk7XG5cdFx0T08udWkuU2VsZWN0RmlsZVdpZGdldC5zdGF0aWMuaXNTdXBwb3J0ZWRDYWNoZSA9ICRpbnB1dFsgMCBdLmZpbGVzICE9PSB1bmRlZmluZWQ7XG5cdH1cblx0cmV0dXJuIE9PLnVpLlNlbGVjdEZpbGVXaWRnZXQuc3RhdGljLmlzU3VwcG9ydGVkQ2FjaGU7XG59O1xuXG5PTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnN0YXRpYy5pc1N1cHBvcnRlZENhY2hlID0gbnVsbDtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGNoYW5nZVxuICpcbiAqIEEgY2hhbmdlIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgb24vb2ZmIHN0YXRlIG9mIHRoZSB0b2dnbGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0ZpbGV8bnVsbH0gdmFsdWUgTmV3IHZhbHVlXG4gKi9cblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZmllbGRcbiAqXG4gKiBAcmV0dXJuIHtGaWxlfG51bGx9XG4gKi9cbk9PLnVpLlNlbGVjdEZpbGVXaWRnZXQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jdXJyZW50RmlsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBmaWVsZFxuICpcbiAqIEBwYXJhbSB7RmlsZXxudWxsfSBmaWxlIEZpbGUgdG8gc2VsZWN0XG4gKi9cbk9PLnVpLlNlbGVjdEZpbGVXaWRnZXQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXHRpZiAoIHRoaXMuY3VycmVudEZpbGUgIT09IGZpbGUgKSB7XG5cdFx0dGhpcy5jdXJyZW50RmlsZSA9IGZpbGU7XG5cdFx0dGhpcy51cGRhdGVVSSgpO1xuXHRcdHRoaXMuZW1pdCggJ2NoYW5nZScsIHRoaXMuY3VycmVudEZpbGUgKTtcblx0fVxufTtcblxuLyoqXG4gKiBGb2N1cyB0aGUgd2lkZ2V0LlxuICpcbiAqIEZvY3Vzc2VzIHRoZSBzZWxlY3QgZmlsZSBidXR0b24uXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuc2VsZWN0QnV0dG9uLmZvY3VzKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBCbHVyIHRoZSB3aWRnZXQuXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2lkZ2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZWxlY3RCdXR0b24uYmx1cigpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUuc2ltdWxhdGVMYWJlbENsaWNrID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdXNlciBpbnRlcmZhY2Ugd2hlbiBhIGZpbGUgaXMgc2VsZWN0ZWQgb3IgdW5zZWxlY3RlZFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUudXBkYXRlVUkgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciAkbGFiZWw7XG5cdGlmICggIXRoaXMuaXNTdXBwb3J0ZWQgKSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXNlbGVjdEZpbGVXaWRnZXQtbm90c3VwcG9ydGVkJyApO1xuXHRcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWVtcHR5JyApO1xuXHRcdHRoaXMuc2V0TGFiZWwoIHRoaXMubm90c3VwcG9ydGVkICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXNlbGVjdEZpbGVXaWRnZXQtc3VwcG9ydGVkJyApO1xuXHRcdGlmICggdGhpcy5jdXJyZW50RmlsZSApIHtcblx0XHRcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWVtcHR5JyApO1xuXHRcdFx0JGxhYmVsID0gJCggW10gKTtcblx0XHRcdCRsYWJlbCA9ICRsYWJlbC5hZGQoXG5cdFx0XHRcdCQoICc8c3Bhbj4nIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWZpbGVOYW1lJyApXG5cdFx0XHRcdFx0LnRleHQoIHRoaXMuY3VycmVudEZpbGUubmFtZSApXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5zZXRMYWJlbCggJGxhYmVsICk7XG5cblx0XHRcdGlmICggdGhpcy5zaG93RHJvcFRhcmdldCApIHtcblx0XHRcdFx0dGhpcy5wdXNoUGVuZGluZygpO1xuXHRcdFx0XHR0aGlzLmxvYWRBbmRHZXRJbWFnZVVybCgpLmRvbmUoIGZ1bmN0aW9uICggdXJsICkge1xuXHRcdFx0XHRcdHRoaXMuJHRodW1ibmFpbC5jc3MoICdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybCggJyArIHVybCArICcgKScgKTtcblx0XHRcdFx0fS5iaW5kKCB0aGlzICkgKS5mYWlsKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy4kdGh1bWJuYWlsLmFwcGVuZChcblx0XHRcdFx0XHRcdG5ldyBPTy51aS5JY29uV2lkZ2V0KCB7XG5cdFx0XHRcdFx0XHRcdGljb246ICdhdHRhY2htZW50Jyxcblx0XHRcdFx0XHRcdFx0Y2xhc3NlczogWyAnb28tdWktc2VsZWN0RmlsZVdpZGdldC1ub1RodW1ibmFpbC1pY29uJyBdXG5cdFx0XHRcdFx0XHR9ICkuJGVsZW1lbnRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LmJpbmQoIHRoaXMgKSApLmFsd2F5cyggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMucG9wUGVuZGluZygpO1xuXHRcdFx0XHR9LmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0XHR0aGlzLiRlbGVtZW50Lm9mZiggJ2NsaWNrJyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHRoaXMuc2hvd0Ryb3BUYXJnZXQgKSB7XG5cdFx0XHRcdHRoaXMuJGVsZW1lbnQub2ZmKCAnY2xpY2snICk7XG5cdFx0XHRcdHRoaXMuJGVsZW1lbnQub24oIHtcblx0XHRcdFx0XHRjbGljazogdGhpcy5vbkRyb3BUYXJnZXRDbGljay5iaW5kKCB0aGlzIClcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLiR0aHVtYm5haWxcblx0XHRcdFx0XHQuZW1wdHkoKVxuXHRcdFx0XHRcdC5jc3MoICdiYWNrZ3JvdW5kLWltYWdlJywgJycgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWVtcHR5JyApO1xuXHRcdFx0dGhpcy5zZXRMYWJlbCggdGhpcy5wbGFjZWhvbGRlciApO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgZmlsZSBpcyBhbiBpbWFnZSwgZ2V0IGl0cyBVUkwgYW5kIGxvYWQgaXQuXG4gKlxuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgaW1hZ2UgVVJMIGFmdGVyIGl0IGhhcyBsb2FkZWRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUubG9hZEFuZEdldEltYWdlVXJsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG5cdFx0ZmlsZSA9IHRoaXMuY3VycmVudEZpbGUsXG5cdFx0cmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuXHRpZiAoXG5cdFx0ZmlsZSAmJlxuXHRcdCggT08uZ2V0UHJvcCggZmlsZSwgJ3R5cGUnICkgfHwgJycgKS5pbmRleE9mKCAnaW1hZ2UvJyApID09PSAwICYmXG5cdFx0ZmlsZS5zaXplIDwgdGhpcy50aHVtYm5haWxTaXplTGltaXQgKiAxMDI0ICogMTAyNFxuXHQpIHtcblx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW1nJyApO1xuXHRcdFx0aW1nLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aW1nLm5hdHVyYWxXaWR0aCA9PT0gMCB8fFxuXHRcdFx0XHRcdGltZy5uYXR1cmFsSGVpZ2h0ID09PSAwIHx8XG5cdFx0XHRcdFx0aW1nLmNvbXBsZXRlID09PSBmYWxzZVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKCBldmVudC50YXJnZXQucmVzdWx0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGltZy5zcmMgPSBldmVudC50YXJnZXQucmVzdWx0O1xuXHRcdH07XG5cdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoIGZpbGUgKTtcblx0fSBlbHNlIHtcblx0XHRkZWZlcnJlZC5yZWplY3QoKTtcblx0fVxuXG5cdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgaW5wdXQgdG8gdGhlIHdpZGdldFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk9PLnVpLlNlbGVjdEZpbGVXaWRnZXQucHJvdG90eXBlLmFkZElucHV0ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuJGlucHV0ICkge1xuXHRcdHRoaXMuJGlucHV0LnJlbW92ZSgpO1xuXHR9XG5cblx0aWYgKCAhdGhpcy5pc1N1cHBvcnRlZCApIHtcblx0XHR0aGlzLiRpbnB1dCA9IG51bGw7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy4kaW5wdXQgPSAkKCAnPGlucHV0PicgKS5hdHRyKCAndHlwZScsICdmaWxlJyApO1xuXHR0aGlzLiRpbnB1dC5vbiggJ2NoYW5nZScsIHRoaXMub25GaWxlU2VsZWN0ZWRIYW5kbGVyICk7XG5cdHRoaXMuJGlucHV0Lm9uKCAnY2xpY2snLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0Ly8gUHJldmVudHMgZHJvcFRhcmdldCB0byBnZXQgY2xpY2tlZCB3aGljaCBjYWxsc1xuXHRcdC8vIGEgY2xpY2sgb24gdGhpcyBpbnB1dFxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0gKTtcblx0dGhpcy4kaW5wdXQuYXR0cigge1xuXHRcdHRhYmluZGV4OiAtMVxuXHR9ICk7XG5cdGlmICggdGhpcy5hY2NlcHQgKSB7XG5cdFx0dGhpcy4kaW5wdXQuYXR0ciggJ2FjY2VwdCcsIHRoaXMuYWNjZXB0LmpvaW4oICcsICcgKSApO1xuXHR9XG5cdHRoaXMuc2VsZWN0QnV0dG9uLiRidXR0b24uYXBwZW5kKCB0aGlzLiRpbnB1dCApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGFjY2VwdCB0aGlzIGZpbGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIEZpbGUgTUlNRSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnByb3RvdHlwZS5pc0FsbG93ZWRUeXBlID0gZnVuY3Rpb24gKCBtaW1lVHlwZSApIHtcblx0dmFyIGksIG1pbWVUZXN0O1xuXG5cdGlmICggIXRoaXMuYWNjZXB0IHx8ICFtaW1lVHlwZSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5hY2NlcHQubGVuZ3RoOyBpKysgKSB7XG5cdFx0bWltZVRlc3QgPSB0aGlzLmFjY2VwdFsgaSBdO1xuXHRcdGlmICggbWltZVRlc3QgPT09IG1pbWVUeXBlICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmICggbWltZVRlc3Quc3Vic3RyKCAtMiApID09PSAnLyonICkge1xuXHRcdFx0bWltZVRlc3QgPSBtaW1lVGVzdC5zdWJzdHIoIDAsIG1pbWVUZXN0Lmxlbmd0aCAtIDEgKTtcblx0XHRcdGlmICggbWltZVR5cGUuc3Vic3RyKCAwLCBtaW1lVGVzdC5sZW5ndGggKSA9PT0gbWltZVRlc3QgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGZpbGUgc2VsZWN0aW9uIGZyb20gdGhlIGlucHV0XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlXG4gKi9cbk9PLnVpLlNlbGVjdEZpbGVXaWRnZXQucHJvdG90eXBlLm9uRmlsZVNlbGVjdGVkID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgZmlsZSA9IE9PLmdldFByb3AoIGUudGFyZ2V0LCAnZmlsZXMnLCAwICkgfHwgbnVsbDtcblxuXHRpZiAoIGZpbGUgJiYgIXRoaXMuaXNBbGxvd2VkVHlwZSggZmlsZS50eXBlICkgKSB7XG5cdFx0ZmlsZSA9IG51bGw7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlKCBmaWxlICk7XG5cdHRoaXMuYWRkSW5wdXQoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGNsZWFyIGJ1dHRvbiBjbGljayBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnByb3RvdHlwZS5vbkNsZWFyQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuc2V0VmFsdWUoIG51bGwgKTtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGUga2V5IHByZXNzIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgS2V5IHByZXNzIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICggZSApIHtcblx0aWYgKCB0aGlzLmlzU3VwcG9ydGVkICYmICF0aGlzLmlzRGlzYWJsZWQoKSAmJiB0aGlzLiRpbnB1dCAmJlxuXHRcdCggZS53aGljaCA9PT0gT08udWkuS2V5cy5TUEFDRSB8fCBlLndoaWNoID09PSBPTy51aS5LZXlzLkVOVEVSIClcblx0KSB7XG5cdFx0dGhpcy4kaW5wdXQuY2xpY2soKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGRyb3AgdGFyZ2V0IGNsaWNrIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgS2V5IHByZXNzIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUub25Ecm9wVGFyZ2V0Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy5pc1N1cHBvcnRlZCAmJiAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgdGhpcy4kaW5wdXQgKSB7XG5cdFx0dGhpcy4kaW5wdXQuY2xpY2soKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGRyYWcgZW50ZXIgYW5kIG92ZXIgZXZlbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIERyYWcgZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnByb3RvdHlwZS5vbkRyYWdFbnRlck9yT3ZlciA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyIGl0ZW1PckZpbGUsXG5cdFx0ZHJvcHBhYmxlRmlsZSA9IGZhbHNlLFxuXHRcdGR0ID0gZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2ZlcjtcblxuXHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0aWYgKCB0aGlzLmlzRGlzYWJsZWQoKSB8fCAhdGhpcy5pc1N1cHBvcnRlZCApIHtcblx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCAnb28tdWktc2VsZWN0RmlsZVdpZGdldC1jYW5Ecm9wJyApO1xuXHRcdGR0LmRyb3BFZmZlY3QgPSAnbm9uZSc7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gRGF0YVRyYW5zZmVySXRlbSBhbmQgRmlsZSBib3RoIGhhdmUgYSB0eXBlIHByb3BlcnR5LCBidXQgaW4gQ2hyb21lIGZpbGVzXG5cdC8vIGhhdmUgbm8gaW5mb3JtYXRpb24gYXQgdGhpcyBwb2ludC5cblx0aXRlbU9yRmlsZSA9IE9PLmdldFByb3AoIGR0LCAnaXRlbXMnLCAwICkgfHwgT08uZ2V0UHJvcCggZHQsICdmaWxlcycsIDAgKTtcblx0aWYgKCBpdGVtT3JGaWxlICkge1xuXHRcdGlmICggdGhpcy5pc0FsbG93ZWRUeXBlKCBpdGVtT3JGaWxlLnR5cGUgKSApIHtcblx0XHRcdGRyb3BwYWJsZUZpbGUgPSB0cnVlO1xuXHRcdH1cblx0Ly8gZHQudHlwZXMgaXMgQXJyYXktbGlrZSwgYnV0IG5vdCBhbiBBcnJheVxuXHR9IGVsc2UgaWYgKCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKCBPTy5nZXRQcm9wKCBkdCwgJ3R5cGVzJyApIHx8IFtdLCAnRmlsZXMnICkgIT09IC0xICkge1xuXHRcdC8vIEZpbGUgaW5mb3JtYXRpb24gaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGZvciBzZWN1cml0eSBzbyBqdXN0IGFzc3VtZVxuXHRcdC8vIGl0IGlzIGFjY2VwdGFibGUgZm9yIG5vdy5cblx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDA1MzRcblx0XHRkcm9wcGFibGVGaWxlID0gdHJ1ZTtcblx0fVxuXG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWNhbkRyb3AnLCBkcm9wcGFibGVGaWxlICk7XG5cdGlmICggIWRyb3BwYWJsZUZpbGUgKSB7XG5cdFx0ZHQuZHJvcEVmZmVjdCA9ICdub25lJztcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGRyYWcgbGVhdmUgZXZlbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIERyYWcgZXZlbnRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUub25EcmFnTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoICdvby11aS1zZWxlY3RGaWxlV2lkZ2V0LWNhbkRyb3AnICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBkcm9wIGV2ZW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBEcm9wIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUub25Ecm9wID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgZmlsZSA9IG51bGwsXG5cdFx0ZHQgPSBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO1xuXG5cdGUucHJldmVudERlZmF1bHQoKTtcblx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLXNlbGVjdEZpbGVXaWRnZXQtY2FuRHJvcCcgKTtcblxuXHRpZiAoIHRoaXMuaXNEaXNhYmxlZCgpIHx8ICF0aGlzLmlzU3VwcG9ydGVkICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZpbGUgPSBPTy5nZXRQcm9wKCBkdCwgJ2ZpbGVzJywgMCApO1xuXHRpZiAoIGZpbGUgJiYgIXRoaXMuaXNBbGxvd2VkVHlwZSggZmlsZS50eXBlICkgKSB7XG5cdFx0ZmlsZSA9IG51bGw7XG5cdH1cblx0aWYgKCBmaWxlICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIGZpbGUgKTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuU2VsZWN0RmlsZVdpZGdldC5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbiAoIGRpc2FibGVkICkge1xuXHRPTy51aS5TZWxlY3RGaWxlV2lkZ2V0LnBhcmVudC5wcm90b3R5cGUuc2V0RGlzYWJsZWQuY2FsbCggdGhpcywgZGlzYWJsZWQgKTtcblx0aWYgKCB0aGlzLnNlbGVjdEJ1dHRvbiApIHtcblx0XHR0aGlzLnNlbGVjdEJ1dHRvbi5zZXREaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fVxuXHRpZiAoIHRoaXMuY2xlYXJCdXR0b24gKSB7XG5cdFx0dGhpcy5jbGVhckJ1dHRvbi5zZXREaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VhcmNoV2lkZ2V0cyBjb21iaW5lIGEge0BsaW5rIE9PLnVpLlRleHRJbnB1dFdpZGdldCB0ZXh0IGlucHV0IGZpZWxkfSwgd2hlcmUgdXNlcnMgY2FuIHR5cGUgYSBzZWFyY2ggcXVlcnksXG4gKiBhbmQgYSBtZW51IG9mIHNlYXJjaCByZXN1bHRzLCB3aGljaCBpcyBkaXNwbGF5ZWQgYmVuZWF0aCB0aGUgcXVlcnlcbiAqIGZpZWxkLiBVbmxpa2Uge0BsaW5rIE9PLnVpLm1peGluLkxvb2t1cEVsZW1lbnQgbG9va3VwIG1lbnVzfSwgc2VhcmNoIHJlc3VsdCBtZW51cyBhcmUgYWx3YXlzIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gKiBVc2VycyBjYW4gY2hvb3NlIGFuIGl0ZW0gZnJvbSB0aGUgbWVudSBvciB0eXBlIGEgcXVlcnkgaW50byB0aGUgdGV4dCBmaWVsZCB0byBzZWFyY2ggZm9yIGEgbWF0Y2hpbmcgcmVzdWx0IGl0ZW0uXG4gKiBJbiBnZW5lcmFsLCBzZWFyY2ggd2lkZ2V0cyBhcmUgdXNlZCBpbnNpZGUgYSBzZXBhcmF0ZSB7QGxpbmsgT08udWkuRGlhbG9nIGRpYWxvZ30gd2luZG93LlxuICpcbiAqIEVhY2ggdGltZSB0aGUgcXVlcnkgaXMgY2hhbmdlZCwgdGhlIHNlYXJjaCByZXN1bHQgbWVudSBpcyBjbGVhcmVkIGFuZCByZXBvcHVsYXRlZC4gUGxlYXNlIHNlZVxuICogdGhlIFtPT1VJIGRlbW9zXVsxXSBmb3IgYW4gZXhhbXBsZS5cbiAqXG4gKiBbMV06IGh0dHBzOi8vZG9jLndpa2ltZWRpYS5vcmcvb29qcy11aS9tYXN0ZXIvZGVtb3MvI1NlYXJjaElucHV0V2lkZ2V0LXR5cGUtc2VhcmNoXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ3xqUXVlcnl9IFtwbGFjZWhvbGRlcl0gUGxhY2Vob2xkZXIgdGV4dCBmb3IgcXVlcnkgaW5wdXRcbiAqIEBjZmcge3N0cmluZ30gW3ZhbHVlXSBJbml0aWFsIHF1ZXJ5IHZhbHVlXG4gKi9cbk9PLnVpLlNlYXJjaFdpZGdldCA9IGZ1bmN0aW9uIE9vVWlTZWFyY2hXaWRnZXQoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlNlYXJjaFdpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnF1ZXJ5ID0gbmV3IE9PLnVpLlRleHRJbnB1dFdpZGdldCgge1xuXHRcdGljb246ICdzZWFyY2gnLFxuXHRcdHBsYWNlaG9sZGVyOiBjb25maWcucGxhY2Vob2xkZXIsXG5cdFx0dmFsdWU6IGNvbmZpZy52YWx1ZVxuXHR9ICk7XG5cdHRoaXMucmVzdWx0cyA9IG5ldyBPTy51aS5TZWxlY3RXaWRnZXQoKTtcblx0dGhpcy4kcXVlcnkgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJHJlc3VsdHMgPSAkKCAnPGRpdj4nICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMucXVlcnkuY29ubmVjdCggdGhpcywge1xuXHRcdGNoYW5nZTogJ29uUXVlcnlDaGFuZ2UnLFxuXHRcdGVudGVyOiAnb25RdWVyeUVudGVyJ1xuXHR9ICk7XG5cdHRoaXMucXVlcnkuJGlucHV0Lm9uKCAna2V5ZG93bicsIHRoaXMub25RdWVyeUtleWRvd24uYmluZCggdGhpcyApICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kcXVlcnlcblx0XHQuYWRkQ2xhc3MoICdvby11aS1zZWFyY2hXaWRnZXQtcXVlcnknIClcblx0XHQuYXBwZW5kKCB0aGlzLnF1ZXJ5LiRlbGVtZW50ICk7XG5cdHRoaXMuJHJlc3VsdHNcblx0XHQuYWRkQ2xhc3MoICdvby11aS1zZWFyY2hXaWRnZXQtcmVzdWx0cycgKVxuXHRcdC5hcHBlbmQoIHRoaXMucmVzdWx0cy4kZWxlbWVudCApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktc2VhcmNoV2lkZ2V0JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kcmVzdWx0cywgdGhpcy4kcXVlcnkgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuU2VhcmNoV2lkZ2V0LCBPTy51aS5XaWRnZXQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSBxdWVyeSBrZXkgZG93biBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIEtleSBkb3duIGV2ZW50XG4gKi9cbk9PLnVpLlNlYXJjaFdpZGdldC5wcm90b3R5cGUub25RdWVyeUtleWRvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBoaWdobGlnaHRlZEl0ZW0sIG5leHRJdGVtLFxuXHRcdGRpciA9IGUud2hpY2ggPT09IE9PLnVpLktleXMuRE9XTiA/IDEgOiAoIGUud2hpY2ggPT09IE9PLnVpLktleXMuVVAgPyAtMSA6IDAgKTtcblxuXHRpZiAoIGRpciApIHtcblx0XHRoaWdobGlnaHRlZEl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZEhpZ2hsaWdodGVkSXRlbSgpO1xuXHRcdGlmICggIWhpZ2hsaWdodGVkSXRlbSApIHtcblx0XHRcdGhpZ2hsaWdodGVkSXRlbSA9IHRoaXMucmVzdWx0cy5maW5kU2VsZWN0ZWRJdGVtKCk7XG5cdFx0fVxuXHRcdG5leHRJdGVtID0gdGhpcy5yZXN1bHRzLmZpbmRSZWxhdGl2ZVNlbGVjdGFibGVJdGVtKCBoaWdobGlnaHRlZEl0ZW0sIGRpciApO1xuXHRcdHRoaXMucmVzdWx0cy5oaWdobGlnaHRJdGVtKCBuZXh0SXRlbSApO1xuXHRcdG5leHRJdGVtLnNjcm9sbEVsZW1lbnRJbnRvVmlldygpO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBzZWxlY3Qgd2lkZ2V0IHNlbGVjdCBldmVudHMuXG4gKlxuICogQ2xlYXJzIGV4aXN0aW5nIHJlc3VsdHMuIFN1YmNsYXNzZXMgc2hvdWxkIHJlcG9wdWxhdGUgaXRlbXMgYWNjb3JkaW5nIHRvIG5ldyBxdWVyeS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIE5ldyB2YWx1ZVxuICovXG5PTy51aS5TZWFyY2hXaWRnZXQucHJvdG90eXBlLm9uUXVlcnlDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFJlc2V0XG5cdHRoaXMucmVzdWx0cy5jbGVhckl0ZW1zKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBzZWxlY3Qgd2lkZ2V0IGVudGVyIGtleSBldmVudHMuXG4gKlxuICogQ2hvb3NlcyBoaWdobGlnaHRlZCBpdGVtLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgTmV3IHZhbHVlXG4gKi9cbk9PLnVpLlNlYXJjaFdpZGdldC5wcm90b3R5cGUub25RdWVyeUVudGVyID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaGlnaGxpZ2h0ZWRJdGVtID0gdGhpcy5yZXN1bHRzLmZpbmRIaWdobGlnaHRlZEl0ZW0oKTtcblx0aWYgKCBoaWdobGlnaHRlZEl0ZW0gKSB7XG5cdFx0dGhpcy5yZXN1bHRzLmNob29zZUl0ZW0oIGhpZ2hsaWdodGVkSXRlbSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVlcnkgaW5wdXQuXG4gKlxuICogQHJldHVybiB7T08udWkuVGV4dElucHV0V2lkZ2V0fSBRdWVyeSBpbnB1dFxuICovXG5PTy51aS5TZWFyY2hXaWRnZXQucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5xdWVyeTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzZWFyY2ggcmVzdWx0cyBtZW51LlxuICpcbiAqIEByZXR1cm4ge09PLnVpLlNlbGVjdFdpZGdldH0gTWVudSBvZiBzZWFyY2ggcmVzdWx0c1xuICovXG5PTy51aS5TZWFyY2hXaWRnZXQucHJvdG90eXBlLmdldFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnJlc3VsdHM7XG59O1xuXG59KCBPTyApICk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9vanMtdWktd2lkZ2V0cy5qcy5tYXAuanNvblxuLyohXG4gKiBPT1VJIHYwLjMwLjJcbiAqIGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJXG4gKlxuICogQ29weXJpZ2h0IDIwMTHigJMyMDE5IE9PVUkgVGVhbSBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vb29qcy5taXQtbGljZW5zZS5vcmdcbiAqXG4gKiBEYXRlOiAyMDE5LTAxLTIzVDAxOjE0OjIwWlxuICovXG4oIGZ1bmN0aW9uICggT08gKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUb29sYmFycyBhcmUgY29tcGxleCBpbnRlcmZhY2UgY29tcG9uZW50cyB0aGF0IHBlcm1pdCB1c2VycyB0byBlYXNpbHkgYWNjZXNzIGEgdmFyaWV0eVxuICogb2Yge0BsaW5rIE9PLnVpLlRvb2wgdG9vbHN9IChlLmcuLCBmb3JtYXR0aW5nIGNvbW1hbmRzKSBhbmQgYWN0aW9ucywgd2hpY2ggYXJlIGFkZGl0aW9uYWwgY29tbWFuZHMgdGhhdCBhcmVcbiAqIHBhcnQgb2YgdGhlIHRvb2xiYXIsIGJ1dCBub3QgY29uZmlndXJlZCBhcyB0b29scy5cbiAqXG4gKiBJbmRpdmlkdWFsIHRvb2xzIGFyZSBjdXN0b21pemVkIGFuZCB0aGVuIHJlZ2lzdGVyZWQgd2l0aCBhIHtAbGluayBPTy51aS5Ub29sRmFjdG9yeSB0b29sIGZhY3Rvcnl9LCB3aGljaCBjcmVhdGVzXG4gKiB0aGUgdG9vbHMgb24gZGVtYW5kLiBFYWNoIHRvb2wgaGFzIGEgc3ltYm9saWMgbmFtZSAodXNlZCB3aGVuIHJlZ2lzdGVyaW5nIHRoZSB0b29sKSwgYSB0aXRsZSAoZS5nLiwg4oCYSW5zZXJ0XG4gKiBpbWFnZeKAmSksIGFuZCBhbiBpY29uLlxuICpcbiAqIEluZGl2aWR1YWwgdG9vbHMgYXJlIG9yZ2FuaXplZCBpbiB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cHN9LCB3aGljaCBjYW4gYmUge0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgbWVudXN9XG4gKiBvZiB0b29scywge0BsaW5rIE9PLnVpLkxpc3RUb29sR3JvdXAgbGlzdHN9IG9mIHRvb2xzLCBvciBhIHNpbmdsZSB7QGxpbmsgT08udWkuQmFyVG9vbEdyb3VwIGJhcn0gb2YgdG9vbHMuXG4gKiBUaGUgYXJyYW5nZW1lbnQgYW5kIG9yZGVyIG9mIHRoZSB0b29sZ3JvdXBzIGlzIGN1c3RvbWl6ZWQgd2hlbiB0aGUgdG9vbGJhciBpcyBzZXQgdXAuIFRvb2xzIGNhbiBiZSBwcmVzZW50ZWQgaW5cbiAqIGFueSBvcmRlciwgYnV0IGVhY2ggY2FuIG9ubHkgYXBwZWFyIG9uY2UgaW4gdGhlIHRvb2xiYXIuXG4gKlxuICogVGhlIHRvb2xiYXIgY2FuIGJlIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgZXh0ZXJuYWwgXCJhcHBsaWNhdGlvblwiLCBsaWtlIGEgdGV4dFxuICogZWRpdG9yJ3MgZWRpdGluZyBhcmVhLCBtYXJraW5nIHRvb2xzIGFzIGFjdGl2ZS9pbmFjdGl2ZSAoZS5nLiBhICdib2xkJyB0b29sIHdvdWxkIGJlIHNob3duIGFzXG4gKiBhY3RpdmUgd2hlbiB0aGUgdGV4dCBjdXJzb3Igd2FzIGluc2lkZSBib2xkZWQgdGV4dCkgb3IgZW5hYmxlZC9kaXNhYmxlZCAoZS5nLiBhIHRhYmxlIGNhcHRpb25cbiAqIHRvb2wgd291bGQgYmUgZGlzYWJsZWQgd2hpbGUgdGhlIHVzZXIgaXMgbm90IGVkaXRpbmcgYSB0YWJsZSkuIEEgc3RhdGUgY2hhbmdlIGlzIHNpZ25hbGxlZCBieVxuICogZW1pdHRpbmcgdGhlIHtAbGluayAjZXZlbnQtdXBkYXRlU3RhdGUgJ3VwZGF0ZVN0YXRlJyBldmVudH0sIHdoaWNoIGNhbGxzIFRvb2xzJ1xuICoge0BsaW5rIE9PLnVpLlRvb2wjb25VcGRhdGVTdGF0ZSBvblVwZGF0ZVN0YXRlIG1ldGhvZH0uXG4gKlxuICogVGhlIGZvbGxvd2luZyBpcyBhbiBleGFtcGxlIG9mIGEgYmFzaWMgdG9vbGJhci5cbiAqXG4gKiAgICAgQGV4YW1wbGVcbiAqICAgICAvLyBFeGFtcGxlIG9mIGEgdG9vbGJhclxuICogICAgIC8vIENyZWF0ZSB0aGUgdG9vbGJhclxuICogICAgIHZhciB0b29sRmFjdG9yeSA9IG5ldyBPTy51aS5Ub29sRmFjdG9yeSgpO1xuICogICAgIHZhciB0b29sR3JvdXBGYWN0b3J5ID0gbmV3IE9PLnVpLlRvb2xHcm91cEZhY3RvcnkoKTtcbiAqICAgICB2YXIgdG9vbGJhciA9IG5ldyBPTy51aS5Ub29sYmFyKCB0b29sRmFjdG9yeSwgdG9vbEdyb3VwRmFjdG9yeSApO1xuICpcbiAqICAgICAvLyBXZSB3aWxsIGJlIHBsYWNpbmcgc3RhdHVzIHRleHQgaW4gdGhpcyBlbGVtZW50IHdoZW4gdG9vbHMgYXJlIHVzZWRcbiAqICAgICB2YXIgJGFyZWEgPSAkKCAnPHA+JyApLnRleHQoICdUb29sYmFyIGV4YW1wbGUnICk7XG4gKlxuICogICAgIC8vIERlZmluZSB0aGUgdG9vbHMgdGhhdCB3ZSdyZSBnb2luZyB0byBwbGFjZSBpbiBvdXIgdG9vbGJhclxuICpcbiAqICAgICAvLyBDcmVhdGUgYSBjbGFzcyBpbmhlcml0aW5nIGZyb20gT08udWkuVG9vbFxuICogICAgIGZ1bmN0aW9uIFNlYXJjaFRvb2woKSB7XG4gKiAgICAgICAgIFNlYXJjaFRvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBTZWFyY2hUb29sLCBPTy51aS5Ub29sICk7XG4gKiAgICAgLy8gRWFjaCB0b29sIG11c3QgaGF2ZSBhICduYW1lJyAodXNlZCBhcyBhbiBpbnRlcm5hbCBpZGVudGlmaWVyLCBzZWUgbGF0ZXIpIGFuZCBhdCBsZWFzdCBvbmVcbiAqICAgICAvLyBvZiAnaWNvbicgYW5kICd0aXRsZScgKGRpc3BsYXllZCBpY29uIGFuZCB0ZXh0KS5cbiAqICAgICBTZWFyY2hUb29sLnN0YXRpYy5uYW1lID0gJ3NlYXJjaCc7XG4gKiAgICAgU2VhcmNoVG9vbC5zdGF0aWMuaWNvbiA9ICdzZWFyY2gnO1xuICogICAgIFNlYXJjaFRvb2wuc3RhdGljLnRpdGxlID0gJ1NlYXJjaC4uLic7XG4gKiAgICAgLy8gRGVmaW5lcyB0aGUgYWN0aW9uIHRoYXQgd2lsbCBoYXBwZW4gd2hlbiB0aGlzIHRvb2wgaXMgc2VsZWN0ZWQgKGNsaWNrZWQpLlxuICogICAgIFNlYXJjaFRvb2wucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICAkYXJlYS50ZXh0KCAnU2VhcmNoIHRvb2wgY2xpY2tlZCEnICk7XG4gKiAgICAgICAgIC8vIE5ldmVyIGRpc3BsYXkgdGhpcyB0b29sIGFzIFwiYWN0aXZlXCIgKHNlbGVjdGVkKS5cbiAqICAgICAgICAgdGhpcy5zZXRBY3RpdmUoIGZhbHNlICk7XG4gKiAgICAgfTtcbiAqICAgICBTZWFyY2hUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge307XG4gKiAgICAgLy8gTWFrZSB0aGlzIHRvb2wgYXZhaWxhYmxlIGluIG91ciB0b29sRmFjdG9yeSBhbmQgdGh1cyBvdXIgdG9vbGJhclxuICogICAgIHRvb2xGYWN0b3J5LnJlZ2lzdGVyKCBTZWFyY2hUb29sICk7XG4gKlxuICogICAgIC8vIFJlZ2lzdGVyIHR3byBtb3JlIHRvb2xzLCBub3RoaW5nIGludGVyZXN0aW5nIGhlcmVcbiAqICAgICBmdW5jdGlvbiBTZXR0aW5nc1Rvb2woKSB7XG4gKiAgICAgICAgIFNldHRpbmdzVG9vbC5wYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIFNldHRpbmdzVG9vbCwgT08udWkuVG9vbCApO1xuICogICAgIFNldHRpbmdzVG9vbC5zdGF0aWMubmFtZSA9ICdzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy5pY29uID0gJ3NldHRpbmdzJztcbiAqICAgICBTZXR0aW5nc1Rvb2wuc3RhdGljLnRpdGxlID0gJ0NoYW5nZSBzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnByb3RvdHlwZS5vblNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgJGFyZWEudGV4dCggJ1NldHRpbmdzIHRvb2wgY2xpY2tlZCEnICk7XG4gKiAgICAgICAgIHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xuICogICAgIH07XG4gKiAgICAgU2V0dGluZ3NUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge307XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFNldHRpbmdzVG9vbCApO1xuICpcbiAqICAgICAvLyBSZWdpc3RlciB0d28gbW9yZSB0b29scywgbm90aGluZyBpbnRlcmVzdGluZyBoZXJlXG4gKiAgICAgZnVuY3Rpb24gU3R1ZmZUb29sKCkge1xuICogICAgICAgICBTdHVmZlRvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBTdHVmZlRvb2wsIE9PLnVpLlRvb2wgKTtcbiAqICAgICBTdHVmZlRvb2wuc3RhdGljLm5hbWUgPSAnc3R1ZmYnO1xuICogICAgIFN0dWZmVG9vbC5zdGF0aWMuaWNvbiA9ICdlbGxpcHNpcyc7XG4gKiAgICAgU3R1ZmZUb29sLnN0YXRpYy50aXRsZSA9ICdNb3JlIHN0dWZmJztcbiAqICAgICBTdHVmZlRvb2wucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICAkYXJlYS50ZXh0KCAnTW9yZSBzdHVmZiB0b29sIGNsaWNrZWQhJyApO1xuICogICAgICAgICB0aGlzLnNldEFjdGl2ZSggZmFsc2UgKTtcbiAqICAgICB9O1xuICogICAgIFN0dWZmVG9vbC5wcm90b3R5cGUub25VcGRhdGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuICogICAgIHRvb2xGYWN0b3J5LnJlZ2lzdGVyKCBTdHVmZlRvb2wgKTtcbiAqXG4gKiAgICAgLy8gVGhpcyBpcyBhIFBvcHVwVG9vbC4gUmF0aGVyIHRoYW4gaGF2aW5nIGEgY3VzdG9tICdvblNlbGVjdCcgYWN0aW9uLCBpdCB3aWxsIGRpc3BsYXkgYVxuICogICAgIC8vIGxpdHRsZSBwb3B1cCB3aW5kb3cgKGEgUG9wdXBXaWRnZXQpLlxuICogICAgIGZ1bmN0aW9uIEhlbHBUb29sKCB0b29sR3JvdXAsIGNvbmZpZyApIHtcbiAqICAgICAgICAgT08udWkuUG9wdXBUb29sLmNhbGwoIHRoaXMsIHRvb2xHcm91cCwgJC5leHRlbmQoIHsgcG9wdXA6IHtcbiAqICAgICAgICAgICAgIHBhZGRlZDogdHJ1ZSxcbiAqICAgICAgICAgICAgIGxhYmVsOiAnSGVscCcsXG4gKiAgICAgICAgICAgICBoZWFkOiB0cnVlXG4gKiAgICAgICAgIH0gfSwgY29uZmlnICkgKTtcbiAqICAgICAgICAgdGhpcy5wb3B1cC4kYm9keS5hcHBlbmQoICc8cD5JIGFtIGhlbHBmdWwhPC9wPicgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBIZWxwVG9vbCwgT08udWkuUG9wdXBUb29sICk7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLm5hbWUgPSAnaGVscCc7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLmljb24gPSAnaGVscCc7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLnRpdGxlID0gJ0hlbHAnO1xuICogICAgIHRvb2xGYWN0b3J5LnJlZ2lzdGVyKCBIZWxwVG9vbCApO1xuICpcbiAqICAgICAvLyBGaW5hbGx5IGRlZmluZSB3aGljaCB0b29scyBhbmQgaW4gd2hhdCBvcmRlciBhcHBlYXIgaW4gdGhlIHRvb2xiYXIuIEVhY2ggdG9vbCBtYXkgb25seSBiZVxuICogICAgIC8vIHVzZWQgb25jZSAoYnV0IG5vdCBhbGwgZGVmaW5lZCB0b29scyBtdXN0IGJlIHVzZWQpLlxuICogICAgIHRvb2xiYXIuc2V0dXAoIFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgLy8gJ2JhcicgdG9vbCBncm91cHMgZGlzcGxheSB0b29scycgaWNvbnMgb25seSwgc2lkZS1ieS1zaWRlLlxuICogICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gKiAgICAgICAgICAgICBpbmNsdWRlOiBbICdzZWFyY2gnLCAnaGVscCcgXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgICAvLyAnbGlzdCcgdG9vbCBncm91cHMgZGlzcGxheSBib3RoIHRoZSB0aXRsZXMgYW5kIGljb25zLCBpbiBhIGRyb3Bkb3duIGxpc3QuXG4gKiAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gKiAgICAgICAgICAgICBpbmRpY2F0b3I6ICdkb3duJyxcbiAqICAgICAgICAgICAgIGxhYmVsOiAnTW9yZScsXG4gKiAgICAgICAgICAgICBpbmNsdWRlOiBbICdzZXR0aW5ncycsICdzdHVmZicgXVxuICogICAgICAgICB9XG4gKiAgICAgICAgIC8vIE5vdGUgaG93IHRoZSB0b29scyB0aGVtc2VsdmVzIGFyZSB0b29sZ3JvdXAtYWdub3N0aWMgLSB0aGUgc2FtZSB0b29sIGNhbiBiZSBkaXNwbGF5ZWRcbiAqICAgICAgICAgLy8gZWl0aGVyIGluIGEgJ2xpc3QnIG9yIGEgJ2JhcicuIFRoZXJlIGlzIGEgJ21lbnUnIHRvb2wgZ3JvdXAgdG9vLCBub3Qgc2hvd2Nhc2VkIGhlcmUsXG4gKiAgICAgICAgIC8vIHNpbmNlIGl0J3MgbW9yZSBjb21wbGljYXRlZCB0byB1c2UuIChTZWUgdGhlIG5leHQgZXhhbXBsZSBzbmlwcGV0IG9uIHRoaXMgcGFnZS4pXG4gKiAgICAgXSApO1xuICpcbiAqICAgICAvLyBDcmVhdGUgc29tZSBVSSBhcm91bmQgdGhlIHRvb2xiYXIgYW5kIHBsYWNlIGl0IGluIHRoZSBkb2N1bWVudFxuICogICAgIHZhciBmcmFtZSA9IG5ldyBPTy51aS5QYW5lbExheW91dCgge1xuICogICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gKiAgICAgICAgIGZyYW1lZDogdHJ1ZVxuICogICAgIH0gKTtcbiAqICAgICB2YXIgY29udGVudEZyYW1lID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG4gKiAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAqICAgICAgICAgcGFkZGVkOiB0cnVlXG4gKiAgICAgfSApO1xuICogICAgIGZyYW1lLiRlbGVtZW50LmFwcGVuZChcbiAqICAgICAgICAgdG9vbGJhci4kZWxlbWVudCxcbiAqICAgICAgICAgY29udGVudEZyYW1lLiRlbGVtZW50LmFwcGVuZCggJGFyZWEgKVxuICogICAgICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggZnJhbWUuJGVsZW1lbnQgKTtcbiAqXG4gKiAgICAgLy8gSGVyZSBpcyB3aGVyZSB0aGUgdG9vbGJhciBpcyBhY3R1YWxseSBidWlsdC4gVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgaW5zZXJ0aW5nIGl0IGludG8gdGhlXG4gKiAgICAgLy8gZG9jdW1lbnQuXG4gKiAgICAgdG9vbGJhci5pbml0aWFsaXplKCk7XG4gKiAgICAgdG9vbGJhci5lbWl0KCAndXBkYXRlU3RhdGUnICk7XG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGV4dGVuZHMgdGhlIHByZXZpb3VzIG9uZSB0byBpbGx1c3RyYXRlICdtZW51JyB0b29sZ3JvdXBzIGFuZCB0aGUgdXNhZ2Ugb2ZcbiAqIHtAbGluayAjZXZlbnQtdXBkYXRlU3RhdGUgJ3VwZGF0ZVN0YXRlJyBldmVudH0uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSB0b29sYmFyXG4gKiAgICAgdmFyIHRvb2xGYWN0b3J5ID0gbmV3IE9PLnVpLlRvb2xGYWN0b3J5KCk7XG4gKiAgICAgdmFyIHRvb2xHcm91cEZhY3RvcnkgPSBuZXcgT08udWkuVG9vbEdyb3VwRmFjdG9yeSgpO1xuICogICAgIHZhciB0b29sYmFyID0gbmV3IE9PLnVpLlRvb2xiYXIoIHRvb2xGYWN0b3J5LCB0b29sR3JvdXBGYWN0b3J5ICk7XG4gKlxuICogICAgIC8vIFdlIHdpbGwgYmUgcGxhY2luZyBzdGF0dXMgdGV4dCBpbiB0aGlzIGVsZW1lbnQgd2hlbiB0b29scyBhcmUgdXNlZFxuICogICAgIHZhciAkYXJlYSA9ICQoICc8cD4nICkudGV4dCggJ1Rvb2xiYXIgZXhhbXBsZScgKTtcbiAqXG4gKiAgICAgLy8gRGVmaW5lIHRoZSB0b29scyB0aGF0IHdlJ3JlIGdvaW5nIHRvIHBsYWNlIGluIG91ciB0b29sYmFyXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIGNsYXNzIGluaGVyaXRpbmcgZnJvbSBPTy51aS5Ub29sXG4gKiAgICAgZnVuY3Rpb24gU2VhcmNoVG9vbCgpIHtcbiAqICAgICAgICAgU2VhcmNoVG9vbC5wYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIFNlYXJjaFRvb2wsIE9PLnVpLlRvb2wgKTtcbiAqICAgICAvLyBFYWNoIHRvb2wgbXVzdCBoYXZlIGEgJ25hbWUnICh1c2VkIGFzIGFuIGludGVybmFsIGlkZW50aWZpZXIsIHNlZSBsYXRlcikgYW5kIGF0IGxlYXN0IG9uZVxuICogICAgIC8vIG9mICdpY29uJyBhbmQgJ3RpdGxlJyAoZGlzcGxheWVkIGljb24gYW5kIHRleHQpLlxuICogICAgIFNlYXJjaFRvb2wuc3RhdGljLm5hbWUgPSAnc2VhcmNoJztcbiAqICAgICBTZWFyY2hUb29sLnN0YXRpYy5pY29uID0gJ3NlYXJjaCc7XG4gKiAgICAgU2VhcmNoVG9vbC5zdGF0aWMudGl0bGUgPSAnU2VhcmNoLi4uJztcbiAqICAgICAvLyBEZWZpbmVzIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGhhcHBlbiB3aGVuIHRoaXMgdG9vbCBpcyBzZWxlY3RlZCAoY2xpY2tlZCkuXG4gKiAgICAgU2VhcmNoVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgICRhcmVhLnRleHQoICdTZWFyY2ggdG9vbCBjbGlja2VkIScgKTtcbiAqICAgICAgICAgLy8gTmV2ZXIgZGlzcGxheSB0aGlzIHRvb2wgYXMgXCJhY3RpdmVcIiAoc2VsZWN0ZWQpLlxuICogICAgICAgICB0aGlzLnNldEFjdGl2ZSggZmFsc2UgKTtcbiAqICAgICB9O1xuICogICAgIFNlYXJjaFRvb2wucHJvdG90eXBlLm9uVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAqICAgICAvLyBNYWtlIHRoaXMgdG9vbCBhdmFpbGFibGUgaW4gb3VyIHRvb2xGYWN0b3J5IGFuZCB0aHVzIG91ciB0b29sYmFyXG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFNlYXJjaFRvb2wgKTtcbiAqXG4gKiAgICAgLy8gUmVnaXN0ZXIgdHdvIG1vcmUgdG9vbHMsIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGVyZVxuICogICAgIGZ1bmN0aW9uIFNldHRpbmdzVG9vbCgpIHtcbiAqICAgICAgICAgU2V0dGluZ3NUb29sLnBhcmVudC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gKiAgICAgICAgIHRoaXMucmVhbGx5QWN0aXZlID0gZmFsc2U7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggU2V0dGluZ3NUb29sLCBPTy51aS5Ub29sICk7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy5uYW1lID0gJ3NldHRpbmdzJztcbiAqICAgICBTZXR0aW5nc1Rvb2wuc3RhdGljLmljb24gPSAnc2V0dGluZ3MnO1xuICogICAgIFNldHRpbmdzVG9vbC5zdGF0aWMudGl0bGUgPSAnQ2hhbmdlIHNldHRpbmdzJztcbiAqICAgICBTZXR0aW5nc1Rvb2wucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICAkYXJlYS50ZXh0KCAnU2V0dGluZ3MgdG9vbCBjbGlja2VkIScgKTtcbiAqICAgICAgICAgLy8gVG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGUgb24gZWFjaCBjbGlja1xuICogICAgICAgICB0aGlzLnJlYWxseUFjdGl2ZSA9ICF0aGlzLnJlYWxseUFjdGl2ZTtcbiAqICAgICAgICAgdGhpcy5zZXRBY3RpdmUoIHRoaXMucmVhbGx5QWN0aXZlICk7XG4gKiAgICAgICAgIC8vIFRvIHVwZGF0ZSB0aGUgbWVudSBsYWJlbFxuICogICAgICAgICB0aGlzLnRvb2xiYXIuZW1pdCggJ3VwZGF0ZVN0YXRlJyApO1xuICogICAgIH07XG4gKiAgICAgU2V0dGluZ3NUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge307XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFNldHRpbmdzVG9vbCApO1xuICpcbiAqICAgICAvLyBSZWdpc3RlciB0d28gbW9yZSB0b29scywgbm90aGluZyBpbnRlcmVzdGluZyBoZXJlXG4gKiAgICAgZnVuY3Rpb24gU3R1ZmZUb29sKCkge1xuICogICAgICAgICBTdHVmZlRvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICAgICAgdGhpcy5yZWFsbHlBY3RpdmUgPSBmYWxzZTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBTdHVmZlRvb2wsIE9PLnVpLlRvb2wgKTtcbiAqICAgICBTdHVmZlRvb2wuc3RhdGljLm5hbWUgPSAnc3R1ZmYnO1xuICogICAgIFN0dWZmVG9vbC5zdGF0aWMuaWNvbiA9ICdlbGxpcHNpcyc7XG4gKiAgICAgU3R1ZmZUb29sLnN0YXRpYy50aXRsZSA9ICdNb3JlIHN0dWZmJztcbiAqICAgICBTdHVmZlRvb2wucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICAkYXJlYS50ZXh0KCAnTW9yZSBzdHVmZiB0b29sIGNsaWNrZWQhJyApO1xuICogICAgICAgICAvLyBUb2dnbGUgdGhlIGFjdGl2ZSBzdGF0ZSBvbiBlYWNoIGNsaWNrXG4gKiAgICAgICAgIHRoaXMucmVhbGx5QWN0aXZlID0gIXRoaXMucmVhbGx5QWN0aXZlO1xuICogICAgICAgICB0aGlzLnNldEFjdGl2ZSggdGhpcy5yZWFsbHlBY3RpdmUgKTtcbiAqICAgICAgICAgLy8gVG8gdXBkYXRlIHRoZSBtZW51IGxhYmVsXG4gKiAgICAgICAgIHRoaXMudG9vbGJhci5lbWl0KCAndXBkYXRlU3RhdGUnICk7XG4gKiAgICAgfTtcbiAqICAgICBTdHVmZlRvb2wucHJvdG90eXBlLm9uVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAqICAgICB0b29sRmFjdG9yeS5yZWdpc3RlciggU3R1ZmZUb29sICk7XG4gKlxuICogICAgIC8vIFRoaXMgaXMgYSBQb3B1cFRvb2wuIFJhdGhlciB0aGFuIGhhdmluZyBhIGN1c3RvbSAnb25TZWxlY3QnIGFjdGlvbiwgaXQgd2lsbCBkaXNwbGF5IGFcbiAqICAgICAvLyBsaXR0bGUgcG9wdXAgd2luZG93IChhIFBvcHVwV2lkZ2V0KS4gJ29uVXBkYXRlU3RhdGUnIGlzIGFsc28gYWxyZWFkeSBpbXBsZW1lbnRlZC5cbiAqICAgICBmdW5jdGlvbiBIZWxwVG9vbCggdG9vbEdyb3VwLCBjb25maWcgKSB7XG4gKiAgICAgICAgIE9PLnVpLlBvcHVwVG9vbC5jYWxsKCB0aGlzLCB0b29sR3JvdXAsICQuZXh0ZW5kKCB7IHBvcHVwOiB7XG4gKiAgICAgICAgICAgICBwYWRkZWQ6IHRydWUsXG4gKiAgICAgICAgICAgICBsYWJlbDogJ0hlbHAnLFxuICogICAgICAgICAgICAgaGVhZDogdHJ1ZVxuICogICAgICAgICB9IH0sIGNvbmZpZyApICk7XG4gKiAgICAgICAgIHRoaXMucG9wdXAuJGJvZHkuYXBwZW5kKCAnPHA+SSBhbSBoZWxwZnVsITwvcD4nICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggSGVscFRvb2wsIE9PLnVpLlBvcHVwVG9vbCApO1xuICogICAgIEhlbHBUb29sLnN0YXRpYy5uYW1lID0gJ2hlbHAnO1xuICogICAgIEhlbHBUb29sLnN0YXRpYy5pY29uID0gJ2hlbHAnO1xuICogICAgIEhlbHBUb29sLnN0YXRpYy50aXRsZSA9ICdIZWxwJztcbiAqICAgICB0b29sRmFjdG9yeS5yZWdpc3RlciggSGVscFRvb2wgKTtcbiAqXG4gKiAgICAgLy8gRmluYWxseSBkZWZpbmUgd2hpY2ggdG9vbHMgYW5kIGluIHdoYXQgb3JkZXIgYXBwZWFyIGluIHRoZSB0b29sYmFyLiBFYWNoIHRvb2wgbWF5IG9ubHkgYmVcbiAqICAgICAvLyB1c2VkIG9uY2UgKGJ1dCBub3QgYWxsIGRlZmluZWQgdG9vbHMgbXVzdCBiZSB1c2VkKS5cbiAqICAgICB0b29sYmFyLnNldHVwKCBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICAgIC8vICdiYXInIHRvb2wgZ3JvdXBzIGRpc3BsYXkgdG9vbHMnIGljb25zIG9ubHksIHNpZGUtYnktc2lkZS5cbiAqICAgICAgICAgICAgIHR5cGU6ICdiYXInLFxuICogICAgICAgICAgICAgaW5jbHVkZTogWyAnc2VhcmNoJywgJ2hlbHAnIF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgLy8gJ21lbnUnIHRvb2wgZ3JvdXBzIGRpc3BsYXkgYm90aCB0aGUgdGl0bGVzIGFuZCBpY29ucywgaW4gYSBkcm9wZG93biBtZW51LlxuICogICAgICAgICAgICAgLy8gTWVudSBsYWJlbCBpbmRpY2F0ZXMgd2hpY2ggaXRlbXMgYXJlIHNlbGVjdGVkLlxuICogICAgICAgICAgICAgdHlwZTogJ21lbnUnLFxuICogICAgICAgICAgICAgaW5kaWNhdG9yOiAnZG93bicsXG4gKiAgICAgICAgICAgICBpbmNsdWRlOiBbICdzZXR0aW5ncycsICdzdHVmZicgXVxuICogICAgICAgICB9XG4gKiAgICAgXSApO1xuICpcbiAqICAgICAvLyBDcmVhdGUgc29tZSBVSSBhcm91bmQgdGhlIHRvb2xiYXIgYW5kIHBsYWNlIGl0IGluIHRoZSBkb2N1bWVudFxuICogICAgIHZhciBmcmFtZSA9IG5ldyBPTy51aS5QYW5lbExheW91dCgge1xuICogICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gKiAgICAgICAgIGZyYW1lZDogdHJ1ZVxuICogICAgIH0gKTtcbiAqICAgICB2YXIgY29udGVudEZyYW1lID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG4gKiAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAqICAgICAgICAgcGFkZGVkOiB0cnVlXG4gKiAgICAgfSApO1xuICogICAgIGZyYW1lLiRlbGVtZW50LmFwcGVuZChcbiAqICAgICAgICAgdG9vbGJhci4kZWxlbWVudCxcbiAqICAgICAgICAgY29udGVudEZyYW1lLiRlbGVtZW50LmFwcGVuZCggJGFyZWEgKVxuICogICAgICk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggZnJhbWUuJGVsZW1lbnQgKTtcbiAqXG4gKiAgICAgLy8gSGVyZSBpcyB3aGVyZSB0aGUgdG9vbGJhciBpcyBhY3R1YWxseSBidWlsdC4gVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgaW5zZXJ0aW5nIGl0IGludG8gdGhlXG4gKiAgICAgLy8gZG9jdW1lbnQuXG4gKiAgICAgdG9vbGJhci5pbml0aWFsaXplKCk7XG4gKiAgICAgdG9vbGJhci5lbWl0KCAndXBkYXRlU3RhdGUnICk7XG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5FbGVtZW50XG4gKiBAbWl4aW5zIE9PLkV2ZW50RW1pdHRlclxuICogQG1peGlucyBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T08udWkuVG9vbEZhY3Rvcnl9IHRvb2xGYWN0b3J5IEZhY3RvcnkgZm9yIGNyZWF0aW5nIHRvb2xzXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xHcm91cEZhY3Rvcnl9IHRvb2xHcm91cEZhY3RvcnkgRmFjdG9yeSBmb3IgY3JlYXRpbmcgdG9vbGdyb3Vwc1xuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7Ym9vbGVhbn0gW2FjdGlvbnNdIEFkZCBhbiBhY3Rpb25zIHNlY3Rpb24gdG8gdGhlIHRvb2xiYXIuIEFjdGlvbnMgYXJlIGNvbW1hbmRzIHRoYXQgYXJlIGluY2x1ZGVkXG4gKiAgaW4gdGhlIHRvb2xiYXIsIGJ1dCBhcmUgbm90IGNvbmZpZ3VyZWQgYXMgdG9vbHMuIEJ5IGRlZmF1bHQsIGFjdGlvbnMgYXJlIGRpc3BsYXllZCBvbiB0aGUgcmlnaHQgc2lkZSBvZlxuICogIHRoZSB0b29sYmFyLlxuICogQGNmZyB7c3RyaW5nfSBbcG9zaXRpb249J3RvcCddIFdoZXRoZXIgdGhlIHRvb2xiYXIgaXMgcG9zaXRpb25lZCBhYm92ZSAoJ3RvcCcpIG9yIGJlbG93ICgnYm90dG9tJykgY29udGVudC5cbiAqIEBjZmcge2pRdWVyeX0gWyRvdmVybGF5XSBBbiBvdmVybGF5IGZvciB0aGUgcG9wdXAuXG4gKiAgU2VlIDxodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Db25jZXB0cyNPdmVybGF5cz4uXG4gKi9cbk9PLnVpLlRvb2xiYXIgPSBmdW5jdGlvbiBPb1VpVG9vbGJhciggdG9vbEZhY3RvcnksIHRvb2xHcm91cEZhY3RvcnksIGNvbmZpZyApIHtcblx0Ly8gQWxsb3cgcGFzc2luZyBwb3NpdGlvbmFsIHBhcmFtZXRlcnMgaW5zaWRlIHRoZSBjb25maWcgb2JqZWN0XG5cdGlmICggT08uaXNQbGFpbk9iamVjdCggdG9vbEZhY3RvcnkgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSB0b29sRmFjdG9yeTtcblx0XHR0b29sRmFjdG9yeSA9IGNvbmZpZy50b29sRmFjdG9yeTtcblx0XHR0b29sR3JvdXBGYWN0b3J5ID0gY29uZmlnLnRvb2xHcm91cEZhY3Rvcnk7XG5cdH1cblxuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVG9vbGJhci5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLkV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG5cdE9PLnVpLm1peGluLkdyb3VwRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMudG9vbEZhY3RvcnkgPSB0b29sRmFjdG9yeTtcblx0dGhpcy50b29sR3JvdXBGYWN0b3J5ID0gdG9vbEdyb3VwRmFjdG9yeTtcblx0dGhpcy5ncm91cHNCeU5hbWUgPSB7fTtcblx0dGhpcy5hY3RpdmVUb29sR3JvdXBzID0gMDtcblx0dGhpcy50b29scyA9IHt9O1xuXHR0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uIHx8ICd0b3AnO1xuXHR0aGlzLiRiYXIgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJGFjdGlvbnMgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJHBvcHVwcyA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXHR0aGlzLm5hcnJvd1RocmVzaG9sZCA9IG51bGw7XG5cdHRoaXMub25XaW5kb3dSZXNpemVIYW5kbGVyID0gdGhpcy5vbldpbmRvd1Jlc2l6ZS5iaW5kKCB0aGlzICk7XG5cdHRoaXMuJG92ZXJsYXkgPSAoIGNvbmZpZy4kb3ZlcmxheSA9PT0gdHJ1ZSA/IE9PLnVpLmdldERlZmF1bHRPdmVybGF5KCkgOiBjb25maWcuJG92ZXJsYXkgKSB8fCB0aGlzLiRlbGVtZW50O1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZCggdGhpcy4kYmFyICkuYWRkKCB0aGlzLiRncm91cCApLmFkZCggdGhpcy4kYWN0aW9ucyApXG5cdFx0Lm9uKCAnbW91c2Vkb3duIGtleWRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24uYmluZCggdGhpcyApICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZ3JvdXAuYWRkQ2xhc3MoICdvby11aS10b29sYmFyLXRvb2xzJyApO1xuXHRpZiAoIGNvbmZpZy5hY3Rpb25zICkge1xuXHRcdHRoaXMuJGJhci5hcHBlbmQoIHRoaXMuJGFjdGlvbnMuYWRkQ2xhc3MoICdvby11aS10b29sYmFyLWFjdGlvbnMnICkgKTtcblx0fVxuXHR0aGlzLiRwb3B1cHMuYWRkQ2xhc3MoICdvby11aS10b29sYmFyLXBvcHVwcycgKTtcblx0dGhpcy4kYmFyXG5cdFx0LmFkZENsYXNzKCAnb28tdWktdG9vbGJhci1iYXInIClcblx0XHQuYXBwZW5kKCB0aGlzLiRncm91cCwgJzxkaXYgc3R5bGU9XCJjbGVhcjpib3RoXCI+PC9kaXY+JyApO1xuXHQvLyBQb3NzaWJsZSBjbGFzc2VzOiBvby11aS10b29sYmFyLXBvc2l0aW9uLXRvcCwgb28tdWktdG9vbGJhci1wb3NpdGlvbi1ib3R0b21cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXRvb2xiYXIgb28tdWktdG9vbGJhci1wb3NpdGlvbi0nICsgdGhpcy5wb3NpdGlvbiApLmFwcGVuZCggdGhpcy4kYmFyICk7XG5cdHRoaXMuJG92ZXJsYXkuYXBwZW5kKCB0aGlzLiRwb3B1cHMgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9vbGJhciwgT08udWkuRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9vbGJhciwgT08uRXZlbnRFbWl0dGVyICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Ub29sYmFyLCBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IHVwZGF0ZVN0YXRlXG4gKlxuICogQW4gJ3VwZGF0ZVN0YXRlJyBldmVudCBtdXN0IGJlIGVtaXR0ZWQgb24gdGhlIFRvb2xiYXIgKGJ5IGNhbGxpbmcgYHRvb2xiYXIuZW1pdCggJ3VwZGF0ZVN0YXRlJyApYClcbiAqIGV2ZXJ5IHRpbWUgdGhlIHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZyB0aGUgdG9vbGJhciBjaGFuZ2VzLCBhbmQgYW4gdXBkYXRlIHRvIHRoZSBzdGF0ZSBvZlxuICogdG9vbHMgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHsuLi5NaXhlZH0gZGF0YSBBcHBsaWNhdGlvbi1kZWZpbmVkIHBhcmFtZXRlcnNcbiAqL1xuXG4vKipcbiAqIEBldmVudCBhY3RpdmVcbiAqXG4gKiBBbiAnYWN0aXZlJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIG51bWJlciBvZiBhY3RpdmUgdG9vbGdyb3VwcyBpbmNyZWFzZXMgZnJvbSAwLCBvclxuICogcmV0dXJucyB0byAwLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gVGhlcmUgYXJlIGFjdGl2ZSB0b29sZ3JvdXBzIGluIHRoaXMgdG9vbGJhclxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgdGhlIHRvb2wgZmFjdG9yeS5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5Ub29sRmFjdG9yeX0gVG9vbCBmYWN0b3J5XG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLmdldFRvb2xGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy50b29sRmFjdG9yeTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b29sZ3JvdXAgZmFjdG9yeS5cbiAqXG4gKiBAcmV0dXJuIHtPTy5GYWN0b3J5fSBUb29sZ3JvdXAgZmFjdG9yeVxuICovXG5PTy51aS5Ub29sYmFyLnByb3RvdHlwZS5nZXRUb29sR3JvdXBGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy50b29sR3JvdXBGYWN0b3J5O1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIG1vdXNlIGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBNb3VzZSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWQvYm9vbGVhbn0gRmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGlmIGV2ZW50IGlzIGhhbmRsZWRcbiAqL1xuT08udWkuVG9vbGJhci5wcm90b3R5cGUub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyICRjbG9zZXN0V2lkZ2V0VG9FdmVudCA9ICQoIGUudGFyZ2V0ICkuY2xvc2VzdCggJy5vby11aS13aWRnZXQnICksXG5cdFx0JGNsb3Nlc3RXaWRnZXRUb1Rvb2xiYXIgPSB0aGlzLiRlbGVtZW50LmNsb3Nlc3QoICcub28tdWktd2lkZ2V0JyApO1xuXHRpZiAoICEkY2xvc2VzdFdpZGdldFRvRXZlbnQubGVuZ3RoIHx8ICRjbG9zZXN0V2lkZ2V0VG9FdmVudFsgMCBdID09PSAkY2xvc2VzdFdpZGdldFRvVG9vbGJhclsgMCBdICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGUgd2luZG93IHJlc2l6ZSBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgV2luZG93IHJlc2l6ZSBldmVudFxuICovXG5PTy51aS5Ub29sYmFyLnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy4kZWxlbWVudC5hZGQoIHRoaXMuJHBvcHVwcyApLnRvZ2dsZUNsYXNzKFxuXHRcdCdvby11aS10b29sYmFyLW5hcnJvdycsXG5cdFx0dGhpcy4kYmFyWyAwIF0uY2xpZW50V2lkdGggPD0gdGhpcy5nZXROYXJyb3dUaHJlc2hvbGQoKVxuXHQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIChsYXppbHktY29tcHV0ZWQpIHdpZHRoIHRocmVzaG9sZCBmb3IgYXBwbHlpbmcgdGhlIG9vLXVpLXRvb2xiYXItbmFycm93XG4gKiBjbGFzcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCB0aHJlc2hvbGQgaW4gcGl4ZWxzXG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLmdldE5hcnJvd1RocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLm5hcnJvd1RocmVzaG9sZCA9PT0gbnVsbCApIHtcblx0XHR0aGlzLm5hcnJvd1RocmVzaG9sZCA9IHRoaXMuJGdyb3VwWyAwIF0ub2Zmc2V0V2lkdGggKyB0aGlzLiRhY3Rpb25zWyAwIF0ub2Zmc2V0V2lkdGg7XG5cdH1cblx0cmV0dXJuIHRoaXMubmFycm93VGhyZXNob2xkO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGhhbmRsZXMgYW5kIHByZWxvYWRzIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciB0aGUgdG9vbGJhciB0byB3b3JrLlxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBpdCBpcyBhdHRhY2hlZCB0byBhIHZpc2libGUgZG9jdW1lbnQgYW5kIGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICovXG5PTy51aS5Ub29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLmluaXRpYWxpemVkICkge1xuXHRcdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdCQoIHRoaXMuZ2V0RWxlbWVudFdpbmRvdygpICkub24oICdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplSGFuZGxlciApO1xuXHRcdHRoaXMub25XaW5kb3dSZXNpemUoKTtcblx0fVxufTtcblxuLyoqXG4gKiBTZXQgdXAgdGhlIHRvb2xiYXIuXG4gKlxuICogVGhlIHRvb2xiYXIgaXMgc2V0IHVwIHdpdGggYSBsaXN0IG9mIHRvb2xncm91cCBjb25maWd1cmF0aW9ucyB0aGF0IHNwZWNpZnkgdGhlIHR5cGUgb2ZcbiAqIHRvb2xncm91cCAoe0BsaW5rIE9PLnVpLkJhclRvb2xHcm91cCBiYXJ9LCB7QGxpbmsgT08udWkuTWVudVRvb2xHcm91cCBtZW51fSwgb3Ige0BsaW5rIE9PLnVpLkxpc3RUb29sR3JvdXAgbGlzdH0pXG4gKiB0byBhZGQgYW5kIHdoaWNoIHRvb2xzIHRvIGluY2x1ZGUsIGV4Y2x1ZGUsIHByb21vdGUsIG9yIGRlbW90ZSB3aXRoaW4gdGhhdCB0b29sZ3JvdXAuIFBsZWFzZVxuICogc2VlIHtAbGluayBPTy51aS5Ub29sR3JvdXAgdG9vbGdyb3Vwc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaW5jbHVkaW5nIHRvb2xzIGluIHRvb2xncm91cHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxBcnJheT59IGdyb3VwcyBMaXN0IG9mIHRvb2xncm91cCBjb25maWd1cmF0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtncm91cHMubmFtZV0gU3ltYm9saWMgbmFtZSBmb3IgdGhpcyB0b29sZ3JvdXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZ3JvdXBzLnR5cGVdIFRvb2xncm91cCB0eXBlLCBzaG91bGQgZXhpc3QgaW4gdGhlIHRvb2xncm91cCBmYWN0b3J5XG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW2dyb3Vwcy5pbmNsdWRlXSBUb29scyB0byBpbmNsdWRlIGluIHRoZSB0b29sZ3JvdXBcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBbZ3JvdXBzLmV4Y2x1ZGVdIFRvb2xzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgdG9vbGdyb3VwXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW2dyb3Vwcy5wcm9tb3RlXSBUb29scyB0byBwcm9tb3RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRvb2xncm91cFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtncm91cHMuZGVtb3RlXSBUb29scyB0byBkZW1vdGUgdG8gdGhlIGVuZCBvZiB0aGUgdG9vbGdyb3VwXG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCBncm91cHMgKSB7XG5cdHZhciBpLCBsZW4sIHR5cGUsIHRvb2xHcm91cCwgZ3JvdXBDb25maWcsXG5cdFx0aXRlbXMgPSBbXSxcblx0XHRkZWZhdWx0VHlwZSA9ICdiYXInO1xuXG5cdC8vIENsZWFudXAgcHJldmlvdXMgZ3JvdXBzXG5cdHRoaXMucmVzZXQoKTtcblxuXHQvLyBCdWlsZCBvdXQgbmV3IGdyb3Vwc1xuXHRmb3IgKCBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGdyb3VwQ29uZmlnID0gZ3JvdXBzWyBpIF07XG5cdFx0aWYgKCBncm91cENvbmZpZy5pbmNsdWRlID09PSAnKicgKSB7XG5cdFx0XHQvLyBBcHBseSBkZWZhdWx0cyB0byBjYXRjaC1hbGwgZ3JvdXBzXG5cdFx0XHRpZiAoIGdyb3VwQ29uZmlnLnR5cGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Z3JvdXBDb25maWcudHlwZSA9ICdsaXN0Jztcblx0XHRcdH1cblx0XHRcdGlmICggZ3JvdXBDb25maWcubGFiZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Z3JvdXBDb25maWcubGFiZWwgPSBPTy51aS5tc2coICdvb3VpLXRvb2xiYXItbW9yZScgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gQ2hlY2sgdHlwZSBoYXMgYmVlbiByZWdpc3RlcmVkXG5cdFx0dHlwZSA9IHRoaXMuZ2V0VG9vbEdyb3VwRmFjdG9yeSgpLmxvb2t1cCggZ3JvdXBDb25maWcudHlwZSApID8gZ3JvdXBDb25maWcudHlwZSA6IGRlZmF1bHRUeXBlO1xuXHRcdHRvb2xHcm91cCA9IHRoaXMuZ2V0VG9vbEdyb3VwRmFjdG9yeSgpLmNyZWF0ZSggdHlwZSwgdGhpcywgZ3JvdXBDb25maWcgKTtcblx0XHRpdGVtcy5wdXNoKCB0b29sR3JvdXAgKTtcblx0XHRpZiAoIGdyb3VwQ29uZmlnLm5hbWUgKSB7XG5cdFx0XHR0aGlzLmdyb3Vwc0J5TmFtZVsgZ3JvdXBDb25maWcubmFtZSBdID0gdG9vbEdyb3VwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHcm91cHMgd2l0aG91dCBuYW1lIGFyZSBkZXByZWNhdGVkXG5cdFx0XHRPTy51aS53YXJuRGVwcmVjYXRpb24oICdUb29sZ3JvdXBzIG11c3QgaGF2ZSBhIFxcJ25hbWVcXCcgcHJvcGVydHknICk7XG5cdFx0fVxuXHRcdHRvb2xHcm91cC5jb25uZWN0KCB0aGlzLCB7IGFjdGl2ZTogJ29uVG9vbEdyb3VwQWN0aXZlJyB9ICk7XG5cdH1cblx0dGhpcy5hZGRJdGVtcyggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGFjdGl2ZSBldmVudHMgZnJvbSB0b29sIGdyb3Vwc1xuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIFRvb2wgZ3JvdXAgaGFzIGJlY29tZSBhY3RpdmUsIGluYWN0aXZlIGlmIGZhbHNlXG4gKiBAZmlyZXMgYWN0aXZlXG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLm9uVG9vbEdyb3VwQWN0aXZlID0gZnVuY3Rpb24gKCBhY3RpdmUgKSB7XG5cdGlmICggYWN0aXZlICkge1xuXHRcdHRoaXMuYWN0aXZlVG9vbEdyb3VwcysrO1xuXHRcdGlmICggdGhpcy5hY3RpdmVUb29sR3JvdXBzID09PSAxICkge1xuXHRcdFx0dGhpcy5lbWl0KCAnYWN0aXZlJywgdHJ1ZSApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aGlzLmFjdGl2ZVRvb2xHcm91cHMtLTtcblx0XHRpZiAoIHRoaXMuYWN0aXZlVG9vbEdyb3VwcyA9PT0gMCApIHtcblx0XHRcdHRoaXMuZW1pdCggJ2FjdGl2ZScsIGZhbHNlICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEdldCBhIHRvb2xncm91cCBieSBuYW1lXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgR3JvdXAgbmFtZVxuICogQHJldHVybiB7T08udWkuVG9vbEdyb3VwfG51bGx9IFRvb2wgZ3JvdXAsIG9yIG51bGwgaWYgbm9uZSBmb3VuZCBieSB0aGF0IG5hbWVcbiAqL1xuT08udWkuVG9vbGJhci5wcm90b3R5cGUuZ2V0VG9vbEdyb3VwQnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXHRyZXR1cm4gdGhpcy5ncm91cHNCeU5hbWVbIG5hbWUgXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRvb2xzIGFuZCB0b29sZ3JvdXBzIGZyb20gdGhlIHRvb2xiYXIuXG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdHRoaXMuZ3JvdXBzQnlOYW1lID0ge307XG5cdHRoaXMudG9vbHMgPSB7fTtcblx0Zm9yICggaSA9IDAsIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGhpcy5pdGVtc1sgaSBdLmRlc3Ryb3koKTtcblx0fVxuXHR0aGlzLmNsZWFySXRlbXMoKTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgdG9vbGJhci5cbiAqXG4gKiBEZXN0cm95aW5nIHRoZSB0b29sYmFyIHJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBET00gZWxlbWVudHMgdGhhdCBjb25zdGl0dXRlIHRoZSB0b29sYmFyLiBDYWxsXG4gKiB0aGlzIG1ldGhvZCB3aGVuZXZlciB5b3UgYXJlIGRvbmUgdXNpbmcgYSB0b29sYmFyLlxuICovXG5PTy51aS5Ub29sYmFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHQkKCB0aGlzLmdldEVsZW1lbnRXaW5kb3coKSApLm9mZiggJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemVIYW5kbGVyICk7XG5cdHRoaXMucmVzZXQoKTtcblx0dGhpcy4kZWxlbWVudC5yZW1vdmUoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvb2wgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEF2YWlsYWJsZSB0b29scyBhcmUgb25lcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIGFkZGVkIHRvIHRoZSB0b29sYmFyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN5bWJvbGljIG5hbWUgb2YgdG9vbFxuICogQHJldHVybiB7Ym9vbGVhbn0gVG9vbCBpcyBhdmFpbGFibGVcbiAqL1xuT08udWkuVG9vbGJhci5wcm90b3R5cGUuaXNUb29sQXZhaWxhYmxlID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXHRyZXR1cm4gIXRoaXMudG9vbHNbIG5hbWUgXTtcbn07XG5cbi8qKlxuICogUHJldmVudCB0b29sIGZyb20gYmVpbmcgdXNlZCBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLlRvb2x9IHRvb2wgVG9vbCB0byByZXNlcnZlXG4gKi9cbk9PLnVpLlRvb2xiYXIucHJvdG90eXBlLnJlc2VydmVUb29sID0gZnVuY3Rpb24gKCB0b29sICkge1xuXHR0aGlzLnRvb2xzWyB0b29sLmdldE5hbWUoKSBdID0gdG9vbDtcbn07XG5cbi8qKlxuICogQWxsb3cgdG9vbCB0byBiZSB1c2VkIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T08udWkuVG9vbH0gdG9vbCBUb29sIHRvIHJlbGVhc2VcbiAqL1xuT08udWkuVG9vbGJhci5wcm90b3R5cGUucmVsZWFzZVRvb2wgPSBmdW5jdGlvbiAoIHRvb2wgKSB7XG5cdGRlbGV0ZSB0aGlzLnRvb2xzWyB0b29sLmdldE5hbWUoKSBdO1xufTtcblxuLyoqXG4gKiBHZXQgYWNjZWxlcmF0b3IgbGFiZWwgZm9yIHRvb2wuXG4gKlxuICogVGhlIE9PVUkgbGlicmFyeSBkb2VzIG5vdCBjb250YWluIGFuIGFjY2VsZXJhdG9yIHN5c3RlbSwgYnV0IHRoaXMgaXMgdGhlIGhvb2sgZm9yIG9uZS4gVG9cbiAqIHVzZSBhbiBhY2NlbGVyYXRvciBzeXN0ZW0sIHN1YmNsYXNzIHRoZSB0b29sYmFyIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZCwgd2hpY2ggaXMgbWVhbnQgdG8gcmV0dXJuIGEgbGFiZWxcbiAqIHRoYXQgZGVzY3JpYmVzIHRoZSBhY2NlbGVyYXRvciBrZXlzIGZvciB0aGUgdG9vbCBwYXNzZWQgKGJ5IHN5bWJvbGljIG5hbWUpIHRvIHRoZSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3ltYm9saWMgbmFtZSBvZiB0b29sXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUb29sIGFjY2VsZXJhdG9yIGxhYmVsIGlmIGF2YWlsYWJsZVxuICovXG5PTy51aS5Ub29sYmFyLnByb3RvdHlwZS5nZXRUb29sQWNjZWxlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFRvb2xzLCB0b2dldGhlciB3aXRoIHtAbGluayBPTy51aS5Ub29sR3JvdXAgdG9vbGdyb3Vwc30sIGNvbnN0aXR1dGUge0BsaW5rIE9PLnVpLlRvb2xiYXIgdG9vbGJhcnN9LlxuICogRWFjaCB0b29sIGlzIGNvbmZpZ3VyZWQgd2l0aCBhIHN0YXRpYyBuYW1lLCB0aXRsZSwgYW5kIGljb24gYW5kIGlzIGN1c3RvbWl6ZWQgd2l0aCB0aGUgY29tbWFuZCB0byBjYXJyeVxuICogb3V0IHdoZW4gdGhlIHRvb2wgaXMgc2VsZWN0ZWQuIFRvb2xzIG11c3QgYWxzbyBiZSByZWdpc3RlcmVkIHdpdGggYSB7QGxpbmsgT08udWkuVG9vbEZhY3RvcnkgdG9vbCBmYWN0b3J5fSxcbiAqIHdoaWNoIGNyZWF0ZXMgdGhlIHRvb2xzIG9uIGRlbWFuZC5cbiAqXG4gKiBFdmVyeSBUb29sIHN1YmNsYXNzIG11c3QgaW1wbGVtZW50IHR3byBtZXRob2RzOlxuICpcbiAqIC0ge0BsaW5rICNvblVwZGF0ZVN0YXRlfVxuICogLSB7QGxpbmsgI29uU2VsZWN0fVxuICpcbiAqIFRvb2xzIGFyZSBhZGRlZCB0byB0b29sZ3JvdXBzICh7QGxpbmsgT08udWkuTGlzdFRvb2xHcm91cCBMaXN0VG9vbEdyb3VwfSxcbiAqIHtAbGluayBPTy51aS5CYXJUb29sR3JvdXAgQmFyVG9vbEdyb3VwfSwgb3Ige0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgTWVudVRvb2xHcm91cH0pLCB3aGljaCBkZXRlcm1pbmUgaG93XG4gKiB0aGUgdG9vbCBpcyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2xiYXIuIFNlZSB7QGxpbmsgT08udWkuVG9vbGJhciB0b29sYmFyc30gZm9yIGFuIGV4YW1wbGUuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvVG9vbGJhcnNcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkljb25FbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xHcm91cH0gdG9vbEdyb3VwXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtzdHJpbmd8RnVuY3Rpb259IFt0aXRsZV0gVGl0bGUgdGV4dCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0ZXh0LiBJZiB0aGlzIGNvbmZpZyBpcyBvbWl0dGVkLCB0aGUgdmFsdWUgb2ZcbiAqICB0aGUge0BsaW5rICNzdGF0aWMtdGl0bGUgc3RhdGljIHRpdGxlfSBwcm9wZXJ0eSBpcyB1c2VkLlxuICpcbiAqICBUaGUgdGl0bGUgaXMgdXNlZCBpbiBkaWZmZXJlbnQgd2F5cyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdG9vbGdyb3VwIHRoYXQgY29udGFpbnMgdGhlIHRvb2wuIFRoZVxuICogIHRpdGxlIGlzIHVzZWQgYXMgYSB0b29sdGlwIGlmIHRoZSB0b29sIGlzIHBhcnQgb2YgYSB7QGxpbmsgT08udWkuQmFyVG9vbEdyb3VwIGJhcn0gdG9vbGdyb3VwLCBvciBhcyB0aGUgbGFiZWwgdGV4dCBpZiB0aGUgdG9vbCBpc1xuICogIHBhcnQgb2YgYSB7QGxpbmsgT08udWkuTGlzdFRvb2xHcm91cCBsaXN0fSBvciB7QGxpbmsgT08udWkuTWVudVRvb2xHcm91cCBtZW51fSB0b29sZ3JvdXAuXG4gKlxuICogIEZvciBiYXIgdG9vbGdyb3VwcywgYSBkZXNjcmlwdGlvbiBvZiB0aGUgYWNjZWxlcmF0b3Iga2V5IGlzIGFwcGVuZGVkIHRvIHRoZSB0aXRsZSBpZiBhbiBhY2NlbGVyYXRvciBrZXlcbiAqICBpcyBhc3NvY2lhdGVkIHdpdGggYW4gYWN0aW9uIGJ5IHRoZSBzYW1lIG5hbWUgYXMgdGhlIHRvb2wgYW5kIGFjY2VsZXJhdG9yIGZ1bmN0aW9uYWxpdHkgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICogIFRvIGFkZCBhY2NlbGVyYXRvciBrZXkgZnVuY3Rpb25hbGl0eSwgeW91IG11c3Qgc3ViY2xhc3MgT08udWkuVG9vbGJhciBhbmQgb3ZlcnJpZGUgdGhlIHtAbGluayBPTy51aS5Ub29sYmFyI2dldFRvb2xBY2NlbGVyYXRvciBnZXRUb29sQWNjZWxlcmF0b3J9IG1ldGhvZC5cbiAqL1xuT08udWkuVG9vbCA9IGZ1bmN0aW9uIE9vVWlUb29sKCB0b29sR3JvdXAsIGNvbmZpZyApIHtcblx0Ly8gQWxsb3cgcGFzc2luZyBwb3NpdGlvbmFsIHBhcmFtZXRlcnMgaW5zaWRlIHRoZSBjb25maWcgb2JqZWN0XG5cdGlmICggT08uaXNQbGFpbk9iamVjdCggdG9vbEdyb3VwICkgJiYgY29uZmlnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Y29uZmlnID0gdG9vbEdyb3VwO1xuXHRcdHRvb2xHcm91cCA9IGNvbmZpZy50b29sR3JvdXA7XG5cdH1cblxuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuVG9vbC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnRvb2xHcm91cCA9IHRvb2xHcm91cDtcblx0dGhpcy50b29sYmFyID0gdGhpcy50b29sR3JvdXAuZ2V0VG9vbGJhcigpO1xuXHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR0aGlzLiR0aXRsZSA9ICQoICc8c3Bhbj4nICk7XG5cdHRoaXMuJGFjY2VsID0gJCggJzxzcGFuPicgKTtcblx0dGhpcy4kbGluayA9ICQoICc8YT4nICk7XG5cdHRoaXMudGl0bGUgPSBudWxsO1xuXHR0aGlzLmNoZWNrSWNvbiA9IG5ldyBPTy51aS5JY29uV2lkZ2V0KCB7XG5cdFx0aWNvbjogJ2NoZWNrJyxcblx0XHRjbGFzc2VzOiBbICdvby11aS10b29sLWNoZWNrSWNvbicgXVxuXHR9ICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLkljb25FbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uVGFiSW5kZXhlZEVsZW1lbnQuY2FsbCggdGhpcywgJC5leHRlbmQoIHt9LCBjb25maWcsIHsgJHRhYkluZGV4ZWQ6IHRoaXMuJGxpbmsgfSApICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMudG9vbGJhci5jb25uZWN0KCB0aGlzLCB7IHVwZGF0ZVN0YXRlOiAnb25VcGRhdGVTdGF0ZScgfSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJHRpdGxlLmFkZENsYXNzKCAnb28tdWktdG9vbC10aXRsZScgKTtcblx0dGhpcy4kYWNjZWxcblx0XHQuYWRkQ2xhc3MoICdvby11aS10b29sLWFjY2VsJyApXG5cdFx0LnByb3AoIHtcblx0XHRcdC8vIFRoaXMgbWF5IG5lZWQgdG8gYmUgY2hhbmdlZCBpZiB0aGUga2V5IG5hbWVzIGFyZSBldmVyIGxvY2FsaXplZCxcblx0XHRcdC8vIGJ1dCBmb3Igbm93IHRoZXkgYXJlIGVzc2VudGlhbGx5IHdyaXR0ZW4gaW4gRW5nbGlzaFxuXHRcdFx0ZGlyOiAnbHRyJyxcblx0XHRcdGxhbmc6ICdlbidcblx0XHR9ICk7XG5cdHRoaXMuJGxpbmtcblx0XHQuYWRkQ2xhc3MoICdvby11aS10b29sLWxpbmsnIClcblx0XHQuYXBwZW5kKCB0aGlzLmNoZWNrSWNvbi4kZWxlbWVudCwgdGhpcy4kaWNvbiwgdGhpcy4kdGl0bGUsIHRoaXMuJGFjY2VsIClcblx0XHQuYXR0ciggJ3JvbGUnLCAnYnV0dG9uJyApO1xuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmRhdGEoICdvby11aS10b29sJywgdGhpcyApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktdG9vbCcgKVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRvb2wtbmFtZS0nICsgdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMubmFtZS5yZXBsYWNlKCAvXihbXi9dKylcXC8oW14vXSspLiokLywgJyQxLSQyJyApIClcblx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS10b29sLXdpdGgtbGFiZWwnLCB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5kaXNwbGF5Qm90aEljb25BbmRMYWJlbCApXG5cdFx0LmFwcGVuZCggdGhpcy4kbGluayApO1xuXHR0aGlzLnNldFRpdGxlKCBjb25maWcudGl0bGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMudGl0bGUgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9vbCwgT08udWkuV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Ub29sLCBPTy51aS5taXhpbi5JY29uRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9vbCwgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlRvb2wsIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVG9vbC5zdGF0aWMudGFnTmFtZSA9ICdzcGFuJztcblxuLyoqXG4gKiBTeW1ib2xpYyBuYW1lIG9mIHRvb2wuXG4gKlxuICogVGhlIHN5bWJvbGljIG5hbWUgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHJlZ2lzdGVyIHRoZSB0b29sIHdpdGggYSB7QGxpbmsgT08udWkuVG9vbEZhY3RvcnkgVG9vbEZhY3Rvcnl9LiBJdCBjYW5cbiAqIGFsc28gYmUgdXNlZCB3aGVuIGFkZGluZyB0b29scyB0byB0b29sZ3JvdXBzLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ31cbiAqL1xuT08udWkuVG9vbC5zdGF0aWMubmFtZSA9ICcnO1xuXG4vKipcbiAqIFN5bWJvbGljIG5hbWUgb2YgdGhlIGdyb3VwLlxuICpcbiAqIFRoZSBncm91cCBuYW1lIGlzIHVzZWQgdG8gYXNzb2NpYXRlIHRvb2xzIHdpdGggZWFjaCBvdGhlciBzbyB0aGF0IHRoZXkgY2FuIGJlIHNlbGVjdGVkIGxhdGVyIGJ5XG4gKiBhIHtAbGluayBPTy51aS5Ub29sR3JvdXAgdG9vbGdyb3VwfS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKi9cbk9PLnVpLlRvb2wuc3RhdGljLmdyb3VwID0gJyc7XG5cbi8qKlxuICogVG9vbCB0aXRsZSB0ZXh0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRpdGxlIHRleHQuIFRoZSB2YWx1ZSBvZiB0aGUgc3RhdGljIHByb3BlcnR5IGlzIG92ZXJyaWRkZW4gaWYgdGhlICN0aXRsZSBjb25maWcgb3B0aW9uIGlzIHVzZWQuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEZ1bmN0aW9ufVxuICovXG5PTy51aS5Ub29sLnN0YXRpYy50aXRsZSA9ICcnO1xuXG4vKipcbiAqIERpc3BsYXkgYm90aCBpY29uIGFuZCBsYWJlbCB3aGVuIHRoZSB0b29sIGlzIHVzZWQgaW4gYSB7QGxpbmsgT08udWkuQmFyVG9vbEdyb3VwIGJhcn0gdG9vbGdyb3VwLlxuICogTm9ybWFsbHkgb25seSB0aGUgaWNvbiBpcyBkaXNwbGF5ZWQsIG9yIG9ubHkgdGhlIGxhYmVsIGlmIG5vIGljb24gaXMgZ2l2ZW4uXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gKi9cbk9PLnVpLlRvb2wuc3RhdGljLmRpc3BsYXlCb3RoSWNvbkFuZExhYmVsID0gZmFsc2U7XG5cbi8qKlxuICogQWRkIHRvb2wgdG8gY2F0Y2gtYWxsIGdyb3VwcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIEEgY2F0Y2gtYWxsIGdyb3VwLCB3aGljaCBjb250YWlucyBhbGwgdG9vbHMgdGhhdCBkbyBub3QgY3VycmVudGx5IGJlbG9uZyB0byBhIHRvb2xncm91cCxcbiAqIGNhbiBiZSBpbmNsdWRlZCBpbiBhIHRvb2xncm91cCB1c2luZyB0aGUgd2lsZGNhcmQgc2VsZWN0b3IsIGFuIGFzdGVyaXNrICgqKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkuVG9vbC5zdGF0aWMuYXV0b0FkZFRvQ2F0Y2hhbGwgPSB0cnVlO1xuXG4vKipcbiAqIEFkZCB0b29sIHRvIG5hbWVkIGdyb3VwcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRvb2xzIHRoYXQgYXJlIGNvbmZpZ3VyZWQgd2l0aCBhIHN0YXRpYyDigJhncm91cOKAmSBwcm9wZXJ0eSBhcmUgYWRkZWRcbiAqIHRvIHRoYXQgZ3JvdXAgYW5kIHdpbGwgYmUgc2VsZWN0ZWQgd2hlbiB0aGUgc3ltYm9saWMgbmFtZSBvZiB0aGUgZ3JvdXAgaXMgc3BlY2lmaWVkIChlLmcuLCB3aGVuXG4gKiB0b29sZ3JvdXBzIGluY2x1ZGUgdG9vbHMgYnkgZ3JvdXAgbmFtZSkuXG4gKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtib29sZWFufVxuICogQGluaGVyaXRhYmxlXG4gKi9cbk9PLnVpLlRvb2wuc3RhdGljLmF1dG9BZGRUb0dyb3VwID0gdHJ1ZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHRvb2wgaXMgY29tcGF0aWJsZSB3aXRoIGdpdmVuIGRhdGEuXG4gKlxuICogVGhpcyBpcyBhIHN0dWIgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBwcm92aWRlIHN1cHBvcnQgZm9yIGZpbHRlcmluZyB0b29scyBiYXNlZCBvbiBhblxuICogYXJiaXRyYXJ5IHBpZWNlIG9mIGluZm9ybWF0aW9uICAoZS5nLiwgd2hlcmUgdGhlIGN1cnNvciBpcyBpbiBhIGRvY3VtZW50KS4gVGhlIGltcGxlbWVudGF0aW9uXG4gKiBtdXN0IGFsc28gY2FsbCB0aGlzIG1ldGhvZCBzbyB0aGF0IHRoZSBjb21wYXRpYmlsaXR5IGNoZWNrIGNhbiBiZSBwZXJmb3JtZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcGFyYW0ge01peGVkfSBkYXRhIERhdGEgdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRvb2wgY2FuIGJlIHVzZWQgd2l0aCBkYXRhXG4gKi9cbk9PLnVpLlRvb2wuc3RhdGljLmlzQ29tcGF0aWJsZVdpdGggPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBIYW5kbGUgdGhlIHRvb2xiYXIgc3RhdGUgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiB7QGxpbmsgT08udWkuVG9vbGJhciNldmVudC11cGRhdGVTdGF0ZSAndXBkYXRlU3RhdGUnIGV2ZW50fSBpcyBlbWl0dGVkIG9uIHRoZVxuICoge0BsaW5rIE9PLnVpLlRvb2xiYXIgVG9vbGJhcn0gdGhhdCB1c2VzIHRoaXMgdG9vbCwgYW5kIHNob3VsZCBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgdG9vbFxuICogZGVwZW5kaW5nIG9uIGFwcGxpY2F0aW9uIHN0YXRlICh1c3VhbGx5IGJ5IGNhbGxpbmcgI3NldERpc2FibGVkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSB0b29sLFxuICogb3IgI3NldEFjdGl2ZSB0byBtYXJrIGlzIGFzIGN1cnJlbnRseSBpbi11c2Ugb3Igbm90KS5cbiAqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZCB0aGF0IG11c3QgYmUgb3ZlcnJpZGRlbiBpbiBhIGNvbmNyZXRlIHN1YmNsYXNzLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcm90ZWN0ZWRcbiAqIEBhYnN0cmFjdFxuICovXG5PTy51aS5Ub29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gbnVsbDtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIHRvb2wgYmVpbmcgc2VsZWN0ZWQuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHRyaWdnZXJzIHRoaXMgdG9vbCxcbiAqIHVzdWFsbHkgYnkgY2xpY2tpbmcgb24gaXRzIGxhYmVsL2ljb24uXG4gKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QgdGhhdCBtdXN0IGJlIG92ZXJyaWRkZW4gaW4gYSBjb25jcmV0ZSBzdWJjbGFzcy5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJvdGVjdGVkXG4gKiBAYWJzdHJhY3RcbiAqL1xuT08udWkuVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBudWxsO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b29sIGlzIGFjdGl2ZS5cbiAqXG4gKiBUb29scyBiZWNvbWUgYWN0aXZlIHdoZW4gdGhlaXIgI29uU2VsZWN0IG9yICNvblVwZGF0ZVN0YXRlIGhhbmRsZXJzIGNoYW5nZSB0aGVtIHRvIGFwcGVhciBwcmVzc2VkXG4gKiB3aXRoIHRoZSAjc2V0QWN0aXZlIG1ldGhvZC4gQWRkaXRpb25hbCBDU1MgaXMgYXBwbGllZCB0byB0aGUgdG9vbCB0byByZWZsZWN0IHRoZSBhY3RpdmUgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVG9vbCBpcyBhY3RpdmVcbiAqL1xuT08udWkuVG9vbC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmFjdGl2ZTtcbn07XG5cbi8qKlxuICogTWFrZSB0aGUgdG9vbCBhcHBlYXIgYWN0aXZlIG9yIGluYWN0aXZlLlxuICpcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgd2l0aGluICNvblNlbGVjdCBvciAjb25VcGRhdGVTdGF0ZSBldmVudCBoYW5kbGVycyB0byBtYWtlIHRoZSB0b29sXG4gKiBhcHBlYXIgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSBNYWtlIHRvb2wgYXBwZWFyIGFjdGl2ZVxuICovXG5PTy51aS5Ub29sLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiAoIHN0YXRlICkge1xuXHR0aGlzLmFjdGl2ZSA9ICEhc3RhdGU7XG5cdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoICdvby11aS10b29sLWFjdGl2ZScsIHRoaXMuYWN0aXZlICk7XG5cdHRoaXMudXBkYXRlVGhlbWVDbGFzc2VzKCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdG9vbCAjdGl0bGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHRpdGxlIFRpdGxlIHRleHQgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGV4dFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuVG9vbH0gVGhlIHRvb2wsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5Ub29sLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uICggdGl0bGUgKSB7XG5cdHRoaXMudGl0bGUgPSBPTy51aS5yZXNvbHZlTXNnKCB0aXRsZSApO1xuXHR0aGlzLnVwZGF0ZVRpdGxlKCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRvb2wgI3RpdGxlLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGl0bGUgdGV4dFxuICovXG5PTy51aS5Ub29sLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMudGl0bGU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG9vbCdzIHN5bWJvbGljIG5hbWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBTeW1ib2xpYyBuYW1lIG9mIHRvb2xcbiAqL1xuT08udWkuVG9vbC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLm5hbWU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdGl0bGUuXG4gKi9cbk9PLnVpLlRvb2wucHJvdG90eXBlLnVwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdGl0bGVUb29sdGlwcyA9IHRoaXMudG9vbEdyb3VwLmNvbnN0cnVjdG9yLnN0YXRpYy50aXRsZVRvb2x0aXBzLFxuXHRcdGFjY2VsVG9vbHRpcHMgPSB0aGlzLnRvb2xHcm91cC5jb25zdHJ1Y3Rvci5zdGF0aWMuYWNjZWxUb29sdGlwcyxcblx0XHRhY2NlbCA9IHRoaXMudG9vbGJhci5nZXRUb29sQWNjZWxlcmF0b3IoIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLm5hbWUgKSxcblx0XHR0b29sdGlwUGFydHMgPSBbXTtcblxuXHR0aGlzLiR0aXRsZS50ZXh0KCB0aGlzLnRpdGxlICk7XG5cdHRoaXMuJGFjY2VsLnRleHQoIGFjY2VsICk7XG5cblx0aWYgKCB0aXRsZVRvb2x0aXBzICYmIHR5cGVvZiB0aGlzLnRpdGxlID09PSAnc3RyaW5nJyAmJiB0aGlzLnRpdGxlLmxlbmd0aCApIHtcblx0XHR0b29sdGlwUGFydHMucHVzaCggdGhpcy50aXRsZSApO1xuXHR9XG5cdGlmICggYWNjZWxUb29sdGlwcyAmJiB0eXBlb2YgYWNjZWwgPT09ICdzdHJpbmcnICYmIGFjY2VsLmxlbmd0aCApIHtcblx0XHR0b29sdGlwUGFydHMucHVzaCggYWNjZWwgKTtcblx0fVxuXHRpZiAoIHRvb2x0aXBQYXJ0cy5sZW5ndGggKSB7XG5cdFx0dGhpcy4kbGluay5hdHRyKCAndGl0bGUnLCB0b29sdGlwUGFydHMuam9pbiggJyAnICkgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRsaW5rLnJlbW92ZUF0dHIoICd0aXRsZScgKTtcblx0fVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRvb2wuXG4gKlxuICogRGVzdHJveWluZyB0aGUgdG9vbCByZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgdGhlIHRvb2zigJlzIERPTSBlbGVtZW50cy5cbiAqIENhbGwgdGhpcyBtZXRob2Qgd2hlbmV2ZXIgeW91IGFyZSBkb25lIHVzaW5nIGEgdG9vbC5cbiAqL1xuT08udWkuVG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy50b29sYmFyLmRpc2Nvbm5lY3QoIHRoaXMgKTtcblx0dGhpcy4kZWxlbWVudC5yZW1vdmUoKTtcbn07XG5cbi8qKlxuICogVG9vbEdyb3VwcyBhcmUgY29sbGVjdGlvbnMgb2Yge0BsaW5rIE9PLnVpLlRvb2wgdG9vbHN9IHRoYXQgYXJlIHVzZWQgaW4gYSB7QGxpbmsgT08udWkuVG9vbGJhciB0b29sYmFyfS5cbiAqIFRoZSB0eXBlIG9mIHRvb2xncm91cCAoe0BsaW5rIE9PLnVpLkxpc3RUb29sR3JvdXAgbGlzdH0sIHtAbGluayBPTy51aS5CYXJUb29sR3JvdXAgYmFyfSwgb3Ige0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgbWVudX0pXG4gKiB0byB3aGljaCBhIHRvb2wgYmVsb25ncyBkZXRlcm1pbmVzIGhvdyB0aGUgdG9vbCBpcyBhcnJhbmdlZCBhbmQgZGlzcGxheWVkIGluIHRoZSB0b29sYmFyLiBUb29sZ3JvdXBzXG4gKiB0aGVtc2VsdmVzIGFyZSBjcmVhdGVkIG9uIGRlbWFuZCB3aXRoIGEge0BsaW5rIE9PLnVpLlRvb2xHcm91cEZhY3RvcnkgdG9vbGdyb3VwIGZhY3Rvcnl9LlxuICpcbiAqIFRvb2xncm91cHMgY2FuIGNvbnRhaW4gaW5kaXZpZHVhbCB0b29scywgZ3JvdXBzIG9mIHRvb2xzLCBvciBhbGwgYXZhaWxhYmxlIHRvb2xzLCBhcyBzcGVjaWZpZWRcbiAqIHVzaW5nIHRoZSBgaW5jbHVkZWAgY29uZmlnIG9wdGlvbi4gU2VlIE9PLnVpLlRvb2xGYWN0b3J5I2V4dHJhY3Qgb24gZG9jdW1lbnRhdGlvbiBvZiB0aGUgZm9ybWF0LlxuICogVGhlIG9wdGlvbnMgYGV4Y2x1ZGVgLCBgcHJvbW90ZWAsIGFuZCBgZGVtb3RlYCBzdXBwb3J0IHRoZSBzYW1lIGZvcm1hdHMuXG4gKlxuICogU2VlIHtAbGluayBPTy51aS5Ub29sYmFyIHRvb2xiYXJzfSBmb3IgYSBmdWxsIGV4YW1wbGUuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRvb2xiYXJzIGluIGdlbmVyYWwsXG4gKiBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Ub29sYmFyc1xuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5XaWRnZXRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uR3JvdXBFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xiYXJ9IHRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge0FycmF5fHN0cmluZ30gW2luY2x1ZGVdIExpc3Qgb2YgdG9vbHMgdG8gaW5jbHVkZSBpbiB0aGUgdG9vbGdyb3VwLCBzZWUgYWJvdmUuXG4gKiBAY2ZnIHtBcnJheXxzdHJpbmd9IFtleGNsdWRlXSBMaXN0IG9mIHRvb2xzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgdG9vbGdyb3VwLCBzZWUgYWJvdmUuXG4gKiBAY2ZnIHtBcnJheXxzdHJpbmd9IFtwcm9tb3RlXSBMaXN0IG9mIHRvb2xzIHRvIHByb21vdGUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgdG9vbGdyb3VwLCBzZWUgYWJvdmUuXG4gKiBAY2ZnIHtBcnJheXxzdHJpbmd9IFtkZW1vdGVdIExpc3Qgb2YgdG9vbHMgdG8gZGVtb3RlIHRvIHRoZSBlbmQgb2YgdGhlIHRvb2xncm91cCwgc2VlIGFib3ZlLlxuICogIFRoaXMgc2V0dGluZyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdG9vbHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSB0b29sZ3JvdXBcbiAqICBlbiBtYXNzZSAoZS5nLiwgdmlhIHRoZSBjYXRjaC1hbGwgc2VsZWN0b3IpLlxuICovXG5PTy51aS5Ub29sR3JvdXAgPSBmdW5jdGlvbiBPb1VpVG9vbEdyb3VwKCB0b29sYmFyLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHRvb2xiYXIgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSB0b29sYmFyO1xuXHRcdHRvb2xiYXIgPSBjb25maWcudG9vbGJhcjtcblx0fVxuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Ub29sR3JvdXAucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnRvb2xiYXIgPSB0b29sYmFyO1xuXHR0aGlzLnRvb2xzID0ge307XG5cdHRoaXMucHJlc3NlZCA9IG51bGw7XG5cdHRoaXMuYXV0b0Rpc2FibGVkID0gZmFsc2U7XG5cdHRoaXMuaW5jbHVkZSA9IGNvbmZpZy5pbmNsdWRlIHx8IFtdO1xuXHR0aGlzLmV4Y2x1ZGUgPSBjb25maWcuZXhjbHVkZSB8fCBbXTtcblx0dGhpcy5wcm9tb3RlID0gY29uZmlnLnByb21vdGUgfHwgW107XG5cdHRoaXMuZGVtb3RlID0gY29uZmlnLmRlbW90ZSB8fCBbXTtcblx0dGhpcy5vbkRvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIgPSB0aGlzLm9uRG9jdW1lbnRNb3VzZUtleVVwLmJpbmQoIHRoaXMgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy4kZ3JvdXAub24oIHtcblx0XHRtb3VzZWRvd246IHRoaXMub25Nb3VzZUtleURvd24uYmluZCggdGhpcyApLFxuXHRcdG1vdXNldXA6IHRoaXMub25Nb3VzZUtleVVwLmJpbmQoIHRoaXMgKSxcblx0XHRrZXlkb3duOiB0aGlzLm9uTW91c2VLZXlEb3duLmJpbmQoIHRoaXMgKSxcblx0XHRrZXl1cDogdGhpcy5vbk1vdXNlS2V5VXAuYmluZCggdGhpcyApLFxuXHRcdGZvY3VzOiB0aGlzLm9uTW91c2VPdmVyRm9jdXMuYmluZCggdGhpcyApLFxuXHRcdGJsdXI6IHRoaXMub25Nb3VzZU91dEJsdXIuYmluZCggdGhpcyApLFxuXHRcdG1vdXNlb3ZlcjogdGhpcy5vbk1vdXNlT3ZlckZvY3VzLmJpbmQoIHRoaXMgKSxcblx0XHRtb3VzZW91dDogdGhpcy5vbk1vdXNlT3V0Qmx1ci5iaW5kKCB0aGlzIClcblx0fSApO1xuXHR0aGlzLnRvb2xiYXIuZ2V0VG9vbEZhY3RvcnkoKS5jb25uZWN0KCB0aGlzLCB7IHJlZ2lzdGVyOiAnb25Ub29sRmFjdG9yeVJlZ2lzdGVyJyB9ICk7XG5cdHRoaXMuYWdncmVnYXRlKCB7IGRpc2FibGU6ICdpdGVtRGlzYWJsZScgfSApO1xuXHR0aGlzLmNvbm5lY3QoIHRoaXMsIHtcblx0XHRpdGVtRGlzYWJsZTogJ3VwZGF0ZURpc2FibGVkJyxcblx0XHRkaXNhYmxlOiAnb25EaXNhYmxlJ1xuXHR9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZ3JvdXAuYWRkQ2xhc3MoICdvby11aS10b29sR3JvdXAtdG9vbHMnICk7XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS10b29sR3JvdXAnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRncm91cCApO1xuXHR0aGlzLm9uRGlzYWJsZSggdGhpcy5pc0Rpc2FibGVkKCkgKTtcblx0dGhpcy5wb3B1bGF0ZSgpO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Ub29sR3JvdXAsIE9PLnVpLldpZGdldCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuVG9vbEdyb3VwLCBPTy51aS5taXhpbi5Hcm91cEVsZW1lbnQgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGV2ZW50IGFjdGl2ZVxuICpcbiAqIEFuICdhY3RpdmUnIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiBhbnkgcG9wdXAgaXMgc2hvd24vaGlkZGVuLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gVGhlIHBvcHVwIGlzIHZpc2libGVcbiAqL1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIFNob3cgbGFiZWxzIGluIHRvb2x0aXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtib29sZWFufVxuICovXG5PTy51aS5Ub29sR3JvdXAuc3RhdGljLnRpdGxlVG9vbHRpcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBTaG93IGFjY2VsZXJhdGlvbiBsYWJlbHMgaW4gdG9vbHRpcHMuXG4gKlxuICogTm90ZTogVGhlIE9PVUkgbGlicmFyeSBkb2VzIG5vdCBpbmNsdWRlIGFuIGFjY2VsZXJhdG9yIHN5c3RlbSwgYnV0IGRvZXMgY29udGFpblxuICogYSBob29rIGZvciBvbmUuIFRvIHVzZSBhbiBhY2NlbGVyYXRvciBzeXN0ZW0sIHN1YmNsYXNzIHRoZSB7QGxpbmsgT08udWkuVG9vbGJhciB0b29sYmFyfSBhbmRcbiAqIG92ZXJyaWRlIHRoZSB7QGxpbmsgT08udWkuVG9vbGJhciNnZXRUb29sQWNjZWxlcmF0b3IgZ2V0VG9vbEFjY2VsZXJhdG9yfSBtZXRob2QsIHdoaWNoIGlzXG4gKiBtZWFudCB0byByZXR1cm4gYSBsYWJlbCB0aGF0IGRlc2NyaWJlcyB0aGUgYWNjZWxlcmF0b3Iga2V5cyBmb3IgYSBnaXZlbiB0b29sIChlLmcuLCAnQ3RybCArIE0nKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkuVG9vbEdyb3VwLnN0YXRpYy5hY2NlbFRvb2x0aXBzID0gZmFsc2U7XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBkaXNhYmxlIHRoZSB0b29sZ3JvdXAgd2hlbiBhbGwgdG9vbHMgYXJlIGRpc2FibGVkXG4gKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gKi9cbk9PLnVpLlRvb2xHcm91cC5zdGF0aWMuYXV0b0Rpc2FibGUgPSB0cnVlO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge3N0cmluZ31cbiAqL1xuT08udWkuVG9vbEdyb3VwLnN0YXRpYy5uYW1lID0gbnVsbDtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlRvb2xHcm91cC5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuYXV0b0Rpc2FibGVkIHx8IE9PLnVpLlRvb2xHcm91cC5wYXJlbnQucHJvdG90eXBlLmlzRGlzYWJsZWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Ub29sR3JvdXAucHJvdG90eXBlLnVwZGF0ZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgaXRlbSwgYWxsRGlzYWJsZWQgPSB0cnVlO1xuXG5cdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuYXV0b0Rpc2FibGUgKSB7XG5cdFx0Zm9yICggaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0aWYgKCAhaXRlbS5pc0Rpc2FibGVkKCkgKSB7XG5cdFx0XHRcdGFsbERpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmF1dG9EaXNhYmxlZCA9IGFsbERpc2FibGVkO1xuXHR9XG5cdE9PLnVpLlRvb2xHcm91cC5wYXJlbnQucHJvdG90eXBlLnVwZGF0ZURpc2FibGVkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGRpc2FibGUgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZFxuICovXG5PTy51aS5Ub29sR3JvdXAucHJvdG90eXBlLm9uRGlzYWJsZSA9IGZ1bmN0aW9uICggaXNEaXNhYmxlZCApIHtcblx0dGhpcy4kZ3JvdXAudG9nZ2xlQ2xhc3MoICdvby11aS10b29sR3JvdXAtZGlzYWJsZWQtdG9vbHMnLCBpc0Rpc2FibGVkICk7XG5cdHRoaXMuJGdyb3VwLnRvZ2dsZUNsYXNzKCAnb28tdWktdG9vbEdyb3VwLWVuYWJsZWQtdG9vbHMnLCAhaXNEaXNhYmxlZCApO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgbW91c2UgZG93biBhbmQga2V5IGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGRvd24gb3Iga2V5IGRvd24gZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5Ub29sR3JvdXAucHJvdG90eXBlLm9uTW91c2VLZXlEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHRpZiAoXG5cdFx0IXRoaXMuaXNEaXNhYmxlZCgpICYmXG5cdFx0KCBlLndoaWNoID09PSBPTy51aS5Nb3VzZUJ1dHRvbnMuTEVGVCB8fCBlLndoaWNoID09PSBPTy51aS5LZXlzLlNQQUNFIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuRU5URVIgKVxuXHQpIHtcblx0XHR0aGlzLnByZXNzZWQgPSB0aGlzLmZpbmRUYXJnZXRUb29sKCBlICk7XG5cdFx0aWYgKCB0aGlzLnByZXNzZWQgKSB7XG5cdFx0XHR0aGlzLnByZXNzZWQuc2V0QWN0aXZlKCB0cnVlICk7XG5cdFx0XHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdGhpcy5vbkRvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5vbkRvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGRvY3VtZW50IG1vdXNlIHVwIGFuZCBrZXkgdXAgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7TW91c2VFdmVudHxLZXlib2FyZEV2ZW50fSBlIE1vdXNlIHVwIG9yIGtleSB1cCBldmVudFxuICovXG5PTy51aS5Ub29sR3JvdXAucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZUtleVVwID0gZnVuY3Rpb24gKCBlICkge1xuXHR0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgdGhpcy5vbkRvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIsIHRydWUgKTtcblx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCB0aGlzLm9uRG9jdW1lbnRNb3VzZUtleVVwSGFuZGxlciwgdHJ1ZSApO1xuXHQvLyBvbk1vdXNlS2V5VXAgbWF5IGJlIGNhbGxlZCBhIHNlY29uZCB0aW1lLCBkZXBlbmRpbmcgb24gd2hlcmUgdGhlIG1vdXNlIGlzIHdoZW4gdGhlIGJ1dHRvbiBpc1xuXHQvLyByZWxlYXNlZCwgYnV0IHNpbmNlIGB0aGlzLnByZXNzZWRgIHdpbGwgbm8gbG9uZ2VyIGJlIHRydWUsIHRoZSBzZWNvbmQgY2FsbCB3aWxsIGJlIGlnbm9yZWQuXG5cdHRoaXMub25Nb3VzZUtleVVwKCBlICk7XG59O1xuXG4vLyBEZXByZWNhdGVkIGFsaWFzIHNpbmNlIDAuMjguM1xuT08udWkuVG9vbEdyb3VwLnByb3RvdHlwZS5vbkNhcHR1cmVkTW91c2VLZXlVcCA9IGZ1bmN0aW9uICgpIHtcblx0T08udWkud2FybkRlcHJlY2F0aW9uKCAnb25DYXB0dXJlZE1vdXNlS2V5VXAgaXMgZGVwcmVjYXRlZCwgdXNlIG9uRG9jdW1lbnRNb3VzZUtleVVwIGluc3RlYWQnICk7XG5cdHRoaXMub25Eb2N1bWVudE1vdXNlS2V5VXAuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgbW91c2UgdXAgYW5kIGtleSB1cCBldmVudHMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnR9IGUgTW91c2UgdXAgb3Iga2V5IHVwIGV2ZW50XG4gKi9cbk9PLnVpLlRvb2xHcm91cC5wcm90b3R5cGUub25Nb3VzZUtleVVwID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgdG9vbCA9IHRoaXMuZmluZFRhcmdldFRvb2woIGUgKTtcblxuXHRpZiAoXG5cdFx0IXRoaXMuaXNEaXNhYmxlZCgpICYmIHRoaXMucHJlc3NlZCAmJiB0aGlzLnByZXNzZWQgPT09IHRvb2wgJiZcblx0XHQoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuU1BBQ0UgfHwgZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiApXG5cdCkge1xuXHRcdHRoaXMucHJlc3NlZC5vblNlbGVjdCgpO1xuXHRcdHRoaXMucHJlc3NlZCA9IG51bGw7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cblxuXHR0aGlzLnByZXNzZWQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgbW91c2Ugb3ZlciBhbmQgZm9jdXMgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIG92ZXIgb3IgZm9jdXMgZXZlbnRcbiAqL1xuT08udWkuVG9vbEdyb3VwLnByb3RvdHlwZS5vbk1vdXNlT3ZlckZvY3VzID0gZnVuY3Rpb24gKCBlICkge1xuXHR2YXIgdG9vbCA9IHRoaXMuZmluZFRhcmdldFRvb2woIGUgKTtcblxuXHRpZiAoIHRoaXMucHJlc3NlZCAmJiB0aGlzLnByZXNzZWQgPT09IHRvb2wgKSB7XG5cdFx0dGhpcy5wcmVzc2VkLnNldEFjdGl2ZSggdHJ1ZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBtb3VzZSBvdXQgYW5kIGJsdXIgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIG91dCBvciBibHVyIGV2ZW50XG4gKi9cbk9PLnVpLlRvb2xHcm91cC5wcm90b3R5cGUub25Nb3VzZU91dEJsdXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciB0b29sID0gdGhpcy5maW5kVGFyZ2V0VG9vbCggZSApO1xuXG5cdGlmICggdGhpcy5wcmVzc2VkICYmIHRoaXMucHJlc3NlZCA9PT0gdG9vbCApIHtcblx0XHR0aGlzLnByZXNzZWQuc2V0QWN0aXZlKCBmYWxzZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY2xvc2VzdCB0b29sIHRvIGEgalF1ZXJ5LkV2ZW50LlxuICpcbiAqIE9ubHkgdG9vbCBsaW5rcyBhcmUgY29uc2lkZXJlZCwgd2hpY2ggcHJldmVudHMgb3RoZXIgZWxlbWVudHMgaW4gdGhlIHRvb2wgc3VjaCBhcyBwb3B1cHMgZnJvbVxuICogdHJpZ2dlcmluZyB0b29sIGdyb3VwIGludGVyYWN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGVcbiAqIEByZXR1cm4ge09PLnVpLlRvb2x8bnVsbH0gVG9vbCwgYG51bGxgIGlmIG5vbmUgd2FzIGZvdW5kXG4gKi9cbk9PLnVpLlRvb2xHcm91cC5wcm90b3R5cGUuZmluZFRhcmdldFRvb2wgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciB0b29sLFxuXHRcdCRpdGVtID0gJCggZS50YXJnZXQgKS5jbG9zZXN0KCAnLm9vLXVpLXRvb2wtbGluaycgKTtcblxuXHRpZiAoICRpdGVtLmxlbmd0aCApIHtcblx0XHR0b29sID0gJGl0ZW0ucGFyZW50KCkuZGF0YSggJ29vLXVpLXRvb2wnICk7XG5cdH1cblxuXHRyZXR1cm4gdG9vbCAmJiAhdG9vbC5pc0Rpc2FibGVkKCkgPyB0b29sIDogbnVsbDtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRvb2wgcmVnaXN0cnkgcmVnaXN0ZXIgZXZlbnRzLlxuICpcbiAqIElmIGEgdG9vbCBpcyByZWdpc3RlcmVkIGFmdGVyIHRoZSBncm91cCBpcyBjcmVhdGVkLCB3ZSBtdXN0IHJlcG9wdWxhdGUgdGhlIGxpc3QgdG8gYWNjb3VudCBmb3I6XG4gKlxuICogLSBhIHRvb2wgYmVpbmcgYWRkZWQgdGhhdCBtYXkgYmUgaW5jbHVkZWRcbiAqIC0gYSB0b29sIGFscmVhZHkgaW5jbHVkZWQgYmVpbmcgb3ZlcnJpZGRlblxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN5bWJvbGljIG5hbWUgb2YgdG9vbFxuICovXG5PTy51aS5Ub29sR3JvdXAucHJvdG90eXBlLm9uVG9vbEZhY3RvcnlSZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5wb3B1bGF0ZSgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRvb2xiYXIgdGhhdCBjb250YWlucyB0aGUgdG9vbGdyb3VwLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLlRvb2xiYXJ9IFRvb2xiYXIgdGhhdCBjb250YWlucyB0aGUgdG9vbGdyb3VwXG4gKi9cbk9PLnVpLlRvb2xHcm91cC5wcm90b3R5cGUuZ2V0VG9vbGJhciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMudG9vbGJhcjtcbn07XG5cbi8qKlxuICogQWRkIGFuZCByZW1vdmUgdG9vbHMgYmFzZWQgb24gY29uZmlndXJhdGlvbi5cbiAqL1xuT08udWkuVG9vbEdyb3VwLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbiwgbmFtZSwgdG9vbCxcblx0XHR0b29sRmFjdG9yeSA9IHRoaXMudG9vbGJhci5nZXRUb29sRmFjdG9yeSgpLFxuXHRcdG5hbWVzID0ge30sXG5cdFx0YWRkID0gW10sXG5cdFx0cmVtb3ZlID0gW10sXG5cdFx0bGlzdCA9IHRoaXMudG9vbGJhci5nZXRUb29sRmFjdG9yeSgpLmdldFRvb2xzKFxuXHRcdFx0dGhpcy5pbmNsdWRlLCB0aGlzLmV4Y2x1ZGUsIHRoaXMucHJvbW90ZSwgdGhpcy5kZW1vdGVcblx0XHQpO1xuXG5cdC8vIEJ1aWxkIGEgbGlzdCBvZiBuZWVkZWQgdG9vbHNcblx0Zm9yICggaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0bmFtZSA9IGxpc3RbIGkgXTtcblx0XHRpZiAoXG5cdFx0XHQvLyBUb29sIGV4aXN0c1xuXHRcdFx0dG9vbEZhY3RvcnkubG9va3VwKCBuYW1lICkgJiZcblx0XHRcdC8vIFRvb2wgaXMgYXZhaWxhYmxlIG9yIGlzIGFscmVhZHkgaW4gdGhpcyBncm91cFxuXHRcdFx0KCB0aGlzLnRvb2xiYXIuaXNUb29sQXZhaWxhYmxlKCBuYW1lICkgfHwgdGhpcy50b29sc1sgbmFtZSBdIClcblx0XHQpIHtcblx0XHRcdC8vIEhhY2sgdG8gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb24gdmlhIFRvb2xHcm91cFRvb2wuIFdlIG5lZWQgdG8gcmVzZXJ2ZSB0aGUgdG9vbCBiZWZvcmVcblx0XHRcdC8vIGNyZWF0aW5nIGl0LCBidXQgd2UgY2FuJ3QgY2FsbCByZXNlcnZlVG9vbCgpIHlldCBiZWNhdXNlIHdlIGhhdmVuJ3QgY3JlYXRlZCB0aGUgdG9vbC5cblx0XHRcdHRoaXMudG9vbGJhci50b29sc1sgbmFtZSBdID0gdHJ1ZTtcblx0XHRcdHRvb2wgPSB0aGlzLnRvb2xzWyBuYW1lIF07XG5cdFx0XHRpZiAoICF0b29sICkge1xuXHRcdFx0XHQvLyBBdXRvLWluaXRpYWxpemUgdG9vbHMgb24gZmlyc3QgdXNlXG5cdFx0XHRcdHRoaXMudG9vbHNbIG5hbWUgXSA9IHRvb2wgPSB0b29sRmFjdG9yeS5jcmVhdGUoIG5hbWUsIHRoaXMgKTtcblx0XHRcdFx0dG9vbC51cGRhdGVUaXRsZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50b29sYmFyLnJlc2VydmVUb29sKCB0b29sICk7XG5cdFx0XHRhZGQucHVzaCggdG9vbCApO1xuXHRcdFx0bmFtZXNbIG5hbWUgXSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdC8vIFJlbW92ZSB0b29scyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkXG5cdGZvciAoIG5hbWUgaW4gdGhpcy50b29scyApIHtcblx0XHRpZiAoICFuYW1lc1sgbmFtZSBdICkge1xuXHRcdFx0dGhpcy50b29sc1sgbmFtZSBdLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMudG9vbGJhci5yZWxlYXNlVG9vbCggdGhpcy50b29sc1sgbmFtZSBdICk7XG5cdFx0XHRyZW1vdmUucHVzaCggdGhpcy50b29sc1sgbmFtZSBdICk7XG5cdFx0XHRkZWxldGUgdGhpcy50b29sc1sgbmFtZSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIHJlbW92ZS5sZW5ndGggKSB7XG5cdFx0dGhpcy5yZW1vdmVJdGVtcyggcmVtb3ZlICk7XG5cdH1cblx0Ly8gVXBkYXRlIGVtcHRpbmVzcyBzdGF0ZVxuXHRpZiAoIGFkZC5sZW5ndGggKSB7XG5cdFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLXRvb2xHcm91cC1lbXB0eScgKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktdG9vbEdyb3VwLWVtcHR5JyApO1xuXHR9XG5cdC8vIFJlLWFkZCB0b29scyAobW92aW5nIGV4aXN0aW5nIG9uZXMgdG8gbmV3IGxvY2F0aW9ucylcblx0dGhpcy5hZGRJdGVtcyggYWRkICk7XG5cdC8vIERpc2FibGVkIHN0YXRlIG1heSBkZXBlbmQgb24gaXRlbXNcblx0dGhpcy51cGRhdGVEaXNhYmxlZCgpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRvb2xncm91cC5cbiAqL1xuT08udWkuVG9vbEdyb3VwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbmFtZTtcblxuXHR0aGlzLmNsZWFySXRlbXMoKTtcblx0dGhpcy50b29sYmFyLmdldFRvb2xGYWN0b3J5KCkuZGlzY29ubmVjdCggdGhpcyApO1xuXHRmb3IgKCBuYW1lIGluIHRoaXMudG9vbHMgKSB7XG5cdFx0dGhpcy50b29sYmFyLnJlbGVhc2VUb29sKCB0aGlzLnRvb2xzWyBuYW1lIF0gKTtcblx0XHR0aGlzLnRvb2xzWyBuYW1lIF0uZGlzY29ubmVjdCggdGhpcyApLmRlc3Ryb3koKTtcblx0XHRkZWxldGUgdGhpcy50b29sc1sgbmFtZSBdO1xuXHR9XG5cdHRoaXMuJGVsZW1lbnQucmVtb3ZlKCk7XG59O1xuXG4vKipcbiAqIEEgVG9vbEZhY3RvcnkgY3JlYXRlcyB0b29scyBvbiBkZW1hbmQuIEFsbCB0b29scyAoe0BsaW5rIE9PLnVpLlRvb2wgVG9vbHN9LCB7QGxpbmsgT08udWkuUG9wdXBUb29sIFBvcHVwVG9vbHN9LFxuICogYW5kIHtAbGluayBPTy51aS5Ub29sR3JvdXBUb29sIFRvb2xHcm91cFRvb2xzfSkgbXVzdCBiZSByZWdpc3RlcmVkIHdpdGggYSB0b29sIGZhY3RvcnkuIFRvb2xzIGFyZVxuICogcmVnaXN0ZXJlZCBieSB0aGVpciBzeW1ib2xpYyBuYW1lLiBTZWUge0BsaW5rIE9PLnVpLlRvb2xiYXIgdG9vbGJhcnN9IGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRvb2xiYXJzIGluIGdlbmVyYWwsIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXS5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1Rvb2xiYXJzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy5GYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuT08udWkuVG9vbEZhY3RvcnkgPSBmdW5jdGlvbiBPb1VpVG9vbEZhY3RvcnkoKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Ub29sRmFjdG9yeS5wYXJlbnQuY2FsbCggdGhpcyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Ub29sRmFjdG9yeSwgT08uRmFjdG9yeSApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogR2V0IHRvb2xzIGZyb20gdGhlIGZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW2luY2x1ZGVdIEluY2x1ZGVkIHRvb2xzLCBzZWUgI2V4dHJhY3QgZm9yIGZvcm1hdFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtleGNsdWRlXSBFeGNsdWRlZCB0b29scywgc2VlICNleHRyYWN0IGZvciBmb3JtYXRcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBbcHJvbW90ZV0gUHJvbW90ZWQgdG9vbHMsIHNlZSAjZXh0cmFjdCBmb3IgZm9ybWF0XG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW2RlbW90ZV0gRGVtb3RlZCB0b29scywgc2VlICNleHRyYWN0IGZvciBmb3JtYXRcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBMaXN0IG9mIHRvb2xzXG4gKi9cbk9PLnVpLlRvb2xGYWN0b3J5LnByb3RvdHlwZS5nZXRUb29scyA9IGZ1bmN0aW9uICggaW5jbHVkZSwgZXhjbHVkZSwgcHJvbW90ZSwgZGVtb3RlICkge1xuXHR2YXIgaSwgbGVuLCBpbmNsdWRlZCwgcHJvbW90ZWQsIGRlbW90ZWQsXG5cdFx0YXV0byA9IFtdLFxuXHRcdHVzZWQgPSB7fTtcblxuXHQvLyBDb2xsZWN0IGluY2x1ZGVkIGFuZCBub3QgZXhjbHVkZWQgdG9vbHNcblx0aW5jbHVkZWQgPSBPTy5zaW1wbGVBcnJheURpZmZlcmVuY2UoIHRoaXMuZXh0cmFjdCggaW5jbHVkZSApLCB0aGlzLmV4dHJhY3QoIGV4Y2x1ZGUgKSApO1xuXG5cdC8vIFByb21vdGlvblxuXHRwcm9tb3RlZCA9IHRoaXMuZXh0cmFjdCggcHJvbW90ZSwgdXNlZCApO1xuXHRkZW1vdGVkID0gdGhpcy5leHRyYWN0KCBkZW1vdGUsIHVzZWQgKTtcblxuXHQvLyBBdXRvXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBpbmNsdWRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICF1c2VkWyBpbmNsdWRlZFsgaSBdIF0gKSB7XG5cdFx0XHRhdXRvLnB1c2goIGluY2x1ZGVkWyBpIF0gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcHJvbW90ZWQuY29uY2F0KCBhdXRvICkuY29uY2F0KCBkZW1vdGVkICk7XG59O1xuXG4vKipcbiAqIEdldCBhIGZsYXQgbGlzdCBvZiBuYW1lcyBmcm9tIGEgbGlzdCBvZiBuYW1lcyBvciBncm91cHMuXG4gKlxuICogTm9ybWFsbHksIGBjb2xsZWN0aW9uYCBpcyBhbiBhcnJheSBvZiB0b29sIHNwZWNpZmljYXRpb25zLiBUb29scyBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZVxuICogZm9sbG93aW5nIHdheXM6XG4gKlxuICogLSBUbyBpbmNsdWRlIGFuIGluZGl2aWR1YWwgdG9vbCwgdXNlIHRoZSBzeW1ib2xpYyBuYW1lOiBgeyBuYW1lOiAndG9vbC1uYW1lJyB9YCBvciBgJ3Rvb2wtbmFtZSdgLlxuICogLSBUbyBpbmNsdWRlIGFsbCB0b29scyBpbiBhIGdyb3VwLCB1c2UgdGhlIGdyb3VwIG5hbWU6IGB7IGdyb3VwOiAnZ3JvdXAtbmFtZScgfWAuIChUbyBhc3NpZ24gdGhlXG4gKiAgIHRvb2wgdG8gYSBncm91cCwgdXNlIE9PLnVpLlRvb2wuc3RhdGljLmdyb3VwLilcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB0byBpbmNsdWRlIGFsbCB0b29scyB0aGF0IGFyZSBub3QgeWV0IGFzc2lnbmVkIHRvIGFueSBvdGhlciB0b29sZ3JvdXAsIHVzZSB0aGVcbiAqIGNhdGNoLWFsbCBzZWxlY3RvciBgJyonYC5cbiAqXG4gKiBJZiBgdXNlZGAgaXMgcGFzc2VkLCB0b29sIG5hbWVzIHRoYXQgYXBwZWFyIGFzIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBjb25zaWRlcmVkXG4gKiBhbHJlYWR5IGFzc2lnbmVkLCBhbmQgd2lsbCBub3QgYmUgcmV0dXJuZWQgZXZlbiBpZiBzcGVjaWZpZWQgb3RoZXJ3aXNlLiBUaGUgdG9vbCBuYW1lcyBleHRyYWN0ZWRcbiAqIGJ5IHRoaXMgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGFkZGVkIGFzIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBjb2xsZWN0aW9uIExpc3Qgb2YgdG9vbHMsIHNlZSBhYm92ZVxuICogQHBhcmFtIHtPYmplY3R9IFt1c2VkXSBPYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB1c2VkIHRvb2xzLCBzZWUgYWJvdmVcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBMaXN0IG9mIGV4dHJhY3RlZCB0b29sIG5hbWVzXG4gKi9cbk9PLnVpLlRvb2xGYWN0b3J5LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCBjb2xsZWN0aW9uLCB1c2VkICkge1xuXHR2YXIgaSwgbGVuLCBpdGVtLCBuYW1lLCB0b29sLFxuXHRcdG5hbWVzID0gW107XG5cblx0Y29sbGVjdGlvbiA9ICFBcnJheS5pc0FycmF5KCBjb2xsZWN0aW9uICkgPyBbIGNvbGxlY3Rpb24gXSA6IGNvbGxlY3Rpb247XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IGNvbGxlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aXRlbSA9IGNvbGxlY3Rpb25bIGkgXTtcblx0XHRpZiAoIGl0ZW0gPT09ICcqJyApIHtcblx0XHRcdGZvciAoIG5hbWUgaW4gdGhpcy5yZWdpc3RyeSApIHtcblx0XHRcdFx0dG9vbCA9IHRoaXMucmVnaXN0cnlbIG5hbWUgXTtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdC8vIE9ubHkgYWRkIHRvb2xzIGJ5IGdyb3VwIG5hbWUgd2hlbiBhdXRvLWFkZCBpcyBlbmFibGVkXG5cdFx0XHRcdFx0dG9vbC5zdGF0aWMuYXV0b0FkZFRvQ2F0Y2hhbGwgJiZcblx0XHRcdFx0XHQvLyBFeGNsdWRlIGFscmVhZHkgdXNlZCB0b29sc1xuXHRcdFx0XHRcdCggIXVzZWQgfHwgIXVzZWRbIG5hbWUgXSApXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG5hbWVzLnB1c2goIG5hbWUgKTtcblx0XHRcdFx0XHRpZiAoIHVzZWQgKSB7XG5cdFx0XHRcdFx0XHR1c2VkWyBuYW1lIF0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbGxvdyBwbGFpbiBzdHJpbmdzIGFzIHNob3J0aGFuZCBmb3IgbmFtZWQgdG9vbHNcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpdGVtID0geyBuYW1lOiBpdGVtIH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIGl0ZW0gKSApIHtcblx0XHRcdFx0aWYgKCBpdGVtLmdyb3VwICkge1xuXHRcdFx0XHRcdGZvciAoIG5hbWUgaW4gdGhpcy5yZWdpc3RyeSApIHtcblx0XHRcdFx0XHRcdHRvb2wgPSB0aGlzLnJlZ2lzdHJ5WyBuYW1lIF07XG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdC8vIEluY2x1ZGUgdG9vbHMgd2l0aCBtYXRjaGluZyBncm91cFxuXHRcdFx0XHRcdFx0XHR0b29sLnN0YXRpYy5ncm91cCA9PT0gaXRlbS5ncm91cCAmJlxuXHRcdFx0XHRcdFx0XHQvLyBPbmx5IGFkZCB0b29scyBieSBncm91cCBuYW1lIHdoZW4gYXV0by1hZGQgaXMgZW5hYmxlZFxuXHRcdFx0XHRcdFx0XHR0b29sLnN0YXRpYy5hdXRvQWRkVG9Hcm91cCAmJlxuXHRcdFx0XHRcdFx0XHQvLyBFeGNsdWRlIGFscmVhZHkgdXNlZCB0b29sc1xuXHRcdFx0XHRcdFx0XHQoICF1c2VkIHx8ICF1c2VkWyBuYW1lIF0gKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdG5hbWVzLnB1c2goIG5hbWUgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VkICkge1xuXHRcdFx0XHRcdFx0XHRcdHVzZWRbIG5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdC8vIEluY2x1ZGUgdG9vbHMgd2l0aCBtYXRjaGluZyBuYW1lIGFuZCBleGNsdWRlIGFscmVhZHkgdXNlZCB0b29sc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpdGVtLm5hbWUgJiYgKCAhdXNlZCB8fCAhdXNlZFsgaXRlbS5uYW1lIF0gKSApIHtcblx0XHRcdFx0XHRuYW1lcy5wdXNoKCBpdGVtLm5hbWUgKTtcblx0XHRcdFx0XHRpZiAoIHVzZWQgKSB7XG5cdFx0XHRcdFx0XHR1c2VkWyBpdGVtLm5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogVG9vbEdyb3VwRmFjdG9yaWVzIGNyZWF0ZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cHN9IG9uIGRlbWFuZC4gVGhlIHRvb2xncm91cCBjbGFzc2VzIG11c3RcbiAqIHNwZWNpZnkgYSBzeW1ib2xpYyBuYW1lIGFuZCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIGZhY3RvcnkuIFRoZSBmb2xsb3dpbmcgY2xhc3NlcyBhcmUgcmVnaXN0ZXJlZCBieVxuICogZGVmYXVsdDpcbiAqXG4gKiAtIHtAbGluayBPTy51aS5CYXJUb29sR3JvdXAgQmFyVG9vbEdyb3Vwc30gKOKAmGJhcuKAmSlcbiAqIC0ge0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgTWVudVRvb2xHcm91cHN9ICjigJhtZW514oCZKVxuICogLSB7QGxpbmsgT08udWkuTGlzdFRvb2xHcm91cCBMaXN0VG9vbEdyb3Vwc30gKOKAmGxpc3TigJkpXG4gKlxuICogU2VlIHtAbGluayBPTy51aS5Ub29sYmFyIHRvb2xiYXJzfSBmb3IgYW4gZXhhbXBsZS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0b29sYmFycyBpbiBnZW5lcmFsLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Ub29sYmFyc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08uRmFjdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbk9PLnVpLlRvb2xHcm91cEZhY3RvcnkgPSBmdW5jdGlvbiBPb1VpVG9vbEdyb3VwRmFjdG9yeSgpIHtcblx0dmFyIGksIGwsIGRlZmF1bHRDbGFzc2VzO1xuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08uRmFjdG9yeS5jYWxsKCB0aGlzICk7XG5cblx0ZGVmYXVsdENsYXNzZXMgPSB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5nZXREZWZhdWx0Q2xhc3NlcygpO1xuXG5cdC8vIFJlZ2lzdGVyIGRlZmF1bHQgdG9vbGdyb3Vwc1xuXHRmb3IgKCBpID0gMCwgbCA9IGRlZmF1bHRDbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR0aGlzLnJlZ2lzdGVyKCBkZWZhdWx0Q2xhc3Nlc1sgaSBdICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuVG9vbEdyb3VwRmFjdG9yeSwgT08uRmFjdG9yeSApO1xuXG4vKiBTdGF0aWMgTWV0aG9kcyAqL1xuXG4vKipcbiAqIEdldCBhIGRlZmF1bHQgc2V0IG9mIGNsYXNzZXMgdG8gYmUgcmVnaXN0ZXJlZCBvbiBjb25zdHJ1Y3Rpb24uXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb25bXX0gRGVmYXVsdCBjbGFzc2VzXG4gKi9cbk9PLnVpLlRvb2xHcm91cEZhY3Rvcnkuc3RhdGljLmdldERlZmF1bHRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gW1xuXHRcdE9PLnVpLkJhclRvb2xHcm91cCxcblx0XHRPTy51aS5MaXN0VG9vbEdyb3VwLFxuXHRcdE9PLnVpLk1lbnVUb29sR3JvdXBcblx0XTtcbn07XG5cbi8qKlxuICogUG9wdXAgdG9vbHMgb3BlbiBhIHBvcHVwIHdpbmRvdyB3aGVuIHRoZXkgYXJlIHNlbGVjdGVkIGZyb20gdGhlIHtAbGluayBPTy51aS5Ub29sYmFyIHRvb2xiYXJ9LiBFYWNoIHBvcHVwIHRvb2wgaXMgY29uZmlndXJlZFxuICogd2l0aCBhIHN0YXRpYyBuYW1lLCB0aXRsZSwgYW5kIGljb24sIGFzIHdlbGwgd2l0aCBhcyBhbnkgcG9wdXAgY29uZmlndXJhdGlvbnMuIFVubGlrZSBvdGhlciB0b29scywgcG9wdXAgdG9vbHMgZG8gbm90IHJlcXVpcmUgdGhhdCBkZXZlbG9wZXJzIHNwZWNpZnlcbiAqIGFuICNvblNlbGVjdCBvciAjb25VcGRhdGVTdGF0ZSBtZXRob2QsIGFzIHRoZXNlIG1ldGhvZHMgaGF2ZSBiZWVuIGltcGxlbWVudGVkIGFscmVhZHkuXG4gKlxuICogICAgIC8vIEV4YW1wbGUgb2YgYSBwb3B1cCB0b29sLiBXaGVuIHNlbGVjdGVkLCBhIHBvcHVwIHRvb2wgZGlzcGxheXNcbiAqICAgICAvLyBhIHBvcHVwIHdpbmRvdy5cbiAqICAgICBmdW5jdGlvbiBIZWxwVG9vbCggdG9vbEdyb3VwLCBjb25maWcgKSB7XG4gKiAgICAgICAgT08udWkuUG9wdXBUb29sLmNhbGwoIHRoaXMsIHRvb2xHcm91cCwgJC5leHRlbmQoIHsgcG9wdXA6IHtcbiAqICAgICAgICAgICAgcGFkZGVkOiB0cnVlLFxuICogICAgICAgICAgICBsYWJlbDogJ0hlbHAnLFxuICogICAgICAgICAgICBoZWFkOiB0cnVlXG4gKiAgICAgICAgfSB9LCBjb25maWcgKSApO1xuICogICAgICAgIHRoaXMucG9wdXAuJGJvZHkuYXBwZW5kKCAnPHA+SSBhbSBoZWxwZnVsITwvcD4nICk7XG4gKiAgICAgfTtcbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIEhlbHBUb29sLCBPTy51aS5Qb3B1cFRvb2wgKTtcbiAqICAgICBIZWxwVG9vbC5zdGF0aWMubmFtZSA9ICdoZWxwJztcbiAqICAgICBIZWxwVG9vbC5zdGF0aWMuaWNvbiA9ICdoZWxwJztcbiAqICAgICBIZWxwVG9vbC5zdGF0aWMudGl0bGUgPSAnSGVscCc7XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIEhlbHBUb29sICk7XG4gKlxuICogRm9yIGFuIGV4YW1wbGUgb2YgYSB0b29sYmFyIHRoYXQgY29udGFpbnMgYSBwb3B1cCB0b29sLCBzZWUge0BsaW5rIE9PLnVpLlRvb2xiYXIgdG9vbGJhcnN9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dFxuICogdG9vbGJhcnMgaW4gZ2VuZXJhbCwgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvVG9vbGJhcnNcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVG9vbFxuICogQG1peGlucyBPTy51aS5taXhpbi5Qb3B1cEVsZW1lbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T08udWkuVG9vbEdyb3VwfSB0b29sR3JvdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuUG9wdXBUb29sID0gZnVuY3Rpb24gT29VaVBvcHVwVG9vbCggdG9vbEdyb3VwLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHRvb2xHcm91cCApICYmIGNvbmZpZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGNvbmZpZyA9IHRvb2xHcm91cDtcblx0XHR0b29sR3JvdXAgPSBjb25maWcudG9vbEdyb3VwO1xuXHR9XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLlBvcHVwVG9vbC5wYXJlbnQuY2FsbCggdGhpcywgdG9vbEdyb3VwLCBjb25maWcgKTtcblxuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0T08udWkubWl4aW4uUG9wdXBFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLnBvcHVwLmNvbm5lY3QoIHRoaXMsIHsgdG9nZ2xlOiAnb25Qb3B1cFRvZ2dsZScgfSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMucG9wdXAuc2V0QXV0b0ZsaXAoIGZhbHNlICk7XG5cdHRoaXMucG9wdXAuc2V0UG9zaXRpb24oIHRvb2xHcm91cC5nZXRUb29sYmFyKCkucG9zaXRpb24gPT09ICdib3R0b20nID8gJ2Fib3ZlJyA6ICdiZWxvdycgKTtcblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwVG9vbCcgKTtcblx0dGhpcy5wb3B1cC4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwVG9vbC1wb3B1cCcgKTtcblx0dGhpcy50b29sYmFyLiRwb3B1cHMuYXBwZW5kKCB0aGlzLnBvcHVwLiRlbGVtZW50ICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlBvcHVwVG9vbCwgT08udWkuVG9vbCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBUb29sLCBPTy51aS5taXhpbi5Qb3B1cEVsZW1lbnQgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgdG9vbCBiZWluZyBzZWxlY3RlZC5cbiAqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qb3B1cFRvb2wucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHR0aGlzLnBvcHVwLnRvZ2dsZSgpO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSB0b29sYmFyIHN0YXRlIGJlaW5nIHVwZGF0ZWQuXG4gKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUG9wdXBUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcG9wdXAgdmlzaWJpbGl0eSBiZWluZyB0b2dnbGVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWaXNpYmxlXG4gKi9cbk9PLnVpLlBvcHVwVG9vbC5wcm90b3R5cGUub25Qb3B1cFRvZ2dsZSA9IGZ1bmN0aW9uICggaXNWaXNpYmxlICkge1xuXHR0aGlzLnNldEFjdGl2ZSggaXNWaXNpYmxlICk7XG5cdHRoaXMudG9vbEdyb3VwLmVtaXQoICdhY3RpdmUnLCBpc1Zpc2libGUgKTtcbn07XG5cbi8qKlxuICogQSBUb29sR3JvdXBUb29sIGlzIGEgc3BlY2lhbCBzb3J0IG9mIHRvb2wgdGhhdCBjYW4gY29udGFpbiBvdGhlciB7QGxpbmsgT08udWkuVG9vbCB0b29sc31cbiAqIGFuZCB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cHN9LiBUaGUgVG9vbEdyb3VwVG9vbCB3YXMgc3BlY2lmaWNhbGx5IGRlc2lnbmVkIHRvIGJlIHVzZWRcbiAqIGluc2lkZSBhIHtAbGluayBPTy51aS5CYXJUb29sR3JvdXAgYmFyfSB0b29sZ3JvdXAgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gYWRkaXRpb25hbCB0b29scyBmcm9tXG4gKiB0aGUgYmFyIGl0ZW0uIEluY2x1ZGVkIHRvb2xzIHdpbGwgYmUgZGlzcGxheWVkIGluIGEgZHJvcGRvd24ge0BsaW5rIE9PLnVpLkxpc3RUb29sR3JvdXAgbGlzdH1cbiAqIHdoZW4gdGhlIFRvb2xHcm91cFRvb2wgaXMgc2VsZWN0ZWQuXG4gKlxuICogICAgIC8vIEV4YW1wbGU6IFRvb2xHcm91cFRvb2wgd2l0aCB0d28gbmVzdGVkIHRvb2xzLCAnc2V0dGluZzEnIGFuZCAnc2V0dGluZzInLCBkZWZpbmVkIGVsc2V3aGVyZS5cbiAqXG4gKiAgICAgZnVuY3Rpb24gU2V0dGluZ3NUb29sKCkge1xuICogICAgICAgICBTZXR0aW5nc1Rvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICB9O1xuICogICAgIE9PLmluaGVyaXRDbGFzcyggU2V0dGluZ3NUb29sLCBPTy51aS5Ub29sR3JvdXBUb29sICk7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy5uYW1lID0gJ3NldHRpbmdzJztcbiAqICAgICBTZXR0aW5nc1Rvb2wuc3RhdGljLnRpdGxlID0gJ0NoYW5nZSBzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy5ncm91cENvbmZpZyA9IHtcbiAqICAgICAgICAgaWNvbjogJ3NldHRpbmdzJyxcbiAqICAgICAgICAgbGFiZWw6ICdUb29sR3JvdXBUb29sJyxcbiAqICAgICAgICAgaW5jbHVkZTogWyAgJ3NldHRpbmcxJywgJ3NldHRpbmcyJyAgXVxuICogICAgIH07XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFNldHRpbmdzVG9vbCApO1xuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGltcGxlbWVudGF0aW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlIHBlciBbVDc0MTU5XSBbMl0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Ub29sYmFycyNUb29sR3JvdXBUb29sXG4gKiBbMl06IGh0dHBzOi8vcGhhYnJpY2F0b3Iud2lraW1lZGlhLm9yZy9UNzQxNTlcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVG9vbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPTy51aS5Ub29sR3JvdXB9IHRvb2xHcm91cFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5Ub29sR3JvdXBUb29sID0gZnVuY3Rpb24gT29VaVRvb2xHcm91cFRvb2woIHRvb2xHcm91cCwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCB0b29sR3JvdXAgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSB0b29sR3JvdXA7XG5cdFx0dG9vbEdyb3VwID0gY29uZmlnLnRvb2xHcm91cDtcblx0fVxuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Ub29sR3JvdXBUb29sLnBhcmVudC5jYWxsKCB0aGlzLCB0b29sR3JvdXAsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5pbm5lclRvb2xHcm91cCA9IHRoaXMuY3JlYXRlR3JvdXAoIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmdyb3VwQ29uZmlnICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuaW5uZXJUb29sR3JvdXAuY29ubmVjdCggdGhpcywge1xuXHRcdGRpc2FibGU6ICdvblRvb2xHcm91cERpc2FibGUnLFxuXHRcdC8vIFJlLWVtaXQgYWN0aXZlIGV2ZW50cyBmcm9tIHRoZSBpbm5lclRvb2xHcm91cCBvbiB0aGUgcGFyZW50IHRvb2xHcm91cFxuXHRcdGFjdGl2ZTogdGhpcy50b29sR3JvdXAuZW1pdC5iaW5kKCB0aGlzLnRvb2xHcm91cCwgJ2FjdGl2ZScgKVxuXHR9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kbGluay5yZW1vdmUoKTtcblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXRvb2xHcm91cFRvb2wnIClcblx0XHQuYXBwZW5kKCB0aGlzLmlubmVyVG9vbEdyb3VwLiRlbGVtZW50ICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlRvb2xHcm91cFRvb2wsIE9PLnVpLlRvb2wgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBUb29sZ3JvdXAgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGUgdG9vbGdyb3VwIGNvbmZpZ3VyYXRpb24gY29uc2lzdHMgb2YgdGhlIHRvb2xzIHRvIGluY2x1ZGUsIGFzIHdlbGwgYXMgYW4gaWNvbiBhbmQgbGFiZWxcbiAqIHRvIHVzZSBmb3IgdGhlIGJhciBpdGVtLiBUb29scyBjYW4gYmUgaW5jbHVkZWQgYnkgc3ltYm9saWMgbmFtZSwgZ3JvdXAsIG9yIHdpdGggdGhlXG4gKiB3aWxkY2FyZCBzZWxlY3Rvci4gUGxlYXNlIHNlZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBcnJheT59XG4gKi9cbk9PLnVpLlRvb2xHcm91cFRvb2wuc3RhdGljLmdyb3VwQ29uZmlnID0ge307XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBIYW5kbGUgdGhlIHRvb2wgYmVpbmcgc2VsZWN0ZWQuXG4gKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVG9vbEdyb3VwVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuaW5uZXJUb29sR3JvdXAuc2V0QWN0aXZlKCAhdGhpcy5pbm5lclRvb2xHcm91cC5hY3RpdmUgKTtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTeW5jaHJvbml6ZSBkaXNhYmxlZG5lc3Mgc3RhdGUgb2YgdGhlIHRvb2wgd2l0aCB0aGUgaW5uZXIgdG9vbGdyb3VwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIEVsZW1lbnQgaXMgZGlzYWJsZWRcbiAqL1xuT08udWkuVG9vbEdyb3VwVG9vbC5wcm90b3R5cGUub25Ub29sR3JvdXBEaXNhYmxlID0gZnVuY3Rpb24gKCBkaXNhYmxlZCApIHtcblx0dGhpcy5zZXREaXNhYmxlZCggZGlzYWJsZWQgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSB0b29sYmFyIHN0YXRlIGJlaW5nIHVwZGF0ZWQuXG4gKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuVG9vbEdyb3VwVG9vbC5wcm90b3R5cGUub25VcGRhdGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5zZXRBY3RpdmUoIGZhbHNlICk7XG59O1xuXG4vKipcbiAqIEJ1aWxkIGEge0BsaW5rIE9PLnVpLlRvb2xHcm91cCB0b29sZ3JvdXB9IGZyb20gdGhlIHNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsQXJyYXk+fSBncm91cCBUb29sZ3JvdXAgY29uZmlndXJhdGlvbi4gUGxlYXNlIHNlZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cH0gZm9yXG4gKiAgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm4ge09PLnVpLkxpc3RUb29sR3JvdXB9XG4gKi9cbk9PLnVpLlRvb2xHcm91cFRvb2wucHJvdG90eXBlLmNyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKCBncm91cCApIHtcblx0aWYgKCBncm91cC5pbmNsdWRlID09PSAnKicgKSB7XG5cdFx0Ly8gQXBwbHkgZGVmYXVsdHMgdG8gY2F0Y2gtYWxsIGdyb3Vwc1xuXHRcdGlmICggZ3JvdXAubGFiZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGdyb3VwLmxhYmVsID0gT08udWkubXNnKCAnb291aS10b29sYmFyLW1vcmUnICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXMudG9vbGJhci5nZXRUb29sR3JvdXBGYWN0b3J5KCkuY3JlYXRlKCAnbGlzdCcsIHRoaXMudG9vbGJhciwgZ3JvdXAgKTtcbn07XG5cbi8qKlxuICogQmFyVG9vbEdyb3VwcyBhcmUgb25lIG9mIHRocmVlIHR5cGVzIG9mIHtAbGluayBPTy51aS5Ub29sR3JvdXAgdG9vbGdyb3Vwc30gdGhhdCBhcmUgdXNlZCB0b1xuICogY3JlYXRlIHtAbGluayBPTy51aS5Ub29sYmFyIHRvb2xiYXJzfSAodGhlIG90aGVyIHR5cGVzIG9mIGdyb3VwcyBhcmUge0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgTWVudVRvb2xHcm91cH1cbiAqIGFuZCB7QGxpbmsgT08udWkuTGlzdFRvb2xHcm91cCBMaXN0VG9vbEdyb3VwfSkuIFRoZSB7QGxpbmsgT08udWkuVG9vbCB0b29sc30gaW4gYSBCYXJUb29sR3JvdXAgYXJlXG4gKiBkaXNwbGF5ZWQgYnkgaWNvbiBpbiBhIHNpbmdsZSByb3cuIFRoZSB0aXRsZSBvZiB0aGUgdG9vbCBpcyBkaXNwbGF5ZWQgd2hlbiB1c2VycyBtb3ZlIHRoZSBtb3VzZSBvdmVyXG4gKiB0aGUgdG9vbC5cbiAqXG4gKiBCYXJUb29sR3JvdXBzIGFyZSBjcmVhdGVkIGJ5IGEge0BsaW5rIE9PLnVpLlRvb2xHcm91cEZhY3RvcnkgdG9vbCBncm91cCBmYWN0b3J5fSB3aGVuIHRoZSB0b29sYmFyIGlzXG4gKiBzZXQgdXAuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZSBvZiBhIEJhclRvb2xHcm91cCB3aXRoIHR3byB0b29sc1xuICogICAgIHZhciB0b29sRmFjdG9yeSA9IG5ldyBPTy51aS5Ub29sRmFjdG9yeSgpO1xuICogICAgIHZhciB0b29sR3JvdXBGYWN0b3J5ID0gbmV3IE9PLnVpLlRvb2xHcm91cEZhY3RvcnkoKTtcbiAqICAgICB2YXIgdG9vbGJhciA9IG5ldyBPTy51aS5Ub29sYmFyKCB0b29sRmFjdG9yeSwgdG9vbEdyb3VwRmFjdG9yeSApO1xuICpcbiAqICAgICAvLyBXZSB3aWxsIGJlIHBsYWNpbmcgc3RhdHVzIHRleHQgaW4gdGhpcyBlbGVtZW50IHdoZW4gdG9vbHMgYXJlIHVzZWRcbiAqICAgICB2YXIgJGFyZWEgPSAkKCAnPHA+JyApLnRleHQoICdFeGFtcGxlIG9mIGEgQmFyVG9vbEdyb3VwIHdpdGggdHdvIHRvb2xzLicgKTtcbiAqXG4gKiAgICAgLy8gRGVmaW5lIHRoZSB0b29scyB0aGF0IHdlJ3JlIGdvaW5nIHRvIHBsYWNlIGluIG91ciB0b29sYmFyXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIGNsYXNzIGluaGVyaXRpbmcgZnJvbSBPTy51aS5Ub29sXG4gKiAgICAgZnVuY3Rpb24gU2VhcmNoVG9vbCgpIHtcbiAqICAgICAgICAgU2VhcmNoVG9vbC5wYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIFNlYXJjaFRvb2wsIE9PLnVpLlRvb2wgKTtcbiAqICAgICAvLyBFYWNoIHRvb2wgbXVzdCBoYXZlIGEgJ25hbWUnICh1c2VkIGFzIGFuIGludGVybmFsIGlkZW50aWZpZXIsIHNlZSBsYXRlcikgYW5kIGF0IGxlYXN0IG9uZVxuICogICAgIC8vIG9mICdpY29uJyBhbmQgJ3RpdGxlJyAoZGlzcGxheWVkIGljb24gYW5kIHRleHQpLlxuICogICAgIFNlYXJjaFRvb2wuc3RhdGljLm5hbWUgPSAnc2VhcmNoJztcbiAqICAgICBTZWFyY2hUb29sLnN0YXRpYy5pY29uID0gJ3NlYXJjaCc7XG4gKiAgICAgU2VhcmNoVG9vbC5zdGF0aWMudGl0bGUgPSAnU2VhcmNoLi4uJztcbiAqICAgICAvLyBEZWZpbmVzIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGhhcHBlbiB3aGVuIHRoaXMgdG9vbCBpcyBzZWxlY3RlZCAoY2xpY2tlZCkuXG4gKiAgICAgU2VhcmNoVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgICRhcmVhLnRleHQoICdTZWFyY2ggdG9vbCBjbGlja2VkIScgKTtcbiAqICAgICAgICAgLy8gTmV2ZXIgZGlzcGxheSB0aGlzIHRvb2wgYXMgXCJhY3RpdmVcIiAoc2VsZWN0ZWQpLlxuICogICAgICAgICB0aGlzLnNldEFjdGl2ZSggZmFsc2UgKTtcbiAqICAgICB9O1xuICogICAgIFNlYXJjaFRvb2wucHJvdG90eXBlLm9uVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAqICAgICAvLyBNYWtlIHRoaXMgdG9vbCBhdmFpbGFibGUgaW4gb3VyIHRvb2xGYWN0b3J5IGFuZCB0aHVzIG91ciB0b29sYmFyXG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFNlYXJjaFRvb2wgKTtcbiAqXG4gKiAgICAgLy8gVGhpcyBpcyBhIFBvcHVwVG9vbC4gUmF0aGVyIHRoYW4gaGF2aW5nIGEgY3VzdG9tICdvblNlbGVjdCcgYWN0aW9uLCBpdCB3aWxsIGRpc3BsYXkgYVxuICogICAgIC8vIGxpdHRsZSBwb3B1cCB3aW5kb3cgKGEgUG9wdXBXaWRnZXQpLlxuICogICAgIGZ1bmN0aW9uIEhlbHBUb29sKCB0b29sR3JvdXAsIGNvbmZpZyApIHtcbiAqICAgICAgICAgT08udWkuUG9wdXBUb29sLmNhbGwoIHRoaXMsIHRvb2xHcm91cCwgJC5leHRlbmQoIHsgcG9wdXA6IHtcbiAqICAgICAgICAgICAgIHBhZGRlZDogdHJ1ZSxcbiAqICAgICAgICAgICAgIGxhYmVsOiAnSGVscCcsXG4gKiAgICAgICAgICAgICBoZWFkOiB0cnVlXG4gKiAgICAgICAgIH0gfSwgY29uZmlnICkgKTtcbiAqICAgICAgICAgdGhpcy5wb3B1cC4kYm9keS5hcHBlbmQoICc8cD5JIGFtIGhlbHBmdWwhPC9wPicgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBIZWxwVG9vbCwgT08udWkuUG9wdXBUb29sICk7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLm5hbWUgPSAnaGVscCc7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLmljb24gPSAnaGVscCc7XG4gKiAgICAgSGVscFRvb2wuc3RhdGljLnRpdGxlID0gJ0hlbHAnO1xuICogICAgIHRvb2xGYWN0b3J5LnJlZ2lzdGVyKCBIZWxwVG9vbCApO1xuICpcbiAqICAgICAvLyBGaW5hbGx5IGRlZmluZSB3aGljaCB0b29scyBhbmQgaW4gd2hhdCBvcmRlciBhcHBlYXIgaW4gdGhlIHRvb2xiYXIuIEVhY2ggdG9vbCBtYXkgb25seSBiZVxuICogICAgIC8vIHVzZWQgb25jZSAoYnV0IG5vdCBhbGwgZGVmaW5lZCB0b29scyBtdXN0IGJlIHVzZWQpLlxuICogICAgIHRvb2xiYXIuc2V0dXAoIFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgLy8gJ2JhcicgdG9vbCBncm91cHMgZGlzcGxheSB0b29scyBieSBpY29uIG9ubHlcbiAqICAgICAgICAgICAgIHR5cGU6ICdiYXInLFxuICogICAgICAgICAgICAgaW5jbHVkZTogWyAnc2VhcmNoJywgJ2hlbHAnIF1cbiAqICAgICAgICAgfVxuICogICAgIF0gKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHNvbWUgVUkgYXJvdW5kIHRoZSB0b29sYmFyIGFuZCBwbGFjZSBpdCBpbiB0aGUgZG9jdW1lbnRcbiAqICAgICB2YXIgZnJhbWUgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcbiAqICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICogICAgICAgICBmcmFtZWQ6IHRydWVcbiAqICAgICB9ICk7XG4gKiAgICAgdmFyIGNvbnRlbnRGcmFtZSA9IG5ldyBPTy51aS5QYW5lbExheW91dCgge1xuICogICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gKiAgICAgICAgIHBhZGRlZDogdHJ1ZVxuICogICAgIH0gKTtcbiAqICAgICBmcmFtZS4kZWxlbWVudC5hcHBlbmQoXG4gKiAgICAgICAgIHRvb2xiYXIuJGVsZW1lbnQsXG4gKiAgICAgICAgIGNvbnRlbnRGcmFtZS4kZWxlbWVudC5hcHBlbmQoICRhcmVhIClcbiAqICAgICApO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIGZyYW1lLiRlbGVtZW50ICk7XG4gKlxuICogICAgIC8vIEhlcmUgaXMgd2hlcmUgdGhlIHRvb2xiYXIgaXMgYWN0dWFsbHkgYnVpbHQuIFRoaXMgbXVzdCBiZSBkb25lIGFmdGVyIGluc2VydGluZyBpdCBpbnRvIHRoZVxuICogICAgIC8vIGRvY3VtZW50LlxuICogICAgIHRvb2xiYXIuaW5pdGlhbGl6ZSgpO1xuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBhZGQgdG9vbHMgdG8gYSBiYXIgdG9vbCBncm91cCwgcGxlYXNlIHNlZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cH0uXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0b29sYmFycyBpbiBnZW5lcmFsLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9Ub29sYmFyc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVG9vbEdyb3VwXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xiYXJ9IHRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuQmFyVG9vbEdyb3VwID0gZnVuY3Rpb24gT29VaUJhclRvb2xHcm91cCggdG9vbGJhciwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCB0b29sYmFyICkgJiYgY29uZmlnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Y29uZmlnID0gdG9vbGJhcjtcblx0XHR0b29sYmFyID0gY29uZmlnLnRvb2xiYXI7XG5cdH1cblxuXHQvLyBQYXJlbnQgY29uc3RydWN0b3Jcblx0T08udWkuQmFyVG9vbEdyb3VwLnBhcmVudC5jYWxsKCB0aGlzLCB0b29sYmFyLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktYmFyVG9vbEdyb3VwJyApO1xuXHR0aGlzLiRncm91cC5hZGRDbGFzcyggJ29vLXVpLWJhclRvb2xHcm91cC10b29scycgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuQmFyVG9vbEdyb3VwLCBPTy51aS5Ub29sR3JvdXAgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5CYXJUb29sR3JvdXAuc3RhdGljLnRpdGxlVG9vbHRpcHMgPSB0cnVlO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkJhclRvb2xHcm91cC5zdGF0aWMuYWNjZWxUb29sdGlwcyA9IHRydWU7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuQmFyVG9vbEdyb3VwLnN0YXRpYy5uYW1lID0gJ2Jhcic7XG5cbi8qKlxuICogUG9wdXBUb29sR3JvdXAgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB1c2VkIGJ5IGJvdGgge0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgTWVudVRvb2xHcm91cH1cbiAqIGFuZCB7QGxpbmsgT08udWkuTGlzdFRvb2xHcm91cCBMaXN0VG9vbEdyb3VwfSB0byBwcm92aWRlIGEgcG9wdXAgKGFuIG92ZXJsYWlkIG1lbnUgb3IgbGlzdCBvZiB0b29scyB3aXRoIGFuXG4gKiBvcHRpb25hbCBpY29uIGFuZCBsYWJlbCkuIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgZm9yIG90aGVyIGJhc2UgY2xhc3NlcyB0aGF0IGFsc28gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuVG9vbEdyb3VwXG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkljb25FbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLkluZGljYXRvckVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uTGFiZWxFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRpdGxlZEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uRmxhZ2dlZEVsZW1lbnRcbiAqIEBtaXhpbnMgT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudFxuICogQG1peGlucyBPTy51aS5taXhpbi5GbG9hdGFibGVFbGVtZW50XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlRhYkluZGV4ZWRFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xiYXJ9IHRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge3N0cmluZ30gW2hlYWRlcl0gVGV4dCB0byBkaXNwbGF5IGF0IHRoZSB0b3Agb2YgdGhlIHBvcHVwXG4gKi9cbk9PLnVpLlBvcHVwVG9vbEdyb3VwID0gZnVuY3Rpb24gT29VaVBvcHVwVG9vbEdyb3VwKCB0b29sYmFyLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHRvb2xiYXIgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSB0b29sYmFyO1xuXHRcdHRvb2xiYXIgPSBjb25maWcudG9vbGJhcjtcblx0fVxuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gJC5leHRlbmQoIHtcblx0XHRpbmRpY2F0b3I6IGNvbmZpZy5pbmRpY2F0b3IgPT09IHVuZGVmaW5lZCA/ICggdG9vbGJhci5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAndXAnIDogJ2Rvd24nICkgOiBjb25maWcuaW5kaWNhdG9yXG5cdH0sIGNvbmZpZyApO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Qb3B1cFRvb2xHcm91cC5wYXJlbnQuY2FsbCggdGhpcywgdG9vbGJhciwgY29uZmlnICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdC8vIERvbid0IGNvbmZsaWN0IHdpdGggcGFyZW50IG1ldGhvZCBvZiB0aGUgc2FtZSBuYW1lXG5cdHRoaXMub25Qb3B1cERvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIgPSB0aGlzLm9uUG9wdXBEb2N1bWVudE1vdXNlS2V5VXAuYmluZCggdGhpcyApO1xuXHR0aGlzLiRoYW5kbGUgPSAkKCAnPHNwYW4+JyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy51aS5taXhpbi5JY29uRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uSW5kaWNhdG9yRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uTGFiZWxFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5UaXRsZWRFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXHRPTy51aS5taXhpbi5GbGFnZ2VkRWxlbWVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblx0T08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkY2xpcHBhYmxlOiB0aGlzLiRncm91cCB9ICkgKTtcblx0T08udWkubWl4aW4uRmxvYXRhYmxlRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywge1xuXHRcdCRmbG9hdGFibGU6IHRoaXMuJGdyb3VwLFxuXHRcdCRmbG9hdGFibGVDb250YWluZXI6IHRoaXMuJGhhbmRsZSxcblx0XHRoaWRlV2hlbk91dE9mVmlldzogZmFsc2UsXG5cdFx0dmVydGljYWxQb3NpdGlvbjogdGhpcy50b29sYmFyLnBvc2l0aW9uID09PSAnYm90dG9tJyA/ICdhYm92ZScgOiAnYmVsb3cnXG5cdH0gKSApO1xuXHRPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudC5jYWxsKCB0aGlzLCAkLmV4dGVuZCgge30sIGNvbmZpZywgeyAkdGFiSW5kZXhlZDogdGhpcy4kaGFuZGxlIH0gKSApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLiRoYW5kbGUub24oIHtcblx0XHRrZXlkb3duOiB0aGlzLm9uSGFuZGxlTW91c2VLZXlEb3duLmJpbmQoIHRoaXMgKSxcblx0XHRrZXl1cDogdGhpcy5vbkhhbmRsZU1vdXNlS2V5VXAuYmluZCggdGhpcyApLFxuXHRcdG1vdXNlZG93bjogdGhpcy5vbkhhbmRsZU1vdXNlS2V5RG93bi5iaW5kKCB0aGlzICksXG5cdFx0bW91c2V1cDogdGhpcy5vbkhhbmRsZU1vdXNlS2V5VXAuYmluZCggdGhpcyApXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRoYW5kbGVcblx0XHQuYWRkQ2xhc3MoICdvby11aS1wb3B1cFRvb2xHcm91cC1oYW5kbGUnIClcblx0XHQuYXR0ciggJ3JvbGUnLCAnYnV0dG9uJyApXG5cdFx0LmFwcGVuZCggdGhpcy4kaWNvbiwgdGhpcy4kbGFiZWwsIHRoaXMuJGluZGljYXRvciApO1xuXHQvLyBJZiB0aGUgcG9wLXVwIHNob3VsZCBoYXZlIGEgaGVhZGVyLCBhZGQgaXQgdG8gdGhlIHRvcCBvZiB0aGUgdG9vbEdyb3VwLlxuXHQvLyBOb3RlOiBJZiB0aGlzIGZlYXR1cmUgaXMgdXNlZnVsIGZvciBvdGhlciB3aWRnZXRzLCB3ZSBjb3VsZCBhYnN0cmFjdCBpdCBpbnRvIGFuXG5cdC8vIE9PLnVpLkhlYWRlcmVkRWxlbWVudCBtaXhpbiBjb25zdHJ1Y3Rvci5cblx0aWYgKCBjb25maWcuaGVhZGVyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy4kZ3JvdXBcblx0XHRcdC5wcmVwZW5kKCAkKCAnPHNwYW4+JyApXG5cdFx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLXBvcHVwVG9vbEdyb3VwLWhlYWRlcicgKVxuXHRcdFx0XHQudGV4dCggY29uZmlnLmhlYWRlciApXG5cdFx0XHQpO1xuXHR9XG5cdHRoaXMuJGVsZW1lbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1wb3B1cFRvb2xHcm91cCcgKVxuXHRcdC5wcmVwZW5kKCB0aGlzLiRoYW5kbGUgKTtcblx0dGhpcy4kZ3JvdXAuYWRkQ2xhc3MoICdvby11aS1wb3B1cFRvb2xHcm91cC10b29scycgKTtcblx0dGhpcy50b29sYmFyLiRwb3B1cHMuYXBwZW5kKCB0aGlzLiRncm91cCApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5Qb3B1cFRvb2xHcm91cCwgT08udWkuVG9vbEdyb3VwICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Qb3B1cFRvb2xHcm91cCwgT08udWkubWl4aW4uSWNvbkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlBvcHVwVG9vbEdyb3VwLCBPTy51aS5taXhpbi5JbmRpY2F0b3JFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Qb3B1cFRvb2xHcm91cCwgT08udWkubWl4aW4uTGFiZWxFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Qb3B1cFRvb2xHcm91cCwgT08udWkubWl4aW4uVGl0bGVkRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBUb29sR3JvdXAsIE9PLnVpLm1peGluLkZsYWdnZWRFbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5Qb3B1cFRvb2xHcm91cCwgT08udWkubWl4aW4uQ2xpcHBhYmxlRWxlbWVudCApO1xuT08ubWl4aW5DbGFzcyggT08udWkuUG9wdXBUb29sR3JvdXAsIE9PLnVpLm1peGluLkZsb2F0YWJsZUVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLlBvcHVwVG9vbEdyb3VwLCBPTy51aS5taXhpbi5UYWJJbmRleGVkRWxlbWVudCApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUG9wdXBUb29sR3JvdXAucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlBvcHVwVG9vbEdyb3VwLnBhcmVudC5wcm90b3R5cGUuc2V0RGlzYWJsZWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdGlmICggdGhpcy5pc0Rpc2FibGVkKCkgJiYgdGhpcy5pc0VsZW1lbnRBdHRhY2hlZCgpICkge1xuXHRcdHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBkb2N1bWVudCBtb3VzZSB1cCBhbmQga2V5IHVwIGV2ZW50cy5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudH0gZSBNb3VzZSB1cCBvciBrZXkgdXAgZXZlbnRcbiAqL1xuT08udWkuUG9wdXBUb29sR3JvdXAucHJvdG90eXBlLm9uUG9wdXBEb2N1bWVudE1vdXNlS2V5VXAgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciAkdGFyZ2V0ID0gJCggZS50YXJnZXQgKTtcblx0Ly8gT25seSBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgZHJvcGRvd24gZWxlbWVudFxuXHRpZiAoICR0YXJnZXQuY2xvc2VzdCggJy5vby11aS1wb3B1cFRvb2xHcm91cCcgKVsgMCBdID09PSB0aGlzLiRlbGVtZW50WyAwIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmICggJHRhcmdldC5jbG9zZXN0KCAnLm9vLXVpLXBvcHVwVG9vbEdyb3VwLXRvb2xzJyApWyAwIF0gPT09IHRoaXMuJGdyb3VwWyAwIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xufTtcblxuLy8gRGVwcmVjYXRlZCBhbGlhcyBzaW5jZSAwLjI4LjNcbk9PLnVpLlBvcHVwVG9vbEdyb3VwLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG5cdE9PLnVpLndhcm5EZXByZWNhdGlvbiggJ29uQmx1ciBpcyBkZXByZWNhdGVkLCB1c2Ugb25Qb3B1cERvY3VtZW50TW91c2VLZXlVcCBpbnN0ZWFkJyApO1xuXHR0aGlzLm9uUG9wdXBEb2N1bWVudE1vdXNlS2V5VXAuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qb3B1cFRvb2xHcm91cC5wcm90b3R5cGUub25Nb3VzZUtleVVwID0gZnVuY3Rpb24gKCBlICkge1xuXHQvLyBPbmx5IGNsb3NlIHRvb2xncm91cCB3aGVuIGEgdG9vbCB3YXMgYWN0dWFsbHkgc2VsZWN0ZWRcblx0aWYgKFxuXHRcdCF0aGlzLmlzRGlzYWJsZWQoKSAmJiB0aGlzLnByZXNzZWQgJiYgdGhpcy5wcmVzc2VkID09PSB0aGlzLmZpbmRUYXJnZXRUb29sKCBlICkgJiZcblx0XHQoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuU1BBQ0UgfHwgZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiApXG5cdCkge1xuXHRcdHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xuXHR9XG5cdHJldHVybiBPTy51aS5Qb3B1cFRvb2xHcm91cC5wYXJlbnQucHJvdG90eXBlLm9uTW91c2VLZXlVcC5jYWxsKCB0aGlzLCBlICk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlBvcHVwVG9vbEdyb3VwLnByb3RvdHlwZS5vbk1vdXNlS2V5RG93biA9IGZ1bmN0aW9uICggZSApIHtcblx0dmFyICRmb2N1c2VkLCAkZmlyc3RGb2N1c2FibGUsICRsYXN0Rm9jdXNhYmxlO1xuXHQvLyBTaGlmdC1UYWIgb24gdGhlIGZpcnN0IHRvb2wgaW4gdGhlIGdyb3VwIGp1bXBzIHRvIHRoZSBoYW5kbGUuXG5cdC8vIFRhYiBvbiB0aGUgbGFzdCB0b29sIGluIHRoZSBncm91cCBqdW1wcyB0byB0aGUgbmV4dCBncm91cC5cblx0aWYgKCAhdGhpcy5pc0Rpc2FibGVkKCkgJiYgZS53aGljaCA9PT0gT08udWkuS2V5cy5UQUIgKSB7XG5cdFx0Ly8gKFdlIGNhbid0IHVzZSB0aGlzLml0ZW1zIGJlY2F1c2UgTGlzdFRvb2xHcm91cCBpbnNlcnRzIHRoZSBleHRyYSBmYWtlIGV4cGFuZC9jb2xsYXBzZSB0b29sLilcblx0XHQkZm9jdXNlZCA9ICQoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKTtcblx0XHQkZmlyc3RGb2N1c2FibGUgPSBPTy51aS5maW5kRm9jdXNhYmxlKCB0aGlzLiRncm91cCApO1xuXHRcdGlmICggJGZvY3VzZWRbIDAgXSA9PT0gJGZpcnN0Rm9jdXNhYmxlWyAwIF0gJiYgZS5zaGlmdEtleSApIHtcblx0XHRcdHRoaXMuJGhhbmRsZS5mb2N1cygpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQkbGFzdEZvY3VzYWJsZSA9IE9PLnVpLmZpbmRGb2N1c2FibGUoIHRoaXMuJGdyb3VwLCB0cnVlICk7XG5cdFx0aWYgKCAkZm9jdXNlZFsgMCBdID09PSAkbGFzdEZvY3VzYWJsZVsgMCBdICYmICFlLnNoaWZ0S2V5ICkge1xuXHRcdFx0Ly8gRm9jdXMgdGhpcyBncm91cCdzIGhhbmRsZSBhbmQgbGV0IHRoZSBicm93c2VyJ3MgdGFiIGhhbmRsaW5nIGhhcHBlbiAobm8gJ3JldHVybiBmYWxzZScpLlxuXHRcdFx0Ly8gVGhpcyB3YXkgd2UgZG9uJ3QgaGF2ZSB0byBmaWRkbGUgd2l0aCBvdGhlciBUb29sR3JvdXBzJyBidXNpbmVzcywgb3Igd29ycnkgd2hhdCB0byBkb1xuXHRcdFx0Ly8gaWYgdGhlIG5leHQgZ3JvdXAgaXMgbm90IGEgUG9wdXBUb29sR3JvdXAgb3IgZG9lc24ndCBleGlzdCBhdCBhbGwuXG5cdFx0XHR0aGlzLiRoYW5kbGUuZm9jdXMoKTtcblx0XHRcdC8vIENsb3NlIHRoZSBwb3B1cCBzbyB0aGF0IHdlIGRvbid0IG1vdmUgYmFjayBpbnNpZGUgaXQgKGlmIHRoaXMgaXMgdGhlIGxhc3QgZ3JvdXApLlxuXHRcdFx0dGhpcy5zZXRBY3RpdmUoIGZhbHNlICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBPTy51aS5Qb3B1cFRvb2xHcm91cC5wYXJlbnQucHJvdG90eXBlLm9uTW91c2VLZXlEb3duLmNhbGwoIHRoaXMsIGUgKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIHVwIGFuZCBrZXkgdXAgZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIHVwIG9yIGtleSB1cCBldmVudFxuICogQHJldHVybiB7dW5kZWZpbmVkL2Jvb2xlYW59IEZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBpZiBldmVudCBpcyBoYW5kbGVkXG4gKi9cbk9PLnVpLlBvcHVwVG9vbEdyb3VwLnByb3RvdHlwZS5vbkhhbmRsZU1vdXNlS2V5VXAgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdGlmIChcblx0XHQhdGhpcy5pc0Rpc2FibGVkKCkgJiZcblx0XHQoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuU1BBQ0UgfHwgZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiApXG5cdCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGUgbW91c2UgZG93biBhbmQga2V5IGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIE1vdXNlIGRvd24gb3Iga2V5IGRvd24gZXZlbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZC9ib29sZWFufSBGYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgaWYgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5PTy51aS5Qb3B1cFRvb2xHcm91cC5wcm90b3R5cGUub25IYW5kbGVNb3VzZUtleURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciAkZm9jdXNhYmxlO1xuXHRpZiAoICF0aGlzLmlzRGlzYWJsZWQoKSApIHtcblx0XHQvLyBUYWIgb24gdGhlIGhhbmRsZSBqdW1wcyB0byB0aGUgZmlyc3QgdG9vbCBpbiB0aGUgZ3JvdXAgKGlmIHRoZSBwb3B1cCBpcyBvcGVuKS5cblx0XHRpZiAoIGUud2hpY2ggPT09IE9PLnVpLktleXMuVEFCICYmICFlLnNoaWZ0S2V5ICkge1xuXHRcdFx0JGZvY3VzYWJsZSA9IE9PLnVpLmZpbmRGb2N1c2FibGUoIHRoaXMuJGdyb3VwICk7XG5cdFx0XHRpZiAoICRmb2N1c2FibGUubGVuZ3RoICkge1xuXHRcdFx0XHQkZm9jdXNhYmxlLnRyaWdnZXIoICdmb2N1cycgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuU1BBQ0UgfHwgZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiApIHtcblx0XHRcdHRoaXMuc2V0QWN0aXZlKCAhdGhpcy5hY3RpdmUgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvb2wgZ3JvdXAgaXMgYWN0aXZlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRvb2wgZ3JvdXAgaXMgYWN0aXZlXG4gKi9cbk9PLnVpLlBvcHVwVG9vbEdyb3VwLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuYWN0aXZlO1xufTtcblxuLyoqXG4gKiBTd2l0Y2ggaW50byAnYWN0aXZlJyBtb2RlLlxuICpcbiAqIFdoZW4gYWN0aXZlLCB0aGUgcG9wdXAgaXMgdmlzaWJsZS4gQSBtb3VzZXVwIGV2ZW50IGFueXdoZXJlIGluIHRoZSBkb2N1bWVudCB3aWxsIHRyaWdnZXJcbiAqIGRlYWN0aXZhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFRoZSBhY3RpdmUgc3RhdGUgdG8gc2V0XG4gKiBAZmlyZXMgYWN0aXZlXG4gKi9cbk9PLnVpLlBvcHVwVG9vbEdyb3VwLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHR2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckxlZnQ7XG5cdHZhbHVlID0gISF2YWx1ZTtcblx0aWYgKCB0aGlzLmFjdGl2ZSAhPT0gdmFsdWUgKSB7XG5cdFx0dGhpcy5hY3RpdmUgPSB2YWx1ZTtcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHRoaXMub25Qb3B1cERvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5vblBvcHVwRG9jdW1lbnRNb3VzZUtleVVwSGFuZGxlciwgdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLiRjbGlwcGFibGUuY3NzKCAnbGVmdCcsICcnICk7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktcG9wdXBUb29sR3JvdXAtYWN0aXZlJyApO1xuXHRcdFx0dGhpcy4kZ3JvdXAuYWRkQ2xhc3MoICdvby11aS1wb3B1cFRvb2xHcm91cC1hY3RpdmUtdG9vbHMnICk7XG5cdFx0XHR0aGlzLnRvZ2dsZVBvc2l0aW9uaW5nKCB0cnVlICk7XG5cdFx0XHR0aGlzLnRvZ2dsZUNsaXBwaW5nKCB0cnVlICk7XG5cblx0XHRcdC8vIFRyeSBhbmNob3JpbmcgdGhlIHBvcHVwIHRvIHRoZSBsZWZ0IGZpcnN0XG5cdFx0XHR0aGlzLnNldEhvcml6b250YWxQb3NpdGlvbiggJ3N0YXJ0JyApO1xuXG5cdFx0XHRpZiAoIHRoaXMuaXNDbGlwcGVkSG9yaXpvbnRhbGx5KCkgfHwgdGhpcy5pc0Zsb2F0YWJsZU91dE9mVmlldygpICkge1xuXHRcdFx0XHQvLyBBbmNob3JpbmcgdG8gdGhlIGxlZnQgY2F1c2VkIHRoZSBwb3B1cCB0byBjbGlwLCBzbyBhbmNob3IgaXQgdG8gdGhlIHJpZ2h0IGluc3RlYWRcblx0XHRcdFx0dGhpcy5zZXRIb3Jpem9udGFsUG9zaXRpb24oICdlbmQnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuaXNDbGlwcGVkSG9yaXpvbnRhbGx5KCkgfHwgdGhpcy5pc0Zsb2F0YWJsZU91dE9mVmlldygpICkge1xuXHRcdFx0XHQvLyBBbmNob3JpbmcgdG8gdGhlIHJpZ2h0IGFsc28gY2F1c2VkIHRoZSBwb3B1cCB0byBjbGlwLCBzbyBqdXN0IG1ha2UgaXQgZmlsbCB0aGUgY29udGFpbmVyXG5cdFx0XHRcdGNvbnRhaW5lcldpZHRoID0gdGhpcy4kY2xpcHBhYmxlU2Nyb2xsYWJsZUNvbnRhaW5lci53aWR0aCgpO1xuXHRcdFx0XHRjb250YWluZXJMZWZ0ID0gdGhpcy4kY2xpcHBhYmxlU2Nyb2xsYWJsZUNvbnRhaW5lclsgMCBdID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgP1xuXHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdHRoaXMuJGNsaXBwYWJsZVNjcm9sbGFibGVDb250YWluZXIub2Zmc2V0KCkubGVmdDtcblxuXHRcdFx0XHR0aGlzLnRvZ2dsZUNsaXBwaW5nKCBmYWxzZSApO1xuXHRcdFx0XHR0aGlzLnNldEhvcml6b250YWxQb3NpdGlvbiggJ3N0YXJ0JyApO1xuXG5cdFx0XHRcdHRoaXMuJGNsaXBwYWJsZS5jc3MoIHtcblx0XHRcdFx0XHQnbWFyZ2luLWxlZnQnOiAtKCB0aGlzLiRlbGVtZW50Lm9mZnNldCgpLmxlZnQgLSBjb250YWluZXJMZWZ0ICksXG5cdFx0XHRcdFx0d2lkdGg6IGNvbnRhaW5lcldpZHRoXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5nZXRFbGVtZW50RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHRoaXMub25Qb3B1cERvY3VtZW50TW91c2VLZXlVcEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdHRoaXMuZ2V0RWxlbWVudERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5vblBvcHVwRG9jdW1lbnRNb3VzZUtleVVwSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLXBvcHVwVG9vbEdyb3VwLWFjdGl2ZScgKTtcblx0XHRcdHRoaXMuJGdyb3VwLnJlbW92ZUNsYXNzKCAnb28tdWktcG9wdXBUb29sR3JvdXAtYWN0aXZlLXRvb2xzJyApO1xuXHRcdFx0dGhpcy50b2dnbGVQb3NpdGlvbmluZyggZmFsc2UgKTtcblx0XHRcdHRoaXMudG9nZ2xlQ2xpcHBpbmcoIGZhbHNlICk7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCggJ2FjdGl2ZScsIHRoaXMuYWN0aXZlICk7XG5cdFx0dGhpcy51cGRhdGVUaGVtZUNsYXNzZXMoKTtcblx0fVxufTtcblxuLyoqXG4gKiBMaXN0VG9vbEdyb3VwcyBhcmUgb25lIG9mIHRocmVlIHR5cGVzIG9mIHtAbGluayBPTy51aS5Ub29sR3JvdXAgdG9vbGdyb3Vwc30gdGhhdCBhcmUgdXNlZCB0b1xuICogY3JlYXRlIHtAbGluayBPTy51aS5Ub29sYmFyIHRvb2xiYXJzfSAodGhlIG90aGVyIHR5cGVzIG9mIGdyb3VwcyBhcmUge0BsaW5rIE9PLnVpLk1lbnVUb29sR3JvdXAgTWVudVRvb2xHcm91cH1cbiAqIGFuZCB7QGxpbmsgT08udWkuQmFyVG9vbEdyb3VwIEJhclRvb2xHcm91cH0pLiBUaGUge0BsaW5rIE9PLnVpLlRvb2wgdG9vbHN9IGluIGEgTGlzdFRvb2xHcm91cCBhcmUgZGlzcGxheWVkXG4gKiBieSBsYWJlbCBpbiBhIGRyb3Bkb3duIG1lbnUuIFRoZSB0aXRsZSBvZiB0aGUgdG9vbCBpcyB1c2VkIGFzIHRoZSBsYWJlbCB0ZXh0LiBUaGUgbWVudSBpdHNlbGYgY2FuIGJlIGNvbmZpZ3VyZWRcbiAqIHdpdGggYSBsYWJlbCwgaWNvbiwgaW5kaWNhdG9yLCBoZWFkZXIsIGFuZCB0aXRsZS5cbiAqXG4gKiBMaXN0VG9vbEdyb3VwcyBjYW4gYmUgY29uZmlndXJlZCB0byBiZSBleHBhbmRlZCBhbmQgY29sbGFwc2VkLiBDb2xsYXBzZWQgbGlzdHMgd2lsbCBoYXZlIGEg4oCYTW9yZeKAmSBvcHRpb24gdGhhdFxuICogdXNlcnMgY2FuIHNlbGVjdCB0byBzZWUgdGhlIGZ1bGwgbGlzdCBvZiB0b29scy4gSWYgYSBjb2xsYXBzZWQgdG9vbGdyb3VwIGlzIGV4cGFuZGVkLCBhIOKAmEZld2Vy4oCZIG9wdGlvbiBwZXJtaXRzXG4gKiB1c2VycyB0byBjb2xsYXBzZSB0aGUgbGlzdCBhZ2Fpbi5cbiAqXG4gKiBMaXN0VG9vbEdyb3VwcyBhcmUgY3JlYXRlZCBieSBhIHtAbGluayBPTy51aS5Ub29sR3JvdXBGYWN0b3J5IHRvb2xncm91cCBmYWN0b3J5fSB3aGVuIHRoZSB0b29sYmFyIGlzIHNldCB1cC4gVGhlIGZhY3RvcnlcbiAqIHJlcXVpcmVzIHRoZSBMaXN0VG9vbEdyb3VwJ3Mgc3ltYm9saWMgbmFtZSwgJ2xpc3QnLCB3aGljaCBpcyBzcGVjaWZpZWQgYWxvbmcgd2l0aCB0aGUgb3RoZXIgY29uZmlndXJhdGlvbnMuIEZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gYWRkIHRvb2xzIHRvIGEgTGlzdFRvb2xHcm91cCwgcGxlYXNlIHNlZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cH0uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZSBvZiBhIExpc3RUb29sR3JvdXBcbiAqICAgICB2YXIgdG9vbEZhY3RvcnkgPSBuZXcgT08udWkuVG9vbEZhY3RvcnkoKTtcbiAqICAgICB2YXIgdG9vbEdyb3VwRmFjdG9yeSA9IG5ldyBPTy51aS5Ub29sR3JvdXBGYWN0b3J5KCk7XG4gKiAgICAgdmFyIHRvb2xiYXIgPSBuZXcgT08udWkuVG9vbGJhciggdG9vbEZhY3RvcnksIHRvb2xHcm91cEZhY3RvcnkgKTtcbiAqXG4gKiAgICAgLy8gQ29uZmlndXJlIGFuZCByZWdpc3RlciB0d28gdG9vbHNcbiAqICAgICBmdW5jdGlvbiBTZXR0aW5nc1Rvb2woKSB7XG4gKiAgICAgICAgIFNldHRpbmdzVG9vbC5wYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIFNldHRpbmdzVG9vbCwgT08udWkuVG9vbCApO1xuICogICAgIFNldHRpbmdzVG9vbC5zdGF0aWMubmFtZSA9ICdzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy5pY29uID0gJ3NldHRpbmdzJztcbiAqICAgICBTZXR0aW5nc1Rvb2wuc3RhdGljLnRpdGxlID0gJ0NoYW5nZSBzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnByb3RvdHlwZS5vblNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdGhpcy5zZXRBY3RpdmUoIGZhbHNlICk7XG4gKiAgICAgfTtcbiAqICAgICBTZXR0aW5nc1Rvb2wucHJvdG90eXBlLm9uVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAqICAgICB0b29sRmFjdG9yeS5yZWdpc3RlciggU2V0dGluZ3NUb29sICk7XG4gKiAgICAgLy8gUmVnaXN0ZXIgdHdvIG1vcmUgdG9vbHMsIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGVyZVxuICogICAgIGZ1bmN0aW9uIFN0dWZmVG9vbCgpIHtcbiAqICAgICAgICAgU3R1ZmZUb29sLnBhcmVudC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggU3R1ZmZUb29sLCBPTy51aS5Ub29sICk7XG4gKiAgICAgU3R1ZmZUb29sLnN0YXRpYy5uYW1lID0gJ3N0dWZmJztcbiAqICAgICBTdHVmZlRvb2wuc3RhdGljLmljb24gPSAnc2VhcmNoJztcbiAqICAgICBTdHVmZlRvb2wuc3RhdGljLnRpdGxlID0gJ0NoYW5nZSB0aGUgd29ybGQnO1xuICogICAgIFN0dWZmVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xuICogICAgIH07XG4gKiAgICAgU3R1ZmZUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge307XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFN0dWZmVG9vbCApO1xuICogICAgIHRvb2xiYXIuc2V0dXAoIFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgLy8gQ29uZmlndXJhdGlvbnMgZm9yIGxpc3QgdG9vbGdyb3VwLlxuICogICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICogICAgICAgICAgICAgbGFiZWw6ICdMaXN0VG9vbEdyb3VwJyxcbiAqICAgICAgICAgICAgIGljb246ICdlbGxpcHNpcycsXG4gKiAgICAgICAgICAgICB0aXRsZTogJ1RoaXMgaXMgdGhlIHRpdGxlLCBkaXNwbGF5ZWQgd2hlbiB1c2VyIG1vdmVzIHRoZSBtb3VzZSBvdmVyIHRoZSBsaXN0IHRvb2xncm91cCcsXG4gKiAgICAgICAgICAgICBoZWFkZXI6ICdUaGlzIGlzIHRoZSBoZWFkZXInLFxuICogICAgICAgICAgICAgaW5jbHVkZTogWyAnc2V0dGluZ3MnLCAnc3R1ZmYnIF0sXG4gKiAgICAgICAgICAgICBhbGxvd0NvbGxhcHNlOiBbJ3N0dWZmJ11cbiAqICAgICAgICAgfVxuICogICAgIF0gKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHNvbWUgVUkgYXJvdW5kIHRoZSB0b29sYmFyIGFuZCBwbGFjZSBpdCBpbiB0aGUgZG9jdW1lbnRcbiAqICAgICB2YXIgZnJhbWUgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcbiAqICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICogICAgICAgICBmcmFtZWQ6IHRydWVcbiAqICAgICB9ICk7XG4gKiAgICAgZnJhbWUuJGVsZW1lbnQuYXBwZW5kKFxuICogICAgICAgICB0b29sYmFyLiRlbGVtZW50XG4gKiAgICAgKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBmcmFtZS4kZWxlbWVudCApO1xuICogICAgIC8vIEJ1aWxkIHRoZSB0b29sYmFyLiBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciB0aGUgdG9vbGJhciBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgZG9jdW1lbnQuXG4gKiAgICAgdG9vbGJhci5pbml0aWFsaXplKCk7XG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdG9vbGJhcnMgaW4gZ2VuZXJhbCwgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvVG9vbGJhcnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLlBvcHVwVG9vbEdyb3VwXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xiYXJ9IHRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge0FycmF5fSBbYWxsb3dDb2xsYXBzZV0gQWxsb3cgdGhlIHNwZWNpZmllZCB0b29scyB0byBiZSBjb2xsYXBzZWQuIEJ5IGRlZmF1bHQsIGNvbGxhcHNpYmxlIHRvb2xzXG4gKiAgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBpZiB1c2VycyBjbGljayB0aGUg4oCYTW9yZeKAmSBvcHRpb24gZGlzcGxheWVkIGF0IHRoZSBib3R0b20gb2YgdGhlIGxpc3QuIElmXG4gKiAgdGhlIGxpc3QgaXMgZXhwYW5kZWQsIGEg4oCYRmV3ZXLigJkgb3B0aW9uIHBlcm1pdHMgdXNlcnMgdG8gY29sbGFwc2UgdGhlIGxpc3QgYWdhaW4uIEFueSB0b29scyB0aGF0XG4gKiAgYXJlIGluY2x1ZGVkIGluIHRoZSB0b29sZ3JvdXAsIGJ1dCBhcmUgbm90IGRlc2lnbmF0ZWQgYXMgY29sbGFwc2libGUsIHdpbGwgYWx3YXlzIGJlIGRpc3BsYXllZC5cbiAqICBUbyBvcGVuIGEgY29sbGFwc2libGUgbGlzdCBpbiBpdHMgZXhwYW5kZWQgc3RhdGUsIHNldCAjZXhwYW5kZWQgdG8gJ3RydWUnLlxuICogQGNmZyB7QXJyYXl9IFtmb3JjZUV4cGFuZF0gRXhwYW5kIHRoZSBzcGVjaWZpZWQgdG9vbHMuIEFsbCBvdGhlciB0b29scyB3aWxsIGJlIGRlc2lnbmF0ZWQgYXMgY29sbGFwc2libGUuXG4gKiAgVW5sZXNzICNleHBhbmRlZCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGNvbGxhcHNpYmxlIHRvb2xzIHdpbGwgYmUgY29sbGFwc2VkIHdoZW4gdGhlIGxpc3QgaXMgZmlyc3Qgb3BlbmVkLlxuICogQGNmZyB7Ym9vbGVhbn0gW2V4cGFuZGVkPWZhbHNlXSBFeHBhbmQgY29sbGFwc2libGUgdG9vbHMuIFRoaXMgY29uZmlnIGlzIG9ubHkgcmVsZXZhbnQgaWYgdG9vbHMgaGF2ZVxuICogIGJlZW4gZGVzaWduYXRlZCBhcyBjb2xsYXBzaWJsZS4gV2hlbiBleHBhbmRlZCBpcyBzZXQgdG8gdHJ1ZSwgYWxsIHRvb2xzIGluIHRoZSBncm91cCB3aWxsIGJlIGRpc3BsYXllZFxuICogIHdoZW4gdGhlIGxpc3QgaXMgZmlyc3Qgb3BlbmVkLiBVc2VycyBjYW4gY29sbGFwc2UgdGhlIGxpc3Qgd2l0aCBhIOKAmEZld2Vy4oCZIG9wdGlvbiBhdCB0aGUgYm90dG9tLlxuICovXG5PTy51aS5MaXN0VG9vbEdyb3VwID0gZnVuY3Rpb24gT29VaUxpc3RUb29sR3JvdXAoIHRvb2xiYXIsIGNvbmZpZyApIHtcblx0Ly8gQWxsb3cgcGFzc2luZyBwb3NpdGlvbmFsIHBhcmFtZXRlcnMgaW5zaWRlIHRoZSBjb25maWcgb2JqZWN0XG5cdGlmICggT08uaXNQbGFpbk9iamVjdCggdG9vbGJhciApICYmIGNvbmZpZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGNvbmZpZyA9IHRvb2xiYXI7XG5cdFx0dG9vbGJhciA9IGNvbmZpZy50b29sYmFyO1xuXHR9XG5cblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUHJvcGVydGllcyAobXVzdCBiZSBzZXQgYmVmb3JlIHBhcmVudCBjb25zdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgI3BvcHVsYXRlKVxuXHR0aGlzLmFsbG93Q29sbGFwc2UgPSBjb25maWcuYWxsb3dDb2xsYXBzZTtcblx0dGhpcy5mb3JjZUV4cGFuZCA9IGNvbmZpZy5mb3JjZUV4cGFuZDtcblx0dGhpcy5leHBhbmRlZCA9IGNvbmZpZy5leHBhbmRlZCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmV4cGFuZGVkIDogZmFsc2U7XG5cdHRoaXMuY29sbGFwc2libGVUb29scyA9IFtdO1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5MaXN0VG9vbEdyb3VwLnBhcmVudC5jYWxsKCB0aGlzLCB0b29sYmFyLCBjb25maWcgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktbGlzdFRvb2xHcm91cCcgKTtcblx0dGhpcy4kZ3JvdXAuYWRkQ2xhc3MoICdvby11aS1saXN0VG9vbEdyb3VwLXRvb2xzJyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5MaXN0VG9vbEdyb3VwLCBPTy51aS5Qb3B1cFRvb2xHcm91cCApO1xuXG4vKiBTdGF0aWMgUHJvcGVydGllcyAqL1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLkxpc3RUb29sR3JvdXAuc3RhdGljLm5hbWUgPSAnbGlzdCc7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5MaXN0VG9vbEdyb3VwLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbiwgYWxsb3dDb2xsYXBzZSA9IFtdO1xuXG5cdE9PLnVpLkxpc3RUb29sR3JvdXAucGFyZW50LnByb3RvdHlwZS5wb3B1bGF0ZS5jYWxsKCB0aGlzICk7XG5cblx0Ly8gVXBkYXRlIHRoZSBsaXN0IG9mIGNvbGxhcHNpYmxlIHRvb2xzXG5cdGlmICggdGhpcy5hbGxvd0NvbGxhcHNlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0YWxsb3dDb2xsYXBzZSA9IHRoaXMuYWxsb3dDb2xsYXBzZTtcblx0fSBlbHNlIGlmICggdGhpcy5mb3JjZUV4cGFuZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGFsbG93Q29sbGFwc2UgPSBPTy5zaW1wbGVBcnJheURpZmZlcmVuY2UoIE9iamVjdC5rZXlzKCB0aGlzLnRvb2xzICksIHRoaXMuZm9yY2VFeHBhbmQgKTtcblx0fVxuXG5cdHRoaXMuY29sbGFwc2libGVUb29scyA9IFtdO1xuXHRmb3IgKCBpID0gMCwgbGVuID0gYWxsb3dDb2xsYXBzZS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIHRoaXMudG9vbHNbIGFsbG93Q29sbGFwc2VbIGkgXSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNvbGxhcHNpYmxlVG9vbHMucHVzaCggdGhpcy50b29sc1sgYWxsb3dDb2xsYXBzZVsgaSBdIF0gKTtcblx0XHR9XG5cdH1cblxuXHQvLyBLZWVwIGF0IHRoZSBlbmQsIGV2ZW4gd2hlbiB0b29scyBhcmUgYWRkZWRcblx0dGhpcy4kZ3JvdXAuYXBwZW5kKCB0aGlzLmdldEV4cGFuZENvbGxhcHNlVG9vbCgpLiRlbGVtZW50ICk7XG5cblx0dGhpcy5nZXRFeHBhbmRDb2xsYXBzZVRvb2woKS50b2dnbGUoIHRoaXMuY29sbGFwc2libGVUb29scy5sZW5ndGggIT09IDAgKTtcblx0dGhpcy51cGRhdGVDb2xsYXBzaWJsZVN0YXRlKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXhwYW5kL2NvbGxhcHNlIHRvb2wgZm9yIHRoaXMgZ3JvdXBcbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5Ub29sfSBFeHBhbmQgY29sbGFwc2UgdG9vbFxuICovXG5PTy51aS5MaXN0VG9vbEdyb3VwLnByb3RvdHlwZS5nZXRFeHBhbmRDb2xsYXBzZVRvb2wgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBFeHBhbmRDb2xsYXBzZVRvb2w7XG5cdGlmICggdGhpcy5leHBhbmRDb2xsYXBzZVRvb2wgPT09IHVuZGVmaW5lZCApIHtcblx0XHRFeHBhbmRDb2xsYXBzZVRvb2wgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRFeHBhbmRDb2xsYXBzZVRvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0T08uaW5oZXJpdENsYXNzKCBFeHBhbmRDb2xsYXBzZVRvb2wsIE9PLnVpLlRvb2wgKTtcblxuXHRcdEV4cGFuZENvbGxhcHNlVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnRvb2xHcm91cC5leHBhbmRlZCA9ICF0aGlzLnRvb2xHcm91cC5leHBhbmRlZDtcblx0XHRcdHRoaXMudG9vbEdyb3VwLnVwZGF0ZUNvbGxhcHNpYmxlU3RhdGUoKTtcblx0XHRcdHRoaXMuc2V0QWN0aXZlKCBmYWxzZSApO1xuXHRcdH07XG5cdFx0RXhwYW5kQ29sbGFwc2VUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gRG8gbm90aGluZy4gVG9vbCBpbnRlcmZhY2UgcmVxdWlyZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbi5cblx0XHR9O1xuXG5cdFx0RXhwYW5kQ29sbGFwc2VUb29sLnN0YXRpYy5uYW1lID0gJ21vcmUtZmV3ZXInO1xuXG5cdFx0dGhpcy5leHBhbmRDb2xsYXBzZVRvb2wgPSBuZXcgRXhwYW5kQ29sbGFwc2VUb29sKCB0aGlzICk7XG5cdH1cblx0cmV0dXJuIHRoaXMuZXhwYW5kQ29sbGFwc2VUb29sO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5MaXN0VG9vbEdyb3VwLnByb3RvdHlwZS5vbk1vdXNlS2V5VXAgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdC8vIERvIG5vdCBjbG9zZSB0aGUgcG9wdXAgd2hlbiB0aGUgdXNlciB3YW50cyB0byBzaG93IG1vcmUvZmV3ZXIgdG9vbHNcblx0aWYgKFxuXHRcdCQoIGUudGFyZ2V0ICkuY2xvc2VzdCggJy5vby11aS10b29sLW5hbWUtbW9yZS1mZXdlcicgKS5sZW5ndGggJiZcblx0XHQoIGUud2hpY2ggPT09IE9PLnVpLk1vdXNlQnV0dG9ucy5MRUZUIHx8IGUud2hpY2ggPT09IE9PLnVpLktleXMuU1BBQ0UgfHwgZS53aGljaCA9PT0gT08udWkuS2V5cy5FTlRFUiApXG5cdCkge1xuXHRcdC8vIEhBQ0s6IFByZXZlbnQgdGhlIHBvcHVwIGxpc3QgZnJvbSBiZWluZyBoaWRkZW4uIFNraXAgdGhlIFBvcHVwVG9vbEdyb3VwIGltcGxlbWVudGF0aW9uICh3aGljaFxuXHRcdC8vIGhpZGVzIHRoZSBwb3B1cCBsaXN0IHdoZW4gYSB0b29sIGlzIHNlbGVjdGVkKSBhbmQgY2FsbCBUb29sR3JvdXAncyBpbXBsZW1lbnRhdGlvbiBkaXJlY3RseS5cblx0XHRyZXR1cm4gT08udWkuTGlzdFRvb2xHcm91cC5wYXJlbnQucGFyZW50LnByb3RvdHlwZS5vbk1vdXNlS2V5VXAuY2FsbCggdGhpcywgZSApO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBPTy51aS5MaXN0VG9vbEdyb3VwLnBhcmVudC5wcm90b3R5cGUub25Nb3VzZUtleVVwLmNhbGwoIHRoaXMsIGUgKTtcblx0fVxufTtcblxuT08udWkuTGlzdFRvb2xHcm91cC5wcm90b3R5cGUudXBkYXRlQ29sbGFwc2libGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGljb24sIGxlbjtcblxuXHRpZiAoIHRoaXMudG9vbGJhci5wb3NpdGlvbiAhPT0gJ2JvdHRvbScgKSB7XG5cdFx0aWNvbiA9IHRoaXMuZXhwYW5kZWQgPyAnY29sbGFwc2UnIDogJ2V4cGFuZCc7XG5cdH0gZWxzZSB7XG5cdFx0aWNvbiA9IHRoaXMuZXhwYW5kZWQgPyAnZXhwYW5kJyA6ICdjb2xsYXBzZSc7XG5cdH1cblxuXHR0aGlzLmdldEV4cGFuZENvbGxhcHNlVG9vbCgpXG5cdFx0LnNldEljb24oIGljb24gKVxuXHRcdC5zZXRUaXRsZSggT08udWkubXNnKCB0aGlzLmV4cGFuZGVkID8gJ29vdWktdG9vbGdyb3VwLWNvbGxhcHNlJyA6ICdvb3VpLXRvb2xncm91cC1leHBhbmQnICkgKTtcblxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5jb2xsYXBzaWJsZVRvb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHRoaXMuY29sbGFwc2libGVUb29sc1sgaSBdLnRvZ2dsZSggdGhpcy5leHBhbmRlZCApO1xuXHR9XG5cblx0Ly8gUmUtZXZhbHVhdGUgY2xpcHBpbmcsIGJlY2F1c2Ugb3VyIGhlaWdodCBoYXMgY2hhbmdlZFxuXHR0aGlzLmNsaXAoKTtcbn07XG5cbi8qKlxuICogTWVudVRvb2xHcm91cHMgYXJlIG9uZSBvZiB0aHJlZSB0eXBlcyBvZiB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cHN9IHRoYXQgYXJlIHVzZWQgdG9cbiAqIGNyZWF0ZSB7QGxpbmsgT08udWkuVG9vbGJhciB0b29sYmFyc30gKHRoZSBvdGhlciB0eXBlcyBvZiBncm91cHMgYXJlIHtAbGluayBPTy51aS5CYXJUb29sR3JvdXAgQmFyVG9vbEdyb3VwfVxuICogYW5kIHtAbGluayBPTy51aS5MaXN0VG9vbEdyb3VwIExpc3RUb29sR3JvdXB9KS4gTWVudVRvb2xHcm91cHMgY29udGFpbiBzZWxlY3RhYmxlIHtAbGluayBPTy51aS5Ub29sIHRvb2xzfSxcbiAqIHdoaWNoIGFyZSBkaXNwbGF5ZWQgYnkgbGFiZWwgaW4gYSBkcm9wZG93biBtZW51LiBUaGUgdG9vbCdzIHRpdGxlIGlzIHVzZWQgYXMgdGhlIGxhYmVsIHRleHQsIGFuZCB0aGVcbiAqIG1lbnUgbGFiZWwgaXMgdXBkYXRlZCB0byByZWZsZWN0IHdoaWNoIHRvb2wgb3IgdG9vbHMgYXJlIGN1cnJlbnRseSBzZWxlY3RlZC4gSWYgbm8gdG9vbHMgYXJlIHNlbGVjdGVkLFxuICogdGhlIG1lbnUgbGFiZWwgaXMgZW1wdHkuIFRoZSBtZW51IGNhbiBiZSBjb25maWd1cmVkIHdpdGggYW4gaW5kaWNhdG9yLCBpY29uLCB0aXRsZSwgYW5kL29yIGhlYWRlci5cbiAqXG4gKiBNZW51VG9vbEdyb3VwcyBhcmUgY3JlYXRlZCBieSBhIHtAbGluayBPTy51aS5Ub29sR3JvdXBGYWN0b3J5IHRvb2wgZ3JvdXAgZmFjdG9yeX0gd2hlbiB0aGUgdG9vbGJhclxuICogaXMgc2V0IHVwLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEV4YW1wbGUgb2YgYSBNZW51VG9vbEdyb3VwXG4gKiAgICAgdmFyIHRvb2xGYWN0b3J5ID0gbmV3IE9PLnVpLlRvb2xGYWN0b3J5KCk7XG4gKiAgICAgdmFyIHRvb2xHcm91cEZhY3RvcnkgPSBuZXcgT08udWkuVG9vbEdyb3VwRmFjdG9yeSgpO1xuICogICAgIHZhciB0b29sYmFyID0gbmV3IE9PLnVpLlRvb2xiYXIoIHRvb2xGYWN0b3J5LCB0b29sR3JvdXBGYWN0b3J5ICk7XG4gKlxuICogICAgIC8vIFdlIHdpbGwgYmUgcGxhY2luZyBzdGF0dXMgdGV4dCBpbiB0aGlzIGVsZW1lbnQgd2hlbiB0b29scyBhcmUgdXNlZFxuICogICAgIHZhciAkYXJlYSA9ICQoICc8cD4nICkudGV4dCggJ0FuIGV4YW1wbGUgb2YgYSBNZW51VG9vbEdyb3VwLiBTZWxlY3QgYSB0b29sIGZyb20gdGhlIGRyb3Bkb3duIG1lbnUuJyApO1xuICpcbiAqICAgICAvLyBEZWZpbmUgdGhlIHRvb2xzIHRoYXQgd2UncmUgZ29pbmcgdG8gcGxhY2UgaW4gb3VyIHRvb2xiYXJcbiAqXG4gKiAgICAgZnVuY3Rpb24gU2V0dGluZ3NUb29sKCkge1xuICogICAgICAgICBTZXR0aW5nc1Rvb2wucGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICAgICAgdGhpcy5yZWFsbHlBY3RpdmUgPSBmYWxzZTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBTZXR0aW5nc1Rvb2wsIE9PLnVpLlRvb2wgKTtcbiAqICAgICBTZXR0aW5nc1Rvb2wuc3RhdGljLm5hbWUgPSAnc2V0dGluZ3MnO1xuICogICAgIFNldHRpbmdzVG9vbC5zdGF0aWMuaWNvbiA9ICdzZXR0aW5ncyc7XG4gKiAgICAgU2V0dGluZ3NUb29sLnN0YXRpYy50aXRsZSA9ICdDaGFuZ2Ugc2V0dGluZ3MnO1xuICogICAgIFNldHRpbmdzVG9vbC5wcm90b3R5cGUub25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgICRhcmVhLnRleHQoICdTZXR0aW5ncyB0b29sIGNsaWNrZWQhJyApO1xuICogICAgICAgICAvLyBUb2dnbGUgdGhlIGFjdGl2ZSBzdGF0ZSBvbiBlYWNoIGNsaWNrXG4gKiAgICAgICAgIHRoaXMucmVhbGx5QWN0aXZlID0gIXRoaXMucmVhbGx5QWN0aXZlO1xuICogICAgICAgICB0aGlzLnNldEFjdGl2ZSggdGhpcy5yZWFsbHlBY3RpdmUgKTtcbiAqICAgICAgICAgLy8gVG8gdXBkYXRlIHRoZSBtZW51IGxhYmVsXG4gKiAgICAgICAgIHRoaXMudG9vbGJhci5lbWl0KCAndXBkYXRlU3RhdGUnICk7XG4gKiAgICAgfTtcbiAqICAgICBTZXR0aW5nc1Rvb2wucHJvdG90eXBlLm9uVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAqICAgICB0b29sRmFjdG9yeS5yZWdpc3RlciggU2V0dGluZ3NUb29sICk7XG4gKlxuICogICAgIGZ1bmN0aW9uIFN0dWZmVG9vbCgpIHtcbiAqICAgICAgICAgU3R1ZmZUb29sLnBhcmVudC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gKiAgICAgICAgIHRoaXMucmVhbGx5QWN0aXZlID0gZmFsc2U7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggU3R1ZmZUb29sLCBPTy51aS5Ub29sICk7XG4gKiAgICAgU3R1ZmZUb29sLnN0YXRpYy5uYW1lID0gJ3N0dWZmJztcbiAqICAgICBTdHVmZlRvb2wuc3RhdGljLmljb24gPSAnZWxsaXBzaXMnO1xuICogICAgIFN0dWZmVG9vbC5zdGF0aWMudGl0bGUgPSAnTW9yZSBzdHVmZic7XG4gKiAgICAgU3R1ZmZUb29sLnByb3RvdHlwZS5vblNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgJGFyZWEudGV4dCggJ01vcmUgc3R1ZmYgdG9vbCBjbGlja2VkIScgKTtcbiAqICAgICAgICAgLy8gVG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGUgb24gZWFjaCBjbGlja1xuICogICAgICAgICB0aGlzLnJlYWxseUFjdGl2ZSA9ICF0aGlzLnJlYWxseUFjdGl2ZTtcbiAqICAgICAgICAgdGhpcy5zZXRBY3RpdmUoIHRoaXMucmVhbGx5QWN0aXZlICk7XG4gKiAgICAgICAgIC8vIFRvIHVwZGF0ZSB0aGUgbWVudSBsYWJlbFxuICogICAgICAgICB0aGlzLnRvb2xiYXIuZW1pdCggJ3VwZGF0ZVN0YXRlJyApO1xuICogICAgIH07XG4gKiAgICAgU3R1ZmZUb29sLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge307XG4gKiAgICAgdG9vbEZhY3RvcnkucmVnaXN0ZXIoIFN0dWZmVG9vbCApO1xuICpcbiAqICAgICAvLyBGaW5hbGx5IGRlZmluZSB3aGljaCB0b29scyBhbmQgaW4gd2hhdCBvcmRlciBhcHBlYXIgaW4gdGhlIHRvb2xiYXIuIEVhY2ggdG9vbCBtYXkgb25seSBiZVxuICogICAgIC8vIHVzZWQgb25jZSAoYnV0IG5vdCBhbGwgZGVmaW5lZCB0b29scyBtdXN0IGJlIHVzZWQpLlxuICogICAgIHRvb2xiYXIuc2V0dXAoIFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAgdHlwZTogJ21lbnUnLFxuICogICAgICAgICAgICAgaGVhZGVyOiAnVGhpcyBpcyB0aGUgKG9wdGlvbmFsKSBoZWFkZXInLFxuICogICAgICAgICAgICAgdGl0bGU6ICdUaGlzIGlzIHRoZSAob3B0aW9uYWwpIHRpdGxlJyxcbiAqICAgICAgICAgICAgIGluY2x1ZGU6IFsgJ3NldHRpbmdzJywgJ3N0dWZmJyBdXG4gKiAgICAgICAgIH1cbiAqICAgICBdICk7XG4gKlxuICogICAgIC8vIENyZWF0ZSBzb21lIFVJIGFyb3VuZCB0aGUgdG9vbGJhciBhbmQgcGxhY2UgaXQgaW4gdGhlIGRvY3VtZW50XG4gKiAgICAgdmFyIGZyYW1lID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG4gKiAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAqICAgICAgICAgZnJhbWVkOiB0cnVlXG4gKiAgICAgfSApO1xuICogICAgIHZhciBjb250ZW50RnJhbWUgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcbiAqICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICogICAgICAgICBwYWRkZWQ6IHRydWVcbiAqICAgICB9ICk7XG4gKiAgICAgZnJhbWUuJGVsZW1lbnQuYXBwZW5kKFxuICogICAgICAgICB0b29sYmFyLiRlbGVtZW50LFxuICogICAgICAgICBjb250ZW50RnJhbWUuJGVsZW1lbnQuYXBwZW5kKCAkYXJlYSApXG4gKiAgICAgKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBmcmFtZS4kZWxlbWVudCApO1xuICpcbiAqICAgICAvLyBIZXJlIGlzIHdoZXJlIHRoZSB0b29sYmFyIGlzIGFjdHVhbGx5IGJ1aWx0LiBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciBpbnNlcnRpbmcgaXQgaW50byB0aGVcbiAqICAgICAvLyBkb2N1bWVudC5cbiAqICAgICB0b29sYmFyLmluaXRpYWxpemUoKTtcbiAqICAgICB0b29sYmFyLmVtaXQoICd1cGRhdGVTdGF0ZScgKTtcbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gYWRkIHRvb2xzIHRvIGEgTWVudVRvb2xHcm91cCwgcGxlYXNlIHNlZSB7QGxpbmsgT08udWkuVG9vbEdyb3VwIHRvb2xncm91cH0uXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0b29sYmFycyBpbiBnZW5lcmFsLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvVG9vbGJhcnNcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLlBvcHVwVG9vbEdyb3VwXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09PLnVpLlRvb2xiYXJ9IHRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuTWVudVRvb2xHcm91cCA9IGZ1bmN0aW9uIE9vVWlNZW51VG9vbEdyb3VwKCB0b29sYmFyLCBjb25maWcgKSB7XG5cdC8vIEFsbG93IHBhc3NpbmcgcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGluc2lkZSB0aGUgY29uZmlnIG9iamVjdFxuXHRpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHRvb2xiYXIgKSAmJiBjb25maWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRjb25maWcgPSB0b29sYmFyO1xuXHRcdHRvb2xiYXIgPSBjb25maWcudG9vbGJhcjtcblx0fVxuXG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5NZW51VG9vbEdyb3VwLnBhcmVudC5jYWxsKCB0aGlzLCB0b29sYmFyLCBjb25maWcgKTtcblxuXHQvLyBFdmVudHNcblx0dGhpcy50b29sYmFyLmNvbm5lY3QoIHRoaXMsIHsgdXBkYXRlU3RhdGU6ICdvblVwZGF0ZVN0YXRlJyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLW1lbnVUb29sR3JvdXAnICk7XG5cdHRoaXMuJGdyb3VwLmFkZENsYXNzKCAnb28tdWktbWVudVRvb2xHcm91cC10b29scycgKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaGVyaXRDbGFzcyggT08udWkuTWVudVRvb2xHcm91cCwgT08udWkuUG9wdXBUb29sR3JvdXAgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZW51VG9vbEdyb3VwLnN0YXRpYy5uYW1lID0gJ21lbnUnO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIHRoZSB0b29sYmFyIHN0YXRlIGJlaW5nIHVwZGF0ZWQuXG4gKlxuICogV2hlbiB0aGUgc3RhdGUgY2hhbmdlcywgdGhlIHRpdGxlIG9mIGVhY2ggYWN0aXZlIGl0ZW0gaW4gdGhlIG1lbnUgd2lsbCBiZSBqb2luZWQgdG9nZXRoZXIgYW5kXG4gKiB1c2VkIGFzIGEgbGFiZWwgZm9yIHRoZSBncm91cC4gVGhlIGxhYmVsIHdpbGwgYmUgZW1wdHkgaWYgbm9uZSBvZiB0aGUgaXRlbXMgYXJlIGFjdGl2ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5NZW51VG9vbEdyb3VwLnByb3RvdHlwZS5vblVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbmFtZSxcblx0XHRsYWJlbFRleHRzID0gW107XG5cblx0Zm9yICggbmFtZSBpbiB0aGlzLnRvb2xzICkge1xuXHRcdGlmICggdGhpcy50b29sc1sgbmFtZSBdLmlzQWN0aXZlKCkgKSB7XG5cdFx0XHRsYWJlbFRleHRzLnB1c2goIHRoaXMudG9vbHNbIG5hbWUgXS5nZXRUaXRsZSgpICk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5zZXRMYWJlbCggbGFiZWxUZXh0cy5qb2luKCAnLCAnICkgfHwgJyAnICk7XG59O1xuXG59KCBPTyApICk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9vanMtdWktdG9vbGJhcnMuanMubWFwLmpzb25cbi8qIVxuICogT09VSSB2MC4zMC4yXG4gKiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSVxuICpcbiAqIENvcHlyaWdodCAyMDEx4oCTMjAxOSBPT1VJIFRlYW0gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL29vanMubWl0LWxpY2Vuc2Uub3JnXG4gKlxuICogRGF0ZTogMjAxOS0wMS0yM1QwMToxNDoyMFpcbiAqL1xuKCBmdW5jdGlvbiAoIE9PICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gQWN0aW9uV2lkZ2V0IGlzIGEge0BsaW5rIE9PLnVpLkJ1dHRvbldpZGdldCBidXR0b24gd2lkZ2V0fSB0aGF0IGV4ZWN1dGVzIGFuIGFjdGlvbi5cbiAqIEFjdGlvbiB3aWRnZXRzIGFyZSB1c2VkIHdpdGggT08udWkuQWN0aW9uU2V0LCB3aGljaCBtYW5hZ2VzIHRoZSBiZWhhdmlvciBhbmQgYXZhaWxhYmlsaXR5XG4gKiBvZiB0aGUgYWN0aW9ucy5cbiAqXG4gKiBCb3RoIGFjdGlvbnMgYW5kIGFjdGlvbiBzZXRzIGFyZSBwcmltYXJpbHkgdXNlZCB3aXRoIHtAbGluayBPTy51aS5EaWFsb2cgRGlhbG9nc30uXG4gKiBQbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gKiBhbmQgZXhhbXBsZXMuXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzL1Byb2Nlc3NfRGlhbG9ncyNBY3Rpb25fc2V0c1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuQnV0dG9uV2lkZ2V0XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtzdHJpbmd9IFthY3Rpb25dIFN5bWJvbGljIG5hbWUgb2YgdGhlIGFjdGlvbiAoZS5nLiwg4oCYY29udGludWXigJkgb3Ig4oCYY2FuY2Vs4oCZKS5cbiAqIEBjZmcge3N0cmluZ1tdfSBbbW9kZXNdIFN5bWJvbGljIG5hbWVzIG9mIHRoZSBtb2RlcyAoZS5nLiwg4oCYZWRpdOKAmSBvciDigJhyZWFk4oCZKSBpbiB3aGljaCB0aGUgYWN0aW9uXG4gKiAgc2hvdWxkIGJlIG1hZGUgYXZhaWxhYmxlLiBTZWUgdGhlIGFjdGlvbiBzZXQncyB7QGxpbmsgT08udWkuQWN0aW9uU2V0I3NldE1vZGUgc2V0TW9kZX0gbWV0aG9kXG4gKiAgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc2V0dGluZyBtb2Rlcy5cbiAqIEBjZmcge2Jvb2xlYW59IFtmcmFtZWQ9ZmFsc2VdIFJlbmRlciB0aGUgYWN0aW9uIGJ1dHRvbiB3aXRoIGEgZnJhbWVcbiAqL1xuT08udWkuQWN0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gT29VaUFjdGlvbldpZGdldCggY29uZmlnICkge1xuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9ICQuZXh0ZW5kKCB7IGZyYW1lZDogZmFsc2UgfSwgY29uZmlnICk7XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkFjdGlvbldpZGdldC5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5hY3Rpb24gPSBjb25maWcuYWN0aW9uIHx8ICcnO1xuXHR0aGlzLm1vZGVzID0gY29uZmlnLm1vZGVzIHx8IFtdO1xuXHR0aGlzLndpZHRoID0gMDtcblx0dGhpcy5oZWlnaHQgPSAwO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1hY3Rpb25XaWRnZXQnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLkFjdGlvbldpZGdldCwgT08udWkuQnV0dG9uV2lkZ2V0ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5BY3Rpb25XaWRnZXQsIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50ICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYWN0aW9uIGlzIGNvbmZpZ3VyZWQgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBzcGVjaWZpZWQgYG1vZGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIE5hbWUgb2YgbW9kZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGFjdGlvbiBpcyBjb25maWd1cmVkIHdpdGggdGhlIG1vZGVcbiAqL1xuT08udWkuQWN0aW9uV2lkZ2V0LnByb3RvdHlwZS5oYXNNb2RlID0gZnVuY3Rpb24gKCBtb2RlICkge1xuXHRyZXR1cm4gdGhpcy5tb2Rlcy5pbmRleE9mKCBtb2RlICkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN5bWJvbGljIG5hbWUgb2YgdGhlIGFjdGlvbiAoZS5nLiwg4oCYY29udGludWXigJkgb3Ig4oCYY2FuY2Vs4oCZKS5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbk9PLnVpLkFjdGlvbldpZGdldC5wcm90b3R5cGUuZ2V0QWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5hY3Rpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3ltYm9saWMgbmFtZSBvZiB0aGUgbW9kZSBvciBtb2RlcyBmb3Igd2hpY2ggdGhlIGFjdGlvbiBpcyBjb25maWd1cmVkIHRvIGJlIGF2YWlsYWJsZS5cbiAqXG4gKiBUaGUgY3VycmVudCBtb2RlIGlzIHNldCB3aXRoIHRoZSBhY3Rpb24gc2V0J3Mge0BsaW5rIE9PLnVpLkFjdGlvblNldCNzZXRNb2RlIHNldE1vZGV9IG1ldGhvZC5cbiAqIE9ubHkgYWN0aW9ucyB0aGF0IGFyZSBjb25maWd1cmVkIHRvIGJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBtb2RlIHdpbGwgYmUgdmlzaWJsZS4gQWxsIG90aGVyIGFjdGlvbnNcbiAqIGFyZSBoaWRkZW4uXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbk9PLnVpLkFjdGlvbldpZGdldC5wcm90b3R5cGUuZ2V0TW9kZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1vZGVzLnNsaWNlKCk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBBY3Rpb25TZXRzIG1hbmFnZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHtAbGluayBPTy51aS5BY3Rpb25XaWRnZXQgYWN0aW9uIHdpZGdldHN9IHRoYXQgY29tcHJpc2UgdGhlbS5cbiAqIEFjdGlvbnMgY2FuIGJlIG1hZGUgYXZhaWxhYmxlIGZvciBzcGVjaWZpYyBjb250ZXh0cyAobW9kZXMpIGFuZCBjaXJjdW1zdGFuY2VzXG4gKiAoYWJpbGl0aWVzKS4gQWN0aW9uIHNldHMgYXJlIHByaW1hcmlseSB1c2VkIHdpdGgge0BsaW5rIE9PLnVpLkRpYWxvZyBEaWFsb2dzfS5cbiAqXG4gKiBBY3Rpb25TZXRzIGNvbnRhaW4gdHdvIHR5cGVzIG9mIGFjdGlvbnM6XG4gKlxuICogLSBTcGVjaWFsOiBTcGVjaWFsIGFjdGlvbnMgYXJlIHRoZSBmaXJzdCB2aXNpYmxlIGFjdGlvbnMgd2l0aCBzcGVjaWFsIGZsYWdzLCBzdWNoIGFzICdzYWZlJyBhbmQgJ3ByaW1hcnknLCB0aGUgZGVmYXVsdCBzcGVjaWFsIGZsYWdzLiBBZGRpdGlvbmFsIHNwZWNpYWwgZmxhZ3MgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gc3ViY2xhc3NlcyB3aXRoIHRoZSBzdGF0aWMgI3NwZWNpYWxGbGFncyBwcm9wZXJ0eS5cbiAqIC0gT3RoZXI6IE90aGVyIGFjdGlvbnMgaW5jbHVkZSBhbGwgbm9uLXNwZWNpYWwgdmlzaWJsZSBhY3Rpb25zLlxuICpcbiAqIFNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEV4YW1wbGU6IEFuIGFjdGlvbiBzZXQgdXNlZCBpbiBhIHByb2Nlc3MgZGlhbG9nXG4gKiAgICAgZnVuY3Rpb24gTXlQcm9jZXNzRGlhbG9nKCBjb25maWcgKSB7XG4gKiAgICAgICAgIE15UHJvY2Vzc0RpYWxvZy5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggTXlQcm9jZXNzRGlhbG9nLCBPTy51aS5Qcm9jZXNzRGlhbG9nICk7XG4gKiAgICAgTXlQcm9jZXNzRGlhbG9nLnN0YXRpYy50aXRsZSA9ICdBbiBhY3Rpb24gc2V0IGluIGEgcHJvY2VzcyBkaWFsb2cnO1xuICogICAgIE15UHJvY2Vzc0RpYWxvZy5zdGF0aWMubmFtZSA9ICdteVByb2Nlc3NEaWFsb2cnO1xuICogICAgIC8vIEFuIGFjdGlvbiBzZXQgdGhhdCB1c2VzIG1vZGVzICgnZWRpdCcgYW5kICdoZWxwJyBtb2RlLCBpbiB0aGlzIGV4YW1wbGUpLlxuICogICAgIE15UHJvY2Vzc0RpYWxvZy5zdGF0aWMuYWN0aW9ucyA9IFtcbiAqICAgICAgICAgeyBhY3Rpb246ICdjb250aW51ZScsIG1vZGVzOiAnZWRpdCcsIGxhYmVsOiAnQ29udGludWUnLCBmbGFnczogWyAncHJpbWFyeScsICdwcm9ncmVzc2l2ZScgXSB9LFxuICogICAgICAgICB7IGFjdGlvbjogJ2hlbHAnLCBtb2RlczogJ2VkaXQnLCBsYWJlbDogJ0hlbHAnIH0sXG4gKiAgICAgICAgIHsgbW9kZXM6ICdlZGl0JywgbGFiZWw6ICdDYW5jZWwnLCBmbGFnczogJ3NhZmUnIH0sXG4gKiAgICAgICAgIHsgYWN0aW9uOiAnYmFjaycsIG1vZGVzOiAnaGVscCcsIGxhYmVsOiAnQmFjaycsIGZsYWdzOiAnc2FmZScgfVxuICogICAgIF07XG4gKlxuICogICAgIE15UHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgTXlQcm9jZXNzRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gKiAgICAgICAgIHRoaXMucGFuZWwxID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7IHBhZGRlZDogdHJ1ZSwgZXhwYW5kZWQ6IGZhbHNlIH0gKTtcbiAqICAgICAgICAgdGhpcy5wYW5lbDEuJGVsZW1lbnQuYXBwZW5kKCAnPHA+VGhpcyBkaWFsb2cgdXNlcyBhbiBhY3Rpb24gc2V0IChjb250aW51ZSwgaGVscCwgY2FuY2VsLCBiYWNrKSBjb25maWd1cmVkIHdpdGggbW9kZXMuIFRoaXMgaXMgZWRpdCBtb2RlLiBDbGljayBcXCdoZWxwXFwnIHRvIHNlZSBoZWxwIG1vZGUuPC9wPicgKTtcbiAqICAgICAgICAgdGhpcy5wYW5lbDIgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHsgcGFkZGVkOiB0cnVlLCBleHBhbmRlZDogZmFsc2UgfSApO1xuICogICAgICAgICB0aGlzLnBhbmVsMi4kZWxlbWVudC5hcHBlbmQoICc8cD5UaGlzIGlzIGhlbHAgbW9kZS4gT25seSB0aGUgXFwnYmFja1xcJyBhY3Rpb24gd2lkZ2V0IGlzIGNvbmZpZ3VyZWQgdG8gYmUgdmlzaWJsZSBoZXJlLiBDbGljayBcXCdiYWNrXFwnIHRvIHJldHVybiB0byBcXCdlZGl0XFwnIG1vZGUuPC9wPicgKTtcbiAqICAgICAgICAgdGhpcy5zdGFja0xheW91dCA9IG5ldyBPTy51aS5TdGFja0xheW91dCgge1xuICogICAgICAgICAgICAgaXRlbXM6IFsgdGhpcy5wYW5lbDEsIHRoaXMucGFuZWwyIF1cbiAqICAgICAgICAgfSApO1xuICogICAgICAgICB0aGlzLiRib2R5LmFwcGVuZCggdGhpcy5zdGFja0xheW91dC4kZWxlbWVudCApO1xuICogICAgIH07XG4gKiAgICAgTXlQcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5nZXRTZXR1cFByb2Nlc3MgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG4gKiAgICAgICAgIHJldHVybiBNeVByb2Nlc3NEaWFsb2cucGFyZW50LnByb3RvdHlwZS5nZXRTZXR1cFByb2Nlc3MuY2FsbCggdGhpcywgZGF0YSApXG4gKiAgICAgICAgICAgICAubmV4dCggZnVuY3Rpb24gKCkge1xuICogICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5zZXRNb2RlKCAnZWRpdCcgKTtcbiAqICAgICAgICAgICAgIH0sIHRoaXMgKTtcbiAqICAgICB9O1xuICogICAgIE15UHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuZ2V0QWN0aW9uUHJvY2VzcyA9IGZ1bmN0aW9uICggYWN0aW9uICkge1xuICogICAgICAgICBpZiAoIGFjdGlvbiA9PT0gJ2hlbHAnICkge1xuICogICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnNldE1vZGUoICdoZWxwJyApO1xuICogICAgICAgICAgICAgdGhpcy5zdGFja0xheW91dC5zZXRJdGVtKCB0aGlzLnBhbmVsMiApO1xuICogICAgICAgICB9IGVsc2UgaWYgKCBhY3Rpb24gPT09ICdiYWNrJyApIHtcbiAqICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5zZXRNb2RlKCAnZWRpdCcgKTtcbiAqICAgICAgICAgICAgIHRoaXMuc3RhY2tMYXlvdXQuc2V0SXRlbSggdGhpcy5wYW5lbDEgKTtcbiAqICAgICAgICAgfSBlbHNlIGlmICggYWN0aW9uID09PSAnY29udGludWUnICkge1xuICogICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXM7XG4gKiAgICAgICAgICAgICByZXR1cm4gbmV3IE9PLnVpLlByb2Nlc3MoIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAqICAgICAgICAgICAgIH0gKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICByZXR1cm4gTXlQcm9jZXNzRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuZ2V0QWN0aW9uUHJvY2Vzcy5jYWxsKCB0aGlzLCBhY3Rpb24gKTtcbiAqICAgICB9O1xuICogICAgIE15UHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuZ2V0Qm9keUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwxLiRlbGVtZW50Lm91dGVySGVpZ2h0KCB0cnVlICk7XG4gKiAgICAgfTtcbiAqICAgICB2YXIgd2luZG93TWFuYWdlciA9IG5ldyBPTy51aS5XaW5kb3dNYW5hZ2VyKCk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggd2luZG93TWFuYWdlci4kZWxlbWVudCApO1xuICogICAgIHZhciBkaWFsb2cgPSBuZXcgTXlQcm9jZXNzRGlhbG9nKCB7XG4gKiAgICAgICAgIHNpemU6ICdtZWRpdW0nXG4gKiAgICAgfSApO1xuICogICAgIHdpbmRvd01hbmFnZXIuYWRkV2luZG93cyggWyBkaWFsb2cgXSApO1xuICogICAgIHdpbmRvd01hbmFnZXIub3BlbldpbmRvdyggZGlhbG9nICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzL1Byb2Nlc3NfRGlhbG9ncyNBY3Rpb25fc2V0c1xuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAbWl4aW5zIE9PLkV2ZW50RW1pdHRlclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5PTy51aS5BY3Rpb25TZXQgPSBmdW5jdGlvbiBPb1VpQWN0aW9uU2V0KCBjb25maWcgKSB7XG5cdC8vIENvbmZpZ3VyYXRpb24gaW5pdGlhbGl6YXRpb25cblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy5FdmVudEVtaXR0ZXIuY2FsbCggdGhpcyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5saXN0ID0gW107XG5cdHRoaXMuY2F0ZWdvcmllcyA9IHtcblx0XHRhY3Rpb25zOiAnZ2V0QWN0aW9uJyxcblx0XHRmbGFnczogJ2dldEZsYWdzJyxcblx0XHRtb2RlczogJ2dldE1vZGVzJ1xuXHR9O1xuXHR0aGlzLmNhdGVnb3JpemVkID0ge307XG5cdHRoaXMuc3BlY2lhbCA9IHt9O1xuXHR0aGlzLm90aGVycyA9IFtdO1xuXHR0aGlzLm9yZ2FuaXplZCA9IGZhbHNlO1xuXHR0aGlzLmNoYW5naW5nID0gZmFsc2U7XG5cdHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xufTtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyogU2V0dXAgKi9cblxuT08ubWl4aW5DbGFzcyggT08udWkuQWN0aW9uU2V0LCBPTy5FdmVudEVtaXR0ZXIgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBTeW1ib2xpYyBuYW1lIG9mIHRoZSBmbGFncyB1c2VkIHRvIGlkZW50aWZ5IHNwZWNpYWwgYWN0aW9ucy4gU3BlY2lhbCBhY3Rpb25zIGFyZSBkaXNwbGF5ZWQgaW4gdGhlXG4gKiAgaGVhZGVyIG9mIGEge0BsaW5rIE9PLnVpLlByb2Nlc3NEaWFsb2cgcHJvY2VzcyBkaWFsb2d9LlxuICogIFNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzJdIGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcy5cbiAqXG4gKiAgWzJdOmh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpbmRvd3MvUHJvY2Vzc19EaWFsb2dzXG4gKlxuICogQGFic3RyYWN0XG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfVxuICovXG5PTy51aS5BY3Rpb25TZXQuc3RhdGljLnNwZWNpYWxGbGFncyA9IFsgJ3NhZmUnLCAncHJpbWFyeScgXTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQGV2ZW50IGNsaWNrXG4gKlxuICogQSAnY2xpY2snIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiBhbiBhY3Rpb24gaXMgY2xpY2tlZC5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLkFjdGlvbldpZGdldH0gYWN0aW9uIEFjdGlvbiB0aGF0IHdhcyBjbGlja2VkXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgYWRkXG4gKlxuICogQW4gJ2FkZCcgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIGFjdGlvbnMgYXJlIHtAbGluayAjbWV0aG9kLWFkZCBhZGRlZH0gdG8gdGhlIGFjdGlvbiBzZXQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXRbXX0gYWRkZWQgQWN0aW9ucyBhZGRlZFxuICovXG5cbi8qKlxuICogQGV2ZW50IHJlbW92ZVxuICpcbiAqIEEgJ3JlbW92ZScgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIGFjdGlvbnMgYXJlIHtAbGluayAjbWV0aG9kLXJlbW92ZSByZW1vdmVkfVxuICogIG9yIHtAbGluayAjY2xlYXIgY2xlYXJlZH0uXG4gKlxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXRbXX0gYWRkZWQgQWN0aW9ucyByZW1vdmVkXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgY2hhbmdlXG4gKlxuICogQSAnY2hhbmdlJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gYWN0aW9ucyBhcmUge0BsaW5rICNtZXRob2QtYWRkIGFkZGVkfSwge0BsaW5rICNjbGVhciBjbGVhcmVkfSxcbiAqIG9yIHtAbGluayAjbWV0aG9kLXJlbW92ZSByZW1vdmVkfSBmcm9tIHRoZSBhY3Rpb24gc2V0IG9yIHdoZW4gdGhlIHtAbGluayAjc2V0TW9kZSBtb2RlfSBpcyBjaGFuZ2VkLlxuICpcbiAqL1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGFjdGlvbiBjaGFuZ2UgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZmlyZXMgY2hhbmdlXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUub25BY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMub3JnYW5pemVkID0gZmFsc2U7XG5cdGlmICggdGhpcy5jaGFuZ2luZyApIHtcblx0XHR0aGlzLmNoYW5nZWQgPSB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZW1pdCggJ2NoYW5nZScgKTtcblx0fVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhY3Rpb24gaXMgb25lIG9mIHRoZSBzcGVjaWFsIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXR9IGFjdGlvbiBBY3Rpb24gdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEFjdGlvbiBpcyBzcGVjaWFsXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUuaXNTcGVjaWFsID0gZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdHZhciBmbGFnO1xuXG5cdGZvciAoIGZsYWcgaW4gdGhpcy5zcGVjaWFsICkge1xuXHRcdGlmICggYWN0aW9uID09PSB0aGlzLnNwZWNpYWxbIGZsYWcgXSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IGFjdGlvbiB3aWRnZXRzIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZmlsdGVyOiDigJhhY3Rpb25z4oCZLCDigJhmbGFnc+KAmSwg4oCYbW9kZXPigJksIOKAmHZpc2libGXigJksXG4gKiAgb3Ig4oCYZGlzYWJsZWTigJkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJzXSBGaWx0ZXJzIHRvIHVzZSwgb21pdCB0byBnZXQgYWxsIGFjdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbZmlsdGVycy5hY3Rpb25zXSBBY3Rpb25zIHRoYXQgYWN0aW9uIHdpZGdldHMgbXVzdCBoYXZlXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2ZpbHRlcnMuZmxhZ3NdIEZsYWdzIHRoYXQgYWN0aW9uIHdpZGdldHMgbXVzdCBoYXZlIChlLmcuLCAnc2FmZScpXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2ZpbHRlcnMubW9kZXNdIE1vZGVzIHRoYXQgYWN0aW9uIHdpZGdldHMgbXVzdCBoYXZlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmaWx0ZXJzLnZpc2libGVdIEFjdGlvbiB3aWRnZXRzIG11c3QgYmUgdmlzaWJsZVxuICogQHBhcmFtIHtib29sZWFufSBbZmlsdGVycy5kaXNhYmxlZF0gQWN0aW9uIHdpZGdldHMgbXVzdCBiZSBkaXNhYmxlZFxuICogQHJldHVybiB7T08udWkuQWN0aW9uV2lkZ2V0W119IEFjdGlvbiB3aWRnZXRzIG1hdGNoaW5nIGFsbCBjcml0ZXJpYVxuICovXG5PTy51aS5BY3Rpb25TZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICggZmlsdGVycyApIHtcblx0dmFyIGksIGxlbiwgbGlzdCwgY2F0ZWdvcnksIGFjdGlvbnMsIGluZGV4LCBtYXRjaCwgbWF0Y2hlcztcblxuXHRpZiAoIGZpbHRlcnMgKSB7XG5cdFx0dGhpcy5vcmdhbml6ZSgpO1xuXG5cdFx0Ly8gQ29sbGVjdCBjYXRlZ29yeSBjYW5kaWRhdGVzXG5cdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdGZvciAoIGNhdGVnb3J5IGluIHRoaXMuY2F0ZWdvcml6ZWQgKSB7XG5cdFx0XHRsaXN0ID0gZmlsdGVyc1sgY2F0ZWdvcnkgXTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCAhQXJyYXkuaXNBcnJheSggbGlzdCApICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbIGxpc3QgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRhY3Rpb25zID0gdGhpcy5jYXRlZ29yaXplZFsgY2F0ZWdvcnkgXVsgbGlzdFsgaSBdIF07XG5cdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhY3Rpb25zICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2guYXBwbHkoIG1hdGNoZXMsIGFjdGlvbnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gUmVtb3ZlIGJ5IGJvb2xlYW4gZmlsdGVyc1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSBtYXRjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0bWF0Y2ggPSBtYXRjaGVzWyBpIF07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCggZmlsdGVycy52aXNpYmxlICE9PSB1bmRlZmluZWQgJiYgbWF0Y2guaXNWaXNpYmxlKCkgIT09IGZpbHRlcnMudmlzaWJsZSApIHx8XG5cdFx0XHRcdCggZmlsdGVycy5kaXNhYmxlZCAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLmlzRGlzYWJsZWQoKSAhPT0gZmlsdGVycy5kaXNhYmxlZCApXG5cdFx0XHQpIHtcblx0XHRcdFx0bWF0Y2hlcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0bGVuLS07XG5cdFx0XHRcdGktLTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRmb3IgKCBpID0gMCwgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdG1hdGNoID0gbWF0Y2hlc1sgaSBdO1xuXHRcdFx0aW5kZXggPSBtYXRjaGVzLmxhc3RJbmRleE9mKCBtYXRjaCApO1xuXHRcdFx0d2hpbGUgKCBpbmRleCAhPT0gaSApIHtcblx0XHRcdFx0bWF0Y2hlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdGxlbi0tO1xuXHRcdFx0XHRpbmRleCA9IG1hdGNoZXMubGFzdEluZGV4T2YoIG1hdGNoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9XG5cdHJldHVybiB0aGlzLmxpc3Quc2xpY2UoKTtcbn07XG5cbi8qKlxuICogR2V0ICdzcGVjaWFsJyBhY3Rpb25zLlxuICpcbiAqIFNwZWNpYWwgYWN0aW9ucyBhcmUgdGhlIGZpcnN0IHZpc2libGUgYWN0aW9uIHdpZGdldHMgd2l0aCBzcGVjaWFsIGZsYWdzLCBzdWNoIGFzICdzYWZlJyBhbmQgJ3ByaW1hcnknLlxuICogU3BlY2lhbCBmbGFncyBjYW4gYmUgY29uZmlndXJlZCBpbiBzdWJjbGFzc2VzIGJ5IGNoYW5naW5nIHRoZSBzdGF0aWMgI3NwZWNpYWxGbGFncyBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5BY3Rpb25XaWRnZXRbXXxudWxsfSAnU3BlY2lhbCcgYWN0aW9uIHdpZGdldHMuXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUuZ2V0U3BlY2lhbCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5vcmdhbml6ZSgpO1xuXHRyZXR1cm4gJC5leHRlbmQoIHt9LCB0aGlzLnNwZWNpYWwgKTtcbn07XG5cbi8qKlxuICogR2V0ICdvdGhlcicgYWN0aW9ucy5cbiAqXG4gKiBPdGhlciBhY3Rpb25zIGluY2x1ZGUgYWxsIG5vbi1zcGVjaWFsIHZpc2libGUgYWN0aW9uIHdpZGdldHMuXG4gKlxuICogQHJldHVybiB7T08udWkuQWN0aW9uV2lkZ2V0W119ICdPdGhlcicgYWN0aW9uIHdpZGdldHNcbiAqL1xuT08udWkuQWN0aW9uU2V0LnByb3RvdHlwZS5nZXRPdGhlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMub3JnYW5pemUoKTtcblx0cmV0dXJuIHRoaXMub3RoZXJzLnNsaWNlKCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbW9kZSAgKGUuZy4sIOKAmGVkaXTigJkgb3Ig4oCYdmlld+KAmSkuIE9ubHkge0BsaW5rIE9PLnVpLkFjdGlvbldpZGdldCNtb2RlcyBhY3Rpb25zfSBjb25maWd1cmVkXG4gKiB0byBiZSBhdmFpbGFibGUgaW4gdGhlIHNwZWNpZmllZCBtb2RlIHdpbGwgYmUgbWFkZSB2aXNpYmxlLiBBbGwgb3RoZXIgYWN0aW9ucyB3aWxsIGJlIGhpZGRlbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBUaGUgbW9kZS4gT25seSBhY3Rpb25zIGNvbmZpZ3VyZWQgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBzcGVjaWZpZWRcbiAqICBtb2RlIHdpbGwgYmUgbWFkZSB2aXNpYmxlLlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQWN0aW9uU2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqIEBmaXJlcyB0b2dnbGVcbiAqIEBmaXJlcyBjaGFuZ2VcbiAqL1xuT08udWkuQWN0aW9uU2V0LnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gKCBtb2RlICkge1xuXHR2YXIgaSwgbGVuLCBhY3Rpb247XG5cblx0dGhpcy5jaGFuZ2luZyA9IHRydWU7XG5cdGZvciAoIGkgPSAwLCBsZW4gPSB0aGlzLmxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0YWN0aW9uID0gdGhpcy5saXN0WyBpIF07XG5cdFx0YWN0aW9uLnRvZ2dsZSggYWN0aW9uLmhhc01vZGUoIG1vZGUgKSApO1xuXHR9XG5cblx0dGhpcy5vcmdhbml6ZWQgPSBmYWxzZTtcblx0dGhpcy5jaGFuZ2luZyA9IGZhbHNlO1xuXHR0aGlzLmVtaXQoICdjaGFuZ2UnICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQgYWN0aW9ucy5cbiAqXG4gKiBBY3Rpb24gd2lkZ2V0cyB0aGF0IGFyZSBjb25maWd1cmVkIHdpdGggdGhlIHNwZWNpZmllZCBhY3Rpb25zIHdpbGwgYmUgZW5hYmxlZFxuICogb3IgZGlzYWJsZWQgYmFzZWQgb24gdGhlIGJvb2xlYW4gdmFsdWVzIHNwZWNpZmllZCBpbiB0aGUgYGFjdGlvbnNgXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxib29sZWFuPn0gYWN0aW9ucyBBIGxpc3Qga2V5ZWQgYnkgYWN0aW9uIG5hbWUgd2l0aCBib29sZWFuXG4gKiAgdmFsdWVzIHRoYXQgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGFjdGlvbiBzaG91bGQgYmUgZW5hYmxlZC5cbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkFjdGlvblNldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUuc2V0QWJpbGl0aWVzID0gZnVuY3Rpb24gKCBhY3Rpb25zICkge1xuXHR2YXIgaSwgbGVuLCBhY3Rpb24sIGl0ZW07XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IHRoaXMubGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpdGVtID0gdGhpcy5saXN0WyBpIF07XG5cdFx0YWN0aW9uID0gaXRlbS5nZXRBY3Rpb24oKTtcblx0XHRpZiAoIGFjdGlvbnNbIGFjdGlvbiBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpdGVtLnNldERpc2FibGVkKCAhYWN0aW9uc1sgYWN0aW9uIF0gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBmdW5jdGlvbiBvbmNlIHBlciBhY3Rpb24uXG4gKlxuICogV2hlbiBtYWtpbmcgY2hhbmdlcyB0byBtdWx0aXBsZSBhY3Rpb25zLCB1c2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBpdGVyYXRpbmcgb3ZlciB0aGUgYWN0aW9uc1xuICogbWFudWFsbHkgdG8gZGVmZXIgZW1pdHRpbmcgYSAjY2hhbmdlIGV2ZW50IHVudGlsIGFmdGVyIGFsbCBhY3Rpb25zIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGZpbHRlciBGaWx0ZXJzIHRvIHVzZSB0byBkZXRlcm1pbmUgd2hpY2ggYWN0aW9ucyB0byBpdGVyYXRlIG92ZXI7IHNlZSAjZ2V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4gZm9yIGVhY2ggYWN0aW9uOyBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqICAgYXJndW1lbnRzOiB0aGUgYWN0aW9uLCB0aGUgYWN0aW9uJ3MgaW5kZXgsIHRoZSBsaXN0IG9mIGFjdGlvbnMgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQWN0aW9uU2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuQWN0aW9uU2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKCBmaWx0ZXIsIGNhbGxiYWNrICkge1xuXHR0aGlzLmNoYW5nZWQgPSBmYWxzZTtcblx0dGhpcy5jaGFuZ2luZyA9IHRydWU7XG5cdHRoaXMuZ2V0KCBmaWx0ZXIgKS5mb3JFYWNoKCBjYWxsYmFjayApO1xuXHR0aGlzLmNoYW5naW5nID0gZmFsc2U7XG5cdGlmICggdGhpcy5jaGFuZ2VkICkge1xuXHRcdHRoaXMuZW1pdCggJ2NoYW5nZScgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYWN0aW9uIHdpZGdldHMgdG8gdGhlIGFjdGlvbiBzZXQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXRbXX0gYWN0aW9ucyBBY3Rpb24gd2lkZ2V0cyB0byBhZGRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkFjdGlvblNldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKiBAZmlyZXMgYWRkXG4gKiBAZmlyZXMgY2hhbmdlXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBhY3Rpb25zICkge1xuXHR2YXIgaSwgbGVuLCBhY3Rpb247XG5cblx0dGhpcy5jaGFuZ2luZyA9IHRydWU7XG5cdGZvciAoIGkgPSAwLCBsZW4gPSBhY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcblx0XHRhY3Rpb24uY29ubmVjdCggdGhpcywge1xuXHRcdFx0Y2xpY2s6IFsgJ2VtaXQnLCAnY2xpY2snLCBhY3Rpb24gXSxcblx0XHRcdHRvZ2dsZTogWyAnb25BY3Rpb25DaGFuZ2UnIF1cblx0XHR9ICk7XG5cdFx0dGhpcy5saXN0LnB1c2goIGFjdGlvbiApO1xuXHR9XG5cdHRoaXMub3JnYW5pemVkID0gZmFsc2U7XG5cdHRoaXMuZW1pdCggJ2FkZCcsIGFjdGlvbnMgKTtcblx0dGhpcy5jaGFuZ2luZyA9IGZhbHNlO1xuXHR0aGlzLmVtaXQoICdjaGFuZ2UnICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhY3Rpb24gd2lkZ2V0cyBmcm9tIHRoZSBzZXQuXG4gKlxuICogVG8gcmVtb3ZlIGFsbCBhY3Rpb25zLCB5b3UgbWF5IHdpc2ggdG8gdXNlIHRoZSAjY2xlYXIgbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXRbXX0gYWN0aW9ucyBBY3Rpb24gd2lkZ2V0cyB0byByZW1vdmVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLkFjdGlvblNldH0gVGhlIHdpZGdldCwgZm9yIGNoYWluaW5nXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAZmlyZXMgY2hhbmdlXG4gKi9cbk9PLnVpLkFjdGlvblNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCBhY3Rpb25zICkge1xuXHR2YXIgaSwgbGVuLCBpbmRleCwgYWN0aW9uO1xuXG5cdHRoaXMuY2hhbmdpbmcgPSB0cnVlO1xuXHRmb3IgKCBpID0gMCwgbGVuID0gYWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cdFx0aW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZiggYWN0aW9uICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRhY3Rpb24uZGlzY29ubmVjdCggdGhpcyApO1xuXHRcdFx0dGhpcy5saXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0dGhpcy5vcmdhbml6ZWQgPSBmYWxzZTtcblx0dGhpcy5lbWl0KCAncmVtb3ZlJywgYWN0aW9ucyApO1xuXHR0aGlzLmNoYW5naW5nID0gZmFsc2U7XG5cdHRoaXMuZW1pdCggJ2NoYW5nZScgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBhY3Rpb24gd2lkZ2V0cyBmcm9tIHRoZSBzZXQuXG4gKlxuICogVG8gcmVtb3ZlIG9ubHkgc3BlY2lmaWVkIGFjdGlvbnMsIHVzZSB0aGUge0BsaW5rICNtZXRob2QtcmVtb3ZlIHJlbW92ZX0gbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuQWN0aW9uU2V0fSBUaGUgd2lkZ2V0LCBmb3IgY2hhaW5pbmdcbiAqIEBmaXJlcyByZW1vdmVcbiAqIEBmaXJlcyBjaGFuZ2VcbiAqL1xuT08udWkuQWN0aW9uU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbiwgYWN0aW9uLFxuXHRcdHJlbW92ZWQgPSB0aGlzLmxpc3Quc2xpY2UoKTtcblxuXHR0aGlzLmNoYW5naW5nID0gdHJ1ZTtcblx0Zm9yICggaSA9IDAsIGxlbiA9IHRoaXMubGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRhY3Rpb24gPSB0aGlzLmxpc3RbIGkgXTtcblx0XHRhY3Rpb24uZGlzY29ubmVjdCggdGhpcyApO1xuXHR9XG5cblx0dGhpcy5saXN0ID0gW107XG5cblx0dGhpcy5vcmdhbml6ZWQgPSBmYWxzZTtcblx0dGhpcy5lbWl0KCAncmVtb3ZlJywgcmVtb3ZlZCApO1xuXHR0aGlzLmNoYW5naW5nID0gZmFsc2U7XG5cdHRoaXMuZW1pdCggJ2NoYW5nZScgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3JnYW5pemUgYWN0aW9ucy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuZXZlciBvcmdhbml6ZWQgaW5mb3JtYXRpb24gaXMgcmVxdWVzdGVkLiBJdCB3aWxsIG9ubHkgcmVvcmdhbml6ZSB0aGUgYWN0aW9uc1xuICogaWYgc29tZXRoaW5nIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgcmFuLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5BY3Rpb25TZXR9IFRoZSB3aWRnZXQsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5BY3Rpb25TZXQucHJvdG90eXBlLm9yZ2FuaXplID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgZmxhZywgYWN0aW9uLCBjYXRlZ29yeSwgbGlzdCwgaXRlbSwgc3BlY2lhbCxcblx0XHRzcGVjaWFsRmxhZ3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5zcGVjaWFsRmxhZ3M7XG5cblx0aWYgKCAhdGhpcy5vcmdhbml6ZWQgKSB7XG5cdFx0dGhpcy5jYXRlZ29yaXplZCA9IHt9O1xuXHRcdHRoaXMuc3BlY2lhbCA9IHt9O1xuXHRcdHRoaXMub3RoZXJzID0gW107XG5cdFx0Zm9yICggaSA9IDAsIGlMZW4gPSB0aGlzLmxpc3QubGVuZ3RoOyBpIDwgaUxlbjsgaSsrICkge1xuXHRcdFx0YWN0aW9uID0gdGhpcy5saXN0WyBpIF07XG5cdFx0XHRpZiAoIGFjdGlvbi5pc1Zpc2libGUoKSApIHtcblx0XHRcdFx0Ly8gUG9wdWxhdGUgY2F0ZWdvcmllc1xuXHRcdFx0XHRmb3IgKCBjYXRlZ29yeSBpbiB0aGlzLmNhdGVnb3JpZXMgKSB7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5jYXRlZ29yaXplZFsgY2F0ZWdvcnkgXSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY2F0ZWdvcml6ZWRbIGNhdGVnb3J5IF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGlzdCA9IGFjdGlvblsgdGhpcy5jYXRlZ29yaWVzWyBjYXRlZ29yeSBdIF0oKTtcblx0XHRcdFx0XHRpZiAoICFBcnJheS5pc0FycmF5KCBsaXN0ICkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ID0gWyBsaXN0IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqTGVuID0gbGlzdC5sZW5ndGg7IGogPCBqTGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRpdGVtID0gbGlzdFsgaiBdO1xuXHRcdFx0XHRcdFx0aWYgKCAhdGhpcy5jYXRlZ29yaXplZFsgY2F0ZWdvcnkgXVsgaXRlbSBdICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmNhdGVnb3JpemVkWyBjYXRlZ29yeSBdWyBpdGVtIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuY2F0ZWdvcml6ZWRbIGNhdGVnb3J5IF1bIGl0ZW0gXS5wdXNoKCBhY3Rpb24gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUG9wdWxhdGUgc3BlY2lhbC9vdGhlcnNcblx0XHRcdFx0c3BlY2lhbCA9IGZhbHNlO1xuXHRcdFx0XHRmb3IgKCBqID0gMCwgakxlbiA9IHNwZWNpYWxGbGFncy5sZW5ndGg7IGogPCBqTGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0ZmxhZyA9IHNwZWNpYWxGbGFnc1sgaiBdO1xuXHRcdFx0XHRcdGlmICggIXRoaXMuc3BlY2lhbFsgZmxhZyBdICYmIGFjdGlvbi5oYXNGbGFnKCBmbGFnICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNwZWNpYWxbIGZsYWcgXSA9IGFjdGlvbjtcblx0XHRcdFx0XHRcdHNwZWNpYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0dGhpcy5vdGhlcnMucHVzaCggYWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5vcmdhbml6ZWQgPSB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVycm9ycyBjb250YWluIGEgcmVxdWlyZWQgbWVzc2FnZSAoZWl0aGVyIGEgc3RyaW5nIG9yIGpRdWVyeSBzZWxlY3Rpb24pIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSB3aGF0IHdlbnQgd3JvbmdcbiAqIGluIGEge0BsaW5rIE9PLnVpLlByb2Nlc3MgcHJvY2Vzc30uIFRoZSBlcnJvcidzICNyZWNvdmVyYWJsZSBhbmQgI3dhcm5pbmcgY29uZmlndXJhdGlvbnMgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZVxuICogYXBwZWFyYW5jZSBhbmQgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqIFRoZSBiYXNpYyBlcnJvciBpbnRlcmZhY2UgY29udGFpbnMgYSBmb3JtYXR0ZWQgZXJyb3IgbWVzc2FnZSBhcyB3ZWxsIGFzIHR3byBidXR0b25zOiAnRGlzbWlzcycgYW5kICdUcnkgYWdhaW4nIChpLmUuLCB0aGUgZXJyb3JcbiAqIGlzICdyZWNvdmVyYWJsZScgYnkgZGVmYXVsdCkuIElmIHRoZSBlcnJvciBpcyBub3QgcmVjb3ZlcmFibGUsIHRoZSAnVHJ5IGFnYWluJyBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQgYW5kIHRoZSB3aWRnZXRcbiAqIHRoYXQgaW5pdGlhdGVkIHRoZSBmYWlsZWQgcHJvY2VzcyB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIElmIHRoZSBlcnJvciBpcyBhIHdhcm5pbmcsIHRoZSBlcnJvciBpbnRlcmZhY2Ugd2lsbCBpbmNsdWRlIGEgJ0Rpc21pc3MnIGFuZCBhICdDb250aW51ZScgYnV0dG9uLCB3aGljaCB3aWxsIHRyeSB0aGVcbiAqIHByb2Nlc3MgYWdhaW4uXG4gKlxuICogRm9yIGFuIGV4YW1wbGUgb2YgZXJyb3IgaW50ZXJmYWNlcywgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzFdLlxuICpcbiAqIFsxXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2luZG93cy9Qcm9jZXNzX0RpYWxvZ3MjUHJvY2Vzc2VzX2FuZF9lcnJvcnNcbiAqXG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfGpRdWVyeX0gbWVzc2FnZSBEZXNjcmlwdGlvbiBvZiBlcnJvclxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGNmZyB7Ym9vbGVhbn0gW3JlY292ZXJhYmxlPXRydWVdIEVycm9yIGlzIHJlY292ZXJhYmxlLlxuICogIEJ5IGRlZmF1bHQsIGVycm9ycyBhcmUgcmVjb3ZlcmFibGUsIGFuZCB1c2VycyBjYW4gdHJ5IHRoZSBwcm9jZXNzIGFnYWluLlxuICogQGNmZyB7Ym9vbGVhbn0gW3dhcm5pbmc9ZmFsc2VdIEVycm9yIGlzIGEgd2FybmluZy5cbiAqICBJZiB0aGUgZXJyb3IgaXMgYSB3YXJuaW5nLCB0aGUgZXJyb3IgaW50ZXJmYWNlIHdpbGwgaW5jbHVkZSBhXG4gKiAgJ0Rpc21pc3MnIGFuZCBhICdDb250aW51ZScgYnV0dG9uLiBJdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGRldmVsb3BlciB0byBlbnN1cmUgdGhhdCB0aGUgd2FybmluZ1xuICogIGlzIG5vdCB0cmlnZ2VyZWQgYSBzZWNvbmQgdGltZSBpZiB0aGUgdXNlciBjaG9vc2VzIHRvIGNvbnRpbnVlLlxuICovXG5PTy51aS5FcnJvciA9IGZ1bmN0aW9uIE9vVWlFcnJvciggbWVzc2FnZSwgY29uZmlnICkge1xuXHQvLyBBbGxvdyBwYXNzaW5nIHBvc2l0aW9uYWwgcGFyYW1ldGVycyBpbnNpZGUgdGhlIGNvbmZpZyBvYmplY3Rcblx0aWYgKCBPTy5pc1BsYWluT2JqZWN0KCBtZXNzYWdlICkgJiYgY29uZmlnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Y29uZmlnID0gbWVzc2FnZTtcblx0XHRtZXNzYWdlID0gY29uZmlnLm1lc3NhZ2U7XG5cdH1cblxuXHQvLyBDb25maWd1cmF0aW9uIGluaXRpYWxpemF0aW9uXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgaW5zdGFuY2VvZiAkID8gbWVzc2FnZSA6IFN0cmluZyggbWVzc2FnZSApO1xuXHR0aGlzLnJlY292ZXJhYmxlID0gY29uZmlnLnJlY292ZXJhYmxlID09PSB1bmRlZmluZWQgfHwgISFjb25maWcucmVjb3ZlcmFibGU7XG5cdHRoaXMud2FybmluZyA9ICEhY29uZmlnLndhcm5pbmc7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbml0Q2xhc3MoIE9PLnVpLkVycm9yICk7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUuXG4gKlxuICogSWYgdGhlIGVycm9yIGlzIHJlY292ZXJhYmxlLCB1c2VycyBhcmUgYWJsZSB0byB0cnkgdGhlIHByb2Nlc3MgYWdhaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXJyb3IgaXMgcmVjb3ZlcmFibGVcbiAqL1xuT08udWkuRXJyb3IucHJvdG90eXBlLmlzUmVjb3ZlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnJlY292ZXJhYmxlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZXJyb3IgaXMgYSB3YXJuaW5nLlxuICpcbiAqIElmIHRoZSBlcnJvciBpcyBhIHdhcm5pbmcsIHRoZSBlcnJvciBpbnRlcmZhY2Ugd2lsbCBpbmNsdWRlIGEgJ0Rpc21pc3MnIGFuZCBhICdDb250aW51ZScgYnV0dG9uLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVycm9yIGlzIHdhcm5pbmdcbiAqL1xuT08udWkuRXJyb3IucHJvdG90eXBlLmlzV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMud2FybmluZztcbn07XG5cbi8qKlxuICogR2V0IGVycm9yIG1lc3NhZ2UgYXMgRE9NIG5vZGVzLlxuICpcbiAqIEByZXR1cm4ge2pRdWVyeX0gRXJyb3IgbWVzc2FnZSBpbiBET00gbm9kZXNcbiAqL1xuT08udWkuRXJyb3IucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1lc3NhZ2UgaW5zdGFuY2VvZiAkID9cblx0XHR0aGlzLm1lc3NhZ2UuY2xvbmUoKSA6XG5cdFx0JCggJzxkaXY+JyApLnRleHQoIHRoaXMubWVzc2FnZSApLmNvbnRlbnRzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSB0ZXh0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRXJyb3IgbWVzc2FnZVxuICovXG5PTy51aS5FcnJvci5wcm90b3R5cGUuZ2V0TWVzc2FnZVRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1lc3NhZ2UgaW5zdGFuY2VvZiAkID8gdGhpcy5tZXNzYWdlLnRleHQoKSA6IHRoaXMubWVzc2FnZTtcbn07XG5cbi8qKlxuICogQSBQcm9jZXNzIGlzIGEgbGlzdCBvZiBzdGVwcyB0aGF0IGFyZSBjYWxsZWQgaW4gc2VxdWVuY2UuIFRoZSBzdGVwIGNhbiBiZSBhIG51bWJlciwgYSBqUXVlcnkgcHJvbWlzZSxcbiAqIG9yIGEgZnVuY3Rpb246XG4gKlxuICogLSAqKm51bWJlcioqOiB0aGUgcHJvY2VzcyB3aWxsIHdhaXQgZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZWZvcmUgcHJvY2VlZGluZy5cbiAqIC0gKipwcm9taXNlKio6IHRoZSBwcm9jZXNzIHdpbGwgY29udGludWUgdG8gdGhlIG5leHQgc3RlcCB3aGVuIHRoZSBwcm9taXNlIGlzIHN1Y2Nlc3NmdWxseSByZXNvbHZlZFxuICogIG9yIHN0b3AgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiAtICoqZnVuY3Rpb24qKjogdGhlIHByb2Nlc3Mgd2lsbCBleGVjdXRlIHRoZSBmdW5jdGlvbi4gVGhlIHByb2Nlc3Mgd2lsbCBzdG9wIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiAgZWl0aGVyIGEgYm9vbGVhbiBgZmFsc2VgIG9yIGEgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkOyBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIG51bWJlciwgdGhlIHByb2Nlc3NcbiAqICB3aWxsIHdhaXQgZm9yIHRoYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZWZvcmUgcHJvY2VlZGluZy5cbiAqXG4gKiBJZiB0aGUgcHJvY2VzcyBmYWlscywgYW4ge0BsaW5rIE9PLnVpLkVycm9yIGVycm9yfSBpcyBnZW5lcmF0ZWQuIERlcGVuZGluZyBvbiBob3cgdGhlIGVycm9yIGlzXG4gKiBjb25maWd1cmVkLCB1c2VycyBjYW4gZGlzbWlzcyB0aGUgZXJyb3IgYW5kIHRyeSB0aGUgcHJvY2VzcyBhZ2Fpbiwgb3Igbm90LiBJZiBhIHByb2Nlc3MgaXMgc3RvcHBlZCxcbiAqIGl0cyByZW1haW5pbmcgc3RlcHMgd2lsbCBub3QgYmUgcGVyZm9ybWVkLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ8alF1ZXJ5LlByb21pc2V8RnVuY3Rpb259IHN0ZXAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBwcm9jZWVkaW5nLCBwcm9taXNlXG4gKiAgdGhhdCBtdXN0IGJlIHJlc29sdmVkIGJlZm9yZSBwcm9jZWVkaW5nLCBvciBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuIFNlZSAjY3JlYXRlU3RlcCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gc2VlICNjcmVhdGVTdGVwIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9bnVsbF0gRXhlY3V0aW9uIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLiBUaGUgY29udGV4dCBpcyBpZ25vcmVkIGlmIHRoZSBzdGVwIGlzXG4gKiAgYSBudW1iZXIgb3IgcHJvbWlzZS5cbiAqL1xuT08udWkuUHJvY2VzcyA9IGZ1bmN0aW9uICggc3RlcCwgY29udGV4dCApIHtcblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnN0ZXBzID0gW107XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0aWYgKCBzdGVwICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy5uZXh0KCBzdGVwLCBjb250ZXh0ICk7XG5cdH1cbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaXRDbGFzcyggT08udWkuUHJvY2VzcyApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogU3RhcnQgdGhlIHByb2Nlc3MuXG4gKlxuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCBzdGVwcyBoYXZlIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gKiAgSWYgYW55IG9mIHRoZSBzdGVwcyByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcmVqZWN0ZWQgb3IgYSBib29sZWFuIGZhbHNlLCB0aGlzIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqICBhbmQgYW55IHJlbWFpbmluZyBzdGVwcyBhcmUgbm90IHBlcmZvcm1lZC5cbiAqL1xuT08udWkuUHJvY2Vzcy5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbiwgcHJvbWlzZTtcblxuXHQvKipcblx0ICogQ29udGludWUgZXhlY3V0aW9uLlxuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN0ZXAgQSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRleHQgaXQgc2hvdWxkIGJlIGNhbGxlZCBpblxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBjb250aW51ZXMgdGhlIHByb2Nlc3Ncblx0ICovXG5cdGZ1bmN0aW9uIHByb2NlZWQoIHN0ZXAgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIEV4ZWN1dGUgc3RlcCBpbiB0aGUgY29ycmVjdCBjb250ZXh0XG5cdFx0XHR2YXIgZGVmZXJyZWQsXG5cdFx0XHRcdHJlc3VsdCA9IHN0ZXAuY2FsbGJhY2suY2FsbCggc3RlcC5jb250ZXh0ICk7XG5cblx0XHRcdGlmICggcmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0Ly8gVXNlIHJlamVjdGVkIHByb21pc2UgZm9yIGJvb2xlYW4gZmFsc2UgcmVzdWx0c1xuXHRcdFx0XHRyZXR1cm4gJC5EZWZlcnJlZCgpLnJlamVjdCggW10gKS5wcm9taXNlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdCA8IDAgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGdvIGJhY2sgaW4gdGltZTogZmx1eCBjYXBhY2l0b3IgaXMgb3V0IG9mIHNlcnZpY2UnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVXNlIGEgZGVsYXllZCBwcm9taXNlIGZvciBudW1iZXJzLCBleHBlY3RpbmcgdGhlbSB0byBiZSBpbiBtaWxsaXNlY29uZHNcblx0XHRcdFx0ZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cdFx0XHRcdHNldFRpbWVvdXQoIGRlZmVycmVkLnJlc29sdmUsIHJlc3VsdCApO1xuXHRcdFx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXN1bHQgaW5zdGFuY2VvZiBPTy51aS5FcnJvciApIHtcblx0XHRcdFx0Ly8gVXNlIHJlamVjdGVkIHByb21pc2UgZm9yIGVycm9yXG5cdFx0XHRcdHJldHVybiAkLkRlZmVycmVkKCkucmVqZWN0KCBbIHJlc3VsdCBdICkucHJvbWlzZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCByZXN1bHQgKSAmJiByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFsgMCBdIGluc3RhbmNlb2YgT08udWkuRXJyb3IgKSB7XG5cdFx0XHRcdC8vIFVzZSByZWplY3RlZCBwcm9taXNlIGZvciBsaXN0IG9mIGVycm9yc1xuXHRcdFx0XHRyZXR1cm4gJC5EZWZlcnJlZCgpLnJlamVjdCggcmVzdWx0ICkucHJvbWlzZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRHVjay10eXBlIHRoZSBvYmplY3QgdG8gc2VlIGlmIGl0IGNhbiBwcm9kdWNlIGEgcHJvbWlzZVxuXHRcdFx0aWYgKCByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC5wcm9taXNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHQvLyBVc2UgYSBwcm9taXNlIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5wcm9taXNlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBVc2UgcmVzb2x2ZWQgcHJvbWlzZSBmb3Igb3RoZXIgcmVzdWx0c1xuXHRcdFx0cmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKCkucHJvbWlzZSgpO1xuXHRcdH07XG5cdH1cblxuXHRpZiAoIHRoaXMuc3RlcHMubGVuZ3RoICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgY2hhaW4gcmVhY3Rpb24gb2YgcHJvbWlzZXNcblx0XHRwcm9taXNlID0gcHJvY2VlZCggdGhpcy5zdGVwc1sgMCBdICkoKTtcblx0XHRmb3IgKCBpID0gMSwgbGVuID0gdGhpcy5zdGVwcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oIHByb2NlZWQoIHRoaXMuc3RlcHNbIGkgXSApICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHByb21pc2UgPSAkLkRlZmVycmVkKCkucmVzb2x2ZSgpLnByb21pc2UoKTtcblx0fVxuXG5cdHJldHVybiBwcm9taXNlO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9jZXNzIHN0ZXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfGpRdWVyeS5Qcm9taXNlfEZ1bmN0aW9ufSBzdGVwXG4gKlxuICogLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHByb2NlZWRpbmdcbiAqIC0gUHJvbWlzZSB0aGF0IG11c3QgYmUgcmVzb2x2ZWQgYmVmb3JlIHByb2NlZWRpbmdcbiAqIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICogICAtIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgYm9vbGVhbiBmYWxzZSB0aGUgcHJvY2VzcyB3aWxsIHN0b3BcbiAqICAgLSBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UsIHRoZSBwcm9jZXNzIHdpbGwgY29udGludWUgdG8gdGhlIG5leHRcbiAqICAgICBzdGVwIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3Igc3RvcCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogICAtIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgbnVtYmVyLCB0aGUgcHJvY2VzcyB3aWxsIHdhaXQgZm9yIHRoYXQgbnVtYmVyIG9mXG4gKiAgICAgbWlsbGlzZWNvbmRzIGJlZm9yZSBwcm9jZWVkaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9bnVsbF0gRXhlY3V0aW9uIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLiBUaGUgY29udGV4dCBpc1xuICogIGlnbm9yZWQgaWYgdGhlIHN0ZXAgaXMgYSBudW1iZXIgb3IgcHJvbWlzZS5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RlcCBvYmplY3QsIHdpdGggYGNhbGxiYWNrYCBhbmQgYGNvbnRleHRgIHByb3BlcnRpZXNcbiAqL1xuT08udWkuUHJvY2Vzcy5wcm90b3R5cGUuY3JlYXRlU3RlcCA9IGZ1bmN0aW9uICggc3RlcCwgY29udGV4dCApIHtcblx0aWYgKCB0eXBlb2Ygc3RlcCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHN0ZXAucHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHN0ZXA7XG5cdFx0XHR9LFxuXHRcdFx0Y29udGV4dDogbnVsbFxuXHRcdH07XG5cdH1cblx0aWYgKCB0eXBlb2Ygc3RlcCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbGJhY2s6IHN0ZXAsXG5cdFx0XHRjb250ZXh0OiBjb250ZXh0XG5cdFx0fTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgY3JlYXRlIHByb2Nlc3Mgc3RlcDogbnVtYmVyLCBwcm9taXNlIG9yIGZ1bmN0aW9uIGV4cGVjdGVkJyApO1xufTtcblxuLyoqXG4gKiBBZGQgc3RlcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBpbmhlcml0ZG9jICNjcmVhdGVTdGVwXG4gKiBAcmV0dXJuIHtPTy51aS5Qcm9jZXNzfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk9PLnVpLlByb2Nlc3MucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCBzdGVwLCBjb250ZXh0ICkge1xuXHR0aGlzLnN0ZXBzLnVuc2hpZnQoIHRoaXMuY3JlYXRlU3RlcCggc3RlcCwgY29udGV4dCApICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgc3RlcCB0byB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBpbmhlcml0ZG9jICNjcmVhdGVTdGVwXG4gKiBAcmV0dXJuIHtPTy51aS5Qcm9jZXNzfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk9PLnVpLlByb2Nlc3MucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoIHN0ZXAsIGNvbnRleHQgKSB7XG5cdHRoaXMuc3RlcHMucHVzaCggdGhpcy5jcmVhdGVTdGVwKCBzdGVwLCBjb250ZXh0ICkgKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEEgd2luZG93IGluc3RhbmNlIHJlcHJlc2VudHMgdGhlIGxpZmUgY3ljbGUgZm9yIG9uZSBzaW5nbGUgb3BlbmluZyBvZiBhIHdpbmRvd1xuICogdW50aWwgaXRzIGNsb3NpbmcuXG4gKlxuICogV2hpbGUgT08udWkuV2luZG93TWFuYWdlciB3aWxsIHJldXNlIE9PLnVpLldpbmRvdyBvYmplY3RzLCBlYWNoIHRpbWUgYSB3aW5kb3cgaXNcbiAqIG9wZW5lZCwgYSBuZXcgbGlmZWN5Y2xlIHN0YXJ0cy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFsxXS5cbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpbmRvd3NcbiAqXG4gKiBAY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuT08udWkuV2luZG93SW5zdGFuY2UgPSBmdW5jdGlvbiBPb1VpV2luZG93SW5zdGFuY2UoKSB7XG5cdHZhciBkZWZlcnJlZHMgPSB7XG5cdFx0b3BlbmluZzogJC5EZWZlcnJlZCgpLFxuXHRcdG9wZW5lZDogJC5EZWZlcnJlZCgpLFxuXHRcdGNsb3Npbmc6ICQuRGVmZXJyZWQoKSxcblx0XHRjbG9zZWQ6ICQuRGVmZXJyZWQoKVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge09iamVjdH1cblx0ICovXG5cdHRoaXMuZGVmZXJyZWRzID0gZGVmZXJyZWRzO1xuXG5cdC8vIFNldCB0aGVzZSB1cCBhcyBjaGFpbmVkIHByb21pc2VzIHNvIHRoYXQgcmVqZWN0aW5nIG9mXG5cdC8vIGFuIGVhcmxpZXIgc3RhZ2UgYXV0b21hdGljYWxseSByZWplY3RzIHRoZSBzdWJzZXF1ZW50XG5cdC8vIHdvdWxkLWJlIHN0YWdlcyBhcyB3ZWxsLlxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2pRdWVyeS5Qcm9taXNlfVxuXHQgKi9cblx0dGhpcy5vcGVuaW5nID0gZGVmZXJyZWRzLm9wZW5pbmcucHJvbWlzZSgpO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHtqUXVlcnkuUHJvbWlzZX1cblx0ICovXG5cdHRoaXMub3BlbmVkID0gdGhpcy5vcGVuaW5nLnRoZW4oIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZGVmZXJyZWRzLm9wZW5lZDtcblx0fSApO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHtqUXVlcnkuUHJvbWlzZX1cblx0ICovXG5cdHRoaXMuY2xvc2luZyA9IHRoaXMub3BlbmVkLnRoZW4oIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZGVmZXJyZWRzLmNsb3Npbmc7XG5cdH0gKTtcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7alF1ZXJ5LlByb21pc2V9XG5cdCAqL1xuXHR0aGlzLmNsb3NlZCA9IHRoaXMuY2xvc2luZy50aGVuKCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRlZmVycmVkcy5jbG9zZWQ7XG5cdH0gKTtcbn07XG5cbi8qIFNldHVwICovXG5cbk9PLmluaXRDbGFzcyggT08udWkuV2luZG93SW5zdGFuY2UgKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3aW5kb3cgaXMgb3BlbmluZy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaW5kb3cgaXMgb3BlbmluZ1xuICovXG5PTy51aS5XaW5kb3dJbnN0YW5jZS5wcm90b3R5cGUuaXNPcGVuaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZlcnJlZHMub3BlbmVkLnN0YXRlKCkgPT09ICdwZW5kaW5nJztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgd2luZG93IGlzIG9wZW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaW5kb3cgaXMgb3BlbmVkXG4gKi9cbk9PLnVpLldpbmRvd0luc3RhbmNlLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZGVmZXJyZWRzLm9wZW5lZC5zdGF0ZSgpID09PSAncmVzb2x2ZWQnICYmXG5cdFx0dGhpcy5kZWZlcnJlZHMuY2xvc2luZy5zdGF0ZSgpID09PSAncGVuZGluZyc7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdpbmRvdyBpcyBjbG9zaW5nLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbmRvdyBpcyBjbG9zaW5nXG4gKi9cbk9PLnVpLldpbmRvd0luc3RhbmNlLnByb3RvdHlwZS5pc0Nsb3NpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmRlZmVycmVkcy5jbG9zaW5nLnN0YXRlKCkgPT09ICdyZXNvbHZlZCcgJiZcblx0XHR0aGlzLmRlZmVycmVkcy5jbG9zZWQuc3RhdGUoKSA9PT0gJ3BlbmRpbmcnO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB3aW5kb3cgaXMgY2xvc2VkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbmRvdyBpcyBjbG9zZWRcbiAqL1xuT08udWkuV2luZG93SW5zdGFuY2UucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZlcnJlZHMuY2xvc2VkLnN0YXRlKCkgPT09ICdyZXNvbHZlZCc7XG59O1xuXG4vKipcbiAqIFdpbmRvdyBtYW5hZ2VycyBhcmUgdXNlZCB0byBvcGVuIGFuZCBjbG9zZSB7QGxpbmsgT08udWkuV2luZG93IHdpbmRvd3N9IGFuZCBjb250cm9sIHRoZWlyIHByZXNlbnRhdGlvbi5cbiAqIE1hbmFnZWQgd2luZG93cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBJZiBhIG5ldyB3aW5kb3cgaXMgb3BlbmVkIHdoaWxlIGEgY3VycmVudCB3aW5kb3cgaXMgb3BlbmluZ1xuICogb3IgaXMgb3BlbmVkLCB0aGUgY3VycmVudCB3aW5kb3cgd2lsbCBiZSBjbG9zZWQgYW5kIGFueSBvbmdvaW5nIHtAbGluayBPTy51aS5Qcm9jZXNzIHByb2Nlc3N9IHdpbGwgYmUgY2FuY2VsbGVkLiBXaW5kb3dzXG4gKiB0aGVtc2VsdmVzIGFyZSBwZXJzaXN0ZW50IGFuZOKAlHJhdGhlciB0aGFuIGJlaW5nIHRvcm4gZG93biB3aGVuIGNsb3NlZOKAlGNhbiBiZSByZXBvcHVsYXRlZCB3aXRoIHRoZVxuICogcGVydGluZW50IGRhdGEgYW5kIHJldXNlZC5cbiAqXG4gKiBPdmVyIHRoZSBsaWZlY3ljbGUgb2YgYSB3aW5kb3csIHRoZSB3aW5kb3cgbWFuYWdlciBtYWtlcyBhdmFpbGFibGUgdGhyZWUgcHJvbWlzZXM6IGBvcGVuaW5nYCxcbiAqIGBvcGVuZWRgLCBhbmQgYGNsb3NpbmdgLCB3aGljaCByZXByZXNlbnQgdGhlIHByaW1hcnkgc3RhZ2VzIG9mIHRoZSBjeWNsZTpcbiAqXG4gKiAqKk9wZW5pbmcqKjogdGhlIG9wZW5pbmcgc3RhZ2UgYmVnaW5zIHdoZW4gdGhlIHdpbmRvdyBtYW5hZ2Vy4oCZcyAjb3BlbldpbmRvdyBvciBhIHdpbmRvd+KAmXNcbiAqIHtAbGluayBPTy51aS5XaW5kb3cjb3BlbiBvcGVufSBtZXRob2QgaXMgdXNlZCwgYW5kIHRoZSB3aW5kb3cgbWFuYWdlciBiZWdpbnMgdG8gb3BlbiB0aGUgd2luZG93LlxuICpcbiAqIC0gYW4gYG9wZW5pbmdgIGV2ZW50IGlzIGVtaXR0ZWQgd2l0aCBhbiBgb3BlbmluZ2AgcHJvbWlzZVxuICogLSB0aGUgI2dldFNldHVwRGVsYXkgbWV0aG9kIGlzIGNhbGxlZCBhbmQgdGhlIHJldHVybmVkIHZhbHVlIGlzIHVzZWQgdG8gdGltZSBhIHBhdXNlIGluIGV4ZWN1dGlvbiBiZWZvcmUgdGhlXG4gKiAgIHdpbmRvd+KAmXMge0BsaW5rIE9PLnVpLldpbmRvdyNtZXRob2Qtc2V0dXAgc2V0dXB9IG1ldGhvZCBpcyBjYWxsZWQgd2hpY2ggZXhlY3V0ZXMgT08udWkuV2luZG93I2dldFNldHVwUHJvY2Vzcy5cbiAqIC0gYSBgc2V0dXBgIHByb2dyZXNzIG5vdGlmaWNhdGlvbiBpcyBlbWl0dGVkIGZyb20gdGhlIGBvcGVuaW5nYCBwcm9taXNlXG4gKiAtIHRoZSAjZ2V0UmVhZHlEZWxheSBtZXRob2QgaXMgY2FsbGVkIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIHRvIHRpbWUgYSBwYXVzZSBpbiBleGVjdXRpb24gYmVmb3JlIHRoZVxuICogICB3aW5kb3figJlzIHtAbGluayBPTy51aS5XaW5kb3cjbWV0aG9kLXJlYWR5IHJlYWR5fSBtZXRob2QgaXMgY2FsbGVkIHdoaWNoIGV4ZWN1dGVzIE9PLnVpLldpbmRvdyNnZXRSZWFkeVByb2Nlc3MuXG4gKiAtIGEgYHJlYWR5YCBwcm9ncmVzcyBub3RpZmljYXRpb24gaXMgZW1pdHRlZCBmcm9tIHRoZSBgb3BlbmluZ2AgcHJvbWlzZVxuICogLSB0aGUgYG9wZW5pbmdgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbiBgb3BlbmVkYCBwcm9taXNlXG4gKlxuICogKipPcGVuZWQqKjogdGhlIHdpbmRvdyBpcyBub3cgb3Blbi5cbiAqXG4gKiAqKkNsb3NpbmcqKjogdGhlIGNsb3Npbmcgc3RhZ2UgYmVnaW5zIHdoZW4gdGhlIHdpbmRvdyBtYW5hZ2VyJ3MgI2Nsb3NlV2luZG93IG9yIHRoZVxuICogd2luZG93J3Mge0BsaW5rIE9PLnVpLldpbmRvdyNjbG9zZSBjbG9zZX0gbWV0aG9kcyBpcyB1c2VkLCBhbmQgdGhlIHdpbmRvdyBtYW5hZ2VyIGJlZ2luc1xuICogdG8gY2xvc2UgdGhlIHdpbmRvdy5cbiAqXG4gKiAtIHRoZSBgb3BlbmVkYCBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYGNsb3NpbmdgIHByb21pc2UgYW5kIGEgYGNsb3NpbmdgIGV2ZW50IGlzIGVtaXR0ZWRcbiAqIC0gdGhlICNnZXRIb2xkRGVsYXkgbWV0aG9kIGlzIGNhbGxlZCBhbmQgdGhlIHJldHVybmVkIHZhbHVlIGlzIHVzZWQgdG8gdGltZSBhIHBhdXNlIGluIGV4ZWN1dGlvbiBiZWZvcmVcbiAqICAgdGhlIHdpbmRvdydzIHtAbGluayBPTy51aS5XaW5kb3cjZ2V0SG9sZFByb2Nlc3MgZ2V0SG9sZFByb2Nlc3N9IG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlXG4gKiAgIHdpbmRvdyBhbmQgaXRzIHJlc3VsdCBleGVjdXRlZFxuICogLSBhIGBob2xkYCBwcm9ncmVzcyBub3RpZmljYXRpb24gaXMgZW1pdHRlZCBmcm9tIHRoZSBgY2xvc2luZ2AgcHJvbWlzZVxuICogLSB0aGUgI2dldFRlYXJkb3duRGVsYXkoKSBtZXRob2QgaXMgY2FsbGVkIGFuZCB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgdXNlZCB0byB0aW1lIGEgcGF1c2UgaW4gZXhlY3V0aW9uIGJlZm9yZVxuICogICB0aGUgd2luZG93J3Mge0BsaW5rIE9PLnVpLldpbmRvdyNnZXRUZWFyZG93blByb2Nlc3MgZ2V0VGVhcmRvd25Qcm9jZXNzfSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZVxuICogICB3aW5kb3cgYW5kIGl0cyByZXN1bHQgZXhlY3V0ZWRcbiAqIC0gYSBgdGVhcmRvd25gIHByb2dyZXNzIG5vdGlmaWNhdGlvbiBpcyBlbWl0dGVkIGZyb20gdGhlIGBjbG9zaW5nYCBwcm9taXNlXG4gKiAtIHRoZSBgY2xvc2luZ2AgcHJvbWlzZSBpcyByZXNvbHZlZC4gVGhlIHdpbmRvdyBpcyBub3cgY2xvc2VkXG4gKlxuICogU2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzL1dpbmRvd19tYW5hZ2Vyc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuRWxlbWVudFxuICogQG1peGlucyBPTy5FdmVudEVtaXR0ZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBjZmcge09PLkZhY3Rvcnl9IFtmYWN0b3J5XSBXaW5kb3cgZmFjdG9yeSB0byB1c2UgZm9yIGF1dG9tYXRpYyBpbnN0YW50aWF0aW9uXG4gKiAgTm90ZSB0aGF0IHdpbmRvdyBjbGFzc2VzIHRoYXQgYXJlIGluc3RhbnRpYXRlZCB3aXRoIGEgZmFjdG9yeSBtdXN0IGhhdmVcbiAqICBhIHtAbGluayBPTy51aS5EaWFsb2cjc3RhdGljLW5hbWUgc3RhdGljIG5hbWV9IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGEgc3ltYm9saWMgbmFtZS5cbiAqIEBjZmcge2Jvb2xlYW59IFttb2RhbD10cnVlXSBQcmV2ZW50IGludGVyYWN0aW9uIG91dHNpZGUgdGhlIGRpYWxvZ1xuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyID0gZnVuY3Rpb24gT29VaVdpbmRvd01hbmFnZXIoIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLldpbmRvd01hbmFnZXIucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuXG5cdC8vIE1peGluIGNvbnN0cnVjdG9yc1xuXHRPTy5FdmVudEVtaXR0ZXIuY2FsbCggdGhpcyApO1xuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy5mYWN0b3J5ID0gY29uZmlnLmZhY3Rvcnk7XG5cdHRoaXMubW9kYWwgPSBjb25maWcubW9kYWwgPT09IHVuZGVmaW5lZCB8fCAhIWNvbmZpZy5tb2RhbDtcblx0dGhpcy53aW5kb3dzID0ge307XG5cdC8vIERlcHJlY2F0ZWQgcGxhY2Vob2xkZXIgcHJvbWlzZSBnaXZlbiB0byBjb21wYXRPcGVuaW5nIGluIG9wZW5XaW5kb3coKVxuXHQvLyB0aGF0IGlzIHJlc29sdmVkIGluIGNsb3NlV2luZG93KCkuXG5cdHRoaXMuY29tcGF0T3BlbmVkID0gbnVsbDtcblx0dGhpcy5wcmVwYXJpbmdUb09wZW4gPSBudWxsO1xuXHR0aGlzLnByZXBhcmluZ1RvQ2xvc2UgPSBudWxsO1xuXHR0aGlzLmN1cnJlbnRXaW5kb3cgPSBudWxsO1xuXHR0aGlzLmdsb2JhbEV2ZW50cyA9IGZhbHNlO1xuXHR0aGlzLiRyZXR1cm5Gb2N1c1RvID0gbnVsbDtcblx0dGhpcy4kYXJpYUhpZGRlbiA9IG51bGw7XG5cdHRoaXMub25XaW5kb3dSZXNpemVUaW1lb3V0ID0gbnVsbDtcblx0dGhpcy5vbldpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB0aGlzLm9uV2luZG93UmVzaXplLmJpbmQoIHRoaXMgKTtcblx0dGhpcy5hZnRlcldpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB0aGlzLmFmdGVyV2luZG93UmVzaXplLmJpbmQoIHRoaXMgKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktd2luZG93TWFuYWdlcicgKVxuXHRcdC50b2dnbGVDbGFzcyggJ29vLXVpLXdpbmRvd01hbmFnZXItbW9kYWwnLCB0aGlzLm1vZGFsICk7XG5cdGlmICggdGhpcy5tb2RhbCApIHtcblx0XHR0aGlzLiRlbGVtZW50LmF0dHIoICdhcmlhLWhpZGRlbicsIHRydWUgKTtcblx0fVxufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5XaW5kb3dNYW5hZ2VyLCBPTy51aS5FbGVtZW50ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5XaW5kb3dNYW5hZ2VyLCBPTy5FdmVudEVtaXR0ZXIgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQW4gJ29wZW5pbmcnIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGJlZ2lucyB0byBiZSBvcGVuZWQuXG4gKlxuICogQGV2ZW50IG9wZW5pbmdcbiAqIEBwYXJhbSB7T08udWkuV2luZG93fSB3aW4gV2luZG93IHRoYXQncyBiZWluZyBvcGVuZWRcbiAqIEBwYXJhbSB7alF1ZXJ5LlByb21pc2V9IG9wZW5lZCBBIHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIHZhbHVlIHdoZW4gdGhlIHdpbmRvdyBpcyBvcGVuZWQgc3VjY2Vzc2Z1bGx5LlxuICogIFRoaXMgcHJvbWlzZSBhbHNvIGVtaXRzIGBzZXR1cGAgYW5kIGByZWFkeWAgbm90aWZpY2F0aW9ucy4gV2hlbiB0aGlzIHByb21pc2UgaXMgcmVzb2x2ZWQsIHRoZSBmaXJzdFxuICogIGFyZ3VtZW50IG9mIHRoZSB2YWx1ZSBpcyBhbiAnY2xvc2VkJyBwcm9taXNlLCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBvcGVuaW5nIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBXaW5kb3cgb3BlbmluZyBkYXRhXG4gKi9cblxuLyoqXG4gKiBBICdjbG9zaW5nJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBiZWdpbnMgdG8gYmUgY2xvc2VkLlxuICpcbiAqIEBldmVudCBjbG9zaW5nXG4gKiBAcGFyYW0ge09PLnVpLldpbmRvd30gd2luIFdpbmRvdyB0aGF0J3MgYmVpbmcgY2xvc2VkXG4gKiBAcGFyYW0ge2pRdWVyeS5Qcm9taXNlfSBjbG9zZWQgQSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSB2YWx1ZSB3aGVuIHRoZSB3aW5kb3cgaXMgY2xvc2VkIHN1Y2Nlc3NmdWxseS5cbiAqICBUaGlzIHByb21pc2UgYWxzbyBlbWl0cyBgaG9sZGAgYW5kIGB0ZWFyZG93bmAgbm90aWZpY2F0aW9ucy4gV2hlbiB0aGlzIHByb21pc2UgaXMgcmVzb2x2ZWQsIHRoZSBmaXJzdFxuICogIGFyZ3VtZW50IG9mIGl0cyB2YWx1ZSBpcyB0aGUgY2xvc2luZyBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgV2luZG93IGNsb3NpbmcgZGF0YVxuICovXG5cbi8qKlxuICogQSAncmVzaXplJyBldmVudCBpcyBlbWl0dGVkIHdoZW4gYSB3aW5kb3cgaXMgcmVzaXplZC5cbiAqXG4gKiBAZXZlbnQgcmVzaXplXG4gKiBAcGFyYW0ge09PLnVpLldpbmRvd30gd2luIFdpbmRvdyB0aGF0IHdhcyByZXNpemVkXG4gKi9cblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBNYXAgb2YgdGhlIHN5bWJvbGljIG5hbWUgb2YgZWFjaCB3aW5kb3cgc2l6ZSBhbmQgaXRzIENTUyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtPYmplY3R9XG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIuc3RhdGljLnNpemVzID0ge1xuXHRzbWFsbDoge1xuXHRcdHdpZHRoOiAzMDBcblx0fSxcblx0bWVkaXVtOiB7XG5cdFx0d2lkdGg6IDUwMFxuXHR9LFxuXHRsYXJnZToge1xuXHRcdHdpZHRoOiA3MDBcblx0fSxcblx0bGFyZ2VyOiB7XG5cdFx0d2lkdGg6IDkwMFxuXHR9LFxuXHRmdWxsOiB7XG5cdFx0Ly8gVGhlc2UgY2FuIGJlIG5vbi1udW1lcmljIGJlY2F1c2UgdGhleSBhcmUgbmV2ZXIgdXNlZCBpbiBjYWxjdWxhdGlvbnNcblx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdGhlaWdodDogJzEwMCUnXG5cdH1cbn07XG5cbi8qKlxuICogU3ltYm9saWMgbmFtZSBvZiB0aGUgZGVmYXVsdCB3aW5kb3cgc2l6ZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBzaXplIGlzIHVzZWQgaWYgdGhlIHdpbmRvdydzIHJlcXVlc3RlZCBzaXplIGlzIG5vdCByZWNvZ25pemVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIuc3RhdGljLmRlZmF1bHRTaXplID0gJ21lZGl1bSc7XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBIYW5kbGUgd2luZG93IHJlc2l6ZSBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBlIFdpbmRvdyByZXNpemUgZXZlbnRcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdGNsZWFyVGltZW91dCggdGhpcy5vbldpbmRvd1Jlc2l6ZVRpbWVvdXQgKTtcblx0dGhpcy5vbldpbmRvd1Jlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCB0aGlzLmFmdGVyV2luZG93UmVzaXplSGFuZGxlciwgMjAwICk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB3aW5kb3cgcmVzaXplIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgV2luZG93IHJlc2l6ZSBldmVudFxuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5hZnRlcldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGN1cnJlbnRGb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdGlmICggdGhpcy5jdXJyZW50V2luZG93ICkge1xuXHRcdHRoaXMudXBkYXRlV2luZG93U2l6ZSggdGhpcy5jdXJyZW50V2luZG93ICk7XG5cblx0XHQvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSBvcmlnaW5hbCBlbGVtZW50IGlmIGl0IGhhcyBjaGFuZ2VkLlxuXHRcdC8vIFdoZW4gYSBsYXlvdXQgY2hhbmdlIGlzIG1hZGUgb24gcmVzaXplIGlucHV0cyBsb3NlIGZvY3VzXG5cdFx0Ly8gb24gQW5kcm9pZCAoQ2hyb21lIGFuZCBGaXJlZm94KS4gU2VlIFQxNjIxMjcuXG5cdFx0aWYgKCBjdXJyZW50Rm9jdXNlZEVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKSB7XG5cdFx0XHRjdXJyZW50Rm9jdXNlZEVsZW1lbnQuZm9jdXMoKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgd2luZG93IGlzIG9wZW5pbmcuXG4gKlxuICogQHBhcmFtIHtPTy51aS5XaW5kb3d9IHdpbiBXaW5kb3cgdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbmRvdyBpcyBvcGVuaW5nXG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLmlzT3BlbmluZyA9IGZ1bmN0aW9uICggd2luICkge1xuXHRyZXR1cm4gd2luID09PSB0aGlzLmN1cnJlbnRXaW5kb3cgJiYgISF0aGlzLmxpZmVjeWNsZSAmJlxuXHRcdHRoaXMubGlmZWN5Y2xlLmlzT3BlbmluZygpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB3aW5kb3cgaXMgY2xvc2luZy5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLldpbmRvd30gd2luIFdpbmRvdyB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gV2luZG93IGlzIGNsb3NpbmdcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuaXNDbG9zaW5nID0gZnVuY3Rpb24gKCB3aW4gKSB7XG5cdHJldHVybiB3aW4gPT09IHRoaXMuY3VycmVudFdpbmRvdyAmJiAhIXRoaXMubGlmZWN5Y2xlICYmXG5cdFx0dGhpcy5saWZlY3ljbGUuaXNDbG9zaW5nKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdpbmRvdyBpcyBvcGVuZWQuXG4gKlxuICogQHBhcmFtIHtPTy51aS5XaW5kb3d9IHdpbiBXaW5kb3cgdG8gY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbmRvdyBpcyBvcGVuZWRcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuaXNPcGVuZWQgPSBmdW5jdGlvbiAoIHdpbiApIHtcblx0cmV0dXJuIHdpbiA9PT0gdGhpcy5jdXJyZW50V2luZG93ICYmICEhdGhpcy5saWZlY3ljbGUgJiZcblx0XHR0aGlzLmxpZmVjeWNsZS5pc09wZW5lZCgpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHdpbmRvdyBpcyBiZWluZyBtYW5hZ2VkLlxuICpcbiAqIEBwYXJhbSB7T08udWkuV2luZG93fSB3aW4gV2luZG93IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaW5kb3cgaXMgYmVpbmcgbWFuYWdlZFxuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5oYXNXaW5kb3cgPSBmdW5jdGlvbiAoIHdpbiApIHtcblx0dmFyIG5hbWU7XG5cblx0Zm9yICggbmFtZSBpbiB0aGlzLndpbmRvd3MgKSB7XG5cdFx0aWYgKCB0aGlzLndpbmRvd3NbIG5hbWUgXSA9PT0gd2luICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBvcGVuaW5nIGJlZ2lucyBiZWZvcmUgZXhlY3V0aW5nIHRoZSDigJhzZXR1cOKAmSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7T08udWkuV2luZG93fSB3aW4gV2luZG93IGJlaW5nIG9wZW5lZFxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBXaW5kb3cgb3BlbmluZyBkYXRhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLmdldFNldHVwRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBzZXR1cCBoYXMgZmluaXNoZWQgYmVmb3JlIGV4ZWN1dGluZyB0aGUg4oCYcmVhZHnigJkgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLldpbmRvd30gd2luIFdpbmRvdyBiZWluZyBvcGVuZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IG9wZW5pbmcgZGF0YVxuICogQHJldHVybiB7bnVtYmVyfSBNaWxsaXNlY29uZHMgdG8gd2FpdFxuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZWFkeURlbGF5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5tb2RhbCA/IE9PLnVpLnRoZW1lLmdldERpYWxvZ1RyYW5zaXRpb25EdXJhdGlvbigpIDogMDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYWZ0ZXIgY2xvc2luZyBoYXMgYmVndW4gYmVmb3JlIGV4ZWN1dGluZyB0aGUgJ2hvbGQnIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtPTy51aS5XaW5kb3d9IHdpbiBXaW5kb3cgYmVpbmcgY2xvc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIFdpbmRvdyBjbG9zaW5nIGRhdGFcbiAqIEByZXR1cm4ge251bWJlcn0gTWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuZ2V0SG9sZERlbGF5ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gMDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYWZ0ZXIgdGhlIOKAmGhvbGTigJkgcHJvY2VzcyBoYXMgZmluaXNoZWQgYmVmb3JlXG4gKiBleGVjdXRpbmcgdGhlIOKAmHRlYXJkb3du4oCZIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtPTy51aS5XaW5kb3d9IHdpbiBXaW5kb3cgYmVpbmcgY2xvc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIFdpbmRvdyBjbG9zaW5nIGRhdGFcbiAqIEByZXR1cm4ge251bWJlcn0gTWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuZ2V0VGVhcmRvd25EZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubW9kYWwgPyBPTy51aS50aGVtZS5nZXREaWFsb2dUcmFuc2l0aW9uRHVyYXRpb24oKSA6IDA7XG59O1xuXG4vKipcbiAqIEdldCBhIHdpbmRvdyBieSBpdHMgc3ltYm9saWMgbmFtZS5cbiAqXG4gKiBJZiB0aGUgd2luZG93IGlzIG5vdCB5ZXQgaW5zdGFudGlhdGVkIGFuZCBpdHMgc3ltYm9saWMgbmFtZSBpcyByZWNvZ25pemVkIGJ5IGEgZmFjdG9yeSwgaXQgd2lsbCBiZVxuICogaW5zdGFudGlhdGVkIGFuZCBhZGRlZCB0byB0aGUgd2luZG93IG1hbmFnZXIgYXV0b21hdGljYWxseS4gUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldWzNdXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB1c2luZyBmYWN0b3JpZXMuXG4gKiBbM106IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpbmRvd3MvV2luZG93X21hbmFnZXJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3ltYm9saWMgbmFtZSBvZiB0aGUgd2luZG93XG4gKiBAcmV0dXJuIHtqUXVlcnkuUHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aXRoIG1hdGNoaW5nIHdpbmRvdywgb3IgcmVqZWN0ZWQgd2l0aCBhbiBPTy51aS5FcnJvclxuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgc3ltYm9saWMgbmFtZSBpcyBub3QgcmVjb2duaXplZCBieSB0aGUgZmFjdG9yeS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG5hbWVkIHdpbmRvdyBpcyBub3QgcmVjb2duaXplZCBhcyBhIG1hbmFnZWQgd2luZG93LlxuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cdHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcblx0XHR3aW4gPSB0aGlzLndpbmRvd3NbIG5hbWUgXTtcblxuXHRpZiAoICEoIHdpbiBpbnN0YW5jZW9mIE9PLnVpLldpbmRvdyApICkge1xuXHRcdGlmICggdGhpcy5mYWN0b3J5ICkge1xuXHRcdFx0aWYgKCAhdGhpcy5mYWN0b3J5Lmxvb2t1cCggbmFtZSApICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoIG5ldyBPTy51aS5FcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IGF1dG8taW5zdGFudGlhdGUgd2luZG93OiBzeW1ib2xpYyBuYW1lIGlzIHVucmVjb2duaXplZCBieSB0aGUgZmFjdG9yeSdcblx0XHRcdFx0KSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSggbmFtZSApO1xuXHRcdFx0XHR0aGlzLmFkZFdpbmRvd3MoIFsgd2luIF0gKTtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZSggd2luICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmVycmVkLnJlamVjdCggbmV3IE9PLnVpLkVycm9yKFxuXHRcdFx0XHQnQ2Fubm90IGdldCB1bm1hbmFnZWQgd2luZG93OiBzeW1ib2xpYyBuYW1lIHVucmVjb2duaXplZCBhcyBhIG1hbmFnZWQgd2luZG93J1xuXHRcdFx0KSApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRkZWZlcnJlZC5yZXNvbHZlKCB3aW4gKTtcblx0fVxuXG5cdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG59O1xuXG4vKipcbiAqIEdldCBjdXJyZW50IHdpbmRvdy5cbiAqXG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3d8bnVsbH0gQ3VycmVudGx5IG9wZW5pbmcvb3BlbmVkL2Nsb3Npbmcgd2luZG93XG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLmdldEN1cnJlbnRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmN1cnJlbnRXaW5kb3c7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBPcGVuIGEgd2luZG93LlxuICpcbiAqIEBwYXJhbSB7T08udWkuV2luZG93fHN0cmluZ30gd2luIFdpbmRvdyBvYmplY3Qgb3Igc3ltYm9saWMgbmFtZSBvZiB3aW5kb3cgdG8gb3BlblxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBXaW5kb3cgb3BlbmluZyBkYXRhXG4gKiBAcGFyYW0ge2pRdWVyeXxudWxsfSBbZGF0YS4kcmV0dXJuRm9jdXNUb10gRWxlbWVudCB0byB3aGljaCB0aGUgd2luZG93IHdpbGwgcmV0dXJuIGZvY3VzIHdoZW4gY2xvc2VkLlxuICogIERlZmF1bHRzIHRoZSBjdXJyZW50IGFjdGl2ZUVsZW1lbnQuIElmIHNldCB0byBudWxsLCBmb2N1cyBpc24ndCBjaGFuZ2VkIG9uIGNsb3NlLlxuICogQHJldHVybiB7T08udWkuV2luZG93SW5zdGFuY2V9IEEgbGlmZWN5Y2xlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBwYXJ0aWN1bGFyXG4gKiAgb3BlbmluZyBvZiB0aGUgd2luZG93LiBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZW4gb2JqZWN0IGlzIGFsc28gYSBUaGVuYWJsZSB0aGF0IGlzIHJlc29sdmVkXG4gKiAgd2hlbiB0aGUgd2luZG93IGlzIGRvbmUgb3BlbmluZywgd2l0aCBuZXN0ZWQgcHJvbWlzZSBmb3Igd2hlbiBjbG9zaW5nIHN0YXJ0cy4gVGhpcyBiZWhhdmlvdXJcbiAqICBpcyBkZXByZWNhdGVkIGFuZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGpRdWVyeSAzLiBTZWUgVDE2MzUxMC5cbiAqIEBmaXJlcyBvcGVuaW5nXG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoIHdpbiwgZGF0YSwgbGlmZWN5Y2xlLCBjb21wYXRPcGVuaW5nICkge1xuXHQvKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cdHZhciBlcnJvcixcblx0XHRtYW5hZ2VyID0gdGhpcztcblx0ZGF0YSA9IGRhdGEgfHwge307XG5cblx0Ly8gSW50ZXJuYWwgcGFyYW1ldGVyICdsaWZlY3ljbGUnIGFsbG93cyB0aGlzIG1ldGhvZCB0byBhbHdheXMgcmV0dXJuXG5cdC8vIGEgbGlmZWN5Y2xlIGV2ZW4gaWYgdGhlIHdpbmRvdyBzdGlsbCBuZWVkcyB0byBiZSBjcmVhdGVkXG5cdC8vIGFzeW5jaHJvbm91c2x5IHdoZW4gJ3dpbicgaXMgYSBzdHJpbmcuXG5cdGxpZmVjeWNsZSA9IGxpZmVjeWNsZSB8fCBuZXcgT08udWkuV2luZG93SW5zdGFuY2UoKTtcblx0Y29tcGF0T3BlbmluZyA9IGNvbXBhdE9wZW5pbmcgfHwgJC5EZWZlcnJlZCgpO1xuXG5cdC8vIFR1cm4gbGlmZWN5Y2xlIGludG8gYSBUaGVuYWJsZSBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aFxuXHQvLyB0aGUgZGVwcmVjYXRlZCBuZXN0ZWQtcHJvbWlzZSBiZWhhdmlvdXIsIHNlZSBUMTYzNTEwLlxuXHRbICdzdGF0ZScsICdhbHdheXMnLCAnY2F0Y2gnLCAncGlwZScsICd0aGVuJywgJ3Byb21pc2UnLCAncHJvZ3Jlc3MnLCAnZG9uZScsICdmYWlsJyBdXG5cdFx0LmZvckVhY2goIGZ1bmN0aW9uICggbWV0aG9kICkge1xuXHRcdFx0bGlmZWN5Y2xlWyBtZXRob2QgXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0T08udWkud2FybkRlcHJlY2F0aW9uKFxuXHRcdFx0XHRcdCdVc2luZyB0aGUgcmV0dXJuIHZhbHVlIG9mIG9wZW5XaW5kb3cgYXMgYSBwcm9taXNlIGlzIGRlcHJlY2F0ZWQuICcgK1xuXHRcdFx0XHRcdCdVc2UgLm9wZW5XaW5kb3coIC4uLiApLm9wZW5pbmcuJyArIG1ldGhvZCArICcoIC4uLiApIGluc3RlYWQuJ1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4gY29tcGF0T3BlbmluZ1sgbWV0aG9kIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHR9ICk7XG5cblx0Ly8gQXJndW1lbnQgaGFuZGxpbmdcblx0aWYgKCB0eXBlb2Ygd2luID09PSAnc3RyaW5nJyApIHtcblx0XHR0aGlzLmdldFdpbmRvdyggd2luICkudGhlbihcblx0XHRcdGZ1bmN0aW9uICggd2luICkge1xuXHRcdFx0XHRtYW5hZ2VyLm9wZW5XaW5kb3coIHdpbiwgZGF0YSwgbGlmZWN5Y2xlLCBjb21wYXRPcGVuaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0ZnVuY3Rpb24gKCBlcnIgKSB7XG5cdFx0XHRcdGxpZmVjeWNsZS5kZWZlcnJlZHMub3BlbmluZy5yZWplY3QoIGVyciApO1xuXHRcdFx0fVxuXHRcdCk7XG5cdFx0cmV0dXJuIGxpZmVjeWNsZTtcblx0fVxuXG5cdC8vIEVycm9yIGhhbmRsaW5nXG5cdGlmICggIXRoaXMuaGFzV2luZG93KCB3aW4gKSApIHtcblx0XHRlcnJvciA9ICdDYW5ub3Qgb3BlbiB3aW5kb3c6IHdpbmRvdyBpcyBub3QgYXR0YWNoZWQgdG8gbWFuYWdlcic7XG5cdH0gZWxzZSBpZiAoIHRoaXMubGlmZWN5Y2xlICYmIHRoaXMubGlmZWN5Y2xlLmlzT3BlbmVkKCkgKSB7XG5cdFx0ZXJyb3IgPSAnQ2Fubm90IG9wZW4gd2luZG93OiBhbm90aGVyIHdpbmRvdyBpcyBvcGVuJztcblx0fSBlbHNlIGlmICggdGhpcy5wcmVwYXJpbmdUb09wZW4gfHwgKCB0aGlzLmxpZmVjeWNsZSAmJiB0aGlzLmxpZmVjeWNsZS5pc09wZW5pbmcoKSApICkge1xuXHRcdGVycm9yID0gJ0Nhbm5vdCBvcGVuIHdpbmRvdzogYW5vdGhlciB3aW5kb3cgaXMgb3BlbmluZyc7XG5cdH1cblxuXHRpZiAoIGVycm9yICkge1xuXHRcdGNvbXBhdE9wZW5pbmcucmVqZWN0KCBuZXcgT08udWkuRXJyb3IoIGVycm9yICkgKTtcblx0XHRsaWZlY3ljbGUuZGVmZXJyZWRzLm9wZW5pbmcucmVqZWN0KCBuZXcgT08udWkuRXJyb3IoIGVycm9yICkgKTtcblx0XHRyZXR1cm4gbGlmZWN5Y2xlO1xuXHR9XG5cblx0Ly8gSWYgYSB3aW5kb3cgaXMgY3VycmVudGx5IGNsb3NpbmcsIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG5cdHRoaXMucHJlcGFyaW5nVG9PcGVuID0gJC53aGVuKCB0aGlzLmxpZmVjeWNsZSAmJiB0aGlzLmxpZmVjeWNsZS5jbG9zZWQgKTtcblx0Ly8gRW5zdXJlIGhhbmRsZXJzIGdldCBjYWxsZWQgYWZ0ZXIgcHJlcGFyaW5nVG9PcGVuIGlzIHNldFxuXHR0aGlzLnByZXBhcmluZ1RvT3Blbi5kb25lKCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCBtYW5hZ2VyLm1vZGFsICkge1xuXHRcdFx0bWFuYWdlci50b2dnbGVHbG9iYWxFdmVudHMoIHRydWUgKTtcblx0XHRcdG1hbmFnZXIudG9nZ2xlQXJpYUlzb2xhdGlvbiggdHJ1ZSApO1xuXHRcdH1cblx0XHRtYW5hZ2VyLiRyZXR1cm5Gb2N1c1RvID0gZGF0YS4kcmV0dXJuRm9jdXNUbyAhPT0gdW5kZWZpbmVkID8gZGF0YS4kcmV0dXJuRm9jdXNUbyA6ICQoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKTtcblx0XHRtYW5hZ2VyLmN1cnJlbnRXaW5kb3cgPSB3aW47XG5cdFx0bWFuYWdlci5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG5cdFx0bWFuYWdlci5wcmVwYXJpbmdUb09wZW4gPSBudWxsO1xuXHRcdG1hbmFnZXIuZW1pdCggJ29wZW5pbmcnLCB3aW4sIGNvbXBhdE9wZW5pbmcsIGRhdGEgKTtcblx0XHRsaWZlY3ljbGUuZGVmZXJyZWRzLm9wZW5pbmcucmVzb2x2ZSggZGF0YSApO1xuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdG1hbmFnZXIuY29tcGF0T3BlbmVkID0gJC5EZWZlcnJlZCgpO1xuXHRcdFx0d2luLnNldHVwKCBkYXRhICkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb21wYXRPcGVuaW5nLm5vdGlmeSggeyBzdGF0ZTogJ3NldHVwJyB9ICk7XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW4ucmVhZHkoIGRhdGEgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRjb21wYXRPcGVuaW5nLm5vdGlmeSggeyBzdGF0ZTogJ3JlYWR5JyB9ICk7XG5cdFx0XHRcdFx0XHRsaWZlY3ljbGUuZGVmZXJyZWRzLm9wZW5lZC5yZXNvbHZlKCBkYXRhICk7XG5cdFx0XHRcdFx0XHRjb21wYXRPcGVuaW5nLnJlc29sdmUoIG1hbmFnZXIuY29tcGF0T3BlbmVkLnByb21pc2UoKSwgZGF0YSApO1xuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGxpZmVjeWNsZS5kZWZlcnJlZHMub3BlbmVkLnJlamVjdCgpO1xuXHRcdFx0XHRcdFx0Y29tcGF0T3BlbmluZy5yZWplY3QoKTtcblx0XHRcdFx0XHRcdG1hbmFnZXIuY2xvc2VXaW5kb3coIHdpbiApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSwgbWFuYWdlci5nZXRSZWFkeURlbGF5KCkgKTtcblx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bGlmZWN5Y2xlLmRlZmVycmVkcy5vcGVuZWQucmVqZWN0KCk7XG5cdFx0XHRcdGNvbXBhdE9wZW5pbmcucmVqZWN0KCk7XG5cdFx0XHRcdG1hbmFnZXIuY2xvc2VXaW5kb3coIHdpbiApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG1hbmFnZXIuZ2V0U2V0dXBEZWxheSgpICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gbGlmZWN5Y2xlO1xufTtcblxuLyoqXG4gKiBDbG9zZSBhIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0ge09PLnVpLldpbmRvd3xzdHJpbmd9IHdpbiBXaW5kb3cgb2JqZWN0IG9yIHN5bWJvbGljIG5hbWUgb2Ygd2luZG93IHRvIGNsb3NlXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIFdpbmRvdyBjbG9zaW5nIGRhdGFcbiAqIEByZXR1cm4ge09PLnVpLldpbmRvd0luc3RhbmNlfSBBIGxpZmVjeWNsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgcGFydGljdWxhclxuICogIG9wZW5pbmcgb2YgdGhlIHdpbmRvdy4gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgb2JqZWN0IGlzIGFsc28gYSBUaGVuYWJsZSB0aGF0IGlzIHJlc29sdmVkXG4gKiAgd2hlbiB0aGUgd2luZG93IGlzIGRvbmUgY2xvc2luZywgc2VlIFQxNjM1MTAuXG4gKiBAZmlyZXMgY2xvc2luZ1xuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uICggd2luLCBkYXRhICkge1xuXHR2YXIgZXJyb3IsXG5cdFx0bWFuYWdlciA9IHRoaXMsXG5cdFx0Y29tcGF0Q2xvc2luZyA9ICQuRGVmZXJyZWQoKSxcblx0XHRsaWZlY3ljbGUgPSB0aGlzLmxpZmVjeWNsZSxcblx0XHRjb21wYXRPcGVuZWQ7XG5cblx0Ly8gQXJndW1lbnQgaGFuZGxpbmdcblx0aWYgKCB0eXBlb2Ygd2luID09PSAnc3RyaW5nJyApIHtcblx0XHR3aW4gPSB0aGlzLndpbmRvd3NbIHdpbiBdO1xuXHR9IGVsc2UgaWYgKCAhdGhpcy5oYXNXaW5kb3coIHdpbiApICkge1xuXHRcdHdpbiA9IG51bGw7XG5cdH1cblxuXHQvLyBFcnJvciBoYW5kbGluZ1xuXHRpZiAoICFsaWZlY3ljbGUgKSB7XG5cdFx0ZXJyb3IgPSAnQ2Fubm90IGNsb3NlIHdpbmRvdzogbm8gd2luZG93IGlzIGN1cnJlbnRseSBvcGVuJztcblx0fSBlbHNlIGlmICggIXdpbiApIHtcblx0XHRlcnJvciA9ICdDYW5ub3QgY2xvc2Ugd2luZG93OiB3aW5kb3cgaXMgbm90IGF0dGFjaGVkIHRvIG1hbmFnZXInO1xuXHR9IGVsc2UgaWYgKCB3aW4gIT09IHRoaXMuY3VycmVudFdpbmRvdyB8fCB0aGlzLmxpZmVjeWNsZS5pc0Nsb3NlZCgpICkge1xuXHRcdGVycm9yID0gJ0Nhbm5vdCBjbG9zZSB3aW5kb3c6IHdpbmRvdyBhbHJlYWR5IGNsb3NlZCB3aXRoIGRpZmZlcmVudCBkYXRhJztcblx0fSBlbHNlIGlmICggdGhpcy5wcmVwYXJpbmdUb0Nsb3NlIHx8IHRoaXMubGlmZWN5Y2xlLmlzQ2xvc2luZygpICkge1xuXHRcdGVycm9yID0gJ0Nhbm5vdCBjbG9zZSB3aW5kb3c6IHdpbmRvdyBhbHJlYWR5IGNsb3Npbmcgd2l0aCBkaWZmZXJlbnQgZGF0YSc7XG5cdH1cblxuXHRpZiAoIGVycm9yICkge1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZCBmb3IgdGhlIHdyb25nIHdpbmRvdyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtZXNzIHdpdGggdGhlIGN1cnJlbnRcblx0XHQvLyB3aW5kb3cncyBzdGF0ZS5cblx0XHRsaWZlY3ljbGUgPSBuZXcgT08udWkuV2luZG93SW5zdGFuY2UoKTtcblx0XHQvLyBQcmV0ZW5kIHRoZSB3aW5kb3cgaGFzIGJlZW4gb3BlbmVkLCBzbyB0aGF0IHdlIGNhbiBwcmV0ZW5kIHRvIGZhaWwgdG8gY2xvc2UgaXQuXG5cdFx0bGlmZWN5Y2xlLmRlZmVycmVkcy5vcGVuaW5nLnJlc29sdmUoIHt9ICk7XG5cdFx0bGlmZWN5Y2xlLmRlZmVycmVkcy5vcGVuZWQucmVzb2x2ZSgge30gKTtcblx0fVxuXG5cdC8vIFR1cm4gbGlmZWN5Y2xlIGludG8gYSBUaGVuYWJsZSBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aFxuXHQvLyB0aGUgZGVwcmVjYXRlZCBuZXN0ZWQtcHJvbWlzZSBiZWhhdmlvdXIsIHNlZSBUMTYzNTEwLlxuXHRbICdzdGF0ZScsICdhbHdheXMnLCAnY2F0Y2gnLCAncGlwZScsICd0aGVuJywgJ3Byb21pc2UnLCAncHJvZ3Jlc3MnLCAnZG9uZScsICdmYWlsJyBdXG5cdFx0LmZvckVhY2goIGZ1bmN0aW9uICggbWV0aG9kICkge1xuXHRcdFx0bGlmZWN5Y2xlWyBtZXRob2QgXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0T08udWkud2FybkRlcHJlY2F0aW9uKFxuXHRcdFx0XHRcdCdVc2luZyB0aGUgcmV0dXJuIHZhbHVlIG9mIGNsb3NlV2luZG93IGFzIGEgcHJvbWlzZSBpcyBkZXByZWNhdGVkLiAnICtcblx0XHRcdFx0XHQnVXNlIC5jbG9zZVdpbmRvdyggLi4uICkuY2xvc2VkLicgKyBtZXRob2QgKyAnKCAuLi4gKSBpbnN0ZWFkLidcblx0XHRcdFx0KTtcblx0XHRcdFx0cmV0dXJuIGNvbXBhdENsb3NpbmdbIG1ldGhvZCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0fSApO1xuXG5cdGlmICggZXJyb3IgKSB7XG5cdFx0Y29tcGF0Q2xvc2luZy5yZWplY3QoIG5ldyBPTy51aS5FcnJvciggZXJyb3IgKSApO1xuXHRcdGxpZmVjeWNsZS5kZWZlcnJlZHMuY2xvc2luZy5yZWplY3QoIG5ldyBPTy51aS5FcnJvciggZXJyb3IgKSApO1xuXHRcdHJldHVybiBsaWZlY3ljbGU7XG5cdH1cblxuXHQvLyBJZiB0aGUgd2luZG93IGlzIGN1cnJlbnRseSBvcGVuaW5nLCBjbG9zZSBpdCB3aGVuIGl0J3MgZG9uZVxuXHR0aGlzLnByZXBhcmluZ1RvQ2xvc2UgPSAkLndoZW4oIHRoaXMubGlmZWN5Y2xlLm9wZW5lZCApO1xuXHQvLyBFbnN1cmUgaGFuZGxlcnMgZ2V0IGNhbGxlZCBhZnRlciBwcmVwYXJpbmdUb0Nsb3NlIGlzIHNldFxuXHR0aGlzLnByZXBhcmluZ1RvQ2xvc2UuYWx3YXlzKCBmdW5jdGlvbiAoKSB7XG5cdFx0bWFuYWdlci5wcmVwYXJpbmdUb0Nsb3NlID0gbnVsbDtcblx0XHRtYW5hZ2VyLmVtaXQoICdjbG9zaW5nJywgd2luLCBjb21wYXRDbG9zaW5nLCBkYXRhICk7XG5cdFx0bGlmZWN5Y2xlLmRlZmVycmVkcy5jbG9zaW5nLnJlc29sdmUoIGRhdGEgKTtcblx0XHRjb21wYXRPcGVuZWQgPSBtYW5hZ2VyLmNvbXBhdE9wZW5lZDtcblx0XHRtYW5hZ2VyLmNvbXBhdE9wZW5lZCA9IG51bGw7XG5cdFx0Y29tcGF0T3BlbmVkLnJlc29sdmUoIGNvbXBhdENsb3NpbmcucHJvbWlzZSgpLCBkYXRhICk7XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0d2luLmhvbGQoIGRhdGEgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbXBhdENsb3Npbmcubm90aWZ5KCB7IHN0YXRlOiAnaG9sZCcgfSApO1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0d2luLnRlYXJkb3duKCBkYXRhICkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y29tcGF0Q2xvc2luZy5ub3RpZnkoIHsgc3RhdGU6ICd0ZWFyZG93bicgfSApO1xuXHRcdFx0XHRcdFx0aWYgKCBtYW5hZ2VyLm1vZGFsICkge1xuXHRcdFx0XHRcdFx0XHRtYW5hZ2VyLnRvZ2dsZUdsb2JhbEV2ZW50cyggZmFsc2UgKTtcblx0XHRcdFx0XHRcdFx0bWFuYWdlci50b2dnbGVBcmlhSXNvbGF0aW9uKCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYW5hZ2VyLiRyZXR1cm5Gb2N1c1RvICYmIG1hbmFnZXIuJHJldHVybkZvY3VzVG8ubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRtYW5hZ2VyLiRyZXR1cm5Gb2N1c1RvWyAwIF0uZm9jdXMoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hbmFnZXIuY3VycmVudFdpbmRvdyA9IG51bGw7XG5cdFx0XHRcdFx0XHRtYW5hZ2VyLmxpZmVjeWNsZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRsaWZlY3ljbGUuZGVmZXJyZWRzLmNsb3NlZC5yZXNvbHZlKCBkYXRhICk7XG5cdFx0XHRcdFx0XHRjb21wYXRDbG9zaW5nLnJlc29sdmUoIGRhdGEgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0sIG1hbmFnZXIuZ2V0VGVhcmRvd25EZWxheSgpICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbWFuYWdlci5nZXRIb2xkRGVsYXkoKSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGxpZmVjeWNsZTtcbn07XG5cbi8qKlxuICogQWRkIHdpbmRvd3MgdG8gdGhlIHdpbmRvdyBtYW5hZ2VyLlxuICpcbiAqIFdpbmRvd3MgY2FuIGJlIGFkZGVkIGJ5IHJlZmVyZW5jZSwgc3ltYm9saWMgbmFtZSwgb3IgZXhwbGljaXRseSBkZWZpbmVkIHN5bWJvbGljIG5hbWVzLlxuICogU2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzJdIGZvciBleGFtcGxlcy5cbiAqIFsyXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2luZG93cy9XaW5kb3dfbWFuYWdlcnNcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgaW4gdHdvIG1hbm5lcnM6XG4gKlxuICogMS4gYC5hZGRXaW5kb3dzKCBbIHdpbmRvd0EsIHdpbmRvd0IsIC4uLiBdIClgICh3aGVyZSBgd2luZG93QWAsIGB3aW5kb3dCYCBhcmUgT08udWkuV2luZG93IG9iamVjdHMpXG4gKlxuICogICAgVGhpcyBzeW50YXggcmVnaXN0ZXJzIHdpbmRvd3MgdW5kZXIgdGhlIHN5bWJvbGljIG5hbWVzIGRlZmluZWQgaW4gdGhlaXIgYC5zdGF0aWMubmFtZWBcbiAqICAgIHByb3BlcnRpZXMuIEZvciBleGFtcGxlLCBpZiBgd2luZG93QS5jb25zdHJ1Y3Rvci5zdGF0aWMubmFtZWAgaXMgYCduYW1lQSdgLCBjYWxsaW5nXG4gKiAgICBgLm9wZW5XaW5kb3coICduYW1lQScgKWAgYWZ0ZXJ3YXJkcyB3aWxsIG9wZW4gdGhlIHdpbmRvdyBgd2luZG93QWAuIFRoaXMgc3ludGF4IHJlcXVpcmVzIHRoZVxuICogICAgc3RhdGljIG5hbWUgdG8gYmUgc2V0LCBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqICAgIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIHdheSwgYXMgaXQgYWxsb3dzIGZvciBhbiBlYXNpZXIgc3dpdGNoIHRvIHVzaW5nIGEgd2luZG93IGZhY3RvcnkuXG4gKlxuICogMi4gYC5hZGRXaW5kb3dzKCB7IG5hbWVBOiB3aW5kb3dBLCBuYW1lQjogd2luZG93QiwgLi4uIH0gKWBcbiAqXG4gKiAgICBUaGlzIHN5bnRheCByZWdpc3RlcnMgd2luZG93cyB1bmRlciB0aGUgZXhwbGljaXRseSBnaXZlbiBzeW1ib2xpYyBuYW1lcy4gSW4gdGhpcyBleGFtcGxlLFxuICogICAgY2FsbGluZyBgLm9wZW5XaW5kb3coICduYW1lQScgKWAgYWZ0ZXJ3YXJkcyB3aWxsIG9wZW4gdGhlIHdpbmRvdyBgd2luZG93QWAsIHJlZ2FyZGxlc3Mgb2Ygd2hhdFxuICogICAgaXRzIGAuc3RhdGljLm5hbWVgIGlzIHNldCB0by4gVGhlIHN0YXRpYyBuYW1lIGlzIG5vdCByZXF1aXJlZCB0byBiZSBzZXQuXG4gKlxuICogICAgVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGlmIHlvdSBuZWVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHN5bWJvbGljIG5hbWVzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciB3aW5kb3dNYW5hZ2VyID0gbmV3IE9PLnVpLldpbmRvd01hbmFnZXIoKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCB3aW5kb3dNYW5hZ2VyLiRlbGVtZW50ICk7XG4gKlxuICogICAgIC8vIEFkZCBhIHdpbmRvdyB1bmRlciB0aGUgZGVmYXVsdCBuYW1lOiBzZWUgT08udWkuTWVzc2FnZURpYWxvZy5zdGF0aWMubmFtZVxuICogICAgIHdpbmRvd01hbmFnZXIuYWRkV2luZG93cyggWyBuZXcgT08udWkuTWVzc2FnZURpYWxvZygpIF0gKTtcbiAqICAgICAvLyBBZGQgYSB3aW5kb3cgdW5kZXIgYW4gZXhwbGljaXQgbmFtZVxuICogICAgIHdpbmRvd01hbmFnZXIuYWRkV2luZG93cyggeyBteU1lc3NhZ2VEaWFsb2c6IG5ldyBPTy51aS5NZXNzYWdlRGlhbG9nKCkgfSApO1xuICpcbiAqICAgICAvLyBPcGVuIHdpbmRvdyBieSBkZWZhdWx0IG5hbWVcbiAqICAgICB3aW5kb3dNYW5hZ2VyLm9wZW5XaW5kb3coICdtZXNzYWdlJyApO1xuICogICAgIC8vIE9wZW4gd2luZG93IGJ5IGV4cGxpY2l0bHkgZ2l2ZW4gbmFtZVxuICogICAgIHdpbmRvd01hbmFnZXIub3BlbldpbmRvdyggJ215TWVzc2FnZURpYWxvZycgKTtcbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxPTy51aS5XaW5kb3c+fE9PLnVpLldpbmRvd1tdfSB3aW5kb3dzIEFuIGFycmF5IG9mIHdpbmRvdyBvYmplY3RzIHNwZWNpZmllZFxuICogIGJ5IHJlZmVyZW5jZSwgc3ltYm9saWMgbmFtZSwgb3IgZXhwbGljaXRseSBkZWZpbmVkIHN5bWJvbGljIG5hbWVzLlxuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiBhIHdpbmRvdyBpcyBhZGRlZCBieSBzeW1ib2xpYyBuYW1lLCBidXQgaGFzIG5laXRoZXIgYW5cbiAqICBleHBsaWNpdCBub3IgYSBzdGF0aWNhbGx5IGNvbmZpZ3VyZWQgc3ltYm9saWMgbmFtZS5cbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuYWRkV2luZG93cyA9IGZ1bmN0aW9uICggd2luZG93cyApIHtcblx0dmFyIGksIGxlbiwgd2luLCBuYW1lLCBsaXN0O1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggd2luZG93cyApICkge1xuXHRcdC8vIENvbnZlcnQgdG8gbWFwIG9mIHdpbmRvd3MgYnkgbG9va2luZyB1cCBzeW1ib2xpYyBuYW1lcyBmcm9tIHN0YXRpYyBjb25maWd1cmF0aW9uXG5cdFx0bGlzdCA9IHt9O1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSB3aW5kb3dzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0bmFtZSA9IHdpbmRvd3NbIGkgXS5jb25zdHJ1Y3Rvci5zdGF0aWMubmFtZTtcblx0XHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1dpbmRvd3MgbXVzdCBoYXZlIGEgYG5hbWVgIHN0YXRpYyBwcm9wZXJ0eSBkZWZpbmVkLicgKTtcblx0XHRcdH1cblx0XHRcdGxpc3RbIG5hbWUgXSA9IHdpbmRvd3NbIGkgXTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIE9PLmlzUGxhaW5PYmplY3QoIHdpbmRvd3MgKSApIHtcblx0XHRsaXN0ID0gd2luZG93cztcblx0fVxuXG5cdC8vIEFkZCB3aW5kb3dzXG5cdGZvciAoIG5hbWUgaW4gbGlzdCApIHtcblx0XHR3aW4gPSBsaXN0WyBuYW1lIF07XG5cdFx0dGhpcy53aW5kb3dzWyBuYW1lIF0gPSB3aW4udG9nZ2xlKCBmYWxzZSApO1xuXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKCB3aW4uJGVsZW1lbnQgKTtcblx0XHR3aW4uc2V0TWFuYWdlciggdGhpcyApO1xuXHR9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIHdpbmRvd3MgZnJvbSB0aGUgd2luZG93cyBtYW5hZ2VyLlxuICpcbiAqIFdpbmRvd3Mgd2lsbCBiZSBjbG9zZWQgYmVmb3JlIHRoZXkgYXJlIHJlbW92ZWQuIElmIHlvdSB3aXNoIHRvIHJlbW92ZSBhbGwgd2luZG93cywgeW91IG1heSB3aXNoIHRvIHVzZVxuICogdGhlICNjbGVhcldpbmRvd3MgbWV0aG9kIGluc3RlYWQuIElmIHlvdSBubyBsb25nZXIgbmVlZCB0aGUgd2luZG93IG1hbmFnZXIgYW5kIHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgbm9cbiAqIGxvbmdlciBsaXN0ZW5zIHRvIGV2ZW50cywgdXNlIHRoZSAjZGVzdHJveSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXMgU3ltYm9saWMgbmFtZXMgb2Ygd2luZG93cyB0byByZW1vdmVcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gd2luZG93IGlzIGNsb3NlZCBhbmQgcmVtb3ZlZFxuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgbmFtZWQgd2luZG93cyBhcmUgbm90IG1hbmFnZWQgYnkgdGhlIHdpbmRvdyBtYW5hZ2VyLlxuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVXaW5kb3dzID0gZnVuY3Rpb24gKCBuYW1lcyApIHtcblx0dmFyIGksIGxlbiwgd2luLCBuYW1lLCBjbGVhbnVwV2luZG93LFxuXHRcdG1hbmFnZXIgPSB0aGlzLFxuXHRcdHByb21pc2VzID0gW10sXG5cdFx0Y2xlYW51cCA9IGZ1bmN0aW9uICggbmFtZSwgd2luICkge1xuXHRcdFx0ZGVsZXRlIG1hbmFnZXIud2luZG93c1sgbmFtZSBdO1xuXHRcdFx0d2luLiRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH07XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdG5hbWUgPSBuYW1lc1sgaSBdO1xuXHRcdHdpbiA9IHRoaXMud2luZG93c1sgbmFtZSBdO1xuXHRcdGlmICggIXdpbiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCByZW1vdmUgd2luZG93JyApO1xuXHRcdH1cblx0XHRjbGVhbnVwV2luZG93ID0gY2xlYW51cC5iaW5kKCBudWxsLCBuYW1lLCB3aW4gKTtcblx0XHRwcm9taXNlcy5wdXNoKCB0aGlzLmNsb3NlV2luZG93KCBuYW1lICkuY2xvc2VkLnRoZW4oIGNsZWFudXBXaW5kb3csIGNsZWFudXBXaW5kb3cgKSApO1xuXHR9XG5cblx0cmV0dXJuICQud2hlbi5hcHBseSggJCwgcHJvbWlzZXMgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB3aW5kb3dzIGZyb20gdGhlIHdpbmRvdyBtYW5hZ2VyLlxuICpcbiAqIFdpbmRvd3Mgd2lsbCBiZSBjbG9zZWQgYmVmb3JlIHRoZXkgYXJlIHJlbW92ZWQuIE5vdGUgdGhhdCB0aGUgd2luZG93IG1hbmFnZXIsIHRob3VnaCBub3QgaW4gdXNlLCB3aWxsIHN0aWxsXG4gKiBsaXN0ZW4gdG8gZXZlbnRzLiBJZiB0aGUgd2luZG93IG1hbmFnZXIgd2lsbCBub3QgYmUgdXNlZCBhZ2FpbiwgeW91IG1heSB3aXNoIHRvIHVzZSB0aGUgI2Rlc3Ryb3kgbWV0aG9kIGluc3RlYWQuXG4gKiBUbyByZW1vdmUganVzdCBhIHN1YnNldCBvZiB3aW5kb3dzLCB1c2UgdGhlICNyZW1vdmVXaW5kb3dzIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtqUXVlcnkuUHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIGFsbCB3aW5kb3dzIGFyZSBjbG9zZWQgYW5kIHJlbW92ZWRcbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuY2xlYXJXaW5kb3dzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5yZW1vdmVXaW5kb3dzKCBPYmplY3Qua2V5cyggdGhpcy53aW5kb3dzICkgKTtcbn07XG5cbi8qKlxuICogU2V0IGRpYWxvZyBzaXplLiBJbiBnZW5lcmFsLCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cbiAqXG4gKiBGdWxsc2NyZWVuIG1vZGUgd2lsbCBiZSB1c2VkIGlmIHRoZSBkaWFsb2cgaXMgdG9vIHdpZGUgdG8gZml0IGluIHRoZSBzY3JlZW4uXG4gKlxuICogQHBhcmFtIHtPTy51aS5XaW5kb3d9IHdpbiBXaW5kb3cgdG8gdXBkYXRlLCBzaG91bGQgYmUgdGhlIGN1cnJlbnQgd2luZG93XG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3dNYW5hZ2VyfSBUaGUgbWFuYWdlciwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVdpbmRvd1NpemUgPSBmdW5jdGlvbiAoIHdpbiApIHtcblx0dmFyIGlzRnVsbHNjcmVlbjtcblxuXHQvLyBCeXBhc3MgZm9yIG5vbi1jdXJyZW50LCBhbmQgdGh1cyBpbnZpc2libGUsIHdpbmRvd3Ncblx0aWYgKCB3aW4gIT09IHRoaXMuY3VycmVudFdpbmRvdyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpc0Z1bGxzY3JlZW4gPSB3aW4uZ2V0U2l6ZSgpID09PSAnZnVsbCc7XG5cblx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyggJ29vLXVpLXdpbmRvd01hbmFnZXItZnVsbHNjcmVlbicsIGlzRnVsbHNjcmVlbiApO1xuXHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCAnb28tdWktd2luZG93TWFuYWdlci1mbG9hdGluZycsICFpc0Z1bGxzY3JlZW4gKTtcblx0d2luLnNldERpbWVuc2lvbnMoIHdpbi5nZXRTaXplUHJvcGVydGllcygpICk7XG5cblx0dGhpcy5lbWl0KCAncmVzaXplJywgd2luICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEJpbmQgb3IgdW5iaW5kIGdsb2JhbCBldmVudHMgZm9yIHNjcm9sbGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbb25dIEJpbmQgZ2xvYmFsIGV2ZW50c1xuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2luZG93TWFuYWdlcn0gVGhlIG1hbmFnZXIsIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS50b2dnbGVHbG9iYWxFdmVudHMgPSBmdW5jdGlvbiAoIG9uICkge1xuXHR2YXIgc2Nyb2xsV2lkdGgsIGJvZHlNYXJnaW4sXG5cdFx0JGJvZHkgPSAkKCB0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpLmJvZHkgKSxcblx0XHQvLyBXZSBjb3VsZCBoYXZlIG11bHRpcGxlIHdpbmRvdyBtYW5hZ2VycyBvcGVuIHNvIG9ubHkgbW9kaWZ5XG5cdFx0Ly8gdGhlIGJvZHkgY3NzIGF0IHRoZSBib3R0b20gb2YgdGhlIHN0YWNrXG5cdFx0c3RhY2tEZXB0aCA9ICRib2R5LmRhdGEoICd3aW5kb3dNYW5hZ2VyR2xvYmFsRXZlbnRzJyApIHx8IDA7XG5cblx0b24gPSBvbiA9PT0gdW5kZWZpbmVkID8gISF0aGlzLmdsb2JhbEV2ZW50cyA6ICEhb247XG5cblx0aWYgKCBvbiApIHtcblx0XHRpZiAoICF0aGlzLmdsb2JhbEV2ZW50cyApIHtcblx0XHRcdCQoIHRoaXMuZ2V0RWxlbWVudFdpbmRvdygpICkub24oIHtcblx0XHRcdFx0Ly8gU3RhcnQgbGlzdGVuaW5nIGZvciB0b3AtbGV2ZWwgd2luZG93IGRpbWVuc2lvbiBjaGFuZ2VzXG5cdFx0XHRcdCdvcmllbnRhdGlvbmNoYW5nZSByZXNpemUnOiB0aGlzLm9uV2luZG93UmVzaXplSGFuZGxlclxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCBzdGFja0RlcHRoID09PSAwICkge1xuXHRcdFx0XHRzY3JvbGxXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXHRcdFx0XHRib2R5TWFyZ2luID0gcGFyc2VGbG9hdCggJGJvZHkuY3NzKCAnbWFyZ2luLXJpZ2h0JyApICkgfHwgMDtcblx0XHRcdFx0JGJvZHkuYWRkQ2xhc3MoICdvby11aS13aW5kb3dNYW5hZ2VyLW1vZGFsLWFjdGl2ZScgKTtcblx0XHRcdFx0JGJvZHkuY3NzKCAnbWFyZ2luLXJpZ2h0JywgYm9keU1hcmdpbiArIHNjcm9sbFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRzdGFja0RlcHRoKys7XG5cdFx0XHR0aGlzLmdsb2JhbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCB0aGlzLmdsb2JhbEV2ZW50cyApIHtcblx0XHQkKCB0aGlzLmdldEVsZW1lbnRXaW5kb3coKSApLm9mZigge1xuXHRcdFx0Ly8gU3RvcCBsaXN0ZW5pbmcgZm9yIHRvcC1sZXZlbCB3aW5kb3cgZGltZW5zaW9uIGNoYW5nZXNcblx0XHRcdCdvcmllbnRhdGlvbmNoYW5nZSByZXNpemUnOiB0aGlzLm9uV2luZG93UmVzaXplSGFuZGxlclxuXHRcdH0gKTtcblx0XHRzdGFja0RlcHRoLS07XG5cdFx0aWYgKCBzdGFja0RlcHRoID09PSAwICkge1xuXHRcdFx0JGJvZHkucmVtb3ZlQ2xhc3MoICdvby11aS13aW5kb3dNYW5hZ2VyLW1vZGFsLWFjdGl2ZScgKTtcblx0XHRcdCRib2R5LmNzcyggJ21hcmdpbi1yaWdodCcsICcnICk7XG5cdFx0fVxuXHRcdHRoaXMuZ2xvYmFsRXZlbnRzID0gZmFsc2U7XG5cdH1cblx0JGJvZHkuZGF0YSggJ3dpbmRvd01hbmFnZXJHbG9iYWxFdmVudHMnLCBzdGFja0RlcHRoICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBzY3JlZW4gcmVhZGVyIHZpc2liaWxpdHkgb2YgY29udGVudCBvdGhlciB0aGFuIHRoZSB3aW5kb3cgbWFuYWdlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbaXNvbGF0ZV0gTWFrZSBvbmx5IHRoZSB3aW5kb3cgbWFuYWdlciB2aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3dNYW5hZ2VyfSBUaGUgbWFuYWdlciwgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLldpbmRvd01hbmFnZXIucHJvdG90eXBlLnRvZ2dsZUFyaWFJc29sYXRpb24gPSBmdW5jdGlvbiAoIGlzb2xhdGUgKSB7XG5cdHZhciAkdG9wTGV2ZWxFbGVtZW50O1xuXHRpc29sYXRlID0gaXNvbGF0ZSA9PT0gdW5kZWZpbmVkID8gIXRoaXMuJGFyaWFIaWRkZW4gOiAhIWlzb2xhdGU7XG5cblx0aWYgKCBpc29sYXRlICkge1xuXHRcdGlmICggIXRoaXMuJGFyaWFIaWRkZW4gKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSB0b3AgbGV2ZWwgZWxlbWVudCBjb250YWluaW5nIHRoZSB3aW5kb3cgbWFuYWdlciBvciB0aGVcblx0XHRcdC8vIHdpbmRvdyBtYW5hZ2VyJ3MgZWxlbWVudCBpdHNlbGYgaW4gY2FzZSBpdHMgYSBkaXJlY3QgY2hpbGQgb2YgYm9keVxuXHRcdFx0JHRvcExldmVsRWxlbWVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKCAnYm9keScgKS5sYXN0KCk7XG5cdFx0XHQkdG9wTGV2ZWxFbGVtZW50ID0gJHRvcExldmVsRWxlbWVudC5sZW5ndGggPT09IDAgPyB0aGlzLiRlbGVtZW50IDogJHRvcExldmVsRWxlbWVudDtcblxuXHRcdFx0Ly8gSW4gY2FzZSBwcmV2aW91c2x5IHNldCBieSBhbm90aGVyIHdpbmRvdyBtYW5hZ2VyXG5cdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoICdhcmlhLWhpZGRlbicgKTtcblxuXHRcdFx0Ly8gSGlkZSBldmVyeXRoaW5nIG90aGVyIHRoYW4gdGhlIHdpbmRvdyBtYW5hZ2VyIGZyb20gc2NyZWVuIHJlYWRlcnNcblx0XHRcdHRoaXMuJGFyaWFIaWRkZW4gPSAkKCBkb2N1bWVudC5ib2R5IClcblx0XHRcdFx0LmNoaWxkcmVuKClcblx0XHRcdFx0Lm5vdCggJ3NjcmlwdCcgKVxuXHRcdFx0XHQubm90KCAkdG9wTGV2ZWxFbGVtZW50IClcblx0XHRcdFx0LmF0dHIoICdhcmlhLWhpZGRlbicsIHRydWUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIHRoaXMuJGFyaWFIaWRkZW4gKSB7XG5cdFx0Ly8gUmVzdG9yZSBzY3JlZW4gcmVhZGVyIHZpc2liaWxpdHlcblx0XHR0aGlzLiRhcmlhSGlkZGVuLnJlbW92ZUF0dHIoICdhcmlhLWhpZGRlbicgKTtcblx0XHR0aGlzLiRhcmlhSGlkZGVuID0gbnVsbDtcblxuXHRcdC8vIGFuZCBoaWRlIHRoZSB3aW5kb3cgbWFuYWdlclxuXHRcdHRoaXMuJGVsZW1lbnQuYXR0ciggJ2FyaWEtaGlkZGVuJywgdHJ1ZSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHdpbmRvdyBtYW5hZ2VyLlxuICpcbiAqIERlc3Ryb3lpbmcgdGhlIHdpbmRvdyBtYW5hZ2VyIGVuc3VyZXMgdGhhdCBpdCB3aWxsIG5vIGxvbmdlciBsaXN0ZW4gdG8gZXZlbnRzLiBJZiB5b3Ugd291bGQgbGlrZSB0b1xuICogY29udGludWUgdXNpbmcgdGhlIHdpbmRvdyBtYW5hZ2VyLCBidXQgd2lzaCB0byByZW1vdmUgYWxsIHdpbmRvd3MgZnJvbSBpdCwgdXNlIHRoZSAjY2xlYXJXaW5kb3dzIG1ldGhvZFxuICogaW5zdGVhZC5cbiAqL1xuT08udWkuV2luZG93TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy50b2dnbGVHbG9iYWxFdmVudHMoIGZhbHNlICk7XG5cdHRoaXMudG9nZ2xlQXJpYUlzb2xhdGlvbiggZmFsc2UgKTtcblx0dGhpcy5jbGVhcldpbmRvd3MoKTtcblx0dGhpcy4kZWxlbWVudC5yZW1vdmUoKTtcbn07XG5cbi8qKlxuICogQSB3aW5kb3cgaXMgYSBjb250YWluZXIgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGluIGEgY2hpbGQgZnJhbWUuIFRoZXkgYXJlIHVzZWQgd2l0aFxuICogYSB3aW5kb3cgbWFuYWdlciAoT08udWkuV2luZG93TWFuYWdlciksIHdoaWNoIGlzIHVzZWQgdG8gb3BlbiBhbmQgY2xvc2UgdGhlIHdpbmRvdyBhbmQgY29udHJvbFxuICogaXRzIHByZXNlbnRhdGlvbi4gVGhlIHNpemUgb2YgYSB3aW5kb3cgaXMgc3BlY2lmaWVkIHVzaW5nIGEgc3ltYm9saWMgbmFtZSAoZS5nLiwg4oCYc21hbGzigJksIOKAmG1lZGl1beKAmSxcbiAqIOKAmGxhcmdl4oCZKSwgd2hpY2ggaXMgaW50ZXJwcmV0ZWQgYnkgdGhlIHdpbmRvdyBtYW5hZ2VyLiBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgbm90IHJlY29nbml6ZWQsXG4gKiB0aGUgd2luZG93IG1hbmFnZXIgd2lsbCBjaG9vc2UgYSBzZW5zaWJsZSBmYWxsYmFjay5cbiAqXG4gKiBUaGUgbGlmZWN5Y2xlIG9mIGEgd2luZG93IGhhcyB0aHJlZSBwcmltYXJ5IHN0YWdlcyAob3BlbmluZywgb3BlbmVkLCBhbmQgY2xvc2luZykgaW4gd2hpY2hcbiAqIGRpZmZlcmVudCBwcm9jZXNzZXMgYXJlIGV4ZWN1dGVkOlxuICpcbiAqICoqb3BlbmluZyoqOiBUaGUgb3BlbmluZyBzdGFnZSBiZWdpbnMgd2hlbiB0aGUgd2luZG93IG1hbmFnZXIncyB7QGxpbmsgT08udWkuV2luZG93TWFuYWdlciNvcGVuV2luZG93XG4gKiBvcGVuV2luZG93fSBvciB0aGUgd2luZG93J3Mge0BsaW5rICNvcGVuIG9wZW59IG1ldGhvZHMgYXJlIHVzZWQsIGFuZCB0aGUgd2luZG93IG1hbmFnZXIgYmVnaW5zIHRvIG9wZW5cbiAqIHRoZSB3aW5kb3cuXG4gKlxuICogLSB7QGxpbmsgI2dldFNldHVwUHJvY2Vzc30gbWV0aG9kIGlzIGNhbGxlZCBhbmQgaXRzIHJlc3VsdCBleGVjdXRlZFxuICogLSB7QGxpbmsgI2dldFJlYWR5UHJvY2Vzc30gbWV0aG9kIGlzIGNhbGxlZCBhbmQgaXRzIHJlc3VsdCBleGVjdXRlZFxuICpcbiAqICoqb3BlbmVkKio6IFRoZSB3aW5kb3cgaXMgbm93IG9wZW5cbiAqXG4gKiAqKmNsb3NpbmcqKjogVGhlIGNsb3Npbmcgc3RhZ2UgYmVnaW5zIHdoZW4gdGhlIHdpbmRvdyBtYW5hZ2VyJ3NcbiAqIHtAbGluayBPTy51aS5XaW5kb3dNYW5hZ2VyI2Nsb3NlV2luZG93IGNsb3NlV2luZG93fVxuICogb3IgdGhlIHdpbmRvdydzIHtAbGluayAjY2xvc2V9IG1ldGhvZHMgYXJlIHVzZWQsIGFuZCB0aGUgd2luZG93IG1hbmFnZXIgYmVnaW5zIHRvIGNsb3NlIHRoZSB3aW5kb3cuXG4gKlxuICogLSB7QGxpbmsgI2dldEhvbGRQcm9jZXNzfSBtZXRob2QgaXMgY2FsbGVkIGFuZCBpdHMgcmVzdWx0IGV4ZWN1dGVkXG4gKiAtIHtAbGluayAjZ2V0VGVhcmRvd25Qcm9jZXNzfSBtZXRob2QgaXMgY2FsbGVkIGFuZCBpdHMgcmVzdWx0IGV4ZWN1dGVkLiBUaGUgd2luZG93IGlzIG5vdyBjbG9zZWRcbiAqXG4gKiBFYWNoIG9mIHRoZSB3aW5kb3cncyBwcm9jZXNzZXMgKHNldHVwLCByZWFkeSwgaG9sZCwgYW5kIHRlYXJkb3duKSBjYW4gYmUgZXh0ZW5kZWQgaW4gc3ViY2xhc3Nlc1xuICogYnkgb3ZlcnJpZGluZyB0aGUgd2luZG93J3MgI2dldFNldHVwUHJvY2VzcywgI2dldFJlYWR5UHJvY2VzcywgI2dldEhvbGRQcm9jZXNzIGFuZCAjZ2V0VGVhcmRvd25Qcm9jZXNzXG4gKiBtZXRob2RzLiBOb3RlIHRoYXQgZWFjaCB7QGxpbmsgT08udWkuUHJvY2VzcyBwcm9jZXNzfSBpcyBleGVjdXRlZCBpbiBzZXJpZXMsIHNvIGFzeW5jaHJvbm91c1xuICogcHJvY2Vzc2luZyBjYW4gY29tcGxldGUuIEFsd2F5cyBhc3N1bWUgd2luZG93IHByb2Nlc3NlcyBhcmUgZXhlY3V0ZWQgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXSBbMV0uXG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzXG4gKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIE9PLnVpLkVsZW1lbnRcbiAqIEBtaXhpbnMgT08uRXZlbnRFbWl0dGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAY2ZnIHtzdHJpbmd9IFtzaXplXSBTeW1ib2xpYyBuYW1lIG9mIHRoZSBkaWFsb2cgc2l6ZTogYHNtYWxsYCwgYG1lZGl1bWAsIGBsYXJnZWAsIGBsYXJnZXJgIG9yXG4gKiAgYGZ1bGxgLiAgSWYgb21pdHRlZCwgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgI3N0YXRpYy1zaXplIHN0YXRpYyBzaXplfSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKi9cbk9PLnVpLldpbmRvdyA9IGZ1bmN0aW9uIE9vVWlXaW5kb3coIGNvbmZpZyApIHtcblx0Ly8gQ29uZmlndXJhdGlvbiBpbml0aWFsaXphdGlvblxuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLldpbmRvdy5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLkV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLm1hbmFnZXIgPSBudWxsO1xuXHR0aGlzLnNpemUgPSBjb25maWcuc2l6ZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpYy5zaXplO1xuXHR0aGlzLiRmcmFtZSA9ICQoICc8ZGl2PicgKTtcblx0LyoqXG5cdCAqIE92ZXJsYXkgZWxlbWVudCB0byB1c2UgZm9yIHRoZSBgJG92ZXJsYXlgIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG9mIHdpZGdldHMgdGhhdCBzdXBwb3J0IGl0LlxuXHQgKiBUaGluZ3MgcHV0IGluc2lkZSBvZiBpdCBhcmUgb3ZlcmxhaWQgb24gdG9wIG9mIHRoZSB3aW5kb3cgYW5kIGFyZSBub3QgYm91bmQgdG8gaXRzIGRpbWVuc2lvbnMuXG5cdCAqIFNlZSA8aHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvQ29uY2VwdHMjT3ZlcmxheXM+LlxuXHQgKlxuXHQgKiAgICAgTXlEaWFsb2cucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgIC4uLlxuXHQgKiAgICAgICB2YXIgcG9wdXBCdXR0b24gPSBuZXcgT08udWkuUG9wdXBCdXR0b25XaWRnZXQoIHtcblx0ICogICAgICAgICAkb3ZlcmxheTogdGhpcy4kb3ZlcmxheSxcblx0ICogICAgICAgICBsYWJlbDogJ1BvcHVwIGJ1dHRvbicsXG5cdCAqICAgICAgICAgcG9wdXA6IHtcblx0ICogICAgICAgICAgICRjb250ZW50OiAkKCAnPHA+UG9wdXAgY29udGVudHMuPC9wPjxwPlBvcHVwIGNvbnRlbnRzLjwvcD48cD5Qb3B1cCBjb250ZW50cy48L3A+JyApLFxuXHQgKiAgICAgICAgICAgcGFkZGVkOiB0cnVlXG5cdCAqICAgICAgICAgfVxuXHQgKiAgICAgICB9ICk7XG5cdCAqICAgICAgIC4uLlxuXHQgKiAgICAgfTtcblx0ICpcblx0ICogQHByb3BlcnR5IHtqUXVlcnl9XG5cdCAqL1xuXHR0aGlzLiRvdmVybGF5ID0gJCggJzxkaXY+JyApO1xuXHR0aGlzLiRjb250ZW50ID0gJCggJzxkaXY+JyApO1xuXG5cdHRoaXMuJGZvY3VzVHJhcEJlZm9yZSA9ICQoICc8ZGl2PicgKS5wcm9wKCAndGFiSW5kZXgnLCAwICk7XG5cdHRoaXMuJGZvY3VzVHJhcEFmdGVyID0gJCggJzxkaXY+JyApLnByb3AoICd0YWJJbmRleCcsIDAgKTtcblx0dGhpcy4kZm9jdXNUcmFwcyA9IHRoaXMuJGZvY3VzVHJhcEJlZm9yZS5hZGQoIHRoaXMuJGZvY3VzVHJhcEFmdGVyICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kb3ZlcmxheS5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1vdmVybGF5JyApO1xuXHR0aGlzLiRjb250ZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktd2luZG93LWNvbnRlbnQnIClcblx0XHQuYXR0ciggJ3RhYmluZGV4JywgMCApO1xuXHR0aGlzLiRmcmFtZVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1mcmFtZScgKVxuXHRcdC5hcHBlbmQoIHRoaXMuJGZvY3VzVHJhcEJlZm9yZSwgdGhpcy4kY29udGVudCwgdGhpcy4kZm9jdXNUcmFwQWZ0ZXIgKTtcblxuXHR0aGlzLiRlbGVtZW50XG5cdFx0LmFkZENsYXNzKCAnb28tdWktd2luZG93JyApXG5cdFx0LmFwcGVuZCggdGhpcy4kZnJhbWUsIHRoaXMuJG92ZXJsYXkgKTtcblxuXHQvLyBJbml0aWFsbHkgaGlkZGVuIC0gdXNpbmcgI3RvZ2dsZSBtYXkgY2F1c2UgZXJyb3JzIGlmIHN1YmNsYXNzZXMgb3ZlcnJpZGUgdG9nZ2xlIHdpdGggbWV0aG9kc1xuXHQvLyB0aGF0IHJlZmVyZW5jZSBwcm9wZXJ0aWVzIG5vdCBpbml0aWFsaXplZCBhdCB0aGF0IHRpbWUgb2YgcGFyZW50IGNsYXNzIGNvbnN0cnVjdGlvblxuXHQvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgcG9zdC1jb25zdHJ1Y3RvciBzZXR1cFxuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLWVsZW1lbnQtaGlkZGVuJyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5XaW5kb3csIE9PLnVpLkVsZW1lbnQgKTtcbk9PLm1peGluQ2xhc3MoIE9PLnVpLldpbmRvdywgT08uRXZlbnRFbWl0dGVyICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogU3ltYm9saWMgbmFtZSBvZiB0aGUgd2luZG93IHNpemU6IGBzbWFsbGAsIGBtZWRpdW1gLCBgbGFyZ2VgLCBgbGFyZ2VyYCBvciBgZnVsbGAuXG4gKlxuICogVGhlIHN0YXRpYyBzaXplIGlzIHVzZWQgaWYgbm8gI3NpemUgaXMgY29uZmlndXJlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKi9cbk9PLnVpLldpbmRvdy5zdGF0aWMuc2l6ZSA9ICdtZWRpdW0nO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGRvd24gZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZSBNb3VzZSBkb3duIGV2ZW50XG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3d9IFRoZSB3aW5kb3csIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKCBlICkge1xuXHQvLyBQcmV2ZW50IGNsaWNraW5nIG9uIHRoZSBjbGljay1ibG9jayBmcm9tIHN0ZWFsaW5nIGZvY3VzXG5cdGlmICggZS50YXJnZXQgPT09IHRoaXMuJGVsZW1lbnRbIDAgXSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHdpbmRvdyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqXG4gKiBJbml0aWFsaXphdGlvbiBvY2N1cnMgd2hlbiBhIHdpbmRvdyBpcyBhZGRlZCB0byBhIG1hbmFnZXIuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2luZG93IGhhcyBiZWVuIGluaXRpYWxpemVkXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuaXNJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICEhdGhpcy5tYW5hZ2VyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgd2luZG93IGlzIHZpc2libGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2luZG93IGlzIHZpc2libGVcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLnZpc2libGU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB3aW5kb3cgaXMgb3BlbmluZy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3aW5kb3cgbWFuYWdlcidzIHtAbGluayBPTy51aS5XaW5kb3dNYW5hZ2VyI2lzT3BlbmluZyBpc09wZW5pbmd9XG4gKiBtZXRob2QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2luZG93IGlzIG9wZW5pbmdcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5pc09wZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1hbmFnZXIuaXNPcGVuaW5nKCB0aGlzICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB3aW5kb3cgaXMgY2xvc2luZy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3aW5kb3cgbWFuYWdlcidzIHtAbGluayBPTy51aS5XaW5kb3dNYW5hZ2VyI2lzQ2xvc2luZyBpc0Nsb3Npbmd9IG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaW5kb3cgaXMgY2xvc2luZ1xuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmlzQ2xvc2luZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubWFuYWdlci5pc0Nsb3NpbmcoIHRoaXMgKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHdpbmRvdyBpcyBvcGVuZWQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd2luZG93IG1hbmFnZXIncyB7QGxpbmsgT08udWkuV2luZG93TWFuYWdlciNpc09wZW5lZCBpc09wZW5lZH0gbWV0aG9kLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdpbmRvdyBpcyBvcGVuZWRcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubWFuYWdlci5pc09wZW5lZCggdGhpcyApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBtYW5hZ2VyLlxuICpcbiAqIEFsbCB3aW5kb3dzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSB3aW5kb3cgbWFuYWdlciwgd2hpY2ggaXMgdXNlZCB0byBvcGVuXG4gKiBhbmQgY2xvc2UgdGhlIHdpbmRvdyBhbmQgY29udHJvbCBpdHMgcHJlc2VudGF0aW9uLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLldpbmRvd01hbmFnZXJ9IE1hbmFnZXIgb2Ygd2luZG93XG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuZ2V0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMubWFuYWdlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpYyBuYW1lIG9mIHRoZSB3aW5kb3cgc2l6ZSAoZS5nLiwgYHNtYWxsYCBvciBgbWVkaXVtYCkuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBTeW1ib2xpYyBuYW1lIG9mIHRoZSBzaXplOiBgc21hbGxgLCBgbWVkaXVtYCwgYGxhcmdlYCwgYGxhcmdlcmAsIGBmdWxsYFxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB2aWV3cG9ydCA9IE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldERpbWVuc2lvbnMoIHRoaXMuZ2V0RWxlbWVudFdpbmRvdygpICksXG5cdFx0c2l6ZXMgPSB0aGlzLm1hbmFnZXIuY29uc3RydWN0b3Iuc3RhdGljLnNpemVzLFxuXHRcdHNpemUgPSB0aGlzLnNpemU7XG5cblx0aWYgKCAhc2l6ZXNbIHNpemUgXSApIHtcblx0XHRzaXplID0gdGhpcy5tYW5hZ2VyLmNvbnN0cnVjdG9yLnN0YXRpYy5kZWZhdWx0U2l6ZTtcblx0fVxuXHRpZiAoIHNpemUgIT09ICdmdWxsJyAmJiB2aWV3cG9ydC5yZWN0LnJpZ2h0IC0gdmlld3BvcnQucmVjdC5sZWZ0IDwgc2l6ZXNbIHNpemUgXS53aWR0aCApIHtcblx0XHRzaXplID0gJ2Z1bGwnO1xuXHR9XG5cblx0cmV0dXJuIHNpemU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCB3aW5kb3cgc2l6ZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gU2l6ZSBwcm9wZXJ0aWVzXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuZ2V0U2l6ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLm1hbmFnZXIuY29uc3RydWN0b3Iuc3RhdGljLnNpemVzWyB0aGlzLmdldFNpemUoKSBdO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRyYW5zaXRpb25zIG9uIHdpbmRvdydzIGZyYW1lIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGVuIGVuYWJsZSB0aGVtXG4gKiBiYWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIHdoaWxlIHRyYW5zaXRpb25zIGFyZSBkaXNhYmxlZFxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLndpdGhvdXRTaXplVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXHQvLyBUZW1wb3JhcmlseSByZXNpemUgdGhlIGZyYW1lIHNvIGdldEJvZHlIZWlnaHQoKSBjYW4gdXNlIHNjcm9sbEhlaWdodCBtZWFzdXJlbWVudHMuXG5cdC8vIERpc2FibGUgdHJhbnNpdGlvbnMgZmlyc3QsIG90aGVyd2lzZSB3ZSdsbCBnZXQgdmFsdWVzIGZyb20gd2hlbiB0aGUgd2luZG93IHdhcyBhbmltYXRpbmcuXG5cdC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhlIHRyYW5zaXRpb24gQ1NTIHByb3BlcnRpZXMgdXNpbmcgdGhlc2Ugc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZVxuXHQvLyBGaXJlZm94IGRvZXNuJ3QgcmV0dXJuIGFueXRoaW5nIHVzZWZ1bCB3aGVuIGFza2VkIGp1c3QgZm9yICd0cmFuc2l0aW9uJy5cblx0dmFyIG9sZFRyYW5zaXRpb24gPSB0aGlzLiRmcmFtZS5jc3MoICd0cmFuc2l0aW9uLXByb3BlcnR5JyApICsgJyAnICtcblx0XHR0aGlzLiRmcmFtZS5jc3MoICd0cmFuc2l0aW9uLWR1cmF0aW9uJyApICsgJyAnICtcblx0XHR0aGlzLiRmcmFtZS5jc3MoICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicgKSArICcgJyArXG5cdFx0dGhpcy4kZnJhbWUuY3NzKCAndHJhbnNpdGlvbi1kZWxheScgKTtcblxuXHR0aGlzLiRmcmFtZS5jc3MoICd0cmFuc2l0aW9uJywgJ25vbmUnICk7XG5cdGNhbGxiYWNrKCk7XG5cblx0Ly8gRm9yY2UgcmVmbG93IHRvIG1ha2Ugc3VyZSB0aGUgc3R5bGUgY2hhbmdlcyBkb25lIGluc2lkZSBjYWxsYmFja1xuXHQvLyByZWFsbHkgYXJlIG5vdCB0cmFuc2l0aW9uZWRcblx0dGhpcy4kZnJhbWUuaGVpZ2h0KCk7XG5cdHRoaXMuJGZyYW1lLmNzcyggJ3RyYW5zaXRpb24nLCBvbGRUcmFuc2l0aW9uICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBmdWxsIHdpbmRvdyBjb250ZW50cyAoaS5lLiwgdGhlIHdpbmRvdyBoZWFkLCBib2R5IGFuZCBmb290IHRvZ2V0aGVyKS5cbiAqXG4gKiBXaGF0IGNvbnN0aXR1dGVzIHRoZSBoZWFkLCBib2R5LCBhbmQgZm9vdCB2YXJpZXMgZGVwZW5kaW5nIG9uIHRoZSB3aW5kb3cgdHlwZS5cbiAqIEEge0BsaW5rIE9PLnVpLk1lc3NhZ2VEaWFsb2cgbWVzc2FnZSBkaWFsb2d9IGRpc3BsYXlzIGEgdGl0bGUgYW5kIG1lc3NhZ2UgaW4gaXRzIGJvZHksXG4gKiBhbmQgYW55IGFjdGlvbnMgaW4gdGhlIGZvb3QuIEEge0BsaW5rIE9PLnVpLlByb2Nlc3NEaWFsb2cgcHJvY2VzcyBkaWFsb2d9IGRpc3BsYXlzIGEgdGl0bGVcbiAqIGFuZCBzcGVjaWFsIGFjdGlvbnMgaW4gdGhlIGhlYWQsIGFuZCBkaWFsb2cgY29udGVudCBpbiB0aGUgYm9keS5cbiAqXG4gKiBUbyBnZXQganVzdCB0aGUgaGVpZ2h0IG9mIHRoZSBkaWFsb2cgYm9keSwgdXNlIHRoZSAjZ2V0Qm9keUhlaWdodCBtZXRob2QuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3cgY29udGVudHMgKHRoZSBkaWFsb2cgaGVhZCwgYm9keSBhbmQgZm9vdCkgaW4gcGl4ZWxzXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuZ2V0Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGJvZHlIZWlnaHQsXG5cdFx0d2luID0gdGhpcyxcblx0XHRib2R5U3R5bGVPYmogPSB0aGlzLiRib2R5WyAwIF0uc3R5bGUsXG5cdFx0ZnJhbWVTdHlsZU9iaiA9IHRoaXMuJGZyYW1lWyAwIF0uc3R5bGU7XG5cblx0Ly8gVGVtcG9yYXJpbHkgcmVzaXplIHRoZSBmcmFtZSBzbyBnZXRCb2R5SGVpZ2h0KCkgY2FuIHVzZSBzY3JvbGxIZWlnaHQgbWVhc3VyZW1lbnRzLlxuXHQvLyBEaXNhYmxlIHRyYW5zaXRpb25zIGZpcnN0LCBvdGhlcndpc2Ugd2UnbGwgZ2V0IHZhbHVlcyBmcm9tIHdoZW4gdGhlIHdpbmRvdyB3YXMgYW5pbWF0aW5nLlxuXHR0aGlzLndpdGhvdXRTaXplVHJhbnNpdGlvbnMoIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgb2xkSGVpZ2h0ID0gZnJhbWVTdHlsZU9iai5oZWlnaHQsXG5cdFx0XHRvbGRQb3NpdGlvbiA9IGJvZHlTdHlsZU9iai5wb3NpdGlvbjtcblx0XHRmcmFtZVN0eWxlT2JqLmhlaWdodCA9ICcxcHgnO1xuXHRcdC8vIEZvcmNlIGJvZHkgdG8gcmVzaXplIHRvIG5ldyB3aWR0aFxuXHRcdGJvZHlTdHlsZU9iai5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0Ym9keUhlaWdodCA9IHdpbi5nZXRCb2R5SGVpZ2h0KCk7XG5cdFx0ZnJhbWVTdHlsZU9iai5oZWlnaHQgPSBvbGRIZWlnaHQ7XG5cdFx0Ym9keVN0eWxlT2JqLnBvc2l0aW9uID0gb2xkUG9zaXRpb247XG5cdH0gKTtcblxuXHRyZXR1cm4gKFxuXHRcdC8vIEFkZCBidWZmZXIgZm9yIGJvcmRlclxuXHRcdCggdGhpcy4kZnJhbWUub3V0ZXJIZWlnaHQoKSAtIHRoaXMuJGZyYW1lLmlubmVySGVpZ2h0KCkgKSArXG5cdFx0Ly8gVXNlIGNvbWJpbmVkIGhlaWdodHMgb2YgY2hpbGRyZW5cblx0XHQoIHRoaXMuJGhlYWQub3V0ZXJIZWlnaHQoIHRydWUgKSArIGJvZHlIZWlnaHQgKyB0aGlzLiRmb290Lm91dGVySGVpZ2h0KCB0cnVlICkgKVxuXHQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgd2luZG93IGJvZHkuXG4gKlxuICogVG8gZ2V0IHRoZSBoZWlnaHQgb2YgdGhlIGZ1bGwgd2luZG93IGNvbnRlbnRzICh0aGUgd2luZG93IGJvZHksIGhlYWQsIGFuZCBmb290IHRvZ2V0aGVyKSxcbiAqIHVzZSAjZ2V0Q29udGVudEhlaWdodC5cbiAqXG4gKiBXaGVuIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgd2luZG93IHdpbGwgdGVtcG9yYXJpbHkgaGF2ZSBiZWVuIHJlc2l6ZWRcbiAqIHRvIGhlaWdodD0xcHgsIHNvIC5zY3JvbGxIZWlnaHQgbWVhc3VyZW1lbnRzIGNhbiBiZSB0YWtlbiBhY2N1cmF0ZWx5LlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IG9mIHRoZSB3aW5kb3cgYm9keSBpbiBwaXhlbHNcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5nZXRCb2R5SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy4kYm9keVsgMCBdLnNjcm9sbEhlaWdodDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkaXJlY3Rpb25hbGl0eSBvZiB0aGUgZnJhbWUgKHJpZ2h0LXRvLWxlZnQgb3IgbGVmdC10by1yaWdodCkuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBEaXJlY3Rpb25hbGl0eTogYCdsdHInYCBvciBgJ3J0bCdgXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuZ2V0RGlyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gT08udWkuRWxlbWVudC5zdGF0aWMuZ2V0RGlyKCB0aGlzLiRjb250ZW50ICkgfHwgJ2x0cic7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgJ3NldHVwJyBwcm9jZXNzLlxuICpcbiAqIFRoZSBzZXR1cCBwcm9jZXNzIGlzIHVzZWQgdG8gc2V0IHVwIGEgd2luZG93IGZvciB1c2UgaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHQsIGJhc2VkIG9uIHRoZSBgZGF0YWBcbiAqIGFyZ3VtZW50LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHRoZSBvcGVuaW5nIHBoYXNlIG9mIHRoZSB3aW5kb3figJlzIGxpZmVjeWNsZSAoYmVmb3JlIHRoZVxuICogb3BlbmluZyBhbmltYXRpb24pLiBZb3UgY2FuIGFkZCBlbGVtZW50cyB0byB0aGUgd2luZG93IGluIHRoaXMgcHJvY2VzcyBvciBzZXQgdGhlaXIgZGVmYXVsdFxuICogdmFsdWVzLlxuICpcbiAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBhZGRpdGlvbmFsIHN0ZXBzIHRvIHRoZSDigJhzZXR1cOKAmSBwcm9jZXNzIHRoZSBwYXJlbnQgbWV0aG9kIHByb3ZpZGVzXG4gKiB1c2luZyB0aGUge0BsaW5rIE9PLnVpLlByb2Nlc3MjZmlyc3QgZmlyc3R9IGFuZCB7QGxpbmsgT08udWkuUHJvY2VzcyNuZXh0IG5leHR9IG1ldGhvZHNcbiAqIG9mIE9PLnVpLlByb2Nlc3MuXG4gKlxuICogVG8gYWRkIHdpbmRvdyBjb250ZW50IHRoYXQgcGVyc2lzdHMgYmV0d2VlbiBvcGVuaW5ncywgeW91IG1heSB3aXNoIHRvIHVzZSB0aGUgI2luaXRpYWxpemUgbWV0aG9kXG4gKiBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IG9wZW5pbmcgZGF0YVxuICogQHJldHVybiB7T08udWkuUHJvY2Vzc30gU2V0dXAgcHJvY2Vzc1xuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmdldFNldHVwUHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBPTy51aS5Qcm9jZXNzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUg4oCYcmVhZHnigJkgcHJvY2Vzcy5cbiAqXG4gKiBUaGUgcmVhZHkgcHJvY2VzcyBpcyB1c2VkIHRvIHJlYWR5IGEgd2luZG93IGZvciB1c2UgaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHQsIGJhc2VkIG9uIHRoZSBgZGF0YWBcbiAqIGFyZ3VtZW50LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHRoZSBvcGVuaW5nIHBoYXNlIG9mIHRoZSB3aW5kb3figJlzIGxpZmVjeWNsZSwgYWZ0ZXIgdGhlXG4gKiB3aW5kb3cgaGFzIGJlZW4ge0BsaW5rICNnZXRTZXR1cFByb2Nlc3Mgc2V0dXB9IChhZnRlciB0aGUgb3BlbmluZyBhbmltYXRpb24pLiBZb3UgY2FuIGZvY3VzXG4gKiBlbGVtZW50cyBpbiB0aGUgd2luZG93IGluIHRoaXMgcHJvY2Vzcywgb3Igb3BlbiB0aGVpciBkcm9wZG93bnMuXG4gKlxuICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIGFkZGl0aW9uYWwgc3RlcHMgdG8gdGhlIOKAmHJlYWR54oCZIHByb2Nlc3MgdGhlIHBhcmVudCBtZXRob2RcbiAqIHByb3ZpZGVzIHVzaW5nIHRoZSB7QGxpbmsgT08udWkuUHJvY2VzcyNmaXJzdCBmaXJzdH0gYW5kIHtAbGluayBPTy51aS5Qcm9jZXNzI25leHQgbmV4dH1cbiAqIG1ldGhvZHMgb2YgT08udWkuUHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIFdpbmRvdyBvcGVuaW5nIGRhdGFcbiAqIEByZXR1cm4ge09PLnVpLlByb2Nlc3N9IFJlYWR5IHByb2Nlc3NcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5nZXRSZWFkeVByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgT08udWkuUHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlICdob2xkJyBwcm9jZXNzLlxuICpcbiAqIFRoZSBob2xkIHByb2Nlc3MgaXMgdXNlZCB0byBrZWVwIGEgd2luZG93IGZyb20gYmVpbmcgdXNlZCBpbiBhIHBhcnRpY3VsYXIgY29udGV4dCwgYmFzZWQgb24gdGhlXG4gKiBgZGF0YWAgYXJndW1lbnQuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBkdXJpbmcgdGhlIGNsb3NpbmcgcGhhc2Ugb2YgdGhlIHdpbmRvd+KAmXMgbGlmZWN5Y2xlIChiZWZvcmVcbiAqIHRoZSBjbG9zaW5nIGFuaW1hdGlvbikuIFlvdSBjYW4gY2xvc2UgZHJvcGRvd25zIG9mIGVsZW1lbnRzIGluIHRoZSB3aW5kb3cgaW4gdGhpcyBwcm9jZXNzLCBpZlxuICogdGhleSBkbyBub3QgZ2V0IGNsb3NlZCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBhZGRpdGlvbmFsIHN0ZXBzIHRvIHRoZSAnaG9sZCcgcHJvY2VzcyB0aGUgcGFyZW50IG1ldGhvZCBwcm92aWRlc1xuICogdXNpbmcgdGhlIHtAbGluayBPTy51aS5Qcm9jZXNzI2ZpcnN0IGZpcnN0fSBhbmQge0BsaW5rIE9PLnVpLlByb2Nlc3MjbmV4dCBuZXh0fSBtZXRob2RzXG4gKiBvZiBPTy51aS5Qcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IGNsb3NpbmcgZGF0YVxuICogQHJldHVybiB7T08udWkuUHJvY2Vzc30gSG9sZCBwcm9jZXNzXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuZ2V0SG9sZFByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgT08udWkuUHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIOKAmHRlYXJkb3du4oCZIHByb2Nlc3MuXG4gKlxuICogVGhlIHRlYXJkb3duIHByb2Nlc3MgaXMgdXNlZCB0byB0ZWFyZG93biBhIHdpbmRvdyBhZnRlciB1c2UuIER1cmluZyB0ZWFyZG93biwgdXNlciBpbnRlcmFjdGlvbnNcbiAqIHdpdGhpbiB0aGUgd2luZG93IGFyZSBjb252ZXllZCBhbmQgdGhlIHdpbmRvdyBpcyBjbG9zZWQsIGJhc2VkIG9uIHRoZSBgZGF0YWAgYXJndW1lbnQuIFRoaXNcbiAqIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHRoZSBjbG9zaW5nIHBoYXNlIG9mIHRoZSB3aW5kb3figJlzIGxpZmVjeWNsZSAoYWZ0ZXIgdGhlIGNsb3NpbmdcbiAqIGFuaW1hdGlvbikuIFlvdSBjYW4gcmVtb3ZlIGVsZW1lbnRzIGluIHRoZSB3aW5kb3cgaW4gdGhpcyBwcm9jZXNzIG9yIGNsZWFyIHRoZWlyIHZhbHVlcy5cbiAqXG4gKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgYWRkaXRpb25hbCBzdGVwcyB0byB0aGUg4oCYdGVhcmRvd27igJkgcHJvY2VzcyB0aGUgcGFyZW50IG1ldGhvZCBwcm92aWRlc1xuICogdXNpbmcgdGhlIHtAbGluayBPTy51aS5Qcm9jZXNzI2ZpcnN0IGZpcnN0fSBhbmQge0BsaW5rIE9PLnVpLlByb2Nlc3MjbmV4dCBuZXh0fSBtZXRob2RzXG4gKiBvZiBPTy51aS5Qcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IGNsb3NpbmcgZGF0YVxuICogQHJldHVybiB7T08udWkuUHJvY2Vzc30gVGVhcmRvd24gcHJvY2Vzc1xuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmdldFRlYXJkb3duUHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBPTy51aS5Qcm9jZXNzKCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgd2luZG93IG1hbmFnZXIuXG4gKlxuICogVGhpcyB3aWxsIGNhdXNlIHRoZSB3aW5kb3cgdG8gaW5pdGlhbGl6ZS4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSB3aWxsIGNhdXNlIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7T08udWkuV2luZG93TWFuYWdlcn0gbWFuYWdlciBNYW5hZ2VyIGZvciB0aGlzIHdpbmRvd1xuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2luZG93fSBUaGUgd2luZG93LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5zZXRNYW5hZ2VyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXHRpZiAoIHRoaXMubWFuYWdlciApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3Qgc2V0IHdpbmRvdyBtYW5hZ2VyLCB3aW5kb3cgYWxyZWFkeSBoYXMgYSBtYW5hZ2VyJyApO1xuXHR9XG5cblx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblx0dGhpcy5pbml0aWFsaXplKCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgd2luZG93IHNpemUgYnkgc3ltYm9saWMgbmFtZSAoZS5nLiwgJ3NtYWxsJyBvciAnbWVkaXVtJylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2l6ZSBTeW1ib2xpYyBuYW1lIG9mIHNpemU6IGBzbWFsbGAsIGBtZWRpdW1gLCBgbGFyZ2VgLCBgbGFyZ2VyYCBvclxuICogIGBmdWxsYFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2luZG93fSBUaGUgd2luZG93LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCBzaXplICkge1xuXHR0aGlzLnNpemUgPSBzaXplO1xuXHR0aGlzLnVwZGF0ZVNpemUoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgd2luZG93IHNpemUuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgd2luZG93IGlzIG5vdCBhdHRhY2hlZCB0byBhIHdpbmRvdyBtYW5hZ2VyXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3d9IFRoZSB3aW5kb3csIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICggIXRoaXMubWFuYWdlciApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgdXBkYXRlIHdpbmRvdyBzaXplLCBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgbWFuYWdlcicgKTtcblx0fVxuXG5cdHRoaXMubWFuYWdlci51cGRhdGVXaW5kb3dTaXplKCB0aGlzICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB3aW5kb3cgZGltZW5zaW9ucy4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSB7QGxpbmsgT08udWkuV2luZG93TWFuYWdlciB3aW5kb3cgbWFuYWdlcn1cbiAqIHdoZW4gdGhlIHdpbmRvdyBpcyBvcGVuaW5nLiBJbiBnZW5lcmFsLCBzZXREaW1lbnNpb25zIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuICpcbiAqIFRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgd2luZG93LCB1c2UgdGhlICNzZXRTaXplIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGltIENTUyBkaW1lbnNpb24gcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGltLndpZHRoXSBXaWR0aFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGltLm1pbldpZHRoXSBNaW5pbXVtIHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkaW0ubWF4V2lkdGhdIE1heGltdW0gd2lkdGhcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2RpbS5oZWlnaHRdIEhlaWdodCwgb21pdCB0byBzZXQgYmFzZWQgb24gaGVpZ2h0IG9mIGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkaW0ubWluSGVpZ2h0XSBNaW5pbXVtIGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGltLm1heEhlaWdodF0gTWF4aW11bSBoZWlnaHRcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLldpbmRvd30gVGhlIHdpbmRvdywgZm9yIGNoYWluaW5nXG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICggZGltICkge1xuXHR2YXIgaGVpZ2h0LFxuXHRcdHdpbiA9IHRoaXMsXG5cdFx0c3R5bGVPYmogPSB0aGlzLiRmcmFtZVsgMCBdLnN0eWxlO1xuXG5cdC8vIENhbGN1bGF0ZSB0aGUgaGVpZ2h0IHdlIG5lZWQgdG8gc2V0IHVzaW5nIHRoZSBjb3JyZWN0IHdpZHRoXG5cdGlmICggZGltLmhlaWdodCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXMud2l0aG91dFNpemVUcmFuc2l0aW9ucyggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9sZFdpZHRoID0gc3R5bGVPYmoud2lkdGg7XG5cdFx0XHR3aW4uJGZyYW1lLmNzcyggJ3dpZHRoJywgZGltLndpZHRoIHx8ICcnICk7XG5cdFx0XHRoZWlnaHQgPSB3aW4uZ2V0Q29udGVudEhlaWdodCgpO1xuXHRcdFx0c3R5bGVPYmoud2lkdGggPSBvbGRXaWR0aDtcblx0XHR9ICk7XG5cdH0gZWxzZSB7XG5cdFx0aGVpZ2h0ID0gZGltLmhlaWdodDtcblx0fVxuXG5cdHRoaXMuJGZyYW1lLmNzcygge1xuXHRcdHdpZHRoOiBkaW0ud2lkdGggfHwgJycsXG5cdFx0bWluV2lkdGg6IGRpbS5taW5XaWR0aCB8fCAnJyxcblx0XHRtYXhXaWR0aDogZGltLm1heFdpZHRoIHx8ICcnLFxuXHRcdGhlaWdodDogaGVpZ2h0IHx8ICcnLFxuXHRcdG1pbkhlaWdodDogZGltLm1pbkhlaWdodCB8fCAnJyxcblx0XHRtYXhIZWlnaHQ6IGRpbS5tYXhIZWlnaHQgfHwgJydcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHdpbmRvdyBjb250ZW50cy5cbiAqXG4gKiBCZWZvcmUgdGhlIHdpbmRvdyBpcyBvcGVuZWQgZm9yIHRoZSBmaXJzdCB0aW1lLCAjaW5pdGlhbGl6ZSBpcyBjYWxsZWQgc28gdGhhdCBjb250ZW50IHRoYXRcbiAqIHBlcnNpc3RzIGJldHdlZW4gb3BlbmluZ3MgY2FuIGJlIGFkZGVkIHRvIHRoZSB3aW5kb3cuXG4gKlxuICogVG8gc2V0IHVwIGEgd2luZG93IHdpdGggbmV3IGNvbnRlbnQgZWFjaCB0aW1lIHRoZSB3aW5kb3cgb3BlbnMsIHVzZSAjZ2V0U2V0dXBQcm9jZXNzLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHdpbmRvdyBpcyBub3QgYXR0YWNoZWQgdG8gYSB3aW5kb3cgbWFuYWdlclxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuV2luZG93fSBUaGUgd2luZG93LCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoICF0aGlzLm1hbmFnZXIgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGluaXRpYWxpemUgd2luZG93LCBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgbWFuYWdlcicgKTtcblx0fVxuXG5cdC8vIFByb3BlcnRpZXNcblx0dGhpcy4kaGVhZCA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy4kYm9keSA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy4kZm9vdCA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy4kZG9jdW1lbnQgPSAkKCB0aGlzLmdldEVsZW1lbnREb2N1bWVudCgpICk7XG5cblx0Ly8gRXZlbnRzXG5cdHRoaXMuJGVsZW1lbnQub24oICdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQoIHRoaXMgKSApO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGhlYWQuYWRkQ2xhc3MoICdvby11aS13aW5kb3ctaGVhZCcgKTtcblx0dGhpcy4kYm9keS5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1ib2R5JyApO1xuXHR0aGlzLiRmb290LmFkZENsYXNzKCAnb28tdWktd2luZG93LWZvb3QnICk7XG5cdHRoaXMuJGNvbnRlbnQuYXBwZW5kKCB0aGlzLiRoZWFkLCB0aGlzLiRib2R5LCB0aGlzLiRmb290ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHNvbWVvbmUgdHJpZXMgdG8gZm9jdXMgdGhlIGhpZGRlbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRpYWxvZy5cbiAqIFNlbmRzIGZvY3VzIGJhY2sgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkaWFsb2cuXG4gKlxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGV2ZW50IEZvY3VzIGV2ZW50XG4gKi9cbk9PLnVpLldpbmRvdy5wcm90b3R5cGUub25Gb2N1c1RyYXBGb2N1c2VkID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0dmFyIGJhY2t3YXJkcyA9IHRoaXMuJGZvY3VzVHJhcEJlZm9yZS5pcyggZXZlbnQudGFyZ2V0ICksXG5cdFx0ZWxlbWVudCA9IE9PLnVpLmZpbmRGb2N1c2FibGUoIHRoaXMuJGNvbnRlbnQsIGJhY2t3YXJkcyApO1xuXHRpZiAoIGVsZW1lbnQgKSB7XG5cdFx0Ly8gVGhlcmUncyBhIGZvY3VzYWJsZSBlbGVtZW50IGluc2lkZSB0aGUgY29udGVudCwgYXQgdGhlIGZyb250IG9yXG5cdFx0Ly8gYmFjayBkZXBlbmRpbmcgb24gd2hpY2ggZm9jdXMgdHJhcCB3ZSBoaXQ7IHNlbGVjdCBpdC5cblx0XHRlbGVtZW50LmZvY3VzKCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVGhlcmUncyBub3RoaW5nIGZvY3VzYWJsZSBpbnNpZGUgdGhlIGNvbnRlbnQuIEFzIGEgZmFsbGJhY2ssXG5cdFx0Ly8gdGhpcy4kY29udGVudCBpcyBmb2N1c2FibGUsIGFuZCBmb2N1c2luZyBpdCB3aWxsIGtlZXAgb3VyIGZvY3VzXG5cdFx0Ly8gcHJvcGVybHkgdHJhcHBlZC4gSXQncyBub3QgYSAqbWVhbmluZ2Z1bCogZm9jdXMsIHNpbmNlIGl0J3MganVzdFxuXHRcdC8vIHRoZSBjb250ZW50LWRpdiBmb3IgdGhlIFdpbmRvdywgYnV0IGl0J3MgYmV0dGVyIHRoYW4gbGV0dGluZyBmb2N1c1xuXHRcdC8vIGVzY2FwZSBpbnRvIHRoZSBwYWdlLlxuXHRcdHRoaXMuJGNvbnRlbnQuZm9jdXMoKTtcblx0fVxufTtcblxuLyoqXG4gKiBPcGVuIHRoZSB3aW5kb3cuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIGNhbGwgdG8gdGhlIHdpbmRvd1xuICogbWFuYWdlcuKAmXMge0BsaW5rIE9PLnVpLldpbmRvd01hbmFnZXIjb3BlbldpbmRvdyBvcGVuV2luZG93fSBtZXRob2QuXG4gKlxuICogVG8gY3VzdG9taXplIHRoZSB3aW5kb3cgZWFjaCB0aW1lIGl0IG9wZW5zLCB1c2UgI2dldFNldHVwUHJvY2VzcyBvciAjZ2V0UmVhZHlQcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IG9wZW5pbmcgZGF0YVxuICogQHJldHVybiB7T08udWkuV2luZG93SW5zdGFuY2V9IFNlZSBPTy51aS5XaW5kb3dNYW5hZ2VyI29wZW5XaW5kb3dcbiAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHdpbmRvdyBpcyBub3QgYXR0YWNoZWQgdG8gYSB3aW5kb3cgbWFuYWdlclxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdGlmICggIXRoaXMubWFuYWdlciApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3Qgb3BlbiB3aW5kb3csIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBtYW5hZ2VyJyApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMubWFuYWdlci5vcGVuV2luZG93KCB0aGlzLCBkYXRhICk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSB3aW5kb3cuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIGNhbGwgdG8gdGhlIHdpbmRvd1xuICogbWFuYWdlcuKAmXMge0BsaW5rIE9PLnVpLldpbmRvd01hbmFnZXIjY2xvc2VXaW5kb3cgY2xvc2VXaW5kb3d9IG1ldGhvZC5cbiAqXG4gKiBUaGUgd2luZG93J3MgI2dldEhvbGRQcm9jZXNzIGFuZCAjZ2V0VGVhcmRvd25Qcm9jZXNzIG1ldGhvZHMgYXJlIGNhbGxlZCBkdXJpbmcgdGhlIGNsb3NpbmdcbiAqIHBoYXNlIG9mIHRoZSB3aW5kb3figJlzIGxpZmVjeWNsZSBhbmQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBjbG9zaW5nIGJlaGF2aW9yIGVhY2ggdGltZVxuICogdGhlIHdpbmRvdyBjbG9zZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBXaW5kb3cgY2xvc2luZyBkYXRhXG4gKiBAcmV0dXJuIHtPTy51aS5XaW5kb3dJbnN0YW5jZX0gU2VlIE9PLnVpLldpbmRvd01hbmFnZXIjY2xvc2VXaW5kb3dcbiAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHdpbmRvdyBpcyBub3QgYXR0YWNoZWQgdG8gYSB3aW5kb3cgbWFuYWdlclxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXHRpZiAoICF0aGlzLm1hbmFnZXIgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGNsb3NlIHdpbmRvdywgbXVzdCBiZSBhdHRhY2hlZCB0byBhIG1hbmFnZXInICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5tYW5hZ2VyLmNsb3NlV2luZG93KCB0aGlzLCBkYXRhICk7XG59O1xuXG4vKipcbiAqIFNldHVwIHdpbmRvdy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCBieSBPTy51aS5XaW5kb3dNYW5hZ2VyIGR1cmluZyB3aW5kb3cgb3BlbmluZyAoYmVmb3JlIHRoZSBhbmltYXRpb24pLCBhbmQgc2hvdWxkXG4gKiBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IG90aGVyIHN5c3RlbXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBXaW5kb3cgb3BlbmluZyBkYXRhXG4gKiBAcmV0dXJuIHtqUXVlcnkuUHJvbWlzZX0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHdpbmRvdyBpcyBzZXR1cFxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXHR2YXIgd2luID0gdGhpcztcblxuXHR0aGlzLnRvZ2dsZSggdHJ1ZSApO1xuXG5cdHRoaXMuZm9jdXNUcmFwSGFuZGxlciA9IE9PLnVpLmJpbmQoIHRoaXMub25Gb2N1c1RyYXBGb2N1c2VkLCB0aGlzICk7XG5cdHRoaXMuJGZvY3VzVHJhcHMub24oICdmb2N1cycsIHRoaXMuZm9jdXNUcmFwSGFuZGxlciApO1xuXG5cdHJldHVybiB0aGlzLmdldFNldHVwUHJvY2VzcyggZGF0YSApLmV4ZWN1dGUoKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cdFx0d2luLnVwZGF0ZVNpemUoKTtcblx0XHQvLyBGb3JjZSByZWRyYXcgYnkgYXNraW5nIHRoZSBicm93c2VyIHRvIG1lYXN1cmUgdGhlIGVsZW1lbnRzJyB3aWR0aHNcblx0XHR3aW4uJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS13aW5kb3ctYWN0aXZlIG9vLXVpLXdpbmRvdy1zZXR1cCcgKS53aWR0aCgpO1xuXHRcdHdpbi4kY29udGVudC5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1jb250ZW50LXNldHVwJyApLndpZHRoKCk7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogUmVhZHkgd2luZG93LlxuICpcbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IE9PLnVpLldpbmRvd01hbmFnZXIgZHVyaW5nIHdpbmRvdyBvcGVuaW5nIChhZnRlciB0aGUgYW5pbWF0aW9uKSwgYW5kIHNob3VsZCBub3RcbiAqIGJlIGNhbGxlZCBkaXJlY3RseSBieSBvdGhlciBzeXN0ZW1zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IG9wZW5pbmcgZGF0YVxuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB3aW5kb3cgaXMgcmVhZHlcbiAqL1xuT08udWkuV2luZG93LnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIHdpbiA9IHRoaXM7XG5cblx0dGhpcy4kY29udGVudC5mb2N1cygpO1xuXHRyZXR1cm4gdGhpcy5nZXRSZWFkeVByb2Nlc3MoIGRhdGEgKS5leGVjdXRlKCkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdC8vIEZvcmNlIHJlZHJhdyBieSBhc2tpbmcgdGhlIGJyb3dzZXIgdG8gbWVhc3VyZSB0aGUgZWxlbWVudHMnIHdpZHRoc1xuXHRcdHdpbi4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1yZWFkeScgKS53aWR0aCgpO1xuXHRcdHdpbi4kY29udGVudC5hZGRDbGFzcyggJ29vLXVpLXdpbmRvdy1jb250ZW50LXJlYWR5JyApLndpZHRoKCk7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogSG9sZCB3aW5kb3cuXG4gKlxuICogVGhpcyBpcyBjYWxsZWQgYnkgT08udWkuV2luZG93TWFuYWdlciBkdXJpbmcgd2luZG93IGNsb3NpbmcgKGJlZm9yZSB0aGUgYW5pbWF0aW9uKSwgYW5kIHNob3VsZFxuICogbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSBvdGhlciBzeXN0ZW1zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gV2luZG93IGNsb3NpbmcgZGF0YVxuICogQHJldHVybiB7alF1ZXJ5LlByb21pc2V9IFByb21pc2UgcmVzb2x2ZWQgd2hlbiB3aW5kb3cgaXMgaGVsZFxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLmhvbGQgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdHZhciB3aW4gPSB0aGlzO1xuXG5cdHJldHVybiB0aGlzLmdldEhvbGRQcm9jZXNzKCBkYXRhICkuZXhlY3V0ZSgpLnRoZW4oIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBHZXQgdGhlIGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhlIHdpbmRvdydzIGNvbnRlbnRcblx0XHR2YXIgJGZvY3VzID0gd2luLiRjb250ZW50LmZpbmQoIE9PLnVpLkVsZW1lbnQuc3RhdGljLmdldERvY3VtZW50KCB3aW4uJGNvbnRlbnQgKS5hY3RpdmVFbGVtZW50ICk7XG5cblx0XHQvLyBCbHVyIHRoZSBmb2N1c2VkIGVsZW1lbnRcblx0XHRpZiAoICRmb2N1cy5sZW5ndGggKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganF1ZXJ5L25vLWV2ZW50LXNob3J0aGFuZFxuXHRcdFx0JGZvY3VzWyAwIF0uYmx1cigpO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIHJlZHJhdyBieSBhc2tpbmcgdGhlIGJyb3dzZXIgdG8gbWVhc3VyZSB0aGUgZWxlbWVudHMnIHdpZHRoc1xuXHRcdHdpbi4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLXdpbmRvdy1yZWFkeSBvby11aS13aW5kb3ctc2V0dXAnICkud2lkdGgoKTtcblx0XHR3aW4uJGNvbnRlbnQucmVtb3ZlQ2xhc3MoICdvby11aS13aW5kb3ctY29udGVudC1yZWFkeSBvby11aS13aW5kb3ctY29udGVudC1zZXR1cCcgKS53aWR0aCgpO1xuXHR9ICk7XG59O1xuXG4vKipcbiAqIFRlYXJkb3duIHdpbmRvdy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCBieSBPTy51aS5XaW5kb3dNYW5hZ2VyIGR1cmluZyB3aW5kb3cgY2xvc2luZyAoYWZ0ZXIgdGhlIGFuaW1hdGlvbiksIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseVxuICogYnkgb3RoZXIgc3lzdGVtcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIFdpbmRvdyBjbG9zaW5nIGRhdGFcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gd2luZG93IGlzIHRvcm4gZG93blxuICovXG5PTy51aS5XaW5kb3cucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXHR2YXIgd2luID0gdGhpcztcblxuXHRyZXR1cm4gdGhpcy5nZXRUZWFyZG93blByb2Nlc3MoIGRhdGEgKS5leGVjdXRlKCkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdC8vIEZvcmNlIHJlZHJhdyBieSBhc2tpbmcgdGhlIGJyb3dzZXIgdG8gbWVhc3VyZSB0aGUgZWxlbWVudHMnIHdpZHRoc1xuXHRcdHdpbi4kZWxlbWVudC5yZW1vdmVDbGFzcyggJ29vLXVpLXdpbmRvdy1hY3RpdmUnICkud2lkdGgoKTtcblxuXHRcdHdpbi4kZm9jdXNUcmFwcy5vZmYoICdmb2N1cycsIHdpbi5mb2N1c1RyYXBIYW5kbGVyICk7XG5cdFx0d2luLnRvZ2dsZSggZmFsc2UgKTtcblx0fSApO1xufTtcblxuLyoqXG4gKiBUaGUgRGlhbG9nIGNsYXNzIHNlcnZlcyBhcyB0aGUgYmFzZSBjbGFzcyBmb3IgdGhlIG90aGVyIHR5cGVzIG9mIGRpYWxvZ3MuXG4gKiBVbmxlc3MgZXh0ZW5kZWQgdG8gaW5jbHVkZSBjb250cm9scywgdGhlIHJlbmRlcmVkIGRpYWxvZyBib3ggaXMgYSBzaW1wbGUgd2luZG93XG4gKiB0aGF0IHVzZXJzIGNhbiBjbG9zZSBieSBoaXR0aW5nIHRoZSDigJhFc2PigJkga2V5LiBEaWFsb2cgd2luZG93cyBhcmUgdXNlZCB3aXRoIE9PLnVpLldpbmRvd01hbmFnZXIsXG4gKiB3aGljaCBvcGVucywgY2xvc2VzLCBhbmQgY29udHJvbHMgdGhlIHByZXNlbnRhdGlvbiBvZiB0aGUgd2luZG93LiBTZWUgdGhlXG4gKiBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV0gWzFdIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIC8vIEEgc2ltcGxlIGRpYWxvZyB3aW5kb3cuXG4gKiAgICAgZnVuY3Rpb24gTXlEaWFsb2coIGNvbmZpZyApIHtcbiAqICAgICAgICAgTXlEaWFsb2cucGFyZW50LmNhbGwoIHRoaXMsIGNvbmZpZyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIE15RGlhbG9nLCBPTy51aS5EaWFsb2cgKTtcbiAqICAgICBNeURpYWxvZy5zdGF0aWMubmFtZSA9ICdteURpYWxvZyc7XG4gKiAgICAgTXlEaWFsb2cucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIE15RGlhbG9nLnBhcmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKCB0aGlzICk7XG4gKiAgICAgICAgIHRoaXMuY29udGVudCA9IG5ldyBPTy51aS5QYW5lbExheW91dCggeyBwYWRkZWQ6IHRydWUsIGV4cGFuZGVkOiBmYWxzZSB9ICk7XG4gKiAgICAgICAgIHRoaXMuY29udGVudC4kZWxlbWVudC5hcHBlbmQoICc8cD5BIHNpbXBsZSBkaWFsb2cgd2luZG93LiBQcmVzcyBcXCdFc2NcXCcgdG8gY2xvc2UuPC9wPicgKTtcbiAqICAgICAgICAgdGhpcy4kYm9keS5hcHBlbmQoIHRoaXMuY29udGVudC4kZWxlbWVudCApO1xuICogICAgIH07XG4gKiAgICAgTXlEaWFsb2cucHJvdG90eXBlLmdldEJvZHlIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuJGVsZW1lbnQub3V0ZXJIZWlnaHQoIHRydWUgKTtcbiAqICAgICB9O1xuICogICAgIHZhciBteURpYWxvZyA9IG5ldyBNeURpYWxvZygge1xuICogICAgICAgICBzaXplOiAnbWVkaXVtJ1xuICogICAgIH0gKTtcbiAqICAgICAvLyBDcmVhdGUgYW5kIGFwcGVuZCBhIHdpbmRvdyBtYW5hZ2VyLCB3aGljaCBvcGVucyBhbmQgY2xvc2VzIHRoZSB3aW5kb3cuXG4gKiAgICAgdmFyIHdpbmRvd01hbmFnZXIgPSBuZXcgT08udWkuV2luZG93TWFuYWdlcigpO1xuICogICAgICQoIGRvY3VtZW50LmJvZHkgKS5hcHBlbmQoIHdpbmRvd01hbmFnZXIuJGVsZW1lbnQgKTtcbiAqICAgICB3aW5kb3dNYW5hZ2VyLmFkZFdpbmRvd3MoIFsgbXlEaWFsb2cgXSApO1xuICogICAgIC8vIE9wZW4gdGhlIHdpbmRvdyFcbiAqICAgICB3aW5kb3dNYW5hZ2VyLm9wZW5XaW5kb3coIG15RGlhbG9nICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzL0RpYWxvZ3NcbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgT08udWkuV2luZG93XG4gKiBAbWl4aW5zIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbk9PLnVpLkRpYWxvZyA9IGZ1bmN0aW9uIE9vVWlEaWFsb2coIGNvbmZpZyApIHtcblx0Ly8gUGFyZW50IGNvbnN0cnVjdG9yXG5cdE9PLnVpLkRpYWxvZy5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG5cblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50LmNhbGwoIHRoaXMgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuYWN0aW9ucyA9IG5ldyBPTy51aS5BY3Rpb25TZXQoKTtcblx0dGhpcy5hdHRhY2hlZEFjdGlvbnMgPSBbXTtcblx0dGhpcy5jdXJyZW50QWN0aW9uID0gbnVsbDtcblx0dGhpcy5vbkRpYWxvZ0tleURvd25IYW5kbGVyID0gdGhpcy5vbkRpYWxvZ0tleURvd24uYmluZCggdGhpcyApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmFjdGlvbnMuY29ubmVjdCggdGhpcywge1xuXHRcdGNsaWNrOiAnb25BY3Rpb25DbGljaycsXG5cdFx0Y2hhbmdlOiAnb25BY3Rpb25zQ2hhbmdlJ1xuXHR9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudFxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLWRpYWxvZycgKVxuXHRcdC5hdHRyKCAncm9sZScsICdkaWFsb2cnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLkRpYWxvZywgT08udWkuV2luZG93ICk7XG5PTy5taXhpbkNsYXNzKCBPTy51aS5EaWFsb2csIE9PLnVpLm1peGluLlBlbmRpbmdFbGVtZW50ICk7XG5cbi8qIFN0YXRpYyBQcm9wZXJ0aWVzICovXG5cbi8qKlxuICogU3ltYm9saWMgbmFtZSBvZiBkaWFsb2cuXG4gKlxuICogVGhlIGRpYWxvZyBjbGFzcyBtdXN0IGhhdmUgYSBzeW1ib2xpYyBuYW1lIGluIG9yZGVyIHRvIGJlIHJlZ2lzdGVyZWQgd2l0aCBPTy5GYWN0b3J5LlxuICogUGxlYXNlIHNlZSB0aGUgW09PVUkgZG9jdW1lbnRhdGlvbiBvbiBNZWRpYVdpa2ldIFszXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBbM106IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpbmRvd3MvV2luZG93X21hbmFnZXJzXG4gKlxuICogQGFic3RyYWN0XG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfVxuICovXG5PTy51aS5EaWFsb2cuc3RhdGljLm5hbWUgPSAnJztcblxuLyoqXG4gKiBUaGUgZGlhbG9nIHRpdGxlLlxuICpcbiAqIFRoZSB0aXRsZSBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgcGxhaW50ZXh0IHN0cmluZywgYSB7QGxpbmsgT08udWkubWl4aW4uTGFiZWxFbGVtZW50IExhYmVsfSBub2RlLCBvciBhIGZ1bmN0aW9uXG4gKiB0aGF0IHdpbGwgcHJvZHVjZSBhIExhYmVsIG5vZGUgb3Igc3RyaW5nLiBUaGUgdGl0bGUgY2FuIGFsc28gYmUgc3BlY2lmaWVkIHdpdGggZGF0YSBwYXNzZWQgdG8gdGhlXG4gKiBjb25zdHJ1Y3RvciAoc2VlICNnZXRTZXR1cFByb2Nlc3MpLiBJbiB0aGlzIGNhc2UsIHRoZSBzdGF0aWMgdmFsdWUgd2lsbCBiZSBvdmVycmlkZGVuLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHN0YXRpY1xuICogQGluaGVyaXRhYmxlXG4gKiBAcHJvcGVydHkge2pRdWVyeXxzdHJpbmd8RnVuY3Rpb259XG4gKi9cbk9PLnVpLkRpYWxvZy5zdGF0aWMudGl0bGUgPSAnJztcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBjb25maWd1cmVkIHtAbGluayBPTy51aS5BY3Rpb25XaWRnZXQgYWN0aW9uIHdpZGdldHN9LlxuICpcbiAqIEFjdGlvbnMgY2FuIGFsc28gYmUgc3BlY2lmaWVkIHdpdGggZGF0YSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIChzZWUgI2dldFNldHVwUHJvY2VzcykuIEluIHRoaXMgY2FzZSwgdGhlIHN0YXRpY1xuICogdmFsdWUgd2lsbCBiZSBvdmVycmlkZGVuLlxuICpcbiAqIFsyXTogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PVUkvV2luZG93cy9Qcm9jZXNzX0RpYWxvZ3MjQWN0aW9uX3NldHNcbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119XG4gKi9cbk9PLnVpLkRpYWxvZy5zdGF0aWMuYWN0aW9ucyA9IFtdO1xuXG4vKipcbiAqIENsb3NlIHRoZSBkaWFsb2cgd2hlbiB0aGUgJ0VzYycga2V5IGlzIHByZXNzZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGFic3RyYWN0XG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAqL1xuT08udWkuRGlhbG9nLnN0YXRpYy5lc2NhcGFibGUgPSB0cnVlO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGZyYW1lIGRvY3VtZW50IGtleSBkb3duIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtqUXVlcnkuRXZlbnR9IGUgS2V5IGRvd24gZXZlbnRcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5vbkRpYWxvZ0tleURvd24gPSBmdW5jdGlvbiAoIGUgKSB7XG5cdHZhciBhY3Rpb25zO1xuXHRpZiAoIGUud2hpY2ggPT09IE9PLnVpLktleXMuRVNDQVBFICYmIHRoaXMuY29uc3RydWN0b3Iuc3RhdGljLmVzY2FwYWJsZSApIHtcblx0XHR0aGlzLmV4ZWN1dGVBY3Rpb24oICcnICk7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0gZWxzZSBpZiAoIGUud2hpY2ggPT09IE9PLnVpLktleXMuRU5URVIgJiYgKCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5ICkgKSB7XG5cdFx0YWN0aW9ucyA9IHRoaXMuYWN0aW9ucy5nZXQoIHsgZmxhZ3M6ICdwcmltYXJ5JywgdmlzaWJsZTogdHJ1ZSwgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0XHRpZiAoIGFjdGlvbnMubGVuZ3RoID4gMCApIHtcblx0XHRcdHRoaXMuZXhlY3V0ZUFjdGlvbiggYWN0aW9uc1sgMCBdLmdldEFjdGlvbigpICk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBIYW5kbGUgYWN0aW9uIGNsaWNrIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPTy51aS5BY3Rpb25XaWRnZXR9IGFjdGlvbiBBY3Rpb24gdGhhdCB3YXMgY2xpY2tlZFxuICovXG5PTy51aS5EaWFsb2cucHJvdG90eXBlLm9uQWN0aW9uQ2xpY2sgPSBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0aWYgKCAhdGhpcy5pc1BlbmRpbmcoKSApIHtcblx0XHR0aGlzLmV4ZWN1dGVBY3Rpb24oIGFjdGlvbi5nZXRBY3Rpb24oKSApO1xuXHR9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhY3Rpb25zIGNoYW5nZSBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5EaWFsb2cucHJvdG90eXBlLm9uQWN0aW9uc0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5kZXRhY2hBY3Rpb25zKCk7XG5cdGlmICggIXRoaXMuaXNDbG9zaW5nKCkgKSB7XG5cdFx0dGhpcy5hdHRhY2hBY3Rpb25zKCk7XG5cdFx0aWYgKCAhdGhpcy5pc09wZW5pbmcoKSApIHtcblx0XHRcdC8vIElmIHRoZSBkaWFsb2cgaXMgY3VycmVudGx5IG9wZW5pbmcsIHRoaXMgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBzb29uLlxuXHRcdFx0dGhpcy51cGRhdGVTaXplKCk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2V0IG9mIGFjdGlvbnMgdXNlZCBieSB0aGUgZGlhbG9nLlxuICpcbiAqIEByZXR1cm4ge09PLnVpLkFjdGlvblNldH1cbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5nZXRBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5hY3Rpb25zO1xufTtcblxuLyoqXG4gKiBHZXQgYSBwcm9jZXNzIGZvciB0YWtpbmcgYWN0aW9uLlxuICpcbiAqIFdoZW4geW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLCB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBPTy51aS5Qcm9jZXNzIGFuZCByZXR1cm4gaXQsIG9yIGFkZCBhZGRpdGlvbmFsXG4gKiBhY2NlcHQgc3RlcHMgdG8gdGhlIHByb2Nlc3MgdGhlIHBhcmVudCBtZXRob2QgcHJvdmlkZXMgdXNpbmcgdGhlIHtAbGluayBPTy51aS5Qcm9jZXNzI2ZpcnN0ICdmaXJzdCd9XG4gKiBhbmQge0BsaW5rIE9PLnVpLlByb2Nlc3MjbmV4dCAnbmV4dCd9IG1ldGhvZHMgb2YgT08udWkuUHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbl0gU3ltYm9saWMgbmFtZSBvZiBhY3Rpb25cbiAqIEByZXR1cm4ge09PLnVpLlByb2Nlc3N9IEFjdGlvbiBwcm9jZXNzXG4gKi9cbk9PLnVpLkRpYWxvZy5wcm90b3R5cGUuZ2V0QWN0aW9uUHJvY2VzcyA9IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRyZXR1cm4gbmV3IE9PLnVpLlByb2Nlc3MoKVxuXHRcdC5uZXh0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoICFhY3Rpb24gKSB7XG5cdFx0XHRcdC8vIEFuIGVtcHR5IGFjdGlvbiBhbHdheXMgY2xvc2VzIHRoZSBkaWFsb2cgd2l0aG91dCBkYXRhLCB3aGljaCBzaG91bGQgYWx3YXlzIGJlXG5cdFx0XHRcdC8vIHNhZmUgYW5kIG1ha2Ugbm8gY2hhbmdlc1xuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gRGlhbG9nIG9wZW5pbmcgZGF0YVxuICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9IFtkYXRhLnRpdGxlXSBEaWFsb2cgdGl0bGUsIG9taXQgdG8gdXNlXG4gKiAgdGhlIHtAbGluayAjc3RhdGljLXRpdGxlIHN0YXRpYyB0aXRsZX1cbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLmFjdGlvbnNdIExpc3Qgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBlYWNoXG4gKiAgIHtAbGluayBPTy51aS5BY3Rpb25XaWRnZXQgYWN0aW9uIHdpZGdldH0sIG9taXQgdG8gdXNlIHtAbGluayAjc3RhdGljLWFjdGlvbnMgc3RhdGljIGFjdGlvbnN9LlxuICovXG5PTy51aS5EaWFsb2cucHJvdG90eXBlLmdldFNldHVwUHJvY2VzcyA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0ZGF0YSA9IGRhdGEgfHwge307XG5cblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRyZXR1cm4gT08udWkuRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuZ2V0U2V0dXBQcm9jZXNzLmNhbGwoIHRoaXMsIGRhdGEgKVxuXHRcdC5uZXh0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY29uZmlnID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMsXG5cdFx0XHRcdGFjdGlvbnMgPSBkYXRhLmFjdGlvbnMgIT09IHVuZGVmaW5lZCA/IGRhdGEuYWN0aW9ucyA6IGNvbmZpZy5hY3Rpb25zLFxuXHRcdFx0XHR0aXRsZSA9IGRhdGEudGl0bGUgIT09IHVuZGVmaW5lZCA/IGRhdGEudGl0bGUgOiBjb25maWcudGl0bGU7XG5cblx0XHRcdHRoaXMudGl0bGUuc2V0TGFiZWwoIHRpdGxlICkuc2V0VGl0bGUoIHRpdGxlICk7XG5cdFx0XHR0aGlzLmFjdGlvbnMuYWRkKCB0aGlzLmdldEFjdGlvbldpZGdldHMoIGFjdGlvbnMgKSApO1xuXG5cdFx0XHR0aGlzLiRlbGVtZW50Lm9uKCAna2V5ZG93bicsIHRoaXMub25EaWFsb2dLZXlEb3duSGFuZGxlciApO1xuXHRcdH0sIHRoaXMgKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5nZXRUZWFyZG93blByb2Nlc3MgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0cmV0dXJuIE9PLnVpLkRpYWxvZy5wYXJlbnQucHJvdG90eXBlLmdldFRlYXJkb3duUHJvY2Vzcy5jYWxsKCB0aGlzLCBkYXRhIClcblx0XHQuZmlyc3QoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuJGVsZW1lbnQub2ZmKCAna2V5ZG93bicsIHRoaXMub25EaWFsb2dLZXlEb3duSGFuZGxlciApO1xuXG5cdFx0XHR0aGlzLmFjdGlvbnMuY2xlYXIoKTtcblx0XHRcdHRoaXMuY3VycmVudEFjdGlvbiA9IG51bGw7XG5cdFx0fSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5EaWFsb2cucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIFBhcmVudCBtZXRob2Rcblx0T08udWkuRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKCB0aGlzICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnRpdGxlID0gbmV3IE9PLnVpLkxhYmVsV2lkZ2V0KCk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kY29udGVudC5hZGRDbGFzcyggJ29vLXVpLWRpYWxvZy1jb250ZW50JyApO1xuXHR0aGlzLiRlbGVtZW50LmF0dHIoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLnRpdGxlLmdldEVsZW1lbnRJZCgpICk7XG5cdHRoaXMuc2V0UGVuZGluZ0VsZW1lbnQoIHRoaXMuJGhlYWQgKTtcbn07XG5cbi8qKlxuICogR2V0IGFjdGlvbiB3aWRnZXRzIGZyb20gYSBsaXN0IG9mIGNvbmZpZ3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBhY3Rpb25zIEFjdGlvbiB3aWRnZXQgY29uZmlnc1xuICogQHJldHVybiB7T08udWkuQWN0aW9uV2lkZ2V0W119IEFjdGlvbiB3aWRnZXRzXG4gKi9cbk9PLnVpLkRpYWxvZy5wcm90b3R5cGUuZ2V0QWN0aW9uV2lkZ2V0cyA9IGZ1bmN0aW9uICggYWN0aW9ucyApIHtcblx0dmFyIGksIGxlbiwgd2lkZ2V0cyA9IFtdO1xuXHRmb3IgKCBpID0gMCwgbGVuID0gYWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR3aWRnZXRzLnB1c2goIHRoaXMuZ2V0QWN0aW9uV2lkZ2V0KCBhY3Rpb25zWyBpIF0gKSApO1xuXHR9XG5cdHJldHVybiB3aWRnZXRzO1xufTtcblxuLyoqXG4gKiBHZXQgYWN0aW9uIHdpZGdldCBmcm9tIGNvbmZpZ1xuICpcbiAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYWN0aW9uIHdpZGdldCBjbGFzcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQWN0aW9uIHdpZGdldCBjb25maWdcbiAqIEByZXR1cm4ge09PLnVpLkFjdGlvbldpZGdldH0gQWN0aW9uIHdpZGdldFxuICovXG5PTy51aS5EaWFsb2cucHJvdG90eXBlLmdldEFjdGlvbldpZGdldCA9IGZ1bmN0aW9uICggY29uZmlnICkge1xuXHRyZXR1cm4gbmV3IE9PLnVpLkFjdGlvbldpZGdldCggdGhpcy5nZXRBY3Rpb25XaWRnZXRDb25maWcoIGNvbmZpZyApICk7XG59O1xuXG4vKipcbiAqIEdldCBhY3Rpb24gd2lkZ2V0IGNvbmZpZ1xuICpcbiAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgYWN0aW9uIHdpZGdldCBjb25maWdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEluaXRpYWwgYWN0aW9uIHdpZGdldCBjb25maWdcbiAqIEByZXR1cm4ge09iamVjdH0gQWN0aW9uIHdpZGdldCBjb25maWdcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5nZXRBY3Rpb25XaWRnZXRDb25maWcgPSBmdW5jdGlvbiAoIGNvbmZpZyApIHtcblx0cmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogQXR0YWNoIGFjdGlvbiBhY3Rpb25zLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5hdHRhY2hBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHQvLyBSZW1lbWJlciB0aGUgbGlzdCBvZiBwb3RlbnRpYWxseSBhdHRhY2hlZCBhY3Rpb25zXG5cdHRoaXMuYXR0YWNoZWRBY3Rpb25zID0gdGhpcy5hY3Rpb25zLmdldCgpO1xufTtcblxuLyoqXG4gKiBEZXRhY2ggYWN0aW9uIGFjdGlvbnMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNoYWluYWJsZVxuICogQHJldHVybiB7T08udWkuRGlhbG9nfSBUaGUgZGlhbG9nLCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5kZXRhY2hBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuO1xuXG5cdC8vIERldGFjaCBhbGwgYWN0aW9ucyB0aGF0IG1heSBoYXZlIGJlZW4gcHJldmlvdXNseSBhdHRhY2hlZFxuXHRmb3IgKCBpID0gMCwgbGVuID0gdGhpcy5hdHRhY2hlZEFjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGhpcy5hdHRhY2hlZEFjdGlvbnNbIGkgXS4kZWxlbWVudC5kZXRhY2goKTtcblx0fVxuXHR0aGlzLmF0dGFjaGVkQWN0aW9ucyA9IFtdO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFuIGFjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIFN5bWJvbGljIG5hbWUgb2YgYWN0aW9uIHRvIGV4ZWN1dGVcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gYWN0aW9uIGNvbXBsZXRlcywgcmVqZWN0ZWQgaWYgaXQgZmFpbHNcbiAqL1xuT08udWkuRGlhbG9nLnByb3RvdHlwZS5leGVjdXRlQWN0aW9uID0gZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdHRoaXMucHVzaFBlbmRpbmcoKTtcblx0dGhpcy5jdXJyZW50QWN0aW9uID0gYWN0aW9uO1xuXHRyZXR1cm4gdGhpcy5nZXRBY3Rpb25Qcm9jZXNzKCBhY3Rpb24gKS5leGVjdXRlKClcblx0XHQuYWx3YXlzKCB0aGlzLnBvcFBlbmRpbmcuYmluZCggdGhpcyApICk7XG59O1xuXG4vKipcbiAqIE1lc3NhZ2VEaWFsb2dzIGRpc3BsYXkgYSBjb25maXJtYXRpb24gb3IgYWxlcnQgbWVzc2FnZS4gQnkgZGVmYXVsdCwgdGhlIHJlbmRlcmVkIGRpYWxvZyBib3hcbiAqIGNvbnNpc3RzIG9mIGEgaGVhZGVyIHRoYXQgY29udGFpbnMgdGhlIGRpYWxvZyB0aXRsZSwgYSBib2R5IHdpdGggdGhlIG1lc3NhZ2UsIGFuZCBhIGZvb3RlciB0aGF0XG4gKiBjb250YWlucyBhbnkge0BsaW5rIE9PLnVpLkFjdGlvbldpZGdldCBhY3Rpb24gd2lkZ2V0c30uIFRoZSBNZXNzYWdlRGlhbG9nIGNsYXNzIGlzIHRoZSBvbmx5IHR5cGVcbiAqIG9mIHtAbGluayBPTy51aS5EaWFsb2cgZGlhbG9nfSB0aGF0IGlzIHVzdWFsbHkgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gYmFzaWMgdHlwZXMgb2YgbWVzc2FnZSBkaWFsb2dzLCBjb25maXJtYXRpb24gYW5kIGFsZXJ0OlxuICpcbiAqIC0gKipjb25maXJtYXRpb24qKjogdGhlIGRpYWxvZyB0aXRsZSBkZXNjcmliZXMgd2hhdCBhIHByb2dyZXNzaXZlIGFjdGlvbiB3aWxsIGRvIGFuZCB0aGUgbWVzc2FnZSBwcm92aWRlc1xuICogIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgY29uc2VxdWVuY2VzLlxuICogLSAqKmFsZXJ0Kio6IHRoZSBkaWFsb2cgdGl0bGUgZGVzY3JpYmVzIHdoaWNoIGV2ZW50IG9jY3VycmVkIGFuZCB0aGUgbWVzc2FnZSBwcm92aWRlcyBtb3JlIGluZm9ybWF0aW9uXG4gKiAgYWJvdXQgd2h5IHRoZSBldmVudCBvY2N1cnJlZC5cbiAqXG4gKiBUaGUgTWVzc2FnZURpYWxvZyBjbGFzcyBzcGVjaWZpZXMgdHdvIGFjdGlvbnM6IOKAmGFjY2VwdOKAmSwgdGhlIHByaW1hcnlcbiAqIGFjdGlvbiAoZS5nLiwg4oCYb2vigJkpIGFuZCDigJhyZWplY3Qs4oCZIHRoZSBzYWZlIGFjdGlvbiAoZS5nLiwg4oCYY2FuY2Vs4oCZKS4gQm90aCB3aWxsIGNsb3NlIHRoZSB3aW5kb3csXG4gKiBwYXNzaW5nIGFsb25nIHRoZSBzZWxlY3RlZCBhY3Rpb24uXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCBwbGVhc2Ugc2VlIHRoZSBbT09VSSBkb2N1bWVudGF0aW9uIG9uIE1lZGlhV2lraV1bMV0uXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZTogQ3JlYXRpbmcgYW5kIG9wZW5pbmcgYSBtZXNzYWdlIGRpYWxvZyB3aW5kb3cuXG4gKiAgICAgdmFyIG1lc3NhZ2VEaWFsb2cgPSBuZXcgT08udWkuTWVzc2FnZURpYWxvZygpO1xuICpcbiAqICAgICAvLyBDcmVhdGUgYW5kIGFwcGVuZCBhIHdpbmRvdyBtYW5hZ2VyLlxuICogICAgIHZhciB3aW5kb3dNYW5hZ2VyID0gbmV3IE9PLnVpLldpbmRvd01hbmFnZXIoKTtcbiAqICAgICAkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCB3aW5kb3dNYW5hZ2VyLiRlbGVtZW50ICk7XG4gKiAgICAgd2luZG93TWFuYWdlci5hZGRXaW5kb3dzKCBbIG1lc3NhZ2VEaWFsb2cgXSApO1xuICogICAgIC8vIE9wZW4gdGhlIHdpbmRvdy5cbiAqICAgICB3aW5kb3dNYW5hZ2VyLm9wZW5XaW5kb3coIG1lc3NhZ2VEaWFsb2csIHtcbiAqICAgICAgICAgdGl0bGU6ICdCYXNpYyBtZXNzYWdlIGRpYWxvZycsXG4gKiAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIHRoZSBtZXNzYWdlJ1xuICogICAgIH0gKTtcbiAqXG4gKiBbMV06IGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9PT1VJL1dpbmRvd3MvTWVzc2FnZV9EaWFsb2dzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5EaWFsb2dcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuTWVzc2FnZURpYWxvZyA9IGZ1bmN0aW9uIE9vVWlNZXNzYWdlRGlhbG9nKCBjb25maWcgKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5NZXNzYWdlRGlhbG9nLnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMudmVydGljYWxBY3Rpb25MYXlvdXQgPSBudWxsO1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoICdvby11aS1tZXNzYWdlRGlhbG9nJyApO1xufTtcblxuLyogU2V0dXAgKi9cblxuT08uaW5oZXJpdENsYXNzKCBPTy51aS5NZXNzYWdlRGlhbG9nLCBPTy51aS5EaWFsb2cgKTtcblxuLyogU3RhdGljIFByb3BlcnRpZXMgKi9cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnN0YXRpYy5uYW1lID0gJ21lc3NhZ2UnO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cuc3RhdGljLnNpemUgPSAnc21hbGwnO1xuXG4vKipcbiAqIERpYWxvZyB0aXRsZS5cbiAqXG4gKiBUaGUgdGl0bGUgb2YgYSBjb25maXJtYXRpb24gZGlhbG9nIGRlc2NyaWJlcyB3aGF0IGEgcHJvZ3Jlc3NpdmUgYWN0aW9uIHdpbGwgZG8uIFRoZVxuICogdGl0bGUgb2YgYW4gYWxlcnQgZGlhbG9nIGRlc2NyaWJlcyB3aGljaCBldmVudCBvY2N1cnJlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAaW5oZXJpdGFibGVcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fHN0cmluZ3xGdW5jdGlvbnxudWxsfVxuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnN0YXRpYy50aXRsZSA9IG51bGw7XG5cbi8qKlxuICogVGhlIG1lc3NhZ2UgZGlzcGxheWVkIGluIHRoZSBkaWFsb2cgYm9keS5cbiAqXG4gKiBBIGNvbmZpcm1hdGlvbiBtZXNzYWdlIGRlc2NyaWJlcyB0aGUgY29uc2VxdWVuY2VzIG9mIGEgcHJvZ3Jlc3NpdmUgYWN0aW9uLiBBbiBhbGVydFxuICogbWVzc2FnZSBkZXNjcmliZXMgd2h5IGFuIGV2ZW50IG9jY3VycmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0YWJsZVxuICogQHByb3BlcnR5IHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cuc3RhdGljLm1lc3NhZ2UgPSBudWxsO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cuc3RhdGljLmFjdGlvbnMgPSBbXG5cdC8vIE5vdGUgdGhhdCBPTy51aS5hbGVydCgpIGFuZCBPTy51aS5jb25maXJtKCkgcmVseSBvbiB0aGVzZS5cblx0eyBhY3Rpb246ICdhY2NlcHQnLCBsYWJlbDogT08udWkuZGVmZXJNc2coICdvb3VpLWRpYWxvZy1tZXNzYWdlLWFjY2VwdCcgKSwgZmxhZ3M6ICdwcmltYXJ5JyB9LFxuXHR7IGFjdGlvbjogJ3JlamVjdCcsIGxhYmVsOiBPTy51aS5kZWZlck1zZyggJ29vdWktZGlhbG9nLW1lc3NhZ2UtcmVqZWN0JyApLCBmbGFnczogJ3NhZmUnIH1cbl07XG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBUb2dnbGUgYWN0aW9uIGxheW91dCBiZXR3ZWVuIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV0gTGF5b3V0IGFjdGlvbnMgdmVydGljYWxseSwgb21pdCB0byB0b2dnbGVcbiAqIEBjaGFpbmFibGVcbiAqIEByZXR1cm4ge09PLnVpLk1lc3NhZ2VEaWFsb2d9IFRoZSBkaWFsb2csIGZvciBjaGFpbmluZ1xuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnByb3RvdHlwZS50b2dnbGVWZXJ0aWNhbEFjdGlvbkxheW91dCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICF0aGlzLnZlcnRpY2FsQWN0aW9uTGF5b3V0IDogISF2YWx1ZTtcblxuXHRpZiAoIHZhbHVlICE9PSB0aGlzLnZlcnRpY2FsQWN0aW9uTGF5b3V0ICkge1xuXHRcdHRoaXMudmVydGljYWxBY3Rpb25MYXlvdXQgPSB2YWx1ZTtcblx0XHR0aGlzLiRhY3Rpb25zXG5cdFx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1tZXNzYWdlRGlhbG9nLWFjdGlvbnMtdmVydGljYWwnLCB2YWx1ZSApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoICdvby11aS1tZXNzYWdlRGlhbG9nLWFjdGlvbnMtaG9yaXpvbnRhbCcsICF2YWx1ZSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cucHJvdG90eXBlLmdldEFjdGlvblByb2Nlc3MgPSBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0aWYgKCBhY3Rpb24gKSB7XG5cdFx0cmV0dXJuIG5ldyBPTy51aS5Qcm9jZXNzKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCB7IGFjdGlvbjogYWN0aW9uIH0gKTtcblx0XHR9LCB0aGlzICk7XG5cdH1cblx0cmV0dXJuIE9PLnVpLk1lc3NhZ2VEaWFsb2cucGFyZW50LnByb3RvdHlwZS5nZXRBY3Rpb25Qcm9jZXNzLmNhbGwoIHRoaXMsIGFjdGlvbiApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gRGlhbG9nIG9wZW5pbmcgZGF0YVxuICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9IFtkYXRhLnRpdGxlXSBEZXNjcmlwdGlvbiBvZiB0aGUgYWN0aW9uIGJlaW5nIGNvbmZpcm1lZFxuICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfEZ1bmN0aW9ufG51bGx9IFtkYXRhLm1lc3NhZ2VdIERlc2NyaXB0aW9uIG9mIHRoZSBhY3Rpb24ncyBjb25zZXF1ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhLnNpemVdIFN5bWJvbGljIG5hbWUgb2YgdGhlIGRpYWxvZyBzaXplLCBzZWUgT08udWkuV2luZG93XG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5hY3Rpb25zXSBMaXN0IG9mIE9PLnVpLkFjdGlvbk9wdGlvbldpZGdldCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGVhY2hcbiAqICAgYWN0aW9uIGl0ZW1cbiAqL1xuT08udWkuTWVzc2FnZURpYWxvZy5wcm90b3R5cGUuZ2V0U2V0dXBQcm9jZXNzID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXHRkYXRhID0gZGF0YSB8fCB7fTtcblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdHJldHVybiBPTy51aS5NZXNzYWdlRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuZ2V0U2V0dXBQcm9jZXNzLmNhbGwoIHRoaXMsIGRhdGEgKVxuXHRcdC5uZXh0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnRpdGxlLnNldExhYmVsKFxuXHRcdFx0XHRkYXRhLnRpdGxlICE9PSB1bmRlZmluZWQgPyBkYXRhLnRpdGxlIDogdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMudGl0bGVcblx0XHRcdCk7XG5cdFx0XHR0aGlzLm1lc3NhZ2Uuc2V0TGFiZWwoXG5cdFx0XHRcdGRhdGEubWVzc2FnZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5tZXNzYWdlIDogdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMubWVzc2FnZVxuXHRcdFx0KTtcblx0XHRcdHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5zaXplIDogdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWMuc2l6ZTtcblx0XHR9LCB0aGlzICk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cucHJvdG90eXBlLmdldFJlYWR5UHJvY2VzcyA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0ZGF0YSA9IGRhdGEgfHwge307XG5cblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRyZXR1cm4gT08udWkuTWVzc2FnZURpYWxvZy5wYXJlbnQucHJvdG90eXBlLmdldFJlYWR5UHJvY2Vzcy5jYWxsKCB0aGlzLCBkYXRhIClcblx0XHQubmV4dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gRm9jdXMgdGhlIHByaW1hcnkgYWN0aW9uIGJ1dHRvblxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnMuZ2V0KCk7XG5cdFx0XHRhY3Rpb25zID0gYWN0aW9ucy5maWx0ZXIoIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmdldEZsYWdzKCkuaW5kZXhPZiggJ3ByaW1hcnknICkgPiAtMTtcblx0XHRcdH0gKTtcblx0XHRcdGlmICggYWN0aW9ucy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRhY3Rpb25zWyAwIF0uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzICk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cucHJvdG90eXBlLmdldEJvZHlIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBib2R5SGVpZ2h0LCBvbGRPdmVyZmxvdyxcblx0XHQkc2Nyb2xsYWJsZSA9IHRoaXMuY29udGFpbmVyLiRlbGVtZW50O1xuXG5cdG9sZE92ZXJmbG93ID0gJHNjcm9sbGFibGVbIDAgXS5zdHlsZS5vdmVyZmxvdztcblx0JHNjcm9sbGFibGVbIDAgXS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG5cdE9PLnVpLkVsZW1lbnQuc3RhdGljLnJlY29uc2lkZXJTY3JvbGxiYXJzKCAkc2Nyb2xsYWJsZVsgMCBdICk7XG5cblx0Ym9keUhlaWdodCA9IHRoaXMudGV4dC4kZWxlbWVudC5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHQkc2Nyb2xsYWJsZVsgMCBdLnN0eWxlLm92ZXJmbG93ID0gb2xkT3ZlcmZsb3c7XG5cblx0cmV0dXJuIGJvZHlIZWlnaHQ7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLk1lc3NhZ2VEaWFsb2cucHJvdG90eXBlLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoIGRpbSApIHtcblx0dmFyXG5cdFx0ZGlhbG9nID0gdGhpcyxcblx0XHQkc2Nyb2xsYWJsZSA9IHRoaXMuY29udGFpbmVyLiRlbGVtZW50O1xuXHRPTy51aS5NZXNzYWdlRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuc2V0RGltZW5zaW9ucy5jYWxsKCB0aGlzLCBkaW0gKTtcblxuXHQvLyBUd2lkZGxlIHRoZSBvdmVyZmxvdyBwcm9wZXJ0eSwgb3RoZXJ3aXNlIGFuIHVubmVjZXNzYXJ5IHNjcm9sbGJhciB3aWxsIGJlIHByb2R1Y2VkLlxuXHQvLyBOZWVkIHRvIGRvIGl0IGFmdGVyIHRyYW5zaXRpb24gY29tcGxldGVzICgyNTBtcyksIGFkZCA1MG1zIGp1c3QgaW4gY2FzZS5cblx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvbGRPdmVyZmxvdyA9ICRzY3JvbGxhYmxlWyAwIF0uc3R5bGUub3ZlcmZsb3csXG5cdFx0XHRhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdCRzY3JvbGxhYmxlWyAwIF0uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuXHRcdE9PLnVpLkVsZW1lbnQuc3RhdGljLnJlY29uc2lkZXJTY3JvbGxiYXJzKCAkc2Nyb2xsYWJsZVsgMCBdICk7XG5cblx0XHQvLyBDaGVjayByZWNvbnNpZGVyU2Nyb2xsYmFycyBkaWRuJ3QgZGVzdHJveSBvdXIgZm9jdXMsIGFzIHdlXG5cdFx0Ly8gYXJlIGRvaW5nIHRoaXMgYWZ0ZXIgdGhlIHJlYWR5IHByb2Nlc3MuXG5cdFx0aWYgKCBhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5mb2N1cyApIHtcblx0XHRcdGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblx0XHR9XG5cblx0XHQkc2Nyb2xsYWJsZVsgMCBdLnN0eWxlLm92ZXJmbG93ID0gb2xkT3ZlcmZsb3c7XG5cdH0sIDMwMCApO1xuXG5cdGRpYWxvZy5maXRBY3Rpb25zKCk7XG5cdC8vIFdhaXQgZm9yIENTUyB0cmFuc2l0aW9uIHRvIGZpbmlzaCBhbmQgZG8gaXQgYWdhaW4gOihcblx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdGRpYWxvZy5maXRBY3Rpb25zKCk7XG5cdH0sIDMwMCApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLk1lc3NhZ2VEaWFsb2cucGFyZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwoIHRoaXMgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuJGFjdGlvbnMgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuY29udGFpbmVyID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7XG5cdFx0c2Nyb2xsYWJsZTogdHJ1ZSwgY2xhc3NlczogWyAnb28tdWktbWVzc2FnZURpYWxvZy1jb250YWluZXInIF1cblx0fSApO1xuXHR0aGlzLnRleHQgPSBuZXcgT08udWkuUGFuZWxMYXlvdXQoIHtcblx0XHRwYWRkZWQ6IHRydWUsIGV4cGFuZGVkOiBmYWxzZSwgY2xhc3NlczogWyAnb28tdWktbWVzc2FnZURpYWxvZy10ZXh0JyBdXG5cdH0gKTtcblx0dGhpcy5tZXNzYWdlID0gbmV3IE9PLnVpLkxhYmVsV2lkZ2V0KCB7XG5cdFx0Y2xhc3NlczogWyAnb28tdWktbWVzc2FnZURpYWxvZy1tZXNzYWdlJyBdXG5cdH0gKTtcblxuXHQvLyBJbml0aWFsaXphdGlvblxuXHR0aGlzLnRpdGxlLiRlbGVtZW50LmFkZENsYXNzKCAnb28tdWktbWVzc2FnZURpYWxvZy10aXRsZScgKTtcblx0dGhpcy4kY29udGVudC5hZGRDbGFzcyggJ29vLXVpLW1lc3NhZ2VEaWFsb2ctY29udGVudCcgKTtcblx0dGhpcy5jb250YWluZXIuJGVsZW1lbnQuYXBwZW5kKCB0aGlzLnRleHQuJGVsZW1lbnQgKTtcblx0dGhpcy50ZXh0LiRlbGVtZW50LmFwcGVuZCggdGhpcy50aXRsZS4kZWxlbWVudCwgdGhpcy5tZXNzYWdlLiRlbGVtZW50ICk7XG5cdHRoaXMuJGJvZHkuYXBwZW5kKCB0aGlzLmNvbnRhaW5lci4kZWxlbWVudCApO1xuXHR0aGlzLiRhY3Rpb25zLmFkZENsYXNzKCAnb28tdWktbWVzc2FnZURpYWxvZy1hY3Rpb25zJyApO1xuXHR0aGlzLiRmb290LmFwcGVuZCggdGhpcy4kYWN0aW9ucyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnByb3RvdHlwZS5nZXRBY3Rpb25XaWRnZXRDb25maWcgPSBmdW5jdGlvbiAoIGNvbmZpZyApIHtcblx0Ly8gRm9yY2UgdW5mcmFtZWRcblx0cmV0dXJuICQuZXh0ZW5kKCB7fSwgY29uZmlnLCB7IGZyYW1lZDogZmFsc2UgfSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnByb3RvdHlwZS5hdHRhY2hBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuLCBzcGVjaWFsLCBvdGhlcnM7XG5cblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRPTy51aS5NZXNzYWdlRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuYXR0YWNoQWN0aW9ucy5jYWxsKCB0aGlzICk7XG5cblx0c3BlY2lhbCA9IHRoaXMuYWN0aW9ucy5nZXRTcGVjaWFsKCk7XG5cdG90aGVycyA9IHRoaXMuYWN0aW9ucy5nZXRPdGhlcnMoKTtcblxuXHRpZiAoIHNwZWNpYWwuc2FmZSApIHtcblx0XHR0aGlzLiRhY3Rpb25zLmFwcGVuZCggc3BlY2lhbC5zYWZlLiRlbGVtZW50ICk7XG5cdFx0c3BlY2lhbC5zYWZlLnRvZ2dsZUZyYW1lZCggdHJ1ZSApO1xuXHR9XG5cdGZvciAoIGkgPSAwLCBsZW4gPSBvdGhlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGhpcy4kYWN0aW9ucy5hcHBlbmQoIG90aGVyc1sgaSBdLiRlbGVtZW50ICk7XG5cdFx0b3RoZXJzWyBpIF0udG9nZ2xlRnJhbWVkKCB0cnVlICk7XG5cdH1cblx0aWYgKCBzcGVjaWFsLnByaW1hcnkgKSB7XG5cdFx0dGhpcy4kYWN0aW9ucy5hcHBlbmQoIHNwZWNpYWwucHJpbWFyeS4kZWxlbWVudCApO1xuXHRcdHNwZWNpYWwucHJpbWFyeS50b2dnbGVGcmFtZWQoIHRydWUgKTtcblx0fVxufTtcblxuLyoqXG4gKiBGaXQgYWN0aW9uIGFjdGlvbnMgaW50byBjb2x1bW5zIG9yIHJvd3MuXG4gKlxuICogQ29sdW1ucyB3aWxsIGJlIHVzZWQgaWYgYWxsIGxhYmVscyBjYW4gZml0IHdpdGhvdXQgb3ZlcmZsb3csIG90aGVyd2lzZSByb3dzIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5NZXNzYWdlRGlhbG9nLnByb3RvdHlwZS5maXRBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaSwgbGVuLCBhY3Rpb24sXG5cdFx0cHJldmlvdXMgPSB0aGlzLnZlcnRpY2FsQWN0aW9uTGF5b3V0LFxuXHRcdGFjdGlvbnMgPSB0aGlzLmFjdGlvbnMuZ2V0KCk7XG5cblx0Ly8gRGV0ZWN0IGNsaXBwaW5nXG5cdHRoaXMudG9nZ2xlVmVydGljYWxBY3Rpb25MYXlvdXQoIGZhbHNlICk7XG5cdGZvciAoIGkgPSAwLCBsZW4gPSBhY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcblx0XHRpZiAoIGFjdGlvbi4kZWxlbWVudFsgMCBdLnNjcm9sbFdpZHRoID4gYWN0aW9uLiRlbGVtZW50WyAwIF0uY2xpZW50V2lkdGggKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZVZlcnRpY2FsQWN0aW9uTGF5b3V0KCB0cnVlICk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBNb3ZlIHRoZSBib2R5IG91dCBvZiB0aGUgd2F5IG9mIHRoZSBmb290XG5cdHRoaXMuJGJvZHkuY3NzKCAnYm90dG9tJywgdGhpcy4kZm9vdC5vdXRlckhlaWdodCggdHJ1ZSApICk7XG5cblx0aWYgKCB0aGlzLnZlcnRpY2FsQWN0aW9uTGF5b3V0ICE9PSBwcmV2aW91cyApIHtcblx0XHQvLyBXZSBjaGFuZ2VkIHRoZSBsYXlvdXQsIHdpbmRvdyBoZWlnaHQgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdHRoaXMudXBkYXRlU2l6ZSgpO1xuXHR9XG59O1xuXG4vKipcbiAqIFByb2Nlc3NEaWFsb2cgd2luZG93cyBlbmNhcHN1bGF0ZSBhIHtAbGluayBPTy51aS5Qcm9jZXNzIHByb2Nlc3N9IGFuZCBhbGwgb2YgdGhlIGNvZGUgbmVjZXNzYXJ5XG4gKiB0byBjb21wbGV0ZSBpdC4gSWYgdGhlIHByb2Nlc3MgdGVybWluYXRlcyB3aXRoIGFuIGVycm9yLCBhIGN1c3RvbWl6YWJsZSB7QGxpbmsgT08udWkuRXJyb3IgZXJyb3JcbiAqIGludGVyZmFjZX0gYWxlcnRzIHVzZXJzIHRvIHRoZSB0cm91YmxlLCBwZXJtaXR0aW5nIHRoZSB1c2VyIHRvIGRpc21pc3MgdGhlIGVycm9yIGFuZCB0cnkgYWdhaW4gd2hlblxuICogcmVsZXZhbnQuIFRoZSBQcm9jZXNzRGlhbG9nIGNsYXNzIGlzIGFsd2F5cyBleHRlbmRlZCBhbmQgY3VzdG9taXplZCB3aXRoIHRoZSBhY3Rpb25zIGFuZCBjb250ZW50XG4gKiByZXF1aXJlZCBmb3IgZWFjaCBwcm9jZXNzLlxuICpcbiAqIFRoZSBwcm9jZXNzIGRpYWxvZyBib3ggY29uc2lzdHMgb2YgYSBoZWFkZXIgdGhhdCB2aXN1YWxseSByZXByZXNlbnRzIHRoZSDigJh3b3JraW5n4oCZIHN0YXRlIG9mIGxvbmdcbiAqIHByb2Nlc3NlcyB3aXRoIGFuIGFuaW1hdGlvbi4gVGhlIGhlYWRlciBjb250YWlucyB0aGUgZGlhbG9nIHRpdGxlIGFzIHdlbGwgYXNcbiAqIHR3byB7QGxpbmsgT08udWkuQWN0aW9uV2lkZ2V0IGFjdGlvbiB3aWRnZXRzfTogIGEg4oCYc2FmZeKAmSBhY3Rpb24gb24gdGhlIGxlZnQgKGUuZy4sIOKAmENhbmNlbOKAmSkgYW5kXG4gKiBhIOKAmHByaW1hcnnigJkgYWN0aW9uIG9uIHRoZSByaWdodCAoZS5nLiwg4oCYRG9uZeKAmSkuXG4gKlxuICogTGlrZSBvdGhlciB3aW5kb3dzLCB0aGUgcHJvY2VzcyBkaWFsb2cgaXMgbWFuYWdlZCBieSBhIHtAbGluayBPTy51aS5XaW5kb3dNYW5hZ2VyIHdpbmRvdyBtYW5hZ2VyfS5cbiAqIFBsZWFzZSBzZWUgdGhlIFtPT1VJIGRvY3VtZW50YXRpb24gb24gTWVkaWFXaWtpXVsxXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgLy8gRXhhbXBsZTogQ3JlYXRpbmcgYW5kIG9wZW5pbmcgYSBwcm9jZXNzIGRpYWxvZyB3aW5kb3cuXG4gKiAgICAgZnVuY3Rpb24gTXlQcm9jZXNzRGlhbG9nKCBjb25maWcgKSB7XG4gKiAgICAgICAgIE15UHJvY2Vzc0RpYWxvZy5wYXJlbnQuY2FsbCggdGhpcywgY29uZmlnICk7XG4gKiAgICAgfVxuICogICAgIE9PLmluaGVyaXRDbGFzcyggTXlQcm9jZXNzRGlhbG9nLCBPTy51aS5Qcm9jZXNzRGlhbG9nICk7XG4gKlxuICogICAgIE15UHJvY2Vzc0RpYWxvZy5zdGF0aWMubmFtZSA9ICdteVByb2Nlc3NEaWFsb2cnO1xuICogICAgIE15UHJvY2Vzc0RpYWxvZy5zdGF0aWMudGl0bGUgPSAnUHJvY2VzcyBkaWFsb2cnO1xuICogICAgIE15UHJvY2Vzc0RpYWxvZy5zdGF0aWMuYWN0aW9ucyA9IFtcbiAqICAgICAgICAgeyBhY3Rpb246ICdzYXZlJywgbGFiZWw6ICdEb25lJywgZmxhZ3M6ICdwcmltYXJ5JyB9LFxuICogICAgICAgICB7IGxhYmVsOiAnQ2FuY2VsJywgZmxhZ3M6ICdzYWZlJyB9XG4gKiAgICAgXTtcbiAqXG4gKiAgICAgTXlQcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICBNeVByb2Nlc3NEaWFsb2cucGFyZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IE9PLnVpLlBhbmVsTGF5b3V0KCB7IHBhZGRlZDogdHJ1ZSwgZXhwYW5kZWQ6IGZhbHNlIH0gKTtcbiAqICAgICAgICAgdGhpcy5jb250ZW50LiRlbGVtZW50LmFwcGVuZCggJzxwPlRoaXMgaXMgYSBwcm9jZXNzIGRpYWxvZyB3aW5kb3cuIFRoZSBoZWFkZXIgY29udGFpbnMgdGhlIHRpdGxlIGFuZCB0d28gYnV0dG9uczogXFwnQ2FuY2VsXFwnIChhIHNhZmUgYWN0aW9uKSBvbiB0aGUgbGVmdCBhbmQgXFwnRG9uZVxcJyAoYSBwcmltYXJ5IGFjdGlvbikgIG9uIHRoZSByaWdodC48L3A+JyApO1xuICogICAgICAgICB0aGlzLiRib2R5LmFwcGVuZCggdGhpcy5jb250ZW50LiRlbGVtZW50ICk7XG4gKiAgICAgfTtcbiAqICAgICBNeVByb2Nlc3NEaWFsb2cucHJvdG90eXBlLmdldEFjdGlvblByb2Nlc3MgPSBmdW5jdGlvbiAoIGFjdGlvbiApIHtcbiAqICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXM7XG4gKiAgICAgICAgIGlmICggYWN0aW9uICkge1xuICogICAgICAgICAgICAgcmV0dXJuIG5ldyBPTy51aS5Qcm9jZXNzKCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCB7IGFjdGlvbjogYWN0aW9uIH0gKTtcbiAqICAgICAgICAgICAgIH0gKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICByZXR1cm4gTXlQcm9jZXNzRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuZ2V0QWN0aW9uUHJvY2Vzcy5jYWxsKCB0aGlzLCBhY3Rpb24gKTtcbiAqICAgICB9O1xuICpcbiAqICAgICB2YXIgd2luZG93TWFuYWdlciA9IG5ldyBPTy51aS5XaW5kb3dNYW5hZ2VyKCk7XG4gKiAgICAgJCggZG9jdW1lbnQuYm9keSApLmFwcGVuZCggd2luZG93TWFuYWdlci4kZWxlbWVudCApO1xuICpcbiAqICAgICB2YXIgZGlhbG9nID0gbmV3IE15UHJvY2Vzc0RpYWxvZygpO1xuICogICAgIHdpbmRvd01hbmFnZXIuYWRkV2luZG93cyggWyBkaWFsb2cgXSApO1xuICogICAgIHdpbmRvd01hbmFnZXIub3BlbldpbmRvdyggZGlhbG9nICk7XG4gKlxuICogWzFdOiBodHRwczovL3d3dy5tZWRpYXdpa2kub3JnL3dpa2kvT09VSS9XaW5kb3dzL1Byb2Nlc3NfRGlhbG9nc1xuICpcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBPTy51aS5EaWFsb2dcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZyA9IGZ1bmN0aW9uIE9vVWlQcm9jZXNzRGlhbG9nKCBjb25maWcgKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRPTy51aS5Qcm9jZXNzRGlhbG9nLnBhcmVudC5jYWxsKCB0aGlzLCBjb25maWcgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuZml0T25PcGVuID0gZmFsc2U7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXByb2Nlc3NEaWFsb2cnICk7XG59O1xuXG4vKiBTZXR1cCAqL1xuXG5PTy5pbmhlcml0Q2xhc3MoIE9PLnVpLlByb2Nlc3NEaWFsb2csIE9PLnVpLkRpYWxvZyApO1xuXG4vKiBNZXRob2RzICovXG5cbi8qKlxuICogSGFuZGxlIGRpc21pc3MgYnV0dG9uIGNsaWNrIGV2ZW50cy5cbiAqXG4gKiBIaWRlcyBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUub25EaXNtaXNzRXJyb3JCdXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5oaWRlRXJyb3JzKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZXRyeSBidXR0b24gY2xpY2sgZXZlbnRzLlxuICpcbiAqIEhpZGVzIGVycm9ycyBhbmQgdGhlbiB0cmllcyBhZ2Fpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5PTy51aS5Qcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5vblJldHJ5QnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuaGlkZUVycm9ycygpO1xuXHR0aGlzLmV4ZWN1dGVBY3Rpb24oIHRoaXMuY3VycmVudEFjdGlvbiApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlByb2Nlc3NEaWFsb2cucGFyZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwoIHRoaXMgKTtcblxuXHQvLyBQcm9wZXJ0aWVzXG5cdHRoaXMuJG5hdmlnYXRpb24gPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJGxvY2F0aW9uID0gJCggJzxkaXY+JyApO1xuXHR0aGlzLiRzYWZlQWN0aW9ucyA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy4kcHJpbWFyeUFjdGlvbnMgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJG90aGVyQWN0aW9ucyA9ICQoICc8ZGl2PicgKTtcblx0dGhpcy5kaXNtaXNzQnV0dG9uID0gbmV3IE9PLnVpLkJ1dHRvbldpZGdldCgge1xuXHRcdGxhYmVsOiBPTy51aS5tc2coICdvb3VpLWRpYWxvZy1wcm9jZXNzLWRpc21pc3MnIClcblx0fSApO1xuXHR0aGlzLnJldHJ5QnV0dG9uID0gbmV3IE9PLnVpLkJ1dHRvbldpZGdldCgpO1xuXHR0aGlzLiRlcnJvcnMgPSAkKCAnPGRpdj4nICk7XG5cdHRoaXMuJGVycm9yc1RpdGxlID0gJCggJzxkaXY+JyApO1xuXG5cdC8vIEV2ZW50c1xuXHR0aGlzLmRpc21pc3NCdXR0b24uY29ubmVjdCggdGhpcywgeyBjbGljazogJ29uRGlzbWlzc0Vycm9yQnV0dG9uQ2xpY2snIH0gKTtcblx0dGhpcy5yZXRyeUJ1dHRvbi5jb25uZWN0KCB0aGlzLCB7IGNsaWNrOiAnb25SZXRyeUJ1dHRvbkNsaWNrJyB9ICk7XG5cdHRoaXMudGl0bGUuY29ubmVjdCggdGhpcywgeyBsYWJlbENoYW5nZTogJ2ZpdExhYmVsJyB9ICk7XG5cblx0Ly8gSW5pdGlhbGl6YXRpb25cblx0dGhpcy50aXRsZS4kZWxlbWVudC5hZGRDbGFzcyggJ29vLXVpLXByb2Nlc3NEaWFsb2ctdGl0bGUnICk7XG5cdHRoaXMuJGxvY2F0aW9uXG5cdFx0LmFwcGVuZCggdGhpcy50aXRsZS4kZWxlbWVudCApXG5cdFx0LmFkZENsYXNzKCAnb28tdWktcHJvY2Vzc0RpYWxvZy1sb2NhdGlvbicgKTtcblx0dGhpcy4kc2FmZUFjdGlvbnMuYWRkQ2xhc3MoICdvby11aS1wcm9jZXNzRGlhbG9nLWFjdGlvbnMtc2FmZScgKTtcblx0dGhpcy4kcHJpbWFyeUFjdGlvbnMuYWRkQ2xhc3MoICdvby11aS1wcm9jZXNzRGlhbG9nLWFjdGlvbnMtcHJpbWFyeScgKTtcblx0dGhpcy4kb3RoZXJBY3Rpb25zLmFkZENsYXNzKCAnb28tdWktcHJvY2Vzc0RpYWxvZy1hY3Rpb25zLW90aGVyJyApO1xuXHR0aGlzLiRlcnJvcnNUaXRsZVxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXByb2Nlc3NEaWFsb2ctZXJyb3JzLXRpdGxlJyApXG5cdFx0LnRleHQoIE9PLnVpLm1zZyggJ29vdWktZGlhbG9nLXByb2Nlc3MtZXJyb3InICkgKTtcblx0dGhpcy4kZXJyb3JzXG5cdFx0LmFkZENsYXNzKCAnb28tdWktcHJvY2Vzc0RpYWxvZy1lcnJvcnMgb28tdWktZWxlbWVudC1oaWRkZW4nIClcblx0XHQuYXBwZW5kKCB0aGlzLiRlcnJvcnNUaXRsZSwgdGhpcy5kaXNtaXNzQnV0dG9uLiRlbGVtZW50LCB0aGlzLnJldHJ5QnV0dG9uLiRlbGVtZW50ICk7XG5cdHRoaXMuJGNvbnRlbnRcblx0XHQuYWRkQ2xhc3MoICdvby11aS1wcm9jZXNzRGlhbG9nLWNvbnRlbnQnIClcblx0XHQuYXBwZW5kKCB0aGlzLiRlcnJvcnMgKTtcblx0dGhpcy4kbmF2aWdhdGlvblxuXHRcdC5hZGRDbGFzcyggJ29vLXVpLXByb2Nlc3NEaWFsb2ctbmF2aWdhdGlvbicgKVxuXHRcdC8vIE5vdGU6IE9yZGVyIG9mIGFwcGVuZHMgYmVsb3cgaXMgaW1wb3J0YW50LiBUaGVzZSBhcmUgaW4gdGhlIG9yZGVyXG5cdFx0Ly8gd2Ugd2FudCB0YWIgdG8gZ28gdGhyb3VnaCB0aGVtLiBEaXNwbGF5LW9yZGVyIGlzIGhhbmRsZWQgZW50aXJlbHlcblx0XHQvLyBieSBDU1MgYWJzb2x1dGUtcG9zaXRpb25pbmcuIEFzIHN1Y2gsIHByaW1hcnkgYWN0aW9ucyBsaWtlIFwiZG9uZVwiXG5cdFx0Ly8gc2hvdWxkIGdvIGZpcnN0LlxuXHRcdC5hcHBlbmQoIHRoaXMuJHByaW1hcnlBY3Rpb25zLCB0aGlzLiRsb2NhdGlvbiwgdGhpcy4kc2FmZUFjdGlvbnMgKTtcblx0dGhpcy4kaGVhZC5hcHBlbmQoIHRoaXMuJG5hdmlnYXRpb24gKTtcblx0dGhpcy4kZm9vdC5hcHBlbmQoIHRoaXMuJG90aGVyQWN0aW9ucyApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5nZXRBY3Rpb25XaWRnZXRDb25maWcgPSBmdW5jdGlvbiAoIGNvbmZpZyApIHtcblx0dmFyIGlzTW9iaWxlID0gT08udWkuaXNNb2JpbGUoKTtcblxuXHQvLyBEZWZhdWx0IHRvIHVuZnJhbWVkIG9uIG1vYmlsZVxuXHRjb25maWcgPSAkLmV4dGVuZCggeyBmcmFtZWQ6ICFpc01vYmlsZSB9LCBjb25maWcgKTtcblx0Ly8gQ2hhbmdlIGJhY2sgYnV0dG9ucyB0byBpY29uIG9ubHkgb24gbW9iaWxlXG5cdGlmIChcblx0XHRpc01vYmlsZSAmJlxuXHRcdCggY29uZmlnLmZsYWdzID09PSAnYmFjaycgfHwgKCBBcnJheS5pc0FycmF5KCBjb25maWcuZmxhZ3MgKSAmJiBjb25maWcuZmxhZ3MuaW5kZXhPZiggJ2JhY2snICkgIT09IC0xICkgKVxuXHQpIHtcblx0XHQkLmV4dGVuZCggY29uZmlnLCB7XG5cdFx0XHRpY29uOiAncHJldmlvdXMnLFxuXHRcdFx0bGFiZWw6ICcnXG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIGNvbmZpZztcbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuYXR0YWNoQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGksIGxlbiwgb3RoZXIsIHNwZWNpYWwsIG90aGVycztcblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlByb2Nlc3NEaWFsb2cucGFyZW50LnByb3RvdHlwZS5hdHRhY2hBY3Rpb25zLmNhbGwoIHRoaXMgKTtcblxuXHRzcGVjaWFsID0gdGhpcy5hY3Rpb25zLmdldFNwZWNpYWwoKTtcblx0b3RoZXJzID0gdGhpcy5hY3Rpb25zLmdldE90aGVycygpO1xuXHRpZiAoIHNwZWNpYWwucHJpbWFyeSApIHtcblx0XHR0aGlzLiRwcmltYXJ5QWN0aW9ucy5hcHBlbmQoIHNwZWNpYWwucHJpbWFyeS4kZWxlbWVudCApO1xuXHR9XG5cdGZvciAoIGkgPSAwLCBsZW4gPSBvdGhlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0b3RoZXIgPSBvdGhlcnNbIGkgXTtcblx0XHR0aGlzLiRvdGhlckFjdGlvbnMuYXBwZW5kKCBvdGhlci4kZWxlbWVudCApO1xuXHR9XG5cdGlmICggc3BlY2lhbC5zYWZlICkge1xuXHRcdHRoaXMuJHNhZmVBY3Rpb25zLmFwcGVuZCggc3BlY2lhbC5zYWZlLiRlbGVtZW50ICk7XG5cdH1cbn07XG5cbi8qKlxuICogQGluaGVyaXRkb2NcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuZXhlY3V0ZUFjdGlvbiA9IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHR2YXIgcHJvY2VzcyA9IHRoaXM7XG5cdHJldHVybiBPTy51aS5Qcm9jZXNzRGlhbG9nLnBhcmVudC5wcm90b3R5cGUuZXhlY3V0ZUFjdGlvbi5jYWxsKCB0aGlzLCBhY3Rpb24gKVxuXHRcdC5mYWlsKCBmdW5jdGlvbiAoIGVycm9ycyApIHtcblx0XHRcdHByb2Nlc3Muc2hvd0Vycm9ycyggZXJyb3JzIHx8IFtdICk7XG5cdFx0fSApO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdGRvY1xuICovXG5PTy51aS5Qcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZGlhbG9nID0gdGhpcztcblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdE9PLnVpLlByb2Nlc3NEaWFsb2cucGFyZW50LnByb3RvdHlwZS5zZXREaW1lbnNpb25zLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHR0aGlzLmZpdExhYmVsKCk7XG5cblx0Ly8gSWYgdGhlcmUgYXJlIG1hbnkgYWN0aW9ucywgdGhleSBtaWdodCBiZSBzaG93biBvbiBtdWx0aXBsZSBsaW5lcy4gVGhlaXIgbGF5b3V0IGNhbiBjaGFuZ2Ugd2hlblxuXHQvLyByZXNpemluZyB0aGUgZGlhbG9nIGFuZCB3aGVuIGNoYW5naW5nIHRoZSBhY3Rpb25zLiBBZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgZm9vdGVyIHRvIGZpdCB0aGVtLlxuXHRkaWFsb2cuJGJvZHkuY3NzKCAnYm90dG9tJywgZGlhbG9nLiRmb290Lm91dGVySGVpZ2h0KCB0cnVlICkgKTtcblx0Ly8gV2FpdCBmb3IgQ1NTIHRyYW5zaXRpb24gdG8gZmluaXNoIGFuZCBkbyBpdCBhZ2FpbiA6KFxuXHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0ZGlhbG9nLiRib2R5LmNzcyggJ2JvdHRvbScsIGRpYWxvZy4kZm9vdC5vdXRlckhlaWdodCggdHJ1ZSApICk7XG5cdH0sIDMwMCApO1xufTtcblxuLyoqXG4gKiBGaXQgbGFiZWwgYmV0d2VlbiBhY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBAcmV0dXJuIHtPTy51aS5NZXNzYWdlRGlhbG9nfSBUaGUgZGlhbG9nLCBmb3IgY2hhaW5pbmdcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuZml0TGFiZWwgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzYWZlV2lkdGgsIHByaW1hcnlXaWR0aCwgYmlnZ2VyV2lkdGgsIGxhYmVsV2lkdGgsIG5hdmlnYXRpb25XaWR0aCwgbGVmdFdpZHRoLCByaWdodFdpZHRoLFxuXHRcdHNpemUgPSB0aGlzLmdldFNpemVQcm9wZXJ0aWVzKCk7XG5cblx0aWYgKCB0eXBlb2Ygc2l6ZS53aWR0aCAhPT0gJ251bWJlcicgKSB7XG5cdFx0aWYgKCB0aGlzLmlzT3BlbmVkKCkgKSB7XG5cdFx0XHRuYXZpZ2F0aW9uV2lkdGggPSB0aGlzLiRoZWFkLndpZHRoKCkgLSAyMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmlzT3BlbmluZygpICkge1xuXHRcdFx0aWYgKCAhdGhpcy5maXRPbk9wZW4gKSB7XG5cdFx0XHRcdC8vIFNpemUgaXMgcmVsYXRpdmUgYW5kIHRoZSBkaWFsb2cgaXNuJ3Qgb3BlbiB5ZXQsIHNvIHdhaXQuXG5cdFx0XHRcdC8vIEZJWE1FOiBUaGlzIHNob3VsZCBpZGVhbGx5IGJlIGhhbmRsZWQgYnkgc2V0dXAgc29tZWhvdy5cblx0XHRcdFx0dGhpcy5tYW5hZ2VyLmxpZmVjeWNsZS5vcGVuZWQuZG9uZSggdGhpcy5maXRMYWJlbC5iaW5kKCB0aGlzICkgKTtcblx0XHRcdFx0dGhpcy5maXRPbk9wZW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdG5hdmlnYXRpb25XaWR0aCA9IHNpemUud2lkdGggLSAyMDtcblx0fVxuXG5cdHNhZmVXaWR0aCA9IHRoaXMuJHNhZmVBY3Rpb25zLmlzKCAnOnZpc2libGUnICkgPyB0aGlzLiRzYWZlQWN0aW9ucy53aWR0aCgpIDogMDtcblx0cHJpbWFyeVdpZHRoID0gdGhpcy4kcHJpbWFyeUFjdGlvbnMuaXMoICc6dmlzaWJsZScgKSA/IHRoaXMuJHByaW1hcnlBY3Rpb25zLndpZHRoKCkgOiAwO1xuXHRiaWdnZXJXaWR0aCA9IE1hdGgubWF4KCBzYWZlV2lkdGgsIHByaW1hcnlXaWR0aCApO1xuXG5cdGxhYmVsV2lkdGggPSB0aGlzLnRpdGxlLiRlbGVtZW50LndpZHRoKCk7XG5cblx0aWYgKCAyICogYmlnZ2VyV2lkdGggKyBsYWJlbFdpZHRoIDwgbmF2aWdhdGlvbldpZHRoICkge1xuXHRcdC8vIFdlIGhhdmUgZW5vdWdoIHNwYWNlIHRvIGNlbnRlciB0aGUgbGFiZWxcblx0XHRsZWZ0V2lkdGggPSByaWdodFdpZHRoID0gYmlnZ2VyV2lkdGg7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gTGV0J3MgaG9wZSB3ZSBhdCBsZWFzdCBoYXZlIGVub3VnaCBzcGFjZSBub3QgdG8gb3ZlcmxhcCwgYmVjYXVzZSB3ZSBjYW4ndCB3cmFwIHRoZSBsYWJlbOKAplxuXHRcdGlmICggdGhpcy5nZXREaXIoKSA9PT0gJ2x0cicgKSB7XG5cdFx0XHRsZWZ0V2lkdGggPSBzYWZlV2lkdGg7XG5cdFx0XHRyaWdodFdpZHRoID0gcHJpbWFyeVdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZWZ0V2lkdGggPSBwcmltYXJ5V2lkdGg7XG5cdFx0XHRyaWdodFdpZHRoID0gc2FmZVdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuJGxvY2F0aW9uLmNzcyggeyBwYWRkaW5nTGVmdDogbGVmdFdpZHRoLCBwYWRkaW5nUmlnaHQ6IHJpZ2h0V2lkdGggfSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgZXJyb3JzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGFjY2VwdCBvciByZWplY3QgcHJvY2Vzc2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09PLnVpLkVycm9yW118T08udWkuRXJyb3J9IGVycm9ycyBFcnJvcnMgdG8gYmUgaGFuZGxlZFxuICovXG5PTy51aS5Qcm9jZXNzRGlhbG9nLnByb3RvdHlwZS5zaG93RXJyb3JzID0gZnVuY3Rpb24gKCBlcnJvcnMgKSB7XG5cdHZhciBpLCBsZW4sICRpdGVtLCBhY3Rpb25zLFxuXHRcdGl0ZW1zID0gW10sXG5cdFx0YWJpbGl0aWVzID0ge30sXG5cdFx0cmVjb3ZlcmFibGUgPSB0cnVlLFxuXHRcdHdhcm5pbmcgPSBmYWxzZTtcblxuXHRpZiAoIGVycm9ycyBpbnN0YW5jZW9mIE9PLnVpLkVycm9yICkge1xuXHRcdGVycm9ycyA9IFsgZXJyb3JzIF07XG5cdH1cblxuXHRmb3IgKCBpID0gMCwgbGVuID0gZXJyb3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggIWVycm9yc1sgaSBdLmlzUmVjb3ZlcmFibGUoKSApIHtcblx0XHRcdHJlY292ZXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICggZXJyb3JzWyBpIF0uaXNXYXJuaW5nKCkgKSB7XG5cdFx0XHR3YXJuaW5nID0gdHJ1ZTtcblx0XHR9XG5cdFx0JGl0ZW0gPSAkKCAnPGRpdj4nIClcblx0XHRcdC5hZGRDbGFzcyggJ29vLXVpLXByb2Nlc3NEaWFsb2ctZXJyb3InIClcblx0XHRcdC5hcHBlbmQoIGVycm9yc1sgaSBdLmdldE1lc3NhZ2UoKSApO1xuXHRcdGl0ZW1zLnB1c2goICRpdGVtWyAwIF0gKTtcblx0fVxuXHR0aGlzLiRlcnJvckl0ZW1zID0gJCggaXRlbXMgKTtcblx0aWYgKCByZWNvdmVyYWJsZSApIHtcblx0XHRhYmlsaXRpZXNbIHRoaXMuY3VycmVudEFjdGlvbiBdID0gdHJ1ZTtcblx0XHQvLyBDb3B5IHRoZSBmbGFncyBmcm9tIHRoZSBmaXJzdCBtYXRjaGluZyBhY3Rpb25cblx0XHRhY3Rpb25zID0gdGhpcy5hY3Rpb25zLmdldCggeyBhY3Rpb25zOiB0aGlzLmN1cnJlbnRBY3Rpb24gfSApO1xuXHRcdGlmICggYWN0aW9ucy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLnJldHJ5QnV0dG9uLmNsZWFyRmxhZ3MoKS5zZXRGbGFncyggYWN0aW9uc1sgMCBdLmdldEZsYWdzKCkgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0YWJpbGl0aWVzWyB0aGlzLmN1cnJlbnRBY3Rpb24gXSA9IGZhbHNlO1xuXHRcdHRoaXMuYWN0aW9ucy5zZXRBYmlsaXRpZXMoIGFiaWxpdGllcyApO1xuXHR9XG5cdGlmICggd2FybmluZyApIHtcblx0XHR0aGlzLnJldHJ5QnV0dG9uLnNldExhYmVsKCBPTy51aS5tc2coICdvb3VpLWRpYWxvZy1wcm9jZXNzLWNvbnRpbnVlJyApICk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5yZXRyeUJ1dHRvbi5zZXRMYWJlbCggT08udWkubXNnKCAnb291aS1kaWFsb2ctcHJvY2Vzcy1yZXRyeScgKSApO1xuXHR9XG5cdHRoaXMucmV0cnlCdXR0b24udG9nZ2xlKCByZWNvdmVyYWJsZSApO1xuXHR0aGlzLiRlcnJvcnNUaXRsZS5hZnRlciggdGhpcy4kZXJyb3JJdGVtcyApO1xuXHR0aGlzLiRlcnJvcnMucmVtb3ZlQ2xhc3MoICdvby11aS1lbGVtZW50LWhpZGRlbicgKS5zY3JvbGxUb3AoIDAgKTtcbn07XG5cbi8qKlxuICogSGlkZSBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuT08udWkuUHJvY2Vzc0RpYWxvZy5wcm90b3R5cGUuaGlkZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy4kZXJyb3JzLmFkZENsYXNzKCAnb28tdWktZWxlbWVudC1oaWRkZW4nICk7XG5cdGlmICggdGhpcy4kZXJyb3JJdGVtcyApIHtcblx0XHR0aGlzLiRlcnJvckl0ZW1zLnJlbW92ZSgpO1xuXHRcdHRoaXMuJGVycm9ySXRlbXMgPSBudWxsO1xuXHR9XG59O1xuXG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbk9PLnVpLlByb2Nlc3NEaWFsb2cucHJvdG90eXBlLmdldFRlYXJkb3duUHJvY2VzcyA9IGZ1bmN0aW9uICggZGF0YSApIHtcblx0Ly8gUGFyZW50IG1ldGhvZFxuXHRyZXR1cm4gT08udWkuUHJvY2Vzc0RpYWxvZy5wYXJlbnQucHJvdG90eXBlLmdldFRlYXJkb3duUHJvY2Vzcy5jYWxsKCB0aGlzLCBkYXRhIClcblx0XHQuZmlyc3QoIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0byBoaWRlIGVycm9yc1xuXHRcdFx0dGhpcy5oaWRlRXJyb3JzKCk7XG5cdFx0XHR0aGlzLmZpdE9uT3BlbiA9IGZhbHNlO1xuXHRcdH0sIHRoaXMgKTtcbn07XG5cbi8qKlxuICogQGNsYXNzIE9PLnVpXG4gKi9cblxuLyoqXG4gKiBMYXp5LWluaXRpYWxpemUgYW5kIHJldHVybiBhIGdsb2JhbCBPTy51aS5XaW5kb3dNYW5hZ2VyIGluc3RhbmNlLCB1c2VkIGJ5IE9PLnVpLmFsZXJ0IGFuZFxuICogT08udWkuY29uZmlybS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7T08udWkuV2luZG93TWFuYWdlcn1cbiAqL1xuT08udWkuZ2V0V2luZG93TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCAhT08udWkud2luZG93TWFuYWdlciApIHtcblx0XHRPTy51aS53aW5kb3dNYW5hZ2VyID0gbmV3IE9PLnVpLldpbmRvd01hbmFnZXIoKTtcblx0XHQkKCBkb2N1bWVudC5ib2R5ICkuYXBwZW5kKCBPTy51aS53aW5kb3dNYW5hZ2VyLiRlbGVtZW50ICk7XG5cdFx0T08udWkud2luZG93TWFuYWdlci5hZGRXaW5kb3dzKCBbIG5ldyBPTy51aS5NZXNzYWdlRGlhbG9nKCkgXSApO1xuXHR9XG5cdHJldHVybiBPTy51aS53aW5kb3dNYW5hZ2VyO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgcXVpY2sgbW9kYWwgYWxlcnQgZGlhbG9nLCB1c2luZyBhIE9PLnVpLk1lc3NhZ2VEaWFsb2cuIFdoaWxlIHRoZSBkaWFsb2cgaXMgb3BlbiwgdGhlXG4gKiByZXN0IG9mIHRoZSBwYWdlIHdpbGwgYmUgZGltbWVkIG91dCBhbmQgdGhlIHVzZXIgd29uJ3QgYmUgYWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0LiBUaGUgZGlhbG9nXG4gKiBoYXMgb25seSBvbmUgYWN0aW9uIGJ1dHRvbiwgbGFiZWxsZWQgXCJPS1wiLCBjbGlja2luZyBpdCB3aWxsIHNpbXBseSBjbG9zZSB0aGUgZGlhbG9nLlxuICpcbiAqIEEgd2luZG93IG1hbmFnZXIgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIE9PLnVpLmFsZXJ0KCAnU29tZXRoaW5nIGhhcHBlbmVkIScgKS5kb25lKCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCAnVXNlciBjbG9zZWQgdGhlIGRpYWxvZy4nICk7XG4gKiAgICAgfSApO1xuICpcbiAqICAgICBPTy51aS5hbGVydCggJ1NvbWV0aGluZyBsYXJnZXIgaGFwcGVuZWQhJywgeyBzaXplOiAnbGFyZ2UnIH0gKTtcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeXxzdHJpbmd9IHRleHQgTWVzc2FnZSB0ZXh0IHRvIGRpc3BsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLCBzZWUgT08udWkuTWVzc2FnZURpYWxvZyNnZXRTZXR1cFByb2Nlc3NcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2dcbiAqL1xuT08udWkuYWxlcnQgPSBmdW5jdGlvbiAoIHRleHQsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBPTy51aS5nZXRXaW5kb3dNYW5hZ2VyKCkub3BlbldpbmRvdyggJ21lc3NhZ2UnLCAkLmV4dGVuZCgge1xuXHRcdG1lc3NhZ2U6IHRleHQsXG5cdFx0YWN0aW9uczogWyBPTy51aS5NZXNzYWdlRGlhbG9nLnN0YXRpYy5hY3Rpb25zWyAwIF0gXVxuXHR9LCBvcHRpb25zICkgKS5jbG9zZWQudGhlbiggZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH0gKTtcbn07XG5cbi8qKlxuICogRGlzcGxheSBhIHF1aWNrIG1vZGFsIGNvbmZpcm1hdGlvbiBkaWFsb2csIHVzaW5nIGEgT08udWkuTWVzc2FnZURpYWxvZy4gV2hpbGUgdGhlIGRpYWxvZyBpcyBvcGVuLFxuICogdGhlIHJlc3Qgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBkaW1tZWQgb3V0IGFuZCB0aGUgdXNlciB3b24ndCBiZSBhYmxlIHRvIGludGVyYWN0IHdpdGggaXQuIFRoZVxuICogZGlhbG9nIGhhcyB0d28gYWN0aW9uIGJ1dHRvbnMsIG9uZSB0byBjb25maXJtIGFuIG9wZXJhdGlvbiAobGFiZWxsZWQgXCJPS1wiKSBhbmQgb25lIHRvIGNhbmNlbCBpdFxuICogKGxhYmVsbGVkIFwiQ2FuY2VsXCIpLlxuICpcbiAqIEEgd2luZG93IG1hbmFnZXIgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICpcbiAqICAgICBAZXhhbXBsZVxuICogICAgIE9PLnVpLmNvbmZpcm0oICdBcmUgeW91IHN1cmU/JyApLmRvbmUoIGZ1bmN0aW9uICggY29uZmlybWVkICkge1xuICogICAgICAgICBpZiAoIGNvbmZpcm1lZCApIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnVXNlciBjbGlja2VkIFwiT0tcIiEnICk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ1VzZXIgY2xpY2tlZCBcIkNhbmNlbFwiIG9yIGNsb3NlZCB0aGUgZGlhbG9nLicgKTtcbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeXxzdHJpbmd9IHRleHQgTWVzc2FnZSB0ZXh0IHRvIGRpc3BsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLCBzZWUgT08udWkuTWVzc2FnZURpYWxvZyNnZXRTZXR1cFByb2Nlc3NcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2cuIElmIHRoZSB1c2VyIGNob3NlIHRvXG4gKiAgY29uZmlybSwgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGJvb2xlYW4gYHRydWVgOyBvdGhlcndpc2UsIGl0IHdpbGwgcmVzb2x2ZSB0byBib29sZWFuXG4gKiAgYGZhbHNlYC5cbiAqL1xuT08udWkuY29uZmlybSA9IGZ1bmN0aW9uICggdGV4dCwgb3B0aW9ucyApIHtcblx0cmV0dXJuIE9PLnVpLmdldFdpbmRvd01hbmFnZXIoKS5vcGVuV2luZG93KCAnbWVzc2FnZScsICQuZXh0ZW5kKCB7XG5cdFx0bWVzc2FnZTogdGV4dFxuXHR9LCBvcHRpb25zICkgKS5jbG9zZWQudGhlbiggZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHJldHVybiAhISggZGF0YSAmJiBkYXRhLmFjdGlvbiA9PT0gJ2FjY2VwdCcgKTtcblx0fSApO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgcXVpY2sgbW9kYWwgcHJvbXB0IGRpYWxvZywgdXNpbmcgYSBPTy51aS5NZXNzYWdlRGlhbG9nLiBXaGlsZSB0aGUgZGlhbG9nIGlzIG9wZW4sXG4gKiB0aGUgcmVzdCBvZiB0aGUgcGFnZSB3aWxsIGJlIGRpbW1lZCBvdXQgYW5kIHRoZSB1c2VyIHdvbid0IGJlIGFibGUgdG8gaW50ZXJhY3Qgd2l0aCBpdC4gVGhlXG4gKiBkaWFsb2cgaGFzIGEgdGV4dCBpbnB1dCB3aWRnZXQgYW5kIHR3byBhY3Rpb24gYnV0dG9ucywgb25lIHRvIGNvbmZpcm0gYW4gb3BlcmF0aW9uIChsYWJlbGxlZCBcIk9LXCIpXG4gKiBhbmQgb25lIHRvIGNhbmNlbCBpdCAobGFiZWxsZWQgXCJDYW5jZWxcIikuXG4gKlxuICogQSB3aW5kb3cgbWFuYWdlciBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gKlxuICogICAgIEBleGFtcGxlXG4gKiAgICAgT08udWkucHJvbXB0KCAnQ2hvb3NlIGEgbGluZSB0byBnbyB0bycsIHsgdGV4dElucHV0OiB7IHBsYWNlaG9sZGVyOiAnTGluZSBudW1iZXInIH0gfSApLmRvbmUoIGZ1bmN0aW9uICggcmVzdWx0ICkge1xuICogICAgICAgICBpZiAoIHJlc3VsdCAhPT0gbnVsbCApIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnVXNlciB0eXBlZCBcIicgKyByZXN1bHQgKyAnXCIgdGhlbiBjbGlja2VkIFwiT0tcIi4nICk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ1VzZXIgY2xpY2tlZCBcIkNhbmNlbFwiIG9yIGNsb3NlZCB0aGUgZGlhbG9nLicgKTtcbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeXxzdHJpbmd9IHRleHQgTWVzc2FnZSB0ZXh0IHRvIGRpc3BsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLCBzZWUgT08udWkuTWVzc2FnZURpYWxvZyNnZXRTZXR1cFByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0SW5wdXRdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGV4dCBpbnB1dCB3aWRnZXQsIHNlZSBPTy51aS5UZXh0SW5wdXRXaWRnZXRcbiAqIEByZXR1cm4ge2pRdWVyeS5Qcm9taXNlfSBQcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2cuIElmIHRoZSB1c2VyIGNob3NlIHRvXG4gKiAgY29uZmlybSwgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIHdpdGggdGhlIHZhbHVlIG9mIHRoZSB0ZXh0IGlucHV0IHdpZGdldDsgb3RoZXJ3aXNlLCBpdCB3aWxsXG4gKiAgcmVzb2x2ZSB0byBgbnVsbGAuXG4gKi9cbk9PLnVpLnByb21wdCA9IGZ1bmN0aW9uICggdGV4dCwgb3B0aW9ucyApIHtcblx0dmFyIGluc3RhbmNlLFxuXHRcdG1hbmFnZXIgPSBPTy51aS5nZXRXaW5kb3dNYW5hZ2VyKCksXG5cdFx0dGV4dElucHV0ID0gbmV3IE9PLnVpLlRleHRJbnB1dFdpZGdldCggKCBvcHRpb25zICYmIG9wdGlvbnMudGV4dElucHV0ICkgfHwge30gKSxcblx0XHR0ZXh0RmllbGQgPSBuZXcgT08udWkuRmllbGRMYXlvdXQoIHRleHRJbnB1dCwge1xuXHRcdFx0YWxpZ246ICd0b3AnLFxuXHRcdFx0bGFiZWw6IHRleHRcblx0XHR9ICk7XG5cblx0aW5zdGFuY2UgPSBtYW5hZ2VyLm9wZW5XaW5kb3coICdtZXNzYWdlJywgJC5leHRlbmQoIHtcblx0XHRtZXNzYWdlOiB0ZXh0RmllbGQuJGVsZW1lbnRcblx0fSwgb3B0aW9ucyApICk7XG5cblx0Ly8gVE9ETzogVGhpcyBpcyBhIGxpdHRsZSBoYWNreSwgYW5kIGNvdWxkIGJlIGRvbmUgYnkgZXh0ZW5kaW5nIE1lc3NhZ2VEaWFsb2cgaW5zdGVhZC5cblx0aW5zdGFuY2Uub3BlbmVkLnRoZW4oIGZ1bmN0aW9uICgpIHtcblx0XHR0ZXh0SW5wdXQub24oICdlbnRlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdG1hbmFnZXIuZ2V0Q3VycmVudFdpbmRvdygpLmNsb3NlKCB7IGFjdGlvbjogJ2FjY2VwdCcgfSApO1xuXHRcdH0gKTtcblx0XHR0ZXh0SW5wdXQuZm9jdXMoKTtcblx0fSApO1xuXG5cdHJldHVybiBpbnN0YW5jZS5jbG9zZWQudGhlbiggZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhICYmIGRhdGEuYWN0aW9uID09PSAnYWNjZXB0JyA/IHRleHRJbnB1dC5nZXRWYWx1ZSgpIDogbnVsbDtcblx0fSApO1xufTtcblxufSggT08gKSApO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vb2pzLXVpLXdpbmRvd3MuanMubWFwLmpzb24iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLi4vYXNzZXRzL2ltYWdlcy9tYXBQaW4uYTMwNmI2YWIuc3ZnXCI7IiwiLyohXG4gKiBPT2pzIHYyLjIuMlxuICogaHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE4IE9PanMgVGVhbSBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL29vanMubWl0LWxpY2Vuc2Uub3JnXG4gKlxuICogRGF0ZTogMjAxOC0wNi0xNFQyMDoxMzoxNFpcbiAqL1xuKCBmdW5jdGlvbiAoIGdsb2JhbCApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBleHBvcnRlZCB0b1N0cmluZyAqL1xudmFyXG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgZm9yIGFsbCBjbGFzc2VzLCBzdGF0aWMgbWV0aG9kcyBhbmQgc3RhdGljIHByb3BlcnRpZXMuXG5cdCAqIEBjbGFzcyBPT1xuXHQgKiBAc2luZ2xldG9uXG5cdCAqL1xuXHRvbyA9IHt9LFxuXHQvLyBPcHRpbWlzYXRpb246IExvY2FsIHJlZmVyZW5jZSB0byBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cdGhhc093biA9IG9vLmhhc093blByb3BlcnR5LFxuXHR0b1N0cmluZyA9IG9vLnRvU3RyaW5nO1xuXG4vKiBDbGFzcyBNZXRob2RzICovXG5cbi8qKlxuICogVXRpbGl0eSB0byBpbml0aWFsaXplIGEgY2xhc3MgZm9yIE9PIGluaGVyaXRhbmNlLlxuICpcbiAqIEN1cnJlbnRseSB0aGlzIGp1c3QgaW5pdGlhbGl6ZXMgYW4gZW1wdHkgc3RhdGljIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5vby5pbml0Q2xhc3MgPSBmdW5jdGlvbiAoIGZuICkge1xuXHRmbi5zdGF0aWMgPSBmbi5zdGF0aWMgfHwge307XG59O1xuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBwcm90b3R5cGUgdG8gYW5vdGhlciB1c2luZyBPYmplY3QjY3JlYXRlLlxuICpcbiAqIEJld2FyZTogVGhpcyByZWRlZmluZXMgdGhlIHByb3RvdHlwZSwgY2FsbCBiZWZvcmUgc2V0dGluZyB5b3VyIHByb3RvdHlwZXMuXG4gKlxuICogQmV3YXJlOiBUaGlzIHJlZGVmaW5lcyB0aGUgcHJvdG90eXBlLCBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBvbiBhIGZ1bmN0aW9uLlxuICogSWYgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGZ1bmN0aW9uLCB0aGUgcHJldmlvdXMgcHJvdG90eXBlIGlzIGxvc3QuXG4gKiBUaGlzIGlzIGhvdyBwcm90b3R5cGFsIGluaGVyaXRhbmNlIHdvcmtzLCBpdCBjYW4gb25seSBiZSBvbmUgc3RyYWlnaHQgY2hhaW5cbiAqIChqdXN0IGxpa2UgY2xhc3NpY2FsIGluaGVyaXRhbmNlIGluIFBIUCBmb3IgZXhhbXBsZSkuIElmIHlvdSBuZWVkIHRvIHdvcmsgd2l0aFxuICogbXVsdGlwbGUgY29uc3RydWN0b3JzIGNvbnNpZGVyIHN0b3JpbmcgYW4gaW5zdGFuY2Ugb2YgdGhlIG90aGVyIGNvbnN0cnVjdG9yIGluIGFcbiAqIHByb3BlcnR5IGluc3RlYWQsIG9yIHBlcmhhcHMgdXNlIGEgbWl4aW4gKHNlZSBPTy5taXhpbkNsYXNzKS5cbiAqXG4gKiAgICAgZnVuY3Rpb24gVGhpbmcoKSB7fVxuICogICAgIFRoaW5nLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAoKSB7fTtcbiAqXG4gKiAgICAgZnVuY3Rpb24gUGVyc29uKCkge1xuICogICAgICAgICBQZXJzb24uc3VwZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICogICAgIH1cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIFBlcnNvbiwgVGhpbmcgKTtcbiAqICAgICBQZXJzb24uc3RhdGljLmRlZmF1bHRFeWVDb3VudCA9IDI7XG4gKiAgICAgUGVyc29uLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKCkge307XG4gKlxuICogICAgIGZ1bmN0aW9uIEp1bXBlcigpIHtcbiAqICAgICAgICAgSnVtcGVyLnN1cGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAqICAgICB9XG4gKiAgICAgT08uaW5oZXJpdENsYXNzKCBKdW1wZXIsIFBlcnNvbiApO1xuICogICAgIEp1bXBlci5wcm90b3R5cGUuanVtcCA9IGZ1bmN0aW9uICgpIHt9O1xuICpcbiAqICAgICBKdW1wZXIuc3RhdGljLmRlZmF1bHRFeWVDb3VudCA9PT0gMjtcbiAqICAgICB2YXIgeCA9IG5ldyBKdW1wZXIoKTtcbiAqICAgICB4Lmp1bXAoKTtcbiAqICAgICB4LndhbGsoKTtcbiAqICAgICB4IGluc3RhbmNlb2YgVGhpbmcgJiYgeCBpbnN0YW5jZW9mIFBlcnNvbiAmJiB4IGluc3RhbmNlb2YgSnVtcGVyO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhcmdldEZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcmlnaW5GblxuICogQHRocm93cyB7RXJyb3J9IElmIHRhcmdldCBhbHJlYWR5IGluaGVyaXRzIGZyb20gb3JpZ2luXG4gKi9cbm9vLmluaGVyaXRDbGFzcyA9IGZ1bmN0aW9uICggdGFyZ2V0Rm4sIG9yaWdpbkZuICkge1xuXHR2YXIgdGFyZ2V0Q29uc3RydWN0b3I7XG5cblx0aWYgKCAhb3JpZ2luRm4gKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnaW5oZXJpdENsYXNzOiBPcmlnaW4gaXMgbm90IGEgZnVuY3Rpb24gKGFjdHVhbGx5ICcgKyBvcmlnaW5GbiArICcpJyApO1xuXHR9XG5cdGlmICggdGFyZ2V0Rm4ucHJvdG90eXBlIGluc3RhbmNlb2Ygb3JpZ2luRm4gKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnaW5oZXJpdENsYXNzOiBUYXJnZXQgYWxyZWFkeSBpbmhlcml0cyBmcm9tIG9yaWdpbicgKTtcblx0fVxuXG5cdHRhcmdldENvbnN0cnVjdG9yID0gdGFyZ2V0Rm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5cdC8vIFtERVBSRUNBVEVEXSBQcm92aWRlIC5wYXJlbnQgYXMgYWxpYXMgZm9yIGNvZGUgc3VwcG9ydGluZyBvbGRlciBicm93c2VycyB3aGljaFxuXHQvLyBhbGxvd3MgcGVvcGxlIHRvIGNvbXBseSB3aXRoIHRoZWlyIHN0eWxlIGd1aWRlLlxuXHR0YXJnZXRGbi5zdXBlciA9IHRhcmdldEZuLnBhcmVudCA9IG9yaWdpbkZuO1xuXG5cdHRhcmdldEZuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIG9yaWdpbkZuLnByb3RvdHlwZSwge1xuXHRcdC8vIFJlc3RvcmUgY29uc3RydWN0b3IgcHJvcGVydHkgb2YgdGFyZ2V0Rm5cblx0XHRjb25zdHJ1Y3Rvcjoge1xuXHRcdFx0dmFsdWU6IHRhcmdldENvbnN0cnVjdG9yLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH1cblx0fSApO1xuXG5cdC8vIEV4dGVuZCBzdGF0aWMgcHJvcGVydGllcyAtIGFsd2F5cyBpbml0aWFsaXplIGJvdGggc2lkZXNcblx0b28uaW5pdENsYXNzKCBvcmlnaW5GbiApO1xuXHR0YXJnZXRGbi5zdGF0aWMgPSBPYmplY3QuY3JlYXRlKCBvcmlnaW5Gbi5zdGF0aWMgKTtcbn07XG5cbi8qKlxuICogQ29weSBvdmVyICpvd24qIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9mIGEgbWl4aW4uXG4gKlxuICogVGhlICdjb25zdHJ1Y3RvcicgKHdoZXRoZXIgaW1wbGljaXQgb3IgZXhwbGljaXQpIGlzIG5vdCBjb3BpZWQgb3Zlci5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IGNyZWF0ZSBpbmhlcml0YW5jZSB0byB0aGUgb3JpZ2luLiBJZiB5b3UgbmVlZCBpbmhlcml0YW5jZSxcbiAqIHVzZSBPTy5pbmhlcml0Q2xhc3MgaW5zdGVhZC5cbiAqXG4gKiBCZXdhcmU6IFRoaXMgY2FuIHJlZGVmaW5lIGEgcHJvdG90eXBlIHByb3BlcnR5LCBjYWxsIGJlZm9yZSBzZXR0aW5nIHlvdXIgcHJvdG90eXBlcy5cbiAqXG4gKiBCZXdhcmU6IERvbid0IGNhbGwgYmVmb3JlIE9PLmluaGVyaXRDbGFzcy5cbiAqXG4gKiAgICAgZnVuY3Rpb24gRm9vKCkge31cbiAqICAgICBmdW5jdGlvbiBDb250ZXh0KCkge31cbiAqXG4gKiAgICAgLy8gQXZvaWQgcmVwZWF0aW5nIHRoaXMgY29kZVxuICogICAgIGZ1bmN0aW9uIENvbnRleHRMYXp5TG9hZCgpIHt9XG4gKiAgICAgQ29udGV4dExhenlMb2FkLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICogICAgICAgICBpZiAoICF0aGlzLmNvbnRleHQgKSB7XG4gKiAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZnVuY3Rpb24gRm9vQmFyKCkge31cbiAqICAgICBPTy5pbmhlcml0Q2xhc3MoIEZvb0JhciwgRm9vICk7XG4gKiAgICAgT08ubWl4aW5DbGFzcyggRm9vQmFyLCBDb250ZXh0TGF6eUxvYWQgKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXJnZXRGblxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luRm5cbiAqL1xub28ubWl4aW5DbGFzcyA9IGZ1bmN0aW9uICggdGFyZ2V0Rm4sIG9yaWdpbkZuICkge1xuXHR2YXIga2V5O1xuXG5cdGlmICggIW9yaWdpbkZuICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ21peGluQ2xhc3M6IE9yaWdpbiBpcyBub3QgYSBmdW5jdGlvbiAoYWN0dWFsbHkgJyArIG9yaWdpbkZuICsgJyknICk7XG5cdH1cblxuXHQvLyBDb3B5IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG5cdGZvciAoIGtleSBpbiBvcmlnaW5Gbi5wcm90b3R5cGUgKSB7XG5cdFx0aWYgKCBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgaGFzT3duLmNhbGwoIG9yaWdpbkZuLnByb3RvdHlwZSwga2V5ICkgKSB7XG5cdFx0XHR0YXJnZXRGbi5wcm90b3R5cGVbIGtleSBdID0gb3JpZ2luRm4ucHJvdG90eXBlWyBrZXkgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBDb3B5IHN0YXRpYyBwcm9wZXJ0aWVzIC0gYWx3YXlzIGluaXRpYWxpemUgYm90aCBzaWRlc1xuXHRvby5pbml0Q2xhc3MoIHRhcmdldEZuICk7XG5cdGlmICggb3JpZ2luRm4uc3RhdGljICkge1xuXHRcdGZvciAoIGtleSBpbiBvcmlnaW5Gbi5zdGF0aWMgKSB7XG5cdFx0XHRpZiAoIGhhc093bi5jYWxsKCBvcmlnaW5Gbi5zdGF0aWMsIGtleSApICkge1xuXHRcdFx0XHR0YXJnZXRGbi5zdGF0aWNbIGtleSBdID0gb3JpZ2luRm4uc3RhdGljWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0b28uaW5pdENsYXNzKCBvcmlnaW5GbiApO1xuXHR9XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBvbmUgY2xhc3MgaXMgYSBzdWJjbGFzcyBvZiBhbm90aGVyLCB3aXRob3V0IGluc3RhbnRpYXRpbmcgaXQuXG4gKlxuICogRXZlcnkgY2xhc3MgaXMgY29uc2lkZXJlZCBhIHN1YmNsYXNzIG9mIE9iamVjdCBhbmQgb2YgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3RGbiBUaGUgY2xhc3MgdG8gYmUgdGVzdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlRm4gVGhlIGJhc2UgY2xhc3NcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGVzdEZuIGlzIGEgc3ViY2xhc3Mgb2YgYmFzZUZuIChvciBlcXVhbCB0byBpdClcbiAqL1xub28uaXNTdWJjbGFzcyA9IGZ1bmN0aW9uICggdGVzdEZuLCBiYXNlRm4gKSB7XG5cdHJldHVybiB0ZXN0Rm4gPT09IGJhc2VGbiB8fCB0ZXN0Rm4ucHJvdG90eXBlIGluc3RhbmNlb2YgYmFzZUZuO1xufTtcblxuLyogT2JqZWN0IE1ldGhvZHMgKi9cblxuLyoqXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHByb3BlcnR5IG9mIGFuIG9iamVjdCB1c2luZyB2YXJpYWRpYyBhcmd1bWVudHMsIHByb3RlY3RpbmcgYWdhaW5zdFxuICogdW5kZWZpbmVkIHByb3BlcnR5IGVycm9ycy5cbiAqXG4gKiBgcXV1eCA9IE9PLmdldFByb3AoIG9iaiwgJ2ZvbycsICdiYXInLCAnYmF6JyApO2AgaXMgZXF1aXZhbGVudCB0byBgcXV1eCA9IG9iai5mb28uYmFyLmJhejtgXG4gKiBleGNlcHQgdGhhdCB0aGUgZm9ybWVyIHByb3RlY3RzIGFnYWluc3QgSlMgZXJyb3JzIGlmIG9uZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHByb3BlcnRpZXNcbiAqIGlzIHVuZGVmaW5lZC4gSW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB1bmRlZmluZWQgaW5cbiAqIHRoYXQgY2FzZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gey4uLk1peGVkfSBba2V5c11cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IG9ialthcmd1bWVudHNbMV1dW2FyZ3VtZW50c1syXV0uLi4uIG9yIHVuZGVmaW5lZFxuICovXG5vby5nZXRQcm9wID0gZnVuY3Rpb24gKCBvYmogKSB7XG5cdHZhciBpLFxuXHRcdHJldHZhbCA9IG9iajtcblx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0aWYgKCByZXR2YWwgPT09IHVuZGVmaW5lZCB8fCByZXR2YWwgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBUcnlpbmcgdG8gYWNjZXNzIGEgcHJvcGVydHkgb2YgdW5kZWZpbmVkIG9yIG51bGwgY2F1c2VzIGFuIGVycm9yXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR2YWwgPSByZXR2YWxbIGFyZ3VtZW50c1sgaSBdIF07XG5cdH1cblx0cmV0dXJuIHJldHZhbDtcbn07XG5cbi8qKlxuICogU2V0IGEgZGVlcGx5IG5lc3RlZCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdXNpbmcgdmFyaWFkaWMgYXJndW1lbnRzLCBwcm90ZWN0aW5nIGFnYWluc3RcbiAqIHVuZGVmaW5lZCBwcm9wZXJ0eSBlcnJvcnMuXG4gKlxuICogYG9vLnNldFByb3AoIG9iaiwgJ2ZvbycsICdiYXInLCAnYmF6JyApO2AgaXMgZXF1aXZhbGVudCB0byBgb2JqLmZvby5iYXIgPSBiYXo7YCBleGNlcHQgdGhhdFxuICogdGhlIGZvcm1lciBwcm90ZWN0cyBhZ2FpbnN0IEpTIGVycm9ycyBpZiBvbmUgb2YgdGhlIGludGVybWVkaWF0ZSBwcm9wZXJ0aWVzIGlzXG4gKiB1bmRlZmluZWQuIEluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IsIHVuZGVmaW5lZCBpbnRlcm1lZGlhdGUgcHJvcGVydGllcyB3aWxsIGJlXG4gKiBpbml0aWFsaXplZCB0byBhbiBlbXB0eSBvYmplY3QuIElmIGFuIGludGVybWVkaWF0ZSBwcm9wZXJ0eSBpcyBub3QgYW4gb2JqZWN0LCBvciBpZiBvYmogaXRzZWxmXG4gKiBpcyBub3QgYW4gb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgc2lsZW50bHkgYWJvcnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHsuLi5NaXhlZH0gW2tleXNdXG4gKiBAcGFyYW0ge01peGVkfSBbdmFsdWVdXG4gKi9cbm9vLnNldFByb3AgPSBmdW5jdGlvbiAoIG9iaiApIHtcblx0dmFyIGksXG5cdFx0cHJvcCA9IG9iajtcblx0aWYgKCBPYmplY3QoIG9iaiApICE9PSBvYmogfHwgYXJndW1lbnRzLmxlbmd0aCA8IDIgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKyApIHtcblx0XHRpZiAoIHByb3BbIGFyZ3VtZW50c1sgaSBdIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHByb3BbIGFyZ3VtZW50c1sgaSBdIF0gPSB7fTtcblx0XHR9XG5cdFx0aWYgKCBPYmplY3QoIHByb3BbIGFyZ3VtZW50c1sgaSBdIF0gKSAhPT0gcHJvcFsgYXJndW1lbnRzWyBpIF0gXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJvcCA9IHByb3BbIGFyZ3VtZW50c1sgaSBdIF07XG5cdH1cblx0cHJvcFsgYXJndW1lbnRzWyBhcmd1bWVudHMubGVuZ3RoIC0gMiBdIF0gPSBhcmd1bWVudHNbIGFyZ3VtZW50cy5sZW5ndGggLSAxIF07XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIGRlZXBseSBuZXN0ZWQgcHJvcGVydHkgb2YgYW4gb2JqZWN0IHVzaW5nIHZhcmlhZGljIGFyZ3VtZW50cywgcHJvdGVjdGluZyBhZ2FpbnN0XG4gKiB1bmRlZmluZWQgcHJvcGVydHkgZXJyb3JzLCBhbmQgZGVsZXRpbmcgcmVzdWx0aW5nIGVtcHR5IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHsuLi5NaXhlZH0gW2tleXNdXG4gKi9cbm9vLmRlbGV0ZVByb3AgPSBmdW5jdGlvbiAoIG9iaiApIHtcblx0dmFyIGksXG5cdFx0cHJvcCA9IG9iaixcblx0XHRwcm9wcyA9IFsgcHJvcCBdO1xuXHRpZiAoIE9iamVjdCggb2JqICkgIT09IG9iaiB8fCBhcmd1bWVudHMubGVuZ3RoIDwgMiApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdGlmICggcHJvcFsgYXJndW1lbnRzWyBpIF0gXSA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdCggcHJvcFsgYXJndW1lbnRzWyBpIF0gXSApICE9PSBwcm9wWyBhcmd1bWVudHNbIGkgXSBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm9wID0gcHJvcFsgYXJndW1lbnRzWyBpIF0gXTtcblx0XHRwcm9wcy5wdXNoKCBwcm9wICk7XG5cdH1cblx0ZGVsZXRlIHByb3BbIGFyZ3VtZW50c1sgaSBdIF07XG5cdC8vIFdhbGsgYmFjayB0aHJvdWdoIHByb3BzIHJlbW92aW5nIGFueSBwbGFpbiBlbXB0eSBvYmplY3RzXG5cdHdoaWxlICggcHJvcHMubGVuZ3RoID4gMSAmJiAoIHByb3AgPSBwcm9wcy5wb3AoKSApICYmIG9vLmlzUGxhaW5PYmplY3QoIHByb3AgKSAmJiAhT2JqZWN0LmtleXMoIHByb3AgKS5sZW5ndGggKSB7XG5cdFx0ZGVsZXRlIHByb3BzWyBwcm9wcy5sZW5ndGggLSAxIF1bIGFyZ3VtZW50c1sgcHJvcHMubGVuZ3RoIF0gXTtcblx0fVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHNhbWVcbiAqIGNvbnN0cnVjdG9yIGFzIHRoZSBpbnB1dCwgaW5oZXJpdHMgZnJvbSB0aGUgc2FtZSBvYmplY3RcbiAqIGFuZCBjb250YWlucyB0aGUgc2FtZSBvd24gcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBub24tcmVjdXJzaXZlIGNvcHkgb2Ygb3duIHByb3BlcnRpZXMuXG4gKiBUbyBjcmVhdGUgYSByZWN1cnNpdmUgY29weSBvZiBwbGFpbiBvYmplY3RzLCB1c2UgI2NvcHkuXG4gKlxuICogICAgIHZhciBmb28gPSBuZXcgUGVyc29uKCBtb20sIGRhZCApO1xuICogICAgIGZvby5zZXRBZ2UoIDIxICk7XG4gKiAgICAgdmFyIGZvbzIgPSBPTy5jbG9uZU9iamVjdCggZm9vICk7XG4gKiAgICAgZm9vLnNldEFnZSggMjIgKTtcbiAqXG4gKiAgICAgLy8gVGhlblxuICogICAgIGZvbzIgIT09IGZvbzsgLy8gdHJ1ZVxuICogICAgIGZvbzIgaW5zdGFuY2VvZiBQZXJzb247IC8vIHRydWVcbiAqICAgICBmb28yLmdldEFnZSgpOyAvLyAyMVxuICogICAgIGZvby5nZXRBZ2UoKTsgLy8gMjJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luXG4gKiBAcmV0dXJuIHtPYmplY3R9IENsb25lIG9mIG9yaWdpblxuICovXG5vby5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uICggb3JpZ2luICkge1xuXHR2YXIga2V5LCByO1xuXG5cdHIgPSBPYmplY3QuY3JlYXRlKCBvcmlnaW4uY29uc3RydWN0b3IucHJvdG90eXBlICk7XG5cblx0Zm9yICgga2V5IGluIG9yaWdpbiApIHtcblx0XHRpZiAoIGhhc093bi5jYWxsKCBvcmlnaW4sIGtleSApICkge1xuXHRcdFx0clsga2V5IF0gPSBvcmlnaW5bIGtleSBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgYWxsIHByb3BlcnR5IHZhbHVlcyBpbiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gZ2V0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gTGlzdCBvZiBvYmplY3QgdmFsdWVzXG4gKi9cbm9vLmdldE9iamVjdFZhbHVlcyA9IGZ1bmN0aW9uICggb2JqICkge1xuXHR2YXIga2V5LCB2YWx1ZXM7XG5cblx0aWYgKCBvYmogIT09IE9iamVjdCggb2JqICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0NhbGxlZCBvbiBub24tb2JqZWN0JyApO1xuXHR9XG5cblx0dmFsdWVzID0gW107XG5cdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0aWYgKCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKSApIHtcblx0XHRcdHZhbHVlc1sgdmFsdWVzLmxlbmd0aCBdID0gb2JqWyBrZXkgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBVc2UgYmluYXJ5IHNlYXJjaCB0byBsb2NhdGUgYW4gZWxlbWVudCBpbiBhIHNvcnRlZCBhcnJheS5cbiAqXG4gKiBzZWFyY2hGdW5jIGlzIGdpdmVuIGFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuIGBzZWFyY2hGdW5jKGVsZW0pYCBtdXN0IHJldHVybiBhIG51bWJlclxuICogYWJvdmUgMCBpZiB0aGUgZWxlbWVudCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIHRvIHRoZSByaWdodCBvZiAoaGFzIGEgaGlnaGVyIGluZGV4IHRoYW4pIGVsZW0sXG4gKiBiZWxvdyAwIGlmIGl0IGlzIHRvIHRoZSBsZWZ0IG9mIGVsZW0sIG9yIHplcm8gaWYgaXQncyBlcXVhbCB0byBlbGVtLlxuICpcbiAqIFRvIHNlYXJjaCBmb3IgYSBzcGVjaWZpYyB2YWx1ZSB3aXRoIGEgY29tcGFyYXRvciBmdW5jdGlvbiAoYSBgZnVuY3Rpb24gY21wKGEsYilgIHRoYXQgcmV0dXJuc1xuICogYWJvdmUgMCBpZiBgYSA+IGJgLCBiZWxvdyAwIGlmIGBhIDwgYmAsIGFuZCAwIGlmIGBhID09IGJgKSwgeW91IGNhbiB1c2VcbiAqIGBzZWFyY2hGdW5jID0gY21wLmJpbmQoIG51bGwsIHZhbHVlIClgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaEZ1bmMgU2VhcmNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JJbnNlcnRpb25dIElmIG5vdCBmb3VuZCwgcmV0dXJuIGluZGV4IHdoZXJlIHZhbCBjb3VsZCBiZSBpbnNlcnRlZFxuICogQHJldHVybiB7bnVtYmVyfG51bGx9IEluZGV4IHdoZXJlIHZhbCB3YXMgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cbm9vLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uICggYXJyLCBzZWFyY2hGdW5jLCBmb3JJbnNlcnRpb24gKSB7XG5cdHZhciBtaWQsIGNtcFJlc3VsdCxcblx0XHRsZWZ0ID0gMCxcblx0XHRyaWdodCA9IGFyci5sZW5ndGg7XG5cdHdoaWxlICggbGVmdCA8IHJpZ2h0ICkge1xuXHRcdC8vIEVxdWl2YWxlbnQgdG8gTWF0aC5mbG9vciggKCBsZWZ0ICsgcmlnaHQgKSAvIDIgKSBidXQgbXVjaCBmYXN0ZXJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuXHRcdG1pZCA9ICggbGVmdCArIHJpZ2h0ICkgPj4gMTtcblx0XHRjbXBSZXN1bHQgPSBzZWFyY2hGdW5jKCBhcnJbIG1pZCBdICk7XG5cdFx0aWYgKCBjbXBSZXN1bHQgPCAwICkge1xuXHRcdFx0cmlnaHQgPSBtaWQ7XG5cdFx0fSBlbHNlIGlmICggY21wUmVzdWx0ID4gMCApIHtcblx0XHRcdGxlZnQgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbWlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm9ySW5zZXJ0aW9uID8gcmlnaHQgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb21wYXJlIHByb3BlcnRpZXMgYmV0d2VlbiB0d28gb2JqZWN0cy5cbiAqXG4gKiBBIGZhbHNlIHJlc3VsdCBtYXkgYmUgY2F1c2VkIGJ5IHByb3BlcnR5IGluZXF1YWxpdHkgb3IgYnkgcHJvcGVydGllcyBpbiBvbmUgb2JqZWN0IG1pc3NpbmcgZnJvbVxuICogdGhlIG90aGVyLiBBbiBhc3ltbWV0cmljYWwgdGVzdCBtYXkgYWxzbyBiZSBwZXJmb3JtZWQsIHdoaWNoIGNoZWNrcyBvbmx5IHRoYXQgcHJvcGVydGllcyBpbiB0aGVcbiAqIGZpcnN0IG9iamVjdCBhcmUgcHJlc2VudCBpbiB0aGUgc2Vjb25kIG9iamVjdCwgYnV0IG5vdCB0aGUgaW52ZXJzZS5cbiAqXG4gKiBJZiBlaXRoZXIgYSBvciBiIGlzIG51bGwgb3IgdW5kZWZpbmVkIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhbiBlbXB0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfG51bGx9IGEgRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZHxudWxsfSBiIFNlY29uZCBvYmplY3QgdG8gY29tcGFyZVxuICogQHBhcmFtIHtib29sZWFufSBbYXN5bW1ldHJpY2FsXSBXaGV0aGVyIHRvIGNoZWNrIG9ubHkgdGhhdCBhJ3MgdmFsdWVzIGFyZSBlcXVhbCB0byBiJ3NcbiAqICAoaS5lLiBhIGlzIGEgc3Vic2V0IG9mIGIpXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIHZhbHVlcyBhcyBlYWNoIG90aGVyXG4gKi9cbm9vLmNvbXBhcmUgPSBmdW5jdGlvbiAoIGEsIGIsIGFzeW1tZXRyaWNhbCApIHtcblx0dmFyIGFWYWx1ZSwgYlZhbHVlLCBhVHlwZSwgYlR5cGUsIGs7XG5cblx0aWYgKCBhID09PSBiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0YSA9IGEgfHwge307XG5cdGIgPSBiIHx8IHt9O1xuXG5cdGlmICggdHlwZW9mIGEubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBhLmlzRXF1YWxOb2RlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBhLmlzRXF1YWxOb2RlKCBiICk7XG5cdH1cblxuXHRmb3IgKCBrIGluIGEgKSB7XG5cdFx0aWYgKCAhaGFzT3duLmNhbGwoIGEsIGsgKSB8fCBhWyBrIF0gPT09IHVuZGVmaW5lZCB8fCBhWyBrIF0gPT09IGJbIGsgXSApIHtcblx0XHRcdC8vIElnbm9yZSB1bmRlZmluZWQgdmFsdWVzLCBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbmNlcHR1YWwgZGlmZmVyZW5jZSBiZXR3ZWVuXG5cdFx0XHQvLyBhIGtleSB0aGF0IGlzIGFic2VudCBhbmQgYSBrZXkgdGhhdCBpcyBwcmVzZW50IGJ1dCB3aG9zZSB2YWx1ZSBpcyB1bmRlZmluZWQuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhVmFsdWUgPSBhWyBrIF07XG5cdFx0YlZhbHVlID0gYlsgayBdO1xuXHRcdGFUeXBlID0gdHlwZW9mIGFWYWx1ZTtcblx0XHRiVHlwZSA9IHR5cGVvZiBiVmFsdWU7XG5cdFx0aWYgKCBhVHlwZSAhPT0gYlR5cGUgfHxcblx0XHRcdChcblx0XHRcdFx0KCBhVHlwZSA9PT0gJ3N0cmluZycgfHwgYVR5cGUgPT09ICdudW1iZXInIHx8IGFUeXBlID09PSAnYm9vbGVhbicgKSAmJlxuXHRcdFx0XHRhVmFsdWUgIT09IGJWYWx1ZVxuXHRcdFx0KSB8fFxuXHRcdFx0KCBhVmFsdWUgPT09IE9iamVjdCggYVZhbHVlICkgJiYgIW9vLmNvbXBhcmUoIGFWYWx1ZSwgYlZhbHVlLCB0cnVlICkgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0Ly8gSWYgdGhlIGNoZWNrIGlzIG5vdCBhc3ltbWV0cmljYWwsIHJlY3Vyc2luZyB3aXRoIHRoZSBhcmd1bWVudHMgc3dhcHBlZCB3aWxsIHZlcmlmeSBvdXIgcmVzdWx0XG5cdHJldHVybiBhc3ltbWV0cmljYWwgPyB0cnVlIDogb28uY29tcGFyZSggYiwgYSwgdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwbGFpbiBkZWVwIGNvcHkgb2YgYW55IGtpbmQgb2Ygb2JqZWN0LlxuICpcbiAqIENvcGllcyBhcmUgZGVlcCwgYW5kIHdpbGwgZWl0aGVyIGJlIGFuIG9iamVjdCBvciBhbiBhcnJheSBkZXBlbmRpbmcgb24gYHNvdXJjZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBPYmplY3QgdG8gY29weVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2xlYWZDYWxsYmFja10gQXBwbGllZCB0byBsZWFmIHZhbHVlcyBhZnRlciB0aGV5IGFyZSBjbG9uZWQgYnV0IGJlZm9yZSB0aGV5IGFyZSBhZGRlZCB0byB0aGUgY2xvbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtub2RlQ2FsbGJhY2tdIEFwcGxpZWQgdG8gYWxsIHZhbHVlcyBiZWZvcmUgdGhleSBhcmUgY2xvbmVkLiAgSWYgdGhlIG5vZGVDYWxsYmFjayByZXR1cm5zIGEgdmFsdWUgb3RoZXIgdGhhbiB1bmRlZmluZWQsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgYXR0ZW1wdGluZyB0byBjbG9uZS5cbiAqIEByZXR1cm4ge09iamVjdH0gQ29weSBvZiBzb3VyY2Ugb2JqZWN0XG4gKi9cbm9vLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSwgbGVhZkNhbGxiYWNrLCBub2RlQ2FsbGJhY2sgKSB7XG5cdHZhciBrZXksIGRlc3RpbmF0aW9uO1xuXG5cdGlmICggbm9kZUNhbGxiYWNrICkge1xuXHRcdC8vIEV4dGVuc2liaWxpdHk6IGNoZWNrIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGNsb25lIHNvdXJjZS5cblx0XHRkZXN0aW5hdGlvbiA9IG5vZGVDYWxsYmFjayggc291cmNlICk7XG5cdFx0aWYgKCBkZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGRlc3RpbmF0aW9uO1xuXHRcdH1cblx0fVxuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc291cmNlICkgKSB7XG5cdFx0Ly8gQXJyYXkgKGZhbGwgdGhyb3VnaClcblx0XHRkZXN0aW5hdGlvbiA9IG5ldyBBcnJheSggc291cmNlLmxlbmd0aCApO1xuXHR9IGVsc2UgaWYgKCBzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZS5jbG9uZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHQvLyBEdWNrIHR5cGUgb2JqZWN0IHdpdGggY3VzdG9tIGNsb25lIG1ldGhvZFxuXHRcdHJldHVybiBsZWFmQ2FsbGJhY2sgPyBsZWFmQ2FsbGJhY2soIHNvdXJjZS5jbG9uZSgpICkgOiBzb3VyY2UuY2xvbmUoKTtcblx0fSBlbHNlIGlmICggc291cmNlICYmIHR5cGVvZiBzb3VyY2UuY2xvbmVOb2RlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdC8vIERPTSBOb2RlXG5cdFx0cmV0dXJuIGxlYWZDYWxsYmFjayA/XG5cdFx0XHRsZWFmQ2FsbGJhY2soIHNvdXJjZS5jbG9uZU5vZGUoIHRydWUgKSApIDpcblx0XHRcdHNvdXJjZS5jbG9uZU5vZGUoIHRydWUgKTtcblx0fSBlbHNlIGlmICggb28uaXNQbGFpbk9iamVjdCggc291cmNlICkgKSB7XG5cdFx0Ly8gUGxhaW4gb2JqZWN0cyAoZmFsbCB0aHJvdWdoKVxuXHRcdGRlc3RpbmF0aW9uID0ge307XG5cdH0gZWxzZSB7XG5cdFx0Ly8gTm9uLXBsYWluIG9iamVjdHMgKGluY2wuIGZ1bmN0aW9ucykgYW5kIHByaW1pdGl2ZSB2YWx1ZXNcblx0XHRyZXR1cm4gbGVhZkNhbGxiYWNrID8gbGVhZkNhbGxiYWNrKCBzb3VyY2UgKSA6IHNvdXJjZTtcblx0fVxuXG5cdC8vIHNvdXJjZSBpcyBhbiBhcnJheSBvciBhIHBsYWluIG9iamVjdFxuXHRmb3IgKCBrZXkgaW4gc291cmNlICkge1xuXHRcdGRlc3RpbmF0aW9uWyBrZXkgXSA9IG9vLmNvcHkoIHNvdXJjZVsga2V5IF0sIGxlYWZDYWxsYmFjaywgbm9kZUNhbGxiYWNrICk7XG5cdH1cblxuXHQvLyBUaGlzIGlzIGFuIGludGVybmFsIG5vZGUsIHNvIHdlIGRvbid0IGFwcGx5IHRoZSBsZWFmQ2FsbGJhY2suXG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBoYXNoIG9mIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgbmFtZSBhbmQgZGF0YS5cbiAqXG4gKiBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IDxodHRwOi8vanNwZXJmLmNvbS92ZS1nZXRoYXNoLTIwMTIwOCMvdG9Kc29uX2ZuUmVwbGFjZXJJZkFvRm9yRWxzZT5cbiAqXG4gKiBUbyBhdm9pZCB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIHZhbHVlcyBnZW5lcmF0aW5nIGRpZmZlcmVudCBoYXNoZXMsIHdlIHV0aWxpemUgdGhlIHJlcGxhY2VyXG4gKiBhcmd1bWVudCBvZiBKU09OLnN0cmluZ2lmeSBhbmQgc29ydCB0aGUgb2JqZWN0IGJ5IGtleSBhcyBpdCdzIGJlaW5nIHNlcmlhbGl6ZWQuIFRoaXMgbWF5IG9yIG1heVxuICogbm90IGJlIHRoZSBmYXN0ZXN0IHdheSB0byBkbyB0aGlzOyB3ZSBzaG91bGQgaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyLlxuICpcbiAqIE9iamVjdHMgYW5kIGFycmF5cyBhcmUgaGFzaGVkIHJlY3Vyc2l2ZWx5LiBXaGVuIGhhc2hpbmcgYW4gb2JqZWN0IHRoYXQgaGFzIGEgLmdldEhhc2goKVxuICogZnVuY3Rpb24sIHdlIGNhbGwgdGhhdCBmdW5jdGlvbiBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWUgcmF0aGVyIHRoYW4gaGFzaGluZyB0aGUgb2JqZWN0XG4gKiBvdXJzZWx2ZXMuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gZGVmaW5lIGN1c3RvbSBoYXNoaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgT2JqZWN0IHRvIGdlbmVyYXRlIGhhc2ggZm9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhhc2ggb2Ygb2JqZWN0XG4gKi9cbm9vLmdldEhhc2ggPSBmdW5jdGlvbiAoIHZhbCApIHtcblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCB2YWwsIG9vLmdldEhhc2gua2V5U29ydFJlcGxhY2VyICk7XG59O1xuXG4vKipcbiAqIFNvcnQgb2JqZWN0cyBieSBrZXkgKGhlbHBlciBmdW5jdGlvbiBmb3IgT08uZ2V0SGFzaCkuXG4gKlxuICogVGhpcyBpcyBhIGNhbGxiYWNrIHBhc3NlZCBpbnRvIEpTT04uc3RyaW5naWZ5LlxuICpcbiAqIEBtZXRob2QgZ2V0SGFzaF9rZXlTb3J0UmVwbGFjZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSBvZiB2YWx1ZSBiZWluZyByZXBsYWNlZFxuICogQHBhcmFtIHtNaXhlZH0gdmFsIFByb3BlcnR5IHZhbHVlIHRvIHJlcGxhY2VcbiAqIEByZXR1cm4ge01peGVkfSBSZXBsYWNlbWVudCB2YWx1ZVxuICovXG5vby5nZXRIYXNoLmtleVNvcnRSZXBsYWNlciA9IGZ1bmN0aW9uICgga2V5LCB2YWwgKSB7XG5cdHZhciBub3JtYWxpemVkLCBrZXlzLCBpLCBsZW47XG5cdGlmICggdmFsICYmIHR5cGVvZiB2YWwuZ2V0SGFzaE9iamVjdCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHQvLyBUaGlzIG9iamVjdCBoYXMgaXRzIG93biBjdXN0b20gaGFzaCBmdW5jdGlvbiwgdXNlIGl0XG5cdFx0dmFsID0gdmFsLmdldEhhc2hPYmplY3QoKTtcblx0fVxuXHRpZiAoICFBcnJheS5pc0FycmF5KCB2YWwgKSAmJiBPYmplY3QoIHZhbCApID09PSB2YWwgKSB7XG5cdFx0Ly8gT25seSBub3JtYWxpemUgb2JqZWN0cyB3aGVuIHRoZSBrZXktb3JkZXIgaXMgYW1iaWd1b3VzXG5cdFx0Ly8gKGUuZy4gYW55IG9iamVjdCBub3QgYW4gYXJyYXkpLlxuXHRcdG5vcm1hbGl6ZWQgPSB7fTtcblx0XHRrZXlzID0gT2JqZWN0LmtleXMoIHZhbCApLnNvcnQoKTtcblx0XHRpID0gMDtcblx0XHRsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdG5vcm1hbGl6ZWRbIGtleXNbIGkgXSBdID0gdmFsWyBrZXlzWyBpIF0gXTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWQ7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUHJpbWl0aXZlIHZhbHVlcyBhbmQgYXJyYXlzIGdldCBzdGFibGUgaGFzaGVzXG5cdFx0Ly8gYnkgZGVmYXVsdC4gTGV0cyB0aG9zZSBiZSBzdHJpbmdpZmllZCBhcy1pcy5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5pcXVlIHZhbHVlcyBvZiBhbiBhcnJheSwgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheVxuICogQHJldHVybiB7QXJyYXl9IFVuaXF1ZSB2YWx1ZXMgaW4gYXJyYXlcbiAqL1xub28udW5pcXVlID0gZnVuY3Rpb24gKCBhcnIgKSB7XG5cdHJldHVybiBhcnIucmVkdWNlKCBmdW5jdGlvbiAoIHJlc3VsdCwgY3VycmVudCApIHtcblx0XHRpZiAoIHJlc3VsdC5pbmRleE9mKCBjdXJyZW50ICkgPT09IC0xICkge1xuXHRcdFx0cmVzdWx0LnB1c2goIGN1cnJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgW10gKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgdW5pb24gKGR1cGxpY2F0ZS1mcmVlIG1lcmdlKSBvZiBhIHNldCBvZiBhcnJheXMuXG4gKlxuICogQXJyYXlzIHZhbHVlcyBtdXN0IGJlIGNvbnZlcnRhYmxlIHRvIG9iamVjdCBrZXlzIChzdHJpbmdzKS5cbiAqXG4gKiBCeSBidWlsZGluZyBhbiBvYmplY3QgKHdpdGggdGhlIHZhbHVlcyBmb3Iga2V5cykgaW4gcGFyYWxsZWwgd2l0aFxuICogdGhlIGFycmF5LCBhIG5ldyBpdGVtJ3MgZXhpc3RlbmNlIGluIHRoZSB1bmlvbiBjYW4gYmUgY29tcHV0ZWQgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IGFycmF5cyBBcnJheXMgdG8gdW5pb25cbiAqIEByZXR1cm4ge0FycmF5fSBVbmlvbiBvZiB0aGUgYXJyYXlzXG4gKi9cbm9vLnNpbXBsZUFycmF5VW5pb24gPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpLCBpbGVuLCBhcnIsIGosIGpsZW4sXG5cdFx0b2JqID0ge30sXG5cdFx0cmVzdWx0ID0gW107XG5cblx0Zm9yICggaSA9IDAsIGlsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrICkge1xuXHRcdGFyciA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdGZvciAoIGogPSAwLCBqbGVuID0gYXJyLmxlbmd0aDsgaiA8IGpsZW47IGorKyApIHtcblx0XHRcdGlmICggIW9ialsgYXJyWyBqIF0gXSApIHtcblx0XHRcdFx0b2JqWyBhcnJbIGogXSBdID0gdHJ1ZTtcblx0XHRcdFx0cmVzdWx0LnB1c2goIGFyclsgaiBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tYmluZSBhcnJheXMgKGludGVyc2VjdGlvbiBvciBkaWZmZXJlbmNlKS5cbiAqXG4gKiBBbiBpbnRlcnNlY3Rpb24gY2hlY2tzIHRoZSBpdGVtIGV4aXN0cyBpbiAnYicgd2hpbGUgZGlmZmVyZW5jZSBjaGVja3MgaXQgZG9lc24ndC5cbiAqXG4gKiBBcnJheXMgdmFsdWVzIG11c3QgYmUgY29udmVydGFibGUgdG8gb2JqZWN0IGtleXMgKHN0cmluZ3MpLlxuICpcbiAqIEJ5IGJ1aWxkaW5nIGFuIG9iamVjdCAod2l0aCB0aGUgdmFsdWVzIGZvciBrZXlzKSBvZiAnYicgd2UgY2FuXG4gKiBjb21wdXRlIHRoZSByZXN1bHQgZmFzdGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhIEZpcnN0IGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBiIFNlY29uZCBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQiBXaGV0aGVyIHRvIGl0ZW1zIGluICdiJ1xuICogQHJldHVybiB7QXJyYXl9IENvbWJpbmF0aW9uIChpbnRlcnNlY3Rpb24gb3IgZGlmZmVyZW5jZSkgb2YgYXJyYXlzXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUFycmF5Q29tYmluZSggYSwgYiwgaW5jbHVkZUIgKSB7XG5cdHZhciBpLCBpbGVuLCBpc0luQixcblx0XHRiT2JqID0ge30sXG5cdFx0cmVzdWx0ID0gW107XG5cblx0Zm9yICggaSA9IDAsIGlsZW4gPSBiLmxlbmd0aDsgaSA8IGlsZW47IGkrKyApIHtcblx0XHRiT2JqWyBiWyBpIF0gXSA9IHRydWU7XG5cdH1cblxuXHRmb3IgKCBpID0gMCwgaWxlbiA9IGEubGVuZ3RoOyBpIDwgaWxlbjsgaSsrICkge1xuXHRcdGlzSW5CID0gISFiT2JqWyBhWyBpIF0gXTtcblx0XHRpZiAoIGlzSW5CID09PSBpbmNsdWRlQiApIHtcblx0XHRcdHJlc3VsdC5wdXNoKCBhWyBpIF0gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gYXJyYXlzIChpdGVtcyBpbiBib3RoIGFycmF5cykuXG4gKlxuICogQXJyYXlzIHZhbHVlcyBtdXN0IGJlIGNvbnZlcnRhYmxlIHRvIG9iamVjdCBrZXlzIChzdHJpbmdzKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIEZpcnN0IGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBiIFNlY29uZCBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IEludGVyc2VjdGlvbiBvZiBhcnJheXNcbiAqL1xub28uc2ltcGxlQXJyYXlJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdHJldHVybiBzaW1wbGVBcnJheUNvbWJpbmUoIGEsIGIsIHRydWUgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZGlmZmVyZW5jZSBvZiB0d28gYXJyYXlzIChpdGVtcyBpbiAnYScgYnV0IG5vdCAnYicpLlxuICpcbiAqIEFycmF5cyB2YWx1ZXMgbXVzdCBiZSBjb252ZXJ0YWJsZSB0byBvYmplY3Qga2V5cyAoc3RyaW5ncykuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSBGaXJzdCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYiBTZWNvbmQgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fSBJbnRlcnNlY3Rpb24gb2YgYXJyYXlzXG4gKi9cbm9vLnNpbXBsZUFycmF5RGlmZmVyZW5jZSA9IGZ1bmN0aW9uICggYSwgYiApIHtcblx0cmV0dXJuIHNpbXBsZUFycmF5Q29tYmluZSggYSwgYiwgZmFsc2UgKTtcbn07XG5cbi8qIGdsb2JhbCBoYXNPd24sIHRvU3RyaW5nICovXG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCBvciBub3QuXG4gKlxuICogQG1lbWJlciBPT1xuICogQHBhcmFtIHtNaXhlZH0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5vby5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmogKSB7XG5cdHZhciBwcm90bztcblxuXHQvLyBPcHRpbWlzZSBmb3IgY29tbW9uIGNhc2Ugd2hlcmUgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIk9iamVjdFwiXG5cdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIG9iaiApO1xuXG5cdC8vIE9iamVjdHMgd2l0aG91dCBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgY29uc2lkZXJlZCBwbGFpblxuXHRpZiAoICFwcm90byApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIFRoZSAnaXNQcm90b3R5cGVPZicgbWV0aG9kIGlzIHNldCBvbiBPYmplY3QucHJvdG90eXBlLlxuXHRyZXR1cm4gaGFzT3duLmNhbGwoIHByb3RvLCAnaXNQcm90b3R5cGVPZicgKTtcbn07XG5cbi8qIGdsb2JhbCBoYXNPd24gKi9cblxuKCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEBjbGFzcyBPTy5FdmVudEVtaXR0ZXJcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRvby5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiBPb0V2ZW50RW1pdHRlcigpIHtcblx0XHQvLyBQcm9wZXJ0aWVzXG5cblx0XHQvKipcblx0XHQgKiBTdG9yYWdlIG9mIGJvdW5kIGV2ZW50IGhhbmRsZXJzIGJ5IGV2ZW50IG5hbWUuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHlcblx0XHQgKi9cblx0XHR0aGlzLmJpbmRpbmdzID0ge307XG5cdH07XG5cblx0b28uaW5pdENsYXNzKCBvby5FdmVudEVtaXR0ZXIgKTtcblxuXHQvKiBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgKi9cblxuXHQvKipcblx0ICogVmFsaWRhdGUgYSBmdW5jdGlvbiBvciBtZXRob2QgY2FsbCBpbiBhIGNvbnRleHRcblx0ICpcblx0ICogRm9yIGEgbWV0aG9kIG5hbWUsIGNoZWNrIHRoYXQgaXQgbmFtZXMgYSBmdW5jdGlvbiBpbiB0aGUgY29udGV4dCBvYmplY3Rcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZCBGdW5jdGlvbiBvciBtZXRob2QgbmFtZVxuXHQgKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBjYWxsXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSBBIG1ldGhvZCBuYW1lIGlzIGdpdmVuIGJ1dCB0aGVyZSBpcyBubyBjb250ZXh0XG5cdCAqIEB0aHJvd3Mge0Vycm9yfSBJbiB0aGUgY29udGV4dCBvYmplY3QsIG5vIHByb3BlcnR5IGV4aXN0cyB3aXRoIHRoZSBnaXZlbiBuYW1lXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSBJbiB0aGUgY29udGV4dCBvYmplY3QsIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBub3QgYSBmdW5jdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gdmFsaWRhdGVNZXRob2QoIG1ldGhvZCwgY29udGV4dCApIHtcblx0XHQvLyBWYWxpZGF0ZSBtZXRob2QgYW5kIGNvbnRleHRcblx0XHRpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8gVmFsaWRhdGUgbWV0aG9kXG5cdFx0XHRpZiAoIGNvbnRleHQgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0ID09PSBudWxsICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXRob2QgbmFtZSBcIicgKyBtZXRob2QgKyAnXCIgaGFzIG5vIGNvbnRleHQuJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dFsgbWV0aG9kIF0gIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdC8vIFRlY2huaWNhbGx5IHRoZSBwcm9wZXJ0eSBjb3VsZCBiZSByZXBsYWNlZCBieSBhIGZ1bmN0aW9uIGJlZm9yZVxuXHRcdFx0XHQvLyBjYWxsIHRpbWUuIEJ1dCB0aGlzIHByb2JhYmx5IHNpZ25hbHMgYSB0eXBvLlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdQcm9wZXJ0eSBcIicgKyBtZXRob2QgKyAnXCIgaXMgbm90IGEgZnVuY3Rpb24nICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY2FsbGJhY2suIEZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIGV4cGVjdGVkLicgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPTy5FdmVudEVtaXR0ZXJ9IGV2ZW50RW1pdHRlciBFdmVudCBlbWl0dGVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBFdmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiaW5kaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRCaW5kaW5nKCBldmVudEVtaXR0ZXIsIGV2ZW50LCBiaW5kaW5nICkge1xuXHRcdHZhciBiaW5kaW5ncztcblx0XHQvLyBBdXRvLWluaXRpYWxpemUgYmluZGluZ3MgbGlzdFxuXHRcdGlmICggaGFzT3duLmNhbGwoIGV2ZW50RW1pdHRlci5iaW5kaW5ncywgZXZlbnQgKSApIHtcblx0XHRcdGJpbmRpbmdzID0gZXZlbnRFbWl0dGVyLmJpbmRpbmdzWyBldmVudCBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiaW5kaW5ncyA9IGV2ZW50RW1pdHRlci5iaW5kaW5nc1sgZXZlbnQgXSA9IFtdO1xuXHRcdH1cblx0XHQvLyBBZGQgYmluZGluZ1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcblx0fVxuXG5cdC8qIE1ldGhvZHMgKi9cblxuXHQvKipcblx0ICogQWRkIGEgbGlzdGVuZXIgdG8gZXZlbnRzIG9mIGEgc3BlY2lmaWMgZXZlbnQuXG5cdCAqXG5cdCAqIFRoZSBsaXN0ZW5lciBjYW4gYmUgYSBmdW5jdGlvbiBvciB0aGUgc3RyaW5nIG5hbWUgb2YgYSBtZXRob2Q7IGlmIHRoZSBsYXR0ZXIsIHRoZW4gdGhlXG5cdCAqIG5hbWUgbG9va3VwIGhhcHBlbnMgYXQgdGhlIHRpbWUgdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2QgRnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gY2FsbCB3aGVuIGV2ZW50IG9jY3Vyc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gQXJndW1lbnRzIHRvIHBhc3MgdG8gbGlzdGVuZXIsIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVtaXR0ZWQgYXJndW1lbnRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1udWxsXSBDb250ZXh0IG9iamVjdCBmb3IgZnVuY3Rpb24gb3IgbWV0aG9kIGNhbGxcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gTGlzdGVuZXIgYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24gb3IgYSB2YWxpZCBtZXRob2QgbmFtZVxuXHQgKi9cblx0b28uRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICggZXZlbnQsIG1ldGhvZCwgYXJncywgY29udGV4dCApIHtcblx0XHR2YWxpZGF0ZU1ldGhvZCggbWV0aG9kLCBjb250ZXh0ICk7XG5cblx0XHQvLyBFbnN1cmUgY29uc2lzdGVudCBvYmplY3Qgc2hhcGUgKG9wdGltaXNhdGlvbilcblx0XHRhZGRCaW5kaW5nKCB0aGlzLCBldmVudCwge1xuXHRcdFx0bWV0aG9kOiBtZXRob2QsXG5cdFx0XHRhcmdzOiBhcmdzLFxuXHRcdFx0Y29udGV4dDogKCBhcmd1bWVudHMubGVuZ3RoIDwgNCApID8gbnVsbCA6IGNvbnRleHQsXG5cdFx0XHRvbmNlOiBmYWxzZVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgdG8gYSBzcGVjaWZpYyBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyIHRvIGNhbGwgd2hlbiBldmVudCBvY2N1cnNcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0b28uRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKCBldmVudCwgbGlzdGVuZXIgKSB7XG5cdFx0dmFsaWRhdGVNZXRob2QoIGxpc3RlbmVyICk7XG5cblx0XHQvLyBFbnN1cmUgY29uc2lzdGVudCBvYmplY3Qgc2hhcGUgKG9wdGltaXNhdGlvbilcblx0XHRhZGRCaW5kaW5nKCB0aGlzLCBldmVudCwge1xuXHRcdFx0bWV0aG9kOiBsaXN0ZW5lcixcblx0XHRcdGFyZ3M6IHVuZGVmaW5lZCxcblx0XHRcdGNvbnRleHQ6IG51bGwsXG5cdFx0XHRvbmNlOiB0cnVlXG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lciBmcm9tIGEgc3BlY2lmaWMgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUeXBlIG9mIGV2ZW50IHRvIHJlbW92ZSBsaXN0ZW5lciBmcm9tXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBbbWV0aG9kXSBMaXN0ZW5lciB0byByZW1vdmUuIE11c3QgYmUgaW4gdGhlIHNhbWUgZm9ybSBhcyB3YXMgcGFzc2VkXG5cdCAqIHRvIFwib25cIi4gT21pdCB0byByZW1vdmUgYWxsIGxpc3RlbmVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PW51bGxdIENvbnRleHQgb2JqZWN0IGZ1bmN0aW9uIG9yIG1ldGhvZCBjYWxsXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHRocm93cyB7RXJyb3J9IExpc3RlbmVyIGFyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uIG9yIGEgdmFsaWQgbWV0aG9kIG5hbWVcblx0ICovXG5cdG9vLkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCBldmVudCwgbWV0aG9kLCBjb250ZXh0ICkge1xuXHRcdHZhciBpLCBiaW5kaW5ncztcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdC8vIFJlbW92ZSBhbGwgYmluZGluZ3MgZm9yIGV2ZW50XG5cdFx0XHRkZWxldGUgdGhpcy5iaW5kaW5nc1sgZXZlbnQgXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhbGlkYXRlTWV0aG9kKCBtZXRob2QsIGNvbnRleHQgKTtcblxuXHRcdGlmICggIWhhc093bi5jYWxsKCB0aGlzLmJpbmRpbmdzLCBldmVudCApIHx8ICF0aGlzLmJpbmRpbmdzWyBldmVudCBdLmxlbmd0aCApIHtcblx0XHRcdC8vIE5vIG1hdGNoaW5nIGJpbmRpbmdzXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIG51bGwgY29udGV4dFxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IDMgKSB7XG5cdFx0XHRjb250ZXh0ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgaGFuZGxlcnNcblx0XHRiaW5kaW5ncyA9IHRoaXMuYmluZGluZ3NbIGV2ZW50IF07XG5cdFx0aSA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGlmICggYmluZGluZ3NbIGkgXS5tZXRob2QgPT09IG1ldGhvZCAmJiBiaW5kaW5nc1sgaSBdLmNvbnRleHQgPT09IGNvbnRleHQgKSB7XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsZWFudXAgaWYgbm93IGVtcHR5XG5cdFx0aWYgKCBiaW5kaW5ncy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5iaW5kaW5nc1sgZXZlbnQgXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUeXBlIG9mIGV2ZW50XG5cdCAqIEBwYXJhbSB7Li4uTWl4ZWR9IGFyZ3MgRmlyc3QgaW4gYSBsaXN0IG9mIHZhcmlhZGljIGFyZ3VtZW50cyBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlciAob3B0aW9uYWwpXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV2ZW50IHdhcyBoYW5kbGVkIGJ5IGF0IGxlYXN0IG9uZSBsaXN0ZW5lclxuXHQgKi9cblx0b28uRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHR2YXIgYXJncyA9IFtdLFxuXHRcdFx0aSwgbGVuLCBiaW5kaW5nLCBiaW5kaW5ncywgbWV0aG9kO1xuXG5cdFx0aWYgKCBoYXNPd24uY2FsbCggdGhpcy5iaW5kaW5ncywgZXZlbnQgKSApIHtcblx0XHRcdC8vIFNsaWNpbmcgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGdldCB0cmlwcGVkIHVwIGJ5IGV2ZW50IGhhbmRsZXJzIHRoYXQgYWRkL3JlbW92ZSBiaW5kaW5nc1xuXHRcdFx0YmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzWyBldmVudCBdLnNsaWNlKCk7XG5cdFx0XHRmb3IgKCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRhcmdzLnB1c2goIGFyZ3VtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gYmluZGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBiaW5kaW5nLm1ldGhvZCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0Ly8gTG9va3VwIG1ldGhvZCBieSBuYW1lIChsYXRlIGJpbmRpbmcpXG5cdFx0XHRcdFx0bWV0aG9kID0gYmluZGluZy5jb250ZXh0WyBiaW5kaW5nLm1ldGhvZCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1ldGhvZCA9IGJpbmRpbmcubWV0aG9kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYmluZGluZy5vbmNlICkge1xuXHRcdFx0XHRcdC8vIE11c3QgdW5iaW5kIGJlZm9yZSBjYWxsaW5nIG1ldGhvZCB0byBhdm9pZFxuXHRcdFx0XHRcdC8vIGFueSBuZXN0ZWQgdHJpZ2dlcnMuXG5cdFx0XHRcdFx0dGhpcy5vZmYoIGV2ZW50LCBtZXRob2QgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXRob2QuYXBwbHkoXG5cdFx0XHRcdFx0YmluZGluZy5jb250ZXh0LFxuXHRcdFx0XHRcdGJpbmRpbmcuYXJncyA/IGJpbmRpbmcuYXJncy5jb25jYXQoIGFyZ3MgKSA6IGFyZ3Ncblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbm5lY3QgZXZlbnQgaGFuZGxlcnMgdG8gYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBPYmplY3QgdG8gY2FsbCBtZXRob2RzIG9uIHdoZW4gZXZlbnRzIG9jY3VyXG5cdCAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPnxPYmplY3QuPHN0cmluZyxGdW5jdGlvbj58T2JqZWN0LjxzdHJpbmcsQXJyYXk+fSBtZXRob2RzIExpc3Qgb2Zcblx0ICogIGV2ZW50IGJpbmRpbmdzIGtleWVkIGJ5IGV2ZW50IG5hbWUgY29udGFpbmluZyBlaXRoZXIgbWV0aG9kIG5hbWVzLCBmdW5jdGlvbnMgb3IgYXJyYXlzIGNvbnRhaW5pbmdcblx0ICogIG1ldGhvZCBuYW1lIG9yIGZ1bmN0aW9uIGZvbGxvd2VkIGJ5IGEgbGlzdCBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGJlZm9yZSBlbWl0dGVkXG5cdCAqICBhcmd1bWVudHMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdG9vLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICggY29udGV4dCwgbWV0aG9kcyApIHtcblx0XHR2YXIgbWV0aG9kLCBhcmdzLCBldmVudDtcblxuXHRcdGZvciAoIGV2ZW50IGluIG1ldGhvZHMgKSB7XG5cdFx0XHRtZXRob2QgPSBtZXRob2RzWyBldmVudCBdO1xuXHRcdFx0Ly8gQWxsb3cgcHJvdmlkaW5nIGFkZGl0aW9uYWwgYXJnc1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXRob2QgKSApIHtcblx0XHRcdFx0YXJncyA9IG1ldGhvZC5zbGljZSggMSApO1xuXHRcdFx0XHRtZXRob2QgPSBtZXRob2RbIDAgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFyZ3MgPSBbXTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBiaW5kaW5nXG5cdFx0XHR0aGlzLm9uKCBldmVudCwgbWV0aG9kLCBhcmdzLCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0IGV2ZW50IGhhbmRsZXJzIGZyb20gYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBPYmplY3QgdG8gZGlzY29ubmVjdCBtZXRob2RzIGZyb21cblx0ICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fE9iamVjdC48c3RyaW5nLEZ1bmN0aW9uPnxPYmplY3QuPHN0cmluZyxBcnJheT59IFttZXRob2RzXSBMaXN0IG9mXG5cdCAqICBldmVudCBiaW5kaW5ncyBrZXllZCBieSBldmVudCBuYW1lLiBWYWx1ZXMgY2FuIGJlIGVpdGhlciBtZXRob2QgbmFtZXMsIGZ1bmN0aW9ucyBvciBhcnJheXNcblx0ICogIGNvbnRhaW5pbmcgYSBtZXRob2QgbmFtZS5cblx0ICogIE5PVEU6IFRvIGFsbG93IG1hdGNoaW5nIGNhbGwgc2l0ZXMgd2l0aCBjb25uZWN0KCksIGFycmF5IHZhbHVlcyBhcmUgYWxsb3dlZCB0byBjb250YWluIHRoZVxuXHQgKiAgcGFyYW1ldGVycyBhcyB3ZWxsLCBidXQgb25seSB0aGUgbWV0aG9kIG5hbWUgaXMgdXNlZCB0byBmaW5kIGJpbmRpbmdzLiBUdCBpcyBkaXNjb3VyYWdlZCB0b1xuXHQgKiAgaGF2ZSBtdWx0aXBsZSBiaW5kaW5ncyBmb3IgdGhlIHNhbWUgZXZlbnQgdG8gdGhlIHNhbWUgbGlzdGVuZXIsIGJ1dCBpZiB1c2VkIChhbmQgb25seSB0aGVcblx0ICogIHBhcmFtZXRlcnMgdmFyeSksIGRpc2Nvbm5lY3Rpbmcgb25lIHZhcmlhdGlvbiBvZiAoZXZlbnQgbmFtZSwgZXZlbnQgbGlzdGVuZXIsIHBhcmFtZXRlcnMpXG5cdCAqICB3aWxsIGRpc2Nvbm5lY3Qgb3RoZXIgdmFyaWF0aW9ucyBhcyB3ZWxsLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRvby5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoIGNvbnRleHQsIG1ldGhvZHMgKSB7XG5cdFx0dmFyIGksIGV2ZW50LCBtZXRob2QsIGJpbmRpbmdzO1xuXG5cdFx0aWYgKCBtZXRob2RzICkge1xuXHRcdFx0Ly8gUmVtb3ZlIHNwZWNpZmljIGNvbm5lY3Rpb25zIHRvIHRoZSBjb250ZXh0XG5cdFx0XHRmb3IgKCBldmVudCBpbiBtZXRob2RzICkge1xuXHRcdFx0XHRtZXRob2QgPSBtZXRob2RzWyBldmVudCBdO1xuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGhvZCApICkge1xuXHRcdFx0XHRcdG1ldGhvZCA9IG1ldGhvZFsgMCBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMub2ZmKCBldmVudCwgbWV0aG9kLCBjb250ZXh0ICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSBhbGwgY29ubmVjdGlvbnMgdG8gdGhlIGNvbnRleHRcblx0XHRcdGZvciAoIGV2ZW50IGluIHRoaXMuYmluZGluZ3MgKSB7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5iaW5kaW5nc1sgZXZlbnQgXTtcblx0XHRcdFx0aSA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Ly8gYmluZGluZ3NbaV0gbWF5IGhhdmUgYmVlbiByZW1vdmVkIGJ5IHRoZSBwcmV2aW91cyBzdGVwJ3Ncblx0XHRcdFx0XHQvLyB0aGlzLm9mZiBzbyBjaGVjayBpdCBzdGlsbCBleGlzdHNcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmdzWyBpIF0gJiYgYmluZGluZ3NbIGkgXS5jb250ZXh0ID09PSBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5vZmYoIGV2ZW50LCBiaW5kaW5nc1sgaSBdLm1ldGhvZCwgY29udGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG59KCkgKTtcblxuKCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIENvbnRhaW4gYW5kIG1hbmFnZSBhIGxpc3Qgb2YgT08uRXZlbnRFbWl0dGVyIGl0ZW1zLlxuXHQgKlxuXHQgKiBBZ2dyZWdhdGVzIGFuZCBtYW5hZ2VzIHRoZWlyIGV2ZW50cyBjb2xsZWN0aXZlbHkuXG5cdCAqXG5cdCAqIFRoaXMgbWl4aW4gbXVzdCBiZSB1c2VkIGluIGEgY2xhc3MgdGhhdCBhbHNvIG1peGVzIGluIE9PLkV2ZW50RW1pdHRlci5cblx0ICpcblx0ICogQGFic3RyYWN0XG5cdCAqIEBjbGFzcyBPTy5FbWl0dGVyTGlzdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdG9vLkVtaXR0ZXJMaXN0ID0gZnVuY3Rpb24gT29FbWl0dGVyTGlzdCgpIHtcblx0XHR0aGlzLml0ZW1zID0gW107XG5cdFx0dGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzID0ge307XG5cdH07XG5cblx0LyogRXZlbnRzICovXG5cblx0LyoqXG5cdCAqIEl0ZW0gaGFzIGJlZW4gYWRkZWRcblx0ICpcblx0ICogQGV2ZW50IGFkZFxuXHQgKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcn0gaXRlbSBBZGRlZCBpdGVtXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBpdGVtcyB3ZXJlIGFkZGVkIGF0XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBJdGVtIGhhcyBiZWVuIG1vdmVkIHRvIGEgbmV3IGluZGV4XG5cdCAqXG5cdCAqIEBldmVudCBtb3ZlXG5cdCAqIEBwYXJhbSB7T08uRXZlbnRFbWl0dGVyfSBpdGVtIE1vdmVkIGl0ZW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGl0ZW0gd2FzIG1vdmVkIHRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvbGRJbmRleCBUaGUgb3JpZ2luYWwgaW5kZXggdGhlIGl0ZW0gd2FzIGluXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBJdGVtIGhhcyBiZWVuIHJlbW92ZWRcblx0ICpcblx0ICogQGV2ZW50IHJlbW92ZVxuXHQgKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcn0gaXRlbSBSZW1vdmVkIGl0ZW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoZSBpdGVtIHdhcyByZW1vdmVkIGZyb21cblx0ICovXG5cblx0LyoqXG5cdCAqIEBldmVudCBjbGVhciBUaGUgbGlzdCBoYXMgYmVlbiBjbGVhcmVkIG9mIGl0ZW1zXG5cdCAqL1xuXG5cdC8qIE1ldGhvZHMgKi9cblxuXHQvKipcblx0ICogTm9ybWFsaXplIHJlcXVlc3RlZCBpbmRleCB0byBmaXQgaW50byB0aGUgYm91bmRzIG9mIHRoZSBnaXZlbiBhcnJheS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgR2l2ZW4gYXJyYXlcblx0ICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBpbmRleCBSZXF1ZXN0ZWQgaW5kZXhcblx0ICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGluZGV4XG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVBcnJheUluZGV4KCBhcnIsIGluZGV4ICkge1xuXHRcdHJldHVybiAoIGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IGFyci5sZW5ndGggKSA/XG5cdFx0XHRhcnIubGVuZ3RoIDpcblx0XHRcdGluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbGwgaXRlbXMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09PLkV2ZW50RW1pdHRlcltdfSBJdGVtcyBpbiB0aGUgbGlzdFxuXHQgKi9cblx0b28uRW1pdHRlckxpc3QucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKCAwICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgaW5kZXggb2YgYSBzcGVjaWZpYyBpdGVtLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcn0gaXRlbSBSZXF1ZXN0ZWQgaXRlbVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBpdGVtXG5cdCAqL1xuXHRvby5FbWl0dGVyTGlzdC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IG51bWJlciBvZiBpdGVtcy5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3Rcblx0ICovXG5cdG9vLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5nZXRJdGVtQ291bnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIGxpc3QgY29udGFpbnMgbm8gaXRlbXMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IEdyb3VwIGlzIGVtcHR5XG5cdCAqL1xuXHRvby5FbWl0dGVyTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuaXRlbXMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZ2dyZWdhdGUgdGhlIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBncm91cC5cblx0ICpcblx0ICogV2hlbiBldmVudHMgYXJlIGFnZ3JlZ2F0ZWQsIHRoZSBncm91cCB3aWxsIGxpc3RlbiB0byBhbGwgY29udGFpbmVkIGl0ZW1zIGZvciB0aGUgZXZlbnQsXG5cdCAqIGFuZCB0aGVuIGVtaXQgdGhlIGV2ZW50IHVuZGVyIGEgbmV3IG5hbWUuIFRoZSBuZXcgZXZlbnQgd2lsbCBjb250YWluIGFuIGFkZGl0aW9uYWwgbGVhZGluZ1xuXHQgKiBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGVtaXR0ZWQgdGhlIG9yaWdpbmFsIGV2ZW50LiBPdGhlciBhcmd1bWVudHMgZW1pdHRlZCBmcm9tXG5cdCAqIHRoZSBvcmlnaW5hbCBldmVudCBhcmUgcGFzc2VkIHRocm91Z2guXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nfG51bGw+fSBldmVudHMgQW4gb2JqZWN0IGtleWVkIGJ5IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0aGF0IHNob3VsZCBiZVxuXHQgKiAgYWdncmVnYXRlZCAgKGUuZy4sIOKAmGNsaWNr4oCZKSBhbmQgdGhlIHZhbHVlIG9mIHRoZSBuZXcgbmFtZSB0byB1c2UgKGUuZy4sIOKAmGdyb3VwQ2xpY2vigJkpLlxuXHQgKiAgQSBgbnVsbGAgdmFsdWUgd2lsbCByZW1vdmUgYWdncmVnYXRlZCBldmVudHMuXG5cblx0ICogQHRocm93cyB7RXJyb3J9IElmIGFnZ3JlZ2F0aW9uIGFscmVhZHkgZXhpc3RzXG5cdCAqL1xuXHRvby5FbWl0dGVyTGlzdC5wcm90b3R5cGUuYWdncmVnYXRlID0gZnVuY3Rpb24gKCBldmVudHMgKSB7XG5cdFx0dmFyIGksIGl0ZW0sIGFkZCwgcmVtb3ZlLCBpdGVtRXZlbnQsIGdyb3VwRXZlbnQ7XG5cblx0XHRmb3IgKCBpdGVtRXZlbnQgaW4gZXZlbnRzICkge1xuXHRcdFx0Z3JvdXBFdmVudCA9IGV2ZW50c1sgaXRlbUV2ZW50IF07XG5cblx0XHRcdC8vIFJlbW92ZSBleGlzdGluZyBhZ2dyZWdhdGVkIGV2ZW50XG5cdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggdGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzLCBpdGVtRXZlbnQgKSApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgYWxsb3cgZHVwbGljYXRlIGFnZ3JlZ2F0aW9uc1xuXHRcdFx0XHRpZiAoIGdyb3VwRXZlbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRHVwbGljYXRlIGl0ZW0gZXZlbnQgYWdncmVnYXRpb24gZm9yICcgKyBpdGVtRXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBSZW1vdmUgZXZlbnQgYWdncmVnYXRpb24gZnJvbSBleGlzdGluZyBpdGVtc1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGl0ZW0uY29ubmVjdCAmJiBpdGVtLmRpc2Nvbm5lY3QgKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmUgPSB7fTtcblx0XHRcdFx0XHRcdHJlbW92ZVsgaXRlbUV2ZW50IF0gPSBbICdlbWl0JywgdGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzWyBpdGVtRXZlbnQgXSwgaXRlbSBdO1xuXHRcdFx0XHRcdFx0aXRlbS5kaXNjb25uZWN0KCB0aGlzLCByZW1vdmUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUHJldmVudCBmdXR1cmUgaXRlbXMgZnJvbSBhZ2dyZWdhdGluZyBldmVudFxuXHRcdFx0XHRkZWxldGUgdGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzWyBpdGVtRXZlbnQgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG5ldyBhZ2dyZWdhdGUgZXZlbnRcblx0XHRcdGlmICggZ3JvdXBFdmVudCApIHtcblx0XHRcdFx0Ly8gTWFrZSBmdXR1cmUgaXRlbXMgYWdncmVnYXRlIGV2ZW50XG5cdFx0XHRcdHRoaXMuYWdncmVnYXRlSXRlbUV2ZW50c1sgaXRlbUV2ZW50IF0gPSBncm91cEV2ZW50O1xuXHRcdFx0XHQvLyBBZGQgZXZlbnQgYWdncmVnYXRpb24gdG8gZXhpc3RpbmcgaXRlbXNcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBpdGVtLmNvbm5lY3QgJiYgaXRlbS5kaXNjb25uZWN0ICkge1xuXHRcdFx0XHRcdFx0YWRkID0ge307XG5cdFx0XHRcdFx0XHRhZGRbIGl0ZW1FdmVudCBdID0gWyAnZW1pdCcsIGdyb3VwRXZlbnQsIGl0ZW0gXTtcblx0XHRcdFx0XHRcdGl0ZW0uY29ubmVjdCggdGhpcywgYWRkICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgaXRlbXMgdG8gdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T08uRXZlbnRFbWl0dGVyfE9PLkV2ZW50RW1pdHRlcltdfSBpdGVtcyBJdGVtIHRvIGFkZCBvclxuXHQgKiAgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYWRkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIEluZGV4IHRvIGFkZCBpdGVtcyBhdC4gSWYgbm8gaW5kZXggaXNcblx0ICogIGdpdmVuLCBvciBpZiB0aGUgaW5kZXggdGhhdCBpcyBnaXZlbiBpcyBpbnZhbGlkLCB0aGUgaXRlbVxuXHQgKiAgd2lsbCBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBmaXJlcyBhZGRcblx0ICogQGZpcmVzIG1vdmVcblx0ICovXG5cdG9vLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5hZGRJdGVtcyA9IGZ1bmN0aW9uICggaXRlbXMsIGluZGV4ICkge1xuXHRcdHZhciBpLCBvbGRJbmRleDtcblxuXHRcdGlmICggIUFycmF5LmlzQXJyYXkoIGl0ZW1zICkgKSB7XG5cdFx0XHRpdGVtcyA9IFsgaXRlbXMgXTtcblx0XHR9XG5cblx0XHRpZiAoIGl0ZW1zLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGluZGV4ID0gbm9ybWFsaXplQXJyYXlJbmRleCggdGhpcy5pdGVtcywgaW5kZXggKTtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0b2xkSW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW1zWyBpIF0gKTtcblx0XHRcdGlmICggb2xkSW5kZXggIT09IC0xICkge1xuXHRcdFx0XHQvLyBNb3ZlIGl0ZW0gdG8gbmV3IGluZGV4XG5cdFx0XHRcdGluZGV4ID0gdGhpcy5tb3ZlSXRlbSggaXRlbXNbIGkgXSwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5lbWl0KCAnbW92ZScsIGl0ZW1zWyBpIF0sIGluZGV4LCBvbGRJbmRleCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaW5zZXJ0IGl0ZW0gYXQgaW5kZXhcblx0XHRcdFx0aW5kZXggPSB0aGlzLmluc2VydEl0ZW0oIGl0ZW1zWyBpIF0sIGluZGV4ICk7XG5cdFx0XHRcdHRoaXMuZW1pdCggJ2FkZCcsIGl0ZW1zWyBpIF0sIGluZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRpbmRleCsrO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNb3ZlIGFuIGl0ZW0gZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiB0byBhIG5ldyBpbmRleC5cblx0ICpcblx0ICogVGhlIGl0ZW0gaXMgZXhwZWN0ZWQgdG8gZXhpc3QgaW4gdGhlIGxpc3QuIElmIGl0IGRvZXNuJ3QsXG5cdCAqIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T08uRXZlbnRFbWl0dGVyfSBpdGVtIEl0ZW1zIHRvIGFkZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggSW5kZXggdG8gbW92ZSB0aGUgaXRlbSB0b1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCB0aGUgaXRlbSB3YXMgbW92ZWQgdG9cblx0ICogQHRocm93cyB7RXJyb3J9IElmIGl0ZW0gaXMgbm90IGluIHRoZSBsaXN0XG5cdCAqL1xuXHRvby5FbWl0dGVyTGlzdC5wcm90b3R5cGUubW92ZUl0ZW0gPSBmdW5jdGlvbiAoIGl0ZW0sIG5ld0luZGV4ICkge1xuXHRcdHZhciBleGlzdGluZ0luZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKCBpdGVtICk7XG5cblx0XHRpZiAoIGV4aXN0aW5nSW5kZXggPT09IC0xICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSXRlbSBjYW5ub3QgYmUgbW92ZWQsIGJlY2F1c2UgaXQgaXMgbm90IGluIHRoZSBsaXN0LicgKTtcblx0XHR9XG5cblx0XHRuZXdJbmRleCA9IG5vcm1hbGl6ZUFycmF5SW5kZXgoIHRoaXMuaXRlbXMsIG5ld0luZGV4ICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBpbmRleFxuXHRcdHRoaXMuaXRlbXMuc3BsaWNlKCBleGlzdGluZ0luZGV4LCAxICk7XG5cblx0XHQvLyBJZiBuZWNlc3NhcnksIGFkanVzdCBuZXcgaW5kZXggYWZ0ZXIgcmVtb3ZhbFxuXHRcdGlmICggZXhpc3RpbmdJbmRleCA8IG5ld0luZGV4ICkge1xuXHRcdFx0bmV3SW5kZXgtLTtcblx0XHR9XG5cblx0XHQvLyBNb3ZlIHRoZSBpdGVtIHRvIHRoZSBuZXcgaW5kZXhcblx0XHR0aGlzLml0ZW1zLnNwbGljZSggbmV3SW5kZXgsIDAsIGl0ZW0gKTtcblxuXHRcdHJldHVybiBuZXdJbmRleDtcblx0fTtcblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdG8gaW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgbGlzdCwgYW5kXG5cdCAqIGNvbm5lY3QgaXQgdG8gYWdncmVnYXRlIGV2ZW50cy5cblx0ICpcblx0ICogRG9uJ3QgY2FsbCB0aGlzIGRpcmVjdGx5IHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cblx0ICogVXNlICNhZGRJdGVtcyBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBjYW4gYmUgZXh0ZW5kZWQgaW4gY2hpbGQgY2xhc3NlcyB0byBwcm9kdWNlXG5cdCAqIGRpZmZlcmVudCBiZWhhdmlvciB3aGVuIGFuIGl0ZW0gaXMgaW5zZXJ0ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBpbnNlcnRlZCBpdGVtcyBtYXkgYWxzbyBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIG9yIG1heVxuXHQgKiBpbnRlcmFjdCB3aXRoIHNvbWUgb3RoZXIgbm9kZXMgaW4gY2VydGFpbiB3YXlzLiBFeHRlbmRpbmdcblx0ICogdGhpcyBtZXRob2QgaXMgYWxsb3dlZCwgYnV0IGlmIG92ZXJyaWRlbiwgdGhlIGFnZ3JlZ2F0aW9uXG5cdCAqIG9mIGV2ZW50cyBtdXN0IGJlIHByZXNlcnZlZCwgb3IgYmVoYXZpb3Igb2YgZW1pdHRlZCBldmVudHNcblx0ICogd2lsbCBiZSBicm9rZW4uXG5cdCAqXG5cdCAqIElmIHlvdSBhcmUgZXh0ZW5kaW5nIHRoaXMgbWV0aG9kLCBwbGVhc2UgbWFrZSBzdXJlIHRoZVxuXHQgKiBwYXJlbnQgbWV0aG9kIGlzIGNhbGxlZC5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcn0gaXRlbSBJdGVtcyB0byBhZGRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRvIGFkZCBpdGVtcyBhdFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCB0aGUgaXRlbSB3YXMgYWRkZWQgYXRcblx0ICovXG5cdG9vLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5pbnNlcnRJdGVtID0gZnVuY3Rpb24gKCBpdGVtLCBpbmRleCApIHtcblx0XHR2YXIgZXZlbnRzLCBldmVudDtcblxuXHRcdC8vIEFkZCB0aGUgaXRlbSB0byBldmVudCBhZ2dyZWdhdGlvblxuXHRcdGlmICggaXRlbS5jb25uZWN0ICYmIGl0ZW0uZGlzY29ubmVjdCApIHtcblx0XHRcdGV2ZW50cyA9IHt9O1xuXHRcdFx0Zm9yICggZXZlbnQgaW4gdGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzICkge1xuXHRcdFx0XHRldmVudHNbIGV2ZW50IF0gPSBbICdlbWl0JywgdGhpcy5hZ2dyZWdhdGVJdGVtRXZlbnRzWyBldmVudCBdLCBpdGVtIF07XG5cdFx0XHR9XG5cdFx0XHRpdGVtLmNvbm5lY3QoIHRoaXMsIGV2ZW50cyApO1xuXHRcdH1cblxuXHRcdGluZGV4ID0gbm9ybWFsaXplQXJyYXlJbmRleCggdGhpcy5pdGVtcywgaW5kZXggKTtcblxuXHRcdC8vIEluc2VydCBpbnRvIGl0ZW1zIGFycmF5XG5cdFx0dGhpcy5pdGVtcy5zcGxpY2UoIGluZGV4LCAwLCBpdGVtICk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgaXRlbXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T08uRXZlbnRFbWl0dGVyW119IGl0ZW1zIEl0ZW1zIHRvIHJlbW92ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBmaXJlcyByZW1vdmVcblx0ICovXG5cdG9vLkVtaXR0ZXJMaXN0LnByb3RvdHlwZS5yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uICggaXRlbXMgKSB7XG5cdFx0dmFyIGksIGl0ZW0sIGluZGV4O1xuXG5cdFx0aWYgKCAhQXJyYXkuaXNBcnJheSggaXRlbXMgKSApIHtcblx0XHRcdGl0ZW1zID0gWyBpdGVtcyBdO1xuXHRcdH1cblxuXHRcdGlmICggaXRlbXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHNwZWNpZmljIGl0ZW1zXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0aW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoIGl0ZW0gKTtcblx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRpZiAoIGl0ZW0uY29ubmVjdCAmJiBpdGVtLmRpc2Nvbm5lY3QgKSB7XG5cdFx0XHRcdFx0Ly8gRGlzY29ubmVjdCBhbGwgbGlzdGVuZXJzIGZyb20gdGhlIGl0ZW1cblx0XHRcdFx0XHRpdGVtLmRpc2Nvbm5lY3QoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLml0ZW1zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0dGhpcy5lbWl0KCAncmVtb3ZlJywgaXRlbSwgaW5kZXggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYXIgYWxsIGl0ZW1zXG5cdCAqXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQGZpcmVzIGNsZWFyXG5cdCAqL1xuXHRvby5FbWl0dGVyTGlzdC5wcm90b3R5cGUuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSwgaXRlbSxcblx0XHRcdGNsZWFyZWQgPSB0aGlzLml0ZW1zLnNwbGljZSggMCwgdGhpcy5pdGVtcy5sZW5ndGggKTtcblxuXHRcdC8vIERpc2Nvbm5lY3QgYWxsIGl0ZW1zXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBjbGVhcmVkLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aXRlbSA9IGNsZWFyZWRbIGkgXTtcblx0XHRcdGlmICggaXRlbS5jb25uZWN0ICYmIGl0ZW0uZGlzY29ubmVjdCApIHtcblx0XHRcdFx0aXRlbS5kaXNjb25uZWN0KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbWl0KCAnY2xlYXInICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxufSgpICk7XG5cbi8qKlxuICogTWFuYWdlIGEgc29ydGVkIGxpc3Qgb2YgT08uRW1pdHRlckxpc3Qgb2JqZWN0cy5cbiAqXG4gKiBUaGUgc29ydCBvcmRlciBpcyBiYXNlZCBvbiBhIGNhbGxiYWNrIHRoYXQgY29tcGFyZXMgdHdvIGl0ZW1zLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gKiBjYWxsYmFjayggYSwgYiApIG11c3QgYmUgbGVzcyB0aGFuIHplcm8gaWYgYSA8IGIsIGdyZWF0ZXIgdGhhbiB6ZXJvIGlmIGEgPiBiLCBhbmQgemVyb1xuICogaWYgYSBpcyBlcXVhbCB0byBiLiBUaGUgY2FsbGJhY2sgc2hvdWxkIG9ubHkgcmV0dXJuIHplcm8gaWYgdGhlIHR3byBvYmplY3RzIGFyZVxuICogY29uc2lkZXJlZCBlcXVhbC5cbiAqXG4gKiBXaGVuIGFuIGl0ZW0gY2hhbmdlcyBpbiBhIHdheSB0aGF0IGNvdWxkIGFmZmVjdCB0aGVpciBzb3J0aW5nIGJlaGF2aW9yLCBpdCBtdXN0XG4gKiBlbWl0IHRoZSBpdGVtU29ydENoYW5nZSBldmVudC4gVGhpcyB3aWxsIGNhdXNlIGl0IHRvIGJlIHJlLXNvcnRlZCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoaXMgbWl4aW4gbXVzdCBiZSB1c2VkIGluIGEgY2xhc3MgdGhhdCBhbHNvIG1peGVzIGluIE9PLkV2ZW50RW1pdHRlci5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBPTy5Tb3J0ZWRFbWl0dGVyTGlzdFxuICogQG1peGlucyBPTy5FbWl0dGVyTGlzdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nQ2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjb21wYXJlcyB0d28gaXRlbXMuXG4gKi9cbm9vLlNvcnRlZEVtaXR0ZXJMaXN0ID0gZnVuY3Rpb24gT29Tb3J0ZWRFbWl0dGVyTGlzdCggc29ydGluZ0NhbGxiYWNrICkge1xuXHQvLyBNaXhpbiBjb25zdHJ1Y3RvcnNcblx0b28uRW1pdHRlckxpc3QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuc29ydGluZ0NhbGxiYWNrID0gc29ydGluZ0NhbGxiYWNrO1xuXG5cdC8vIExpc3RlbiB0byBzb3J0Q2hhbmdlIGV2ZW50IGFuZCBtYWtlIHN1cmVcblx0Ly8gd2UgcmUtc29ydCB0aGUgY2hhbmdlZCBpdGVtIHdoZW4gdGhhdCBoYXBwZW5zXG5cdHRoaXMuYWdncmVnYXRlKCB7XG5cdFx0c29ydENoYW5nZTogJ2l0ZW1Tb3J0Q2hhbmdlJ1xuXHR9ICk7XG5cblx0dGhpcy5jb25uZWN0KCB0aGlzLCB7XG5cdFx0aXRlbVNvcnRDaGFuZ2U6ICdvbkl0ZW1Tb3J0Q2hhbmdlJ1xuXHR9ICk7XG59O1xuXG5vby5taXhpbkNsYXNzKCBvby5Tb3J0ZWRFbWl0dGVyTGlzdCwgb28uRW1pdHRlckxpc3QgKTtcblxuLyogRXZlbnRzICovXG5cbi8qKlxuICogQW4gaXRlbSBoYXMgY2hhbmdlZCBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IGl0cyBzb3J0IHBvc2l0aW9uaW5nXG4gKiBpbnNpZGUgdGhlIGxpc3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBldmVudCBpdGVtU29ydENoYW5nZVxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBIYW5kbGUgYSBjYXNlIHdoZXJlIGFuIGl0ZW0gY2hhbmdlZCBhIHByb3BlcnR5IHRoYXQgcmVsYXRlc1xuICogdG8gaXRzIHNvcnRlZCBvcmRlclxuICpcbiAqIEBwYXJhbSB7T08uRXZlbnRFbWl0dGVyfSBpdGVtIEl0ZW0gaW4gdGhlIGxpc3RcbiAqL1xub28uU29ydGVkRW1pdHRlckxpc3QucHJvdG90eXBlLm9uSXRlbVNvcnRDaGFuZ2UgPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdC8vIFJlbW92ZSB0aGUgaXRlbVxuXHR0aGlzLnJlbW92ZUl0ZW1zKCBpdGVtICk7XG5cdC8vIFJlLWFkZCB0aGUgaXRlbSBzbyBpdCBpcyBpbiB0aGUgY29ycmVjdCBwbGFjZVxuXHR0aGlzLmFkZEl0ZW1zKCBpdGVtICk7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgc29ydGluZyBjYWxsYmFjayBmb3IgdGhpcyBzb3J0ZWQgbGlzdC5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgdHdvIGl0ZW1zLiBUaGUgcmV0dXJuIHZhbHVlIG9mIGNhbGxiYWNrKGEsIGIpIG11c3QgYmUgbGVzcyB0aGFuIHplcm9cbiAqIGlmIGEgPCBiLCBncmVhdGVyIHRoYW4gemVybyBpZiBhID4gYiwgYW5kIHplcm8gaWYgYSBpcyBlcXVhbCB0byBiLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmdDYWxsYmFjayBTb3J0aW5nIGNhbGxiYWNrXG4gKi9cbm9vLlNvcnRlZEVtaXR0ZXJMaXN0LnByb3RvdHlwZS5zZXRTb3J0aW5nQ2FsbGJhY2sgPSBmdW5jdGlvbiAoIHNvcnRpbmdDYWxsYmFjayApIHtcblx0dmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuXG5cdHRoaXMuc29ydGluZ0NhbGxiYWNrID0gc29ydGluZ0NhbGxiYWNrO1xuXG5cdC8vIEVtcHR5IHRoZSBsaXN0XG5cdHRoaXMuY2xlYXJJdGVtcygpO1xuXHQvLyBSZS1hZGQgdGhlIGl0ZW1zIGluIHRoZSBuZXcgb3JkZXJcblx0dGhpcy5hZGRJdGVtcyggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogQWRkIGl0ZW1zIHRvIHRoZSBzb3J0ZWQgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcnxPTy5FdmVudEVtaXR0ZXJbXX0gaXRlbXMgSXRlbSB0byBhZGQgb3JcbiAqICBhbiBhcnJheSBvZiBpdGVtcyB0byBhZGRcbiAqIEBjaGFpbmFibGVcbiAqL1xub28uU29ydGVkRW1pdHRlckxpc3QucHJvdG90eXBlLmFkZEl0ZW1zID0gZnVuY3Rpb24gKCBpdGVtcyApIHtcblx0dmFyIGluZGV4LCBpLCBpbnNlcnRpb25JbmRleDtcblxuXHRpZiAoICFBcnJheS5pc0FycmF5KCBpdGVtcyApICkge1xuXHRcdGl0ZW1zID0gWyBpdGVtcyBdO1xuXHR9XG5cblx0aWYgKCBpdGVtcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuXHRcdC8vIEZpbmQgaW5zZXJ0aW9uIGluZGV4XG5cdFx0aW5zZXJ0aW9uSW5kZXggPSB0aGlzLmZpbmRJbnNlcnRpb25JbmRleCggaXRlbXNbIGkgXSApO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIGl0ZW0gZXhpc3RzIHVzaW5nIHRoZSBzb3J0aW5nIGNhbGxiYWNrXG5cdFx0Ly8gYW5kIHJlbW92ZSBpdCBmaXJzdCBpZiBpdCBleGlzdHNcblx0XHRpZiAoXG5cdFx0XHQvLyBGaXJzdCBtYWtlIHN1cmUgdGhlIGluc2VydGlvbiBpbmRleCBpcyBub3QgYXQgdGhlIGVuZFxuXHRcdFx0Ly8gb2YgdGhlIGxpc3QgKHdoaWNoIG1lYW5zIGl0IGRvZXMgbm90IHBvaW50IHRvIGFueSBhY3R1YWxcblx0XHRcdC8vIGl0ZW1zKVxuXHRcdFx0aW5zZXJ0aW9uSW5kZXggPD0gdGhpcy5pdGVtcy5sZW5ndGggJiZcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGVyZSBhY3R1YWxseSBpcyBhbiBpdGVtIGluIHRoaXMgaW5kZXhcblx0XHRcdHRoaXMuaXRlbXNbIGluc2VydGlvbkluZGV4IF0gJiZcblx0XHRcdC8vIFRoZSBjYWxsYmFjayByZXR1cm5zIDAgaWYgdGhlIGl0ZW1zIGFyZSBlcXVhbFxuXHRcdFx0dGhpcy5zb3J0aW5nQ2FsbGJhY2soIHRoaXMuaXRlbXNbIGluc2VydGlvbkluZGV4IF0sIGl0ZW1zWyBpIF0gKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBleGlzdGluZyBpdGVtXG5cdFx0XHR0aGlzLnJlbW92ZUl0ZW1zKCB0aGlzLml0ZW1zWyBpbnNlcnRpb25JbmRleCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gSW5zZXJ0IGl0ZW0gYXQgdGhlIGluc2VydGlvbiBpbmRleFxuXHRcdGluZGV4ID0gdGhpcy5pbnNlcnRJdGVtKCBpdGVtc1sgaSBdLCBpbnNlcnRpb25JbmRleCApO1xuXHRcdHRoaXMuZW1pdCggJ2FkZCcsIGl0ZW1zWyBpIF0sIGluZGV4ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaW5kZXggYSBnaXZlbiBpdGVtIHNob3VsZCBiZSBpbnNlcnRlZCBhdC4gSWYgdGhlIGl0ZW0gaXMgYWxyZWFkeVxuICogaW4gdGhlIGxpc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGluZGV4IHdoZXJlIHRoZSBpdGVtIGN1cnJlbnRseSBpcy5cbiAqXG4gKiBAcGFyYW0ge09PLkV2ZW50RW1pdHRlcn0gaXRlbSBJdGVtcyB0byBpbnNlcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IHRoZSBpdGVtIHNob3VsZCBiZSBpbnNlcnRlZCBhdFxuICovXG5vby5Tb3J0ZWRFbWl0dGVyTGlzdC5wcm90b3R5cGUuZmluZEluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHR2YXIgbGlzdCA9IHRoaXM7XG5cblx0cmV0dXJuIG9vLmJpbmFyeVNlYXJjaChcblx0XHR0aGlzLml0ZW1zLFxuXHRcdC8vIEZha2UgYSB0aGlzLnNvcnRpbmdDYWxsYmFjay5iaW5kKCBudWxsLCBpdGVtICkgY2FsbCBoZXJlXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgZG9lc24ndCBwYXNzIHRlc3RzIGluIHBoYW50b21KU1xuXHRcdGZ1bmN0aW9uICggb3RoZXJJdGVtICkge1xuXHRcdFx0cmV0dXJuIGxpc3Quc29ydGluZ0NhbGxiYWNrKCBpdGVtLCBvdGhlckl0ZW0gKTtcblx0XHR9LFxuXHRcdHRydWVcblx0KTtcblxufTtcblxuLyogZ2xvYmFsIGhhc093biAqL1xuXG4vKipcbiAqIEEgbWFwIGludGVyZmFjZSBmb3IgYXNzb2NpYXRpbmcgYXJiaXRyYXJ5IGRhdGEgd2l0aCBhIHN5bWJvbGljIG5hbWUuIFVzZWQgaW5cbiAqIHBsYWNlIG9mIGEgcGxhaW4gb2JqZWN0IHRvIHByb3ZpZGUgYWRkaXRpb25hbCB7QGxpbmsgI21ldGhvZC1yZWdpc3RlciByZWdpc3RyYXRpb259XG4gKiBvciB7QGxpbmsgI21ldGhvZC1sb29rdXAgbG9va3VwfSBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFNlZSA8aHR0cHM6Ly93d3cubWVkaWF3aWtpLm9yZy93aWtpL09PanMvUmVnaXN0cmllc19hbmRfZmFjdG9yaWVzPi5cbiAqXG4gKiBAY2xhc3MgT08uUmVnaXN0cnlcbiAqIEBtaXhpbnMgT08uRXZlbnRFbWl0dGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbm9vLlJlZ2lzdHJ5ID0gZnVuY3Rpb24gT29SZWdpc3RyeSgpIHtcblx0Ly8gTWl4aW4gY29uc3RydWN0b3JzXG5cdG9vLkV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG5cblx0Ly8gUHJvcGVydGllc1xuXHR0aGlzLnJlZ2lzdHJ5ID0ge307XG59O1xuXG4vKiBJbmhlcml0YW5jZSAqL1xuXG5vby5taXhpbkNsYXNzKCBvby5SZWdpc3RyeSwgb28uRXZlbnRFbWl0dGVyICk7XG5cbi8qIEV2ZW50cyAqL1xuXG4vKipcbiAqIEBldmVudCByZWdpc3RlclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBldmVudCB1bnJlZ2lzdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtNaXhlZH0gZGF0YSBEYXRhIHJlbW92ZWQgZnJvbSByZWdpc3RyeVxuICovXG5cbi8qIE1ldGhvZHMgKi9cblxuLyoqXG4gKiBBc3NvY2lhdGUgb25lIG9yIG1vcmUgc3ltYm9saWMgbmFtZXMgd2l0aCBzb21lIGRhdGEuXG4gKlxuICogQW55IGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWUgU3ltYm9saWMgbmFtZSBvciBsaXN0IG9mIHN5bWJvbGljIG5hbWVzXG4gKiBAcGFyYW0ge01peGVkfSBkYXRhIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggc3ltYm9saWMgbmFtZVxuICogQGZpcmVzIHJlZ2lzdGVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gTmFtZSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5XG4gKi9cbm9vLlJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICggbmFtZSwgZGF0YSApIHtcblx0dmFyIGksIGxlbjtcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0dGhpcy5yZWdpc3RyeVsgbmFtZSBdID0gZGF0YTtcblx0XHR0aGlzLmVtaXQoICdyZWdpc3RlcicsIG5hbWUsIGRhdGEgKTtcblx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSBuYW1lLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0dGhpcy5yZWdpc3RlciggbmFtZVsgaSBdLCBkYXRhICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ05hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheSwgY2Fubm90IGJlIGEgJyArIHR5cGVvZiBuYW1lICk7XG5cdH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIG9uZSBvciBtb3JlIHN5bWJvbGljIG5hbWVzIGZyb20gdGhlIHJlZ2lzdHJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWUgU3ltYm9saWMgbmFtZSBvciBsaXN0IG9mIHN5bWJvbGljIG5hbWVzXG4gKiBAZmlyZXMgdW5yZWdpc3RlclxuICogQHRocm93cyB7RXJyb3J9IE5hbWUgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheVxuICovXG5vby5SZWdpc3RyeS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uICggbmFtZSApIHtcblx0dmFyIGksIGxlbiwgZGF0YTtcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0ZGF0YSA9IHRoaXMubG9va3VwKCBuYW1lICk7XG5cdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5yZWdpc3RyeVsgbmFtZSBdO1xuXHRcdFx0dGhpcy5lbWl0KCAndW5yZWdpc3RlcicsIG5hbWUsIGRhdGEgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRmb3IgKCBpID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHRoaXMudW5yZWdpc3RlciggbmFtZVsgaSBdICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ05hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheSwgY2Fubm90IGJlIGEgJyArIHR5cGVvZiBuYW1lICk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGRhdGEgZm9yIGEgZ2l2ZW4gc3ltYm9saWMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTeW1ib2xpYyBuYW1lXG4gKiBAcmV0dXJuIHtNaXhlZHx1bmRlZmluZWR9IERhdGEgYXNzb2NpYXRlZCB3aXRoIHN5bWJvbGljIG5hbWVcbiAqL1xub28uUmVnaXN0cnkucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblx0aWYgKCBoYXNPd24uY2FsbCggdGhpcy5yZWdpc3RyeSwgbmFtZSApICkge1xuXHRcdHJldHVybiB0aGlzLnJlZ2lzdHJ5WyBuYW1lIF07XG5cdH1cbn07XG5cbi8qKlxuICogQGNsYXNzIE9PLkZhY3RvcnlcbiAqIEBleHRlbmRzIE9PLlJlZ2lzdHJ5XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbm9vLkZhY3RvcnkgPSBmdW5jdGlvbiBPb0ZhY3RvcnkoKSB7XG5cdC8vIFBhcmVudCBjb25zdHJ1Y3RvclxuXHRvby5GYWN0b3J5LnN1cGVyLmNhbGwoIHRoaXMgKTtcbn07XG5cbi8qIEluaGVyaXRhbmNlICovXG5cbm9vLmluaGVyaXRDbGFzcyggb28uRmFjdG9yeSwgb28uUmVnaXN0cnkgKTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY29uc3RydWN0b3Igd2l0aCB0aGUgZmFjdG9yeS5cbiAqXG4gKiBDbGFzc2VzIG11c3QgaGF2ZSBhIHN0YXRpYyBgbmFtZWAgcHJvcGVydHkgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDbGFzcygpIHt9O1xuICogICAgIE9PLmluaXRDbGFzcyggTXlDbGFzcyApO1xuICogICAgIC8vIEFkZHMgYSBzdGF0aWMgcHJvcGVydHkgdG8gdGhlIGNsYXNzIGRlZmluaW5nIGEgc3ltYm9saWMgbmFtZVxuICogICAgIE15Q2xhc3Muc3RhdGljLm5hbWUgPSAnbWluZSc7XG4gKiAgICAgLy8gUmVnaXN0ZXJzIGNsYXNzIHdpdGggZmFjdG9yeSwgYXZhaWxhYmxlIHZpYSBzeW1ib2xpYyBuYW1lICdtaW5lJ1xuICogICAgIGZhY3RvcnkucmVnaXN0ZXIoIE15Q2xhc3MgKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0byB1c2Ugd2hlbiBjcmVhdGluZyBvYmplY3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBOYW1lIG11c3QgYmUgYSBzdHJpbmcgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn0gQ29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXG4gKi9cbm9vLkZhY3RvcnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCB0eXBlb2YgY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnY29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLCBjYW5ub3QgYmUgYSAnICsgdHlwZW9mIGNvbnN0cnVjdG9yICk7XG5cdH1cblx0bmFtZSA9IGNvbnN0cnVjdG9yLnN0YXRpYyAmJiBjb25zdHJ1Y3Rvci5zdGF0aWMubmFtZTtcblx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZSA9PT0gJycgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnTmFtZSBtdXN0IGJlIGEgc3RyaW5nIGFuZCBtdXN0IG5vdCBiZSBlbXB0eScgKTtcblx0fVxuXG5cdC8vIFBhcmVudCBtZXRob2Rcblx0b28uRmFjdG9yeS5zdXBlci5wcm90b3R5cGUucmVnaXN0ZXIuY2FsbCggdGhpcywgbmFtZSwgY29uc3RydWN0b3IgKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIGNvbnN0cnVjdG9yIGZyb20gdGhlIGZhY3RvcnkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ29uc3RydWN0b3IgdG8gdW5yZWdpc3RlclxuICogQHRocm93cyB7RXJyb3J9IE5hbWUgbXVzdCBiZSBhIHN0cmluZyBhbmQgbXVzdCBub3QgYmUgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBDb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb25cbiAqL1xub28uRmFjdG9yeS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggdHlwZW9mIGNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ2NvbnN0cnVjdG9yIG11c3QgYmUgYSBmdW5jdGlvbiwgY2Fubm90IGJlIGEgJyArIHR5cGVvZiBjb25zdHJ1Y3RvciApO1xuXHR9XG5cdG5hbWUgPSBjb25zdHJ1Y3Rvci5zdGF0aWMgJiYgY29uc3RydWN0b3Iuc3RhdGljLm5hbWU7XG5cdGlmICggdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUgPT09ICcnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ05hbWUgbXVzdCBiZSBhIHN0cmluZyBhbmQgbXVzdCBub3QgYmUgZW1wdHknICk7XG5cdH1cblxuXHQvLyBQYXJlbnQgbWV0aG9kXG5cdG9vLkZhY3Rvcnkuc3VwZXIucHJvdG90eXBlLnVucmVnaXN0ZXIuY2FsbCggdGhpcywgbmFtZSApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IGJhc2VkIG9uIGEgbmFtZS5cbiAqXG4gKiBOYW1lIGlzIHVzZWQgdG8gbG9vayB1cCB0aGUgY29uc3RydWN0b3IgdG8gdXNlLCB3aGlsZSBhbGwgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGVcbiAqIGNvbnN0cnVjdG9yIGRpcmVjdGx5LCBzbyBsZWF2aW5nIG9uZSBvdXQgd2lsbCBwYXNzIGFuIHVuZGVmaW5lZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7Li4uTWl4ZWR9IFthcmdzXSBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIG9iamVjdCBuYW1lXG4gKi9cbm9vLkZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblx0dmFyIG9iaiwgaSxcblx0XHRhcmdzID0gW10sXG5cdFx0Y29uc3RydWN0b3IgPSB0aGlzLmxvb2t1cCggbmFtZSApO1xuXG5cdGlmICggIWNvbnN0cnVjdG9yICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ05vIGNsYXNzIHJlZ2lzdGVyZWQgYnkgdGhhdCBuYW1lOiAnICsgbmFtZSApO1xuXHR9XG5cblx0Ly8gQ29udmVydCBhcmd1bWVudHMgdG8gYXJyYXkgYW5kIHNoaWZ0IHRoZSBmaXJzdCBhcmd1bWVudCAobmFtZSkgb2ZmXG5cdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdGFyZ3MucHVzaCggYXJndW1lbnRzWyBpIF0gKTtcblx0fVxuXG5cdC8vIFdlIGNhbid0IHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciB3aXRoIC5hcHBseSBkaXJlY3RseSBiZWNhdXNlIGFwcGx5IG5lZWRzIGFcblx0Ly8gY29udGV4dC4gU28gaW5zdGVhZCBqdXN0IGRvIHdoYXQgXCJuZXdcIiBkb2VzOiBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbVxuXHQvLyB0aGUgY29uc3RydWN0b3IncyBwcm90b3R5cGUgKHdoaWNoIGFsc28gbWFrZXMgaXQgYW4gXCJpbnN0YW5jZW9mXCIgdGhlIGNvbnN0cnVjdG9yKSxcblx0Ly8gdGhlbiBpbnZva2UgdGhlIGNvbnN0cnVjdG9yIHdpdGggdGhlIG9iamVjdCBhcyBjb250ZXh0LCBhbmQgcmV0dXJuIGl0IChpZ25vcmluZ1xuXHQvLyB0aGUgY29uc3RydWN0b3IncyByZXR1cm4gdmFsdWUpLlxuXHRvYmogPSBPYmplY3QuY3JlYXRlKCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcblx0Y29uc3RydWN0b3IuYXBwbHkoIG9iaiwgYXJncyApO1xuXHRyZXR1cm4gb2JqO1xufTtcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IG9vO1xufSBlbHNlIHtcblx0Z2xvYmFsLk9PID0gb287XG59XG5cbn0oIHRoaXMgKSApO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==